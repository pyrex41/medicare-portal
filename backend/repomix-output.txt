This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.ts, **/*.elm
- Files matching these patterns are excluded: node_modules/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
scripts/
  add-agent.ts
  apply-contact-migration.ts
  generate-test-data.ts
  generateQuoteId.ts
  generateQuoteUrl.ts
  manage-recommendations.ts
  manage-turso.ts
  test-bulk-import.ts
src/
  config/
    index.ts
    turso.ts
  middleware/
    account-status.ts
    auth.ts
    error.ts
  routes/
    admin-portal.ts
    admin.ts
    auth.ts
    brand.ts
    contacts.ts
    eligibility.ts
    onboarding.ts
    organizations.ts
    quotes.ts
    schedule.ts
    self-service.ts
    settings.ts
    stripe.ts
  services/
    agentSettings.ts
    auth.ts
    email.ts
    stripe.ts
    subscription.ts
    turso.ts
  utils/
    quoteId.ts
  config.ts
  database.ts
  errors.ts
  index.ts
  logger.ts
  types.ts

================================================================
Files
================================================================

================
File: scripts/add-agent.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for agent data
const AgentSchema = z.object({
  first_name: z.string().min(1),
  last_name: z.string().min(1),
  email: z.string().email(),
  phone: z.string().min(1),
  organization_id: z.number(),
});

async function main() {
  p.intro(chalk.green('✨ Interactive Agent Creation Tool ✨'));

  const db = new Database();

  // Get all organizations
  const orgs = await db.fetchAll<{ id: number; name: string }>('SELECT id, name FROM organizations');
  
  if (orgs.length === 0) {
    p.outro(chalk.red('No organizations found. Please create an organization first.'));
    exit(1);
  }

  // Gather information
  const firstName = await p.text({
    message: 'Enter agent first name:',
    validate: (value) => {
      if (value.length === 0) return 'First name cannot be empty';
    },
  });

  const lastName = await p.text({
    message: 'Enter agent last name:',
    validate: (value) => {
      if (value.length === 0) return 'Last name cannot be empty';
    },
  });

  const email = await p.text({
    message: 'Enter agent email:',
    validate: (value) => {
      if (!value.includes('@')) return 'Invalid email address';
    },
  });

  const phone = await p.text({
    message: 'Enter agent phone:',
    validate: (value) => {
      if (value.length === 0) return 'Phone cannot be empty';
    },
  });

  const organization = await p.select({
    message: 'Select organization:',
    options: orgs.map(org => ({
      value: org.id,
      label: org.name,
    })),
  });

  if (p.isCancel(firstName) || p.isCancel(lastName) || p.isCancel(email) || p.isCancel(phone) || p.isCancel(organization)) {
    p.outro(chalk.yellow('Operation cancelled'));
    exit(0);
  }

  try {
    // Validate data
    const agentData = AgentSchema.parse({
      first_name: firstName,
      last_name: lastName,
      email,
      phone,
      organization_id: organization,
    });

    // Start a transaction
    await db.execute('BEGIN TRANSACTION');

    try {
      // Insert into agents table
      await db.execute(
        `INSERT INTO agents (first_name, last_name, email, phone, organization_id)
         VALUES (?, ?, ?, ?, ?)`,
        [
          agentData.first_name,
          agentData.last_name,
          agentData.email,
          agentData.phone,
          agentData.organization_id
        ]
      );

      // Insert into users table
      await db.execute(
        `INSERT INTO users (email, organization_id, is_admin, is_agent, is_active)
         VALUES (?, ?, ?, ?, true)`,
        [agentData.email, agentData.organization_id, false, true]
      );

      // Commit the transaction
      await db.execute('COMMIT');

      p.outro(chalk.green('Agent created successfully! 🎉'));

    } catch (error) {
      // Rollback on error
      await db.execute('ROLLBACK');
      throw error;
    }

  } catch (error) {
    if (error instanceof z.ZodError) {
      p.outro(chalk.red(`Validation error: ${error.errors.map(e => e.message).join(', ')}`));
    } else {
      p.outro(chalk.red(`Error creating agent: ${error}`));
    }
    exit(1);
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/apply-contact-migration.ts
================
#!/usr/bin/env bun

import { Database } from '../src/database';
import { logger } from '../src/logger';
import fs from 'fs/promises';
import path from 'path';

/**
 * This script applies the contact email uniqueness migration to all organization databases.
 * It:
 * 1. Fetches all organizations from the main database
 * 2. For each organization, connects to its database
 * 3. Applies the migration to ensure contacts have unique emails
 * 4. Reports counts before and after deduplication
 */
async function main() {
  try {
    logger.info('Starting contact migration script');
    
    // Connect to main database
    const mainDb = new Database();
    
    // Get all organizations
    const orgs = await mainDb.fetchAll('SELECT id, name, turso_db_url, turso_auth_token FROM organizations WHERE turso_db_url IS NOT NULL');
    logger.info(`Found ${orgs.length} organizations with databases`);
    
    // Read migration SQL
    const migrationPath = path.join(process.cwd(), 'migrations', '20240326_fix_contact_email_unique.sql');
    const migrationSql = await fs.readFile(migrationPath, 'utf-8');
    
    // Process each organization
    for (let i = 0; i < orgs.length; i++) {
      const org = orgs[i];
      const orgId = org.id;
      const orgName = org.name;
      const dbUrl = org.turso_db_url;
      const authToken = org.turso_auth_token;
      
      logger.info(`Processing organization ${i+1}/${orgs.length}: ${orgName} (ID: ${orgId})`);
      
      try {
        // Connect to organization database
        const orgDb = new Database(dbUrl, authToken);
        
        // Check if contacts table exists
        const tableExists = await orgDb.fetchOne(
          "SELECT 1 FROM sqlite_master WHERE type='table' AND name='contacts'"
        );
        
        if (!tableExists) {
          logger.info(`No contacts table found for organization ${orgId}, skipping`);
          continue;
        }
        
        // Get contacts count before migration
        const beforeCount = await orgDb.fetchOne<{count: number}>('SELECT COUNT(*) as count FROM contacts');
        logger.info(`Organization ${orgId} has ${beforeCount?.count || 0} contacts before deduplication`);
        
        // Get duplicate emails count
        const duplicatesCount = await orgDb.fetchOne<{count: number}>(
          'SELECT COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as count FROM contacts'
        );
        logger.info(`Organization ${orgId} has ${duplicatesCount?.count || 0} duplicate emails`);
        
        if ((duplicatesCount?.count || 0) > 0) {
          // Apply migration
          await orgDb.execute(migrationSql);
          
          // Get contacts count after migration
          const afterCount = await orgDb.fetchOne<{count: number}>('SELECT COUNT(*) as count FROM contacts');
          logger.info(`Organization ${orgId} has ${afterCount?.count || 0} contacts after deduplication`);
          logger.info(`Removed ${(beforeCount?.count || 0) - (afterCount?.count || 0)} duplicate contacts`);
        } else {
          logger.info(`No duplicates found for organization ${orgId}, skipping migration`);
        }
      } catch (error) {
        logger.error(`Error processing organization ${orgId}: ${error}`);
      }
    }
    
    logger.info('Contact migration completed');
  } catch (error) {
    logger.error(`Error in migration script: ${error}`);
    process.exit(1);
  }
}

main();

================
File: scripts/generate-test-data.ts
================
import fs from 'fs/promises';
import { stringify } from 'csv-stringify/sync';
import path from 'path';

/**
 * Script to generate a large dataset of test contacts for performance testing
 * 
 * Usage:
 *   bun run scripts/generate-test-data.ts <count> [output-file]
 * 
 * Where:
 *   <count> is the number of contacts to generate
 *   [output-file] is the optional output file path (defaults to ./scripts/test-contacts-{count}.csv)
 */

// Sample data for random generation
const firstNames = ['John', 'Jane', 'Robert', 'Mary', 'Michael', 'Jennifer', 'William', 'Patricia', 'Richard', 'Linda', 
  'David', 'Elizabeth', 'Joseph', 'Barbara', 'Thomas', 'Susan', 'Charles', 'Jessica', 'Daniel', 'Sarah', 'Matthew', 'Karen', 
  'Anthony', 'Nancy', 'Mark', 'Lisa', 'Donald', 'Betty', 'Steven', 'Dorothy'];

const lastNames = ['Smith', 'Johnson', 'Williams', 'Jones', 'Brown', 'Davis', 'Miller', 'Wilson', 'Moore', 'Taylor', 
  'Anderson', 'Thomas', 'Jackson', 'White', 'Harris', 'Martin', 'Thompson', 'Garcia', 'Martinez', 'Robinson', 'Clark', 
  'Rodriguez', 'Lewis', 'Lee', 'Walker', 'Hall', 'Allen', 'Young', 'Hernandez', 'King'];

const carriers = ['Aetna', 'Humana', 'UnitedHealthcare', 'Cigna', 'Blue Cross Blue Shield', 'Kaiser Permanente', 
  'Anthem', 'Wellcare', 'Centene', 'Molina Healthcare'];

const planTypes = ['A', 'B', 'C', 'D', 'F', 'G', 'K', 'L', 'M', 'N'];

const states = ['AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 
  'LA', 'ME', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 
  'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'];

// Helper functions for random data generation
function getRandomItem<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)];
}

function getRandomDate(start: Date, end: Date): string {
  const date = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
  return date.toISOString().split('T')[0];
}

function getRandomPhone(): string {
  return `${Math.floor(Math.random() * 900) + 100}-${Math.floor(Math.random() * 900) + 100}-${Math.floor(Math.random() * 9000) + 1000}`;
}

function getRandomZip(): string {
  return `${Math.floor(Math.random() * 90000) + 10000}`;
}

// Main function
async function main() {
  try {
    const args = process.argv.slice(2);
    
    if (args.length < 1) {
      console.error('Usage: bun run scripts/generate-test-data.ts <count> [output-file]');
      process.exit(1);
    }
    
    const count = parseInt(args[0], 10);
    
    if (isNaN(count) || count <= 0) {
      console.error('Count must be a positive number');
      process.exit(1);
    }
    
    const outputFile = args[1] || path.join(process.cwd(), 'scripts', `test-contacts-${count}.csv`);
    
    console.log(`Generating ${count} test contacts...`);
    
    // Generate the contacts
    const contacts = [];
    
    for (let i = 0; i < count; i++) {
      const firstName = getRandomItem(firstNames);
      const lastName = getRandomItem(lastNames);
      const email = `${firstName.toLowerCase()}.${lastName.toLowerCase()}${Math.floor(Math.random() * 10000)}@example.com`;
      
      contacts.push({
        first_name: firstName,
        last_name: lastName,
        email: email,
        current_carrier: getRandomItem(carriers),
        plan_type: getRandomItem(planTypes),
        effective_date: getRandomDate(new Date('2022-01-01'), new Date('2023-12-31')),
        birth_date: getRandomDate(new Date('1940-01-01'), new Date('1965-12-31')),
        tobacco_user: Math.random() > 0.8 ? 1 : 0, // 20% are tobacco users
        gender: Math.random() > 0.5 ? 'Male' : 'Female',
        state: getRandomItem(states),
        zip_code: getRandomZip(),
        phone_number: getRandomPhone()
      });
      
      // Log progress for large datasets
      if (i > 0 && i % 10000 === 0) {
        console.log(`Generated ${i} contacts...`);
      }
    }
    
    // Convert to CSV
    console.log('Converting to CSV...');
    const csv = stringify(contacts, { header: true });
    
    // Write to file
    console.log(`Writing to ${outputFile}...`);
    await fs.writeFile(outputFile, csv);
    
    console.log(`Successfully generated ${count} contacts in ${outputFile}`);
    
  } catch (error) {
    console.error(`Error generating test data: ${error}`);
    process.exit(1);
  }
}

main();

================
File: scripts/generateQuoteId.ts
================
import { generateQuoteId } from '../src/utils/quoteId';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteId.ts <orgId> <contactId>');
  process.exit(1);
}

// Generate quote ID
const quoteId = generateQuoteId(orgId, contactId);

// Output results
console.log('Generated Quote ID:', quoteId);
console.log('Quote URL:', `http://localhost:5173/quote?id=${quoteId}`);

================
File: scripts/generateQuoteUrl.ts
================
import axios, { AxiosError } from 'axios';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteUrl.ts <orgId> <contactId>');
  process.exit(1);
}

// Call the API to generate a quote ID
const generateQuoteUrl = async () => {
  try {
    // Use the debug endpoint to generate a quote ID without authentication
    const response = await axios.get(`http://localhost:8000/api/quotes/debug-generate/${orgId}/${contactId}`);

    if (response.data.success) {
      console.log('Quote ID:', response.data.quoteId);
      console.log('Quote URL:', response.data.redirectUrl);
    } else {
      console.error('Failed to generate quote ID:', response.data.error);
      
      if (response.data.availableContacts) {
        console.log('\nAvailable contacts for organization', orgId, ':');
        response.data.availableContacts.forEach((contact: any) => {
          console.log(`- ID: ${contact.id}, Name: ${contact.first_name} ${contact.last_name || ''}, Email: ${contact.email || 'N/A'}`);
        });
      }
    }
  } catch (error) {
    if (error instanceof AxiosError) {
      console.error('Error:', error.response?.data || error.message);
    } else {
      console.error('Error:', error);
    }
  }
};

generateQuoteUrl();

================
File: scripts/manage-recommendations.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for GI recommendation data
const RecommendationSchema = z.object({
  state: z.string().length(2),
  carrier: z.string().min(1),
});

async function main() {
  p.intro(chalk.green('✨ Guaranteed Issue Recommendations Manager ✨'));

  const db = new Database();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all GI recommendations' },
        { value: 'add', label: 'Add new GI recommendation' },
        { value: 'remove', label: 'Remove GI recommendation' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listRecommendations(db);
          break;
        case 'add':
          await addRecommendation(db);
          break;
        case 'remove':
          await removeRecommendation(db);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listRecommendations(db: Database) {
  const results = await db.fetchAll<{ state: string; carrier: string; created_at: string }>(
    `SELECT state, carrier, created_at 
     FROM guaranteed_issue_recommendations 
     ORDER BY carrier, state`
  );

  if (results.length === 0) {
    p.note('No GI recommendations found', 'Empty');
    return;
  }

  const groupedByCarrier = results.reduce((acc, curr) => {
    if (!acc[curr.carrier]) {
      acc[curr.carrier] = [];
    }
    acc[curr.carrier].push(curr.state);
    return acc;
  }, {} as Record<string, string[]>);

  p.note(
    Object.entries(groupedByCarrier)
      .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
      .join('\n\n'),
    'Current GI Recommendations'
  );
}

async function addRecommendation(db: Database) {
  // Get available carriers first
  const carriers = await db.fetchAll<{ name: string }>(
    'SELECT name FROM carriers ORDER BY name'
  );

  if (carriers.length === 0) {
    p.note(chalk.red('No carriers found in database'));
    return;
  }

  const carrier = await p.select({
    message: 'Select carrier:',
    options: carriers.map(c => ({
      value: c.name,
      label: c.name,
    })),
  });

  if (p.isCancel(carrier)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const states = await p.text({
    message: 'Enter state codes (comma/space separated, e.g., TX CA FL):',
    validate: (value) => {
      const stateList = value.toUpperCase().split(/[\s,]+/).filter(Boolean);
      if (stateList.length === 0) return 'At least one state code is required';
      const invalidStates = stateList.filter(s => s.length !== 2);
      if (invalidStates.length > 0) {
        return `Invalid state codes: ${invalidStates.join(', ')}`;
      }
    },
  });

  if (p.isCancel(states)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const stateList = states.toUpperCase().split(/[\s,]+/).filter(Boolean);
  const results: { state: string; success: boolean; message: string }[] = [];

  for (const state of stateList) {
    try {
      const data = RecommendationSchema.parse({
        state,
        carrier,
      });

      // Check if recommendation already exists
      const existing = await db.fetchOne(
        'SELECT 1 FROM guaranteed_issue_recommendations WHERE state = ? AND carrier = ?',
        [data.state, data.carrier]
      );

      if (existing) {
        results.push({
          state: data.state,
          success: false,
          message: 'Already exists'
        });
        continue;
      }

      await db.execute(
        'INSERT INTO guaranteed_issue_recommendations (state, carrier) VALUES (?, ?)',
        [data.state, data.carrier]
      );

      results.push({
        state: data.state,
        success: true,
        message: 'Added successfully'
      });

    } catch (error) {
      results.push({
        state,
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Unknown error'
      });
    }
  }

  // Display results summary
  const successful = results.filter(r => r.success);
  const failed = results.filter(r => !r.success);

  if (successful.length > 0) {
    p.note(
      chalk.green(
        `Successfully added GI recommendations for ${carrier}:\n` +
        successful.map(r => `  ${r.state}`).join('\n')
      ),
      'Success'
    );
  }

  if (failed.length > 0) {
    p.note(
      chalk.yellow(
        `Failed to add some recommendations for ${carrier}:\n` +
        failed.map(r => `  ${r.state}: ${r.message}`).join('\n')
      ),
      'Warnings'
    );
  }
}

async function removeRecommendation(db: Database) {
  const recommendations = await db.fetchAll<{ id: number; state: string; carrier: string }>(
    'SELECT id, state, carrier FROM guaranteed_issue_recommendations ORDER BY carrier, state'
  );

  if (recommendations.length === 0) {
    p.note(chalk.yellow('No recommendations to remove'));
    return;
  }

  const selections = await p.multiselect({
    message: 'Select recommendations to remove (space to select/deselect):',
    options: recommendations
      .sort((a, b) => a.carrier.localeCompare(b.carrier) || a.state.localeCompare(b.state))
      .map(rec => ({
        value: rec.id.toString(),
        label: `${rec.carrier} - ${rec.state}`,
      })),
    required: true,
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const idsToRemove = (selections as string[]).map(Number);

  if (idsToRemove.length === 0) {
    p.note(chalk.yellow('No recommendations selected for removal'));
    return;
  }

  await db.execute(
    `DELETE FROM guaranteed_issue_recommendations WHERE id IN (${idsToRemove.join(',')})`,
  );

  const removedItems = recommendations
    .filter(r => idsToRemove.includes(r.id))
    .reduce((acc, curr) => {
      if (!acc[curr.carrier]) {
        acc[curr.carrier] = [];
      }
      acc[curr.carrier].push(curr.state);
      return acc;
    }, {} as Record<string, string[]>);

  p.note(
    chalk.green(
      'Successfully removed recommendations:\n\n' +
      Object.entries(removedItems)
        .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
        .join('\n\n')
    ),
    'Success'
  );
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/manage-turso.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';
import { TURSO_CONFIG } from '../src/config/turso';
import fetch from 'node-fetch';

interface Organization {
  id: number;
  name: string;
  turso_db_url: string | null;
}

class TursoManager {
  private headers = {
    'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
    'Content-Type': 'application/json'
  };

  async listLocations(): Promise<string[]> {
    const response = await fetch(`${TURSO_CONFIG.API_URL}/locations`, {
      headers: this.headers
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch locations: ${await response.text()}`);
    }

    const data = await response.json() as { locations: Array<{ name: string }> };
    return data.locations.map(l => l.name);
  }

  async listDatabases(): Promise<Array<{name: string, hostname: string}>> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`,
      { headers: this.headers }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch databases: ${await response.text()}`);
    }

    const data = await response.json() as { databases: Array<{Name: string, Hostname: string}> };
    return data.databases.map(db => ({
      name: db.Name,
      hostname: db.Hostname
    }));
  }

  async updateGroup(name: string, location: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/groups/${TURSO_CONFIG.GROUP_NAME}`,
      {
        method: 'PATCH',
        headers: this.headers,
        body: JSON.stringify({ name, location })
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to update group: ${await response.text()}`);
    }
  }

  async deleteDatabase(name: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${name}`,
      {
        method: 'DELETE',
        headers: this.headers
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete database: ${await response.text()}`);
    }
  }
}

async function main() {
  p.intro(chalk.green('✨ Turso Database Manager ✨'));

  const db = new Database();
  const turso = new TursoManager();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all databases and organizations' },
        { value: 'update-group', label: 'Update group configuration' },
        { value: 'delete-db', label: 'Delete a customer database' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listDatabasesAndOrgs(db, turso);
          break;
        case 'update-group':
          await updateGroupConfig(turso);
          break;
        case 'delete-db':
          await deleteCustomerDatabase(db, turso);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listDatabasesAndOrgs(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  const mappedDatabases = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      name: database.name,
      hostname: database.hostname,
      organization: org ? org[1] : 'Not associated with any organization'
    };
  });

  if (mappedDatabases.length === 0) {
    p.note('No databases found', 'Empty');
    return;
  }

  p.note(
    mappedDatabases
      .map(db => `${db.name}:\n  URL: ${db.hostname}\n  Organization: ${db.organization}`)
      .join('\n\n'),
    'Current Databases'
  );
}

async function updateGroupConfig(turso: TursoManager) {
  // Get available locations
  const locations = await turso.listLocations();

  p.note(
    `Current Configuration:\n` +
    `  Group Name: ${TURSO_CONFIG.GROUP_NAME}\n` +
    `  Location: ${TURSO_CONFIG.LOCATION}`,
    'Current Settings'
  );

  const newGroupName = await p.text({
    message: 'Enter new group name (or press enter to keep current):',
    initial: TURSO_CONFIG.GROUP_NAME,
  });

  if (p.isCancel(newGroupName)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const newLocation = await p.select({
    message: 'Select new location:',
    options: locations.map(loc => ({
      value: loc,
      label: loc,
    })),
    initialValue: TURSO_CONFIG.LOCATION,
  });

  if (p.isCancel(newLocation)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const confirm = await p.confirm({
    message: `Update group "${TURSO_CONFIG.GROUP_NAME}" to:\n` +
             `  Name: ${newGroupName}\n` +
             `  Location: ${newLocation}\n` +
             `Are you sure?`,
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  await turso.updateGroup(newGroupName, newLocation as string);
  
  p.note(
    chalk.green(
      `Successfully updated group configuration.\n` +
      `Remember to update TURSO_CONFIG in your code!`
    ),
    'Success'
  );
}

async function deleteCustomerDatabase(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  if (databases.length === 0) {
    p.note('No databases found to delete', 'Empty');
    return;
  }

  const options = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      value: database.name,
      label: `${database.name} (${org ? org[1] : 'Unassociated'})`,
    };
  });

  const selections = await p.multiselect({
    message: 'Select databases to delete (space to select, enter to confirm):',
    options,
    required: true
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const selectedDbs = selections as string[];
  if (selectedDbs.length === 0) {
    p.note(chalk.yellow('No databases selected'));
    return;
  }

  const confirm = await p.confirm({
    message: chalk.red(
      `Are you sure you want to delete the following databases?\n` +
      selectedDbs.map(db => `  - ${db}`).join('\n') +
      `\nThis action cannot be undone!`
    ),
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  for (const dbName of selectedDbs) {
    try {
      await turso.deleteDatabase(dbName);

      // Update organization record
      const org = orgs.find((o: any) => 
        o[2] && 
        o[2].toString().includes(
          databases.find(d => d.name === dbName)?.hostname || ''
        )
      );

      if (org) {
        await db.execute(
          'UPDATE organizations SET turso_db_url = NULL, turso_auth_token = NULL WHERE id = ?',
          [org[0]]
        );
      }

      p.note(
        chalk.green(`Successfully deleted database "${dbName}"`),
        'Success'
      );
    } catch (error) {
      p.note(
        chalk.red(`Failed to delete database "${dbName}": ${error}`),
        'Error'
      );
    }
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/test-bulk-import.ts
================
import { Database } from '../src/database';
import { ContactCreate } from '../src/types';
import { logger } from '../src/logger';
import fs from 'fs/promises';
import { parse } from 'csv-parse/sync';

/**
 * Test utility for the bulk contact import feature
 * 
 * Usage:
 *   bun run scripts/test-bulk-import.ts <org_id> <csv_file> [--overwrite]
 * 
 * Where:
 *   <org_id> is the organization ID to import contacts for
 *   <csv_file> is the path to a CSV file containing contacts
 *   --overwrite is an optional flag to overwrite existing contacts
 * 
 * The CSV file should have headers that match the ContactCreate interface properties
 * Columns can be in either camelCase (firstName) or snake_case (first_name) format
 */

async function main() {
  try {
    // Parse command line arguments
    const args = process.argv.slice(2);
    
    if (args.length < 2) {
      console.error('Usage: bun run scripts/test-bulk-import.ts <org_id> <csv_file> [--overwrite]');
      process.exit(1);
    }
    
    const orgId = args[0];
    const csvPath = args[1];
    const overwriteExisting = args.includes('--overwrite');
    
    // Read and parse the CSV file
    logger.info(`Reading contacts from ${csvPath}`);
    const csvContent = await fs.readFile(csvPath, 'utf-8');
    
    // Parse CSV with header row
    const records = parse(csvContent, {
      columns: true,
      skip_empty_lines: true,
      trim: true
    });
    
    logger.info(`Parsed ${records.length} records from CSV`);
    
    // Convert records to ContactCreate objects
    const contacts: ContactCreate[] = records.map((record: any) => {
      return {
        first_name: record.first_name || record.firstName || '',
        last_name: record.last_name || record.lastName || '',
        email: record.email || '',
        current_carrier: record.current_carrier || record.currentCarrier || '',
        plan_type: record.plan_type || record.planType || '',
        effective_date: record.effective_date || record.effectiveDate || '',
        birth_date: record.birth_date || record.birthDate || '',
        tobacco_user: record.tobacco_user === '1' || record.tobacco_user === 'true' || record.tobaccoUser === true || record.tobaccoUser === '1' || record.tobaccoUser === 'true',
        gender: record.gender || '',
        state: record.state || '',
        zip_code: record.zip_code || record.zipCode || '',
        phone_number: record.phone_number || record.phoneNumber || '',
        agent_id: record.agent_id || record.agentId || null
      };
    });
    
    // Log a sample contact
    logger.info(`Sample contact: ${JSON.stringify(contacts[0])}`);
    
    // Validate contacts
    const validContacts = contacts.filter(contact => {
      return contact.first_name && contact.last_name && contact.email;
    });
    
    logger.info(`Found ${validContacts.length} valid contacts out of ${contacts.length}`);
    
    // Confirm with user
    console.log(`Ready to import ${validContacts.length} contacts for organization ${orgId}.`);
    console.log(`Overwrite existing: ${overwriteExisting}`);
    
    // Add a delay to allow cancellation
    console.log('Starting import in 5 seconds... Press Ctrl+C to cancel');
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Execute bulk import
    const startTime = Date.now();
    logger.info('Starting bulk import...');
    
    await Database.bulkImportContacts(orgId, validContacts, overwriteExisting);
    
    const totalTime = (Date.now() - startTime) / 1000;
    logger.info(`Bulk import completed in ${totalTime.toFixed(2)} seconds`);
    
  } catch (error) {
    logger.error(`Error in test-bulk-import: ${error}`);
    process.exit(1);
  }
}

main();

================
File: src/config/index.ts
================
interface Config {
  TURSO_DATABASE_URL?: string;
  TURSO_AUTH_TOKEN?: string;
  TURSO_DATABASE_PATH?: string;
  TURSO_API_TOKEN?: string;
  TURSO_ORG_GROUP: string;
  TURSO_ORG_SLUG: string;
  STRIPE_SECRET_KEY?: string;
  STRIPE_WEBHOOK_SECRET?: string;
  SENDGRID_API_KEY?: string;
  SENDGRID_FROM_EMAIL?: string;
  SENDGRID_TEMPLATES: Record<string, string>;
  USE_LOCAL_SQLITE: boolean;
  LOCAL_DB_PATH: string;
  clientUrl: string;
}

export const config: Config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  TURSO_API_TOKEN: process.env.TURSO_API_TOKEN,
  TURSO_ORG_GROUP: process.env.TURSO_ORG_GROUP || 'default',
  TURSO_ORG_SLUG: process.env.TURSO_ORG_SLUG || 'default',
  STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
  STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
  SENDGRID_API_KEY: process.env.SENDGRID_API_KEY,
  SENDGRID_FROM_EMAIL: process.env.SENDGRID_FROM_EMAIL,
  SENDGRID_TEMPLATES: {
    QUOTE_EMAIL: 'd-f43dasd8f9a8sd7f98asd7f',
    WELCOME_EMAIL: 'd-a9s8d7f98as7df89as7df9'
  },
  USE_LOCAL_SQLITE: process.env.USE_LOCAL_SQLITE !== 'false',
  LOCAL_DB_PATH: process.env.LOCAL_DB_PATH || 'data/organizations',
  clientUrl: process.env.NODE_ENV === 'production' 
    ? 'https://app.example.com'
    : 'http://localhost:5173'
}

================
File: src/config/turso.ts
================
export const TURSO_CONFIG = {
  API_URL: 'https://api.turso.tech/v1',
  API_TOKEN: process.env.TURSO_API_TOKEN, // Add this to your .env
  ORG_SLUG: 'pyrex41',
  GROUP_NAME: 'medicare-portal',
  LOCATION: 'aws-us-east-1' // We can update this to your preferred location
}

================
File: src/middleware/account-status.ts
================
import { Elysia } from 'elysia';
import { getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { Database } from '../database';

/**
 * Middleware to check if an organization's account is in good standing
 * This can be used on routes that should be blocked if the account has issues
 */
export const accountStatusMiddleware = new Elysia()
  .derive(async ({ request, set }) => {
    try {
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      if (!currentUser) {
        // If no user, let the auth middleware handle it
        return { accountStatus: null };
      }
      
      const db = new Database();
      
      // Query organization status from the view
      const statusResult = await db.query<{
        account_status: string;
        subscription_status: string;
      }>('SELECT account_status, subscription_status FROM organization_status WHERE id = ?', 
         [currentUser.organization_id]);
      
      if (!statusResult || statusResult.length === 0) {
        logger.error(`Could not find organization status for org ID: ${currentUser.organization_id}`);
        return { accountStatus: null };
      }
      
      const status = statusResult[0];
      
      // If account is not in good standing, block access to certain operations
      if (status.account_status !== 'good_standing') {
        logger.warn(`Blocked access due to account status: ${status.account_status} for org ${currentUser.organization_id}`);
        return { accountStatus: status.account_status, subscription_status: status.subscription_status };
      }
      
      // Account is in good standing
      return { accountStatus: 'good_standing' };
      
    } catch (error) {
      logger.error(`Error in account status middleware:`, error);
      return { accountStatus: null };
    }
  });

================
File: src/middleware/auth.ts
================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { Database } from '../database';

interface AuthenticatedRequest extends Request {
  user?: {
    id: number;
    email: string;
    organization_id: number;
    role: string;
    turso_db_url?: string;
    turso_auth_token?: string;
  };
}

export async function authMiddleware(
  req: AuthenticatedRequest, 
  res: Response, 
  next: NextFunction
) {
  try {
    // Verify JWT token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      res.status(401).json({ error: 'No token provided' });
      return;
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
      userId: number;
    };

    const db = new Database();

    // Get user with organization info from central DB
    const user = await db.execute(
      `SELECT u.*, o.turso_db_url, o.turso_auth_token
       FROM users u
       JOIN organizations o ON u.organization_id = o.id
       WHERE u.id = ?`,
      [decoded.userId]
    );

    if (!user) {
      res.status(401).json({ error: 'User not found' });
      return;
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Unauthorized' });
  }
}

================
File: src/middleware/error.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'

export const errorHandler = new Elysia()
  .onError(({ code, error, set }) => {
    logger.error(`❌ Error: ${code} - ${error.message}`);
    
    switch (code) {
      case 'NOT_FOUND':
        set.status = 404;
        return {
          success: false,
          message: 'Resource not found'
        };
      
      case 'VALIDATION':
        set.status = 400;
        return {
          success: false,
          message: error.message
        };
      
      default:
        set.status = 500;
        return {
          success: false,
          message: 'Internal server error'
        };
    }
  });

================
File: src/routes/admin-portal.ts
================
import { Elysia } from 'elysia'
import { spawn } from 'child_process'
import path from 'path'
import { logger } from '../logger'
import { requireAuth, requireAdmin } from '../middleware/auth'

// Create admin portal routes
export const createAdminPortalRoutes = () => {
  const adminPortal = new Elysia({ prefix: '/api/admin' })
    .use(requireAuth)
    .use(requireAdmin)

    // Get available admin scripts
    .get('/scripts', () => {
      const availableScripts = [
        {
          id: 'add-agent',
          name: 'Add Agent',
          description: 'Interactive tool to add new agents',
          script: 'add-agent.ts'
        },
        {
          id: 'manage-recommendations',
          name: 'Manage GI Recommendations', 
          description: 'Manage guaranteed issue recommendations',
          script: 'manage-recommendations.ts'
        }
      ]
      
      return { scripts: availableScripts }
    })

    // Execute script endpoint
    .post('/execute/:scriptId', ({ params, set, server }) => {
      const { scriptId } = params
      const scriptPath = path.join(__dirname, '../../scripts', `${scriptId}.ts`)

      logger.info(`Executing admin script: ${scriptId}`)

      // Spawn script process
      const process = spawn('bun', ['run', scriptPath], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      // Get WebSocket server instance
      const wss = server.webSocket

      // Handle new WebSocket connections
      wss.on('connection', (ws) => {
        logger.info('Admin terminal WebSocket connected')

        // Handle input from client
        ws.on('message', (data: string) => {
          const parsed = JSON.parse(data)
          if (parsed.type === 'input') {
            process.stdin.write(parsed.data)
          }
        })

        // Send output to client
        process.stdout.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'output', 
            data: data.toString() 
          }))
        })

        process.stderr.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'error', 
            data: data.toString() 
          }))
        })

        // Handle process exit
        process.on('exit', (code) => {
          ws.send(JSON.stringify({ type: 'exit', code }))
          logger.info(`Admin script ${scriptId} exited with code ${code}`)
        })

        // Handle WebSocket close
        ws.on('close', () => {
          logger.info('Admin terminal WebSocket disconnected')
          process.kill()
        })
      })

      set.status = 200
      return { 
        success: true, 
        message: 'Script execution started' 
      }
    })

  return adminPortal
}

================
File: src/routes/admin.ts
================
import { Elysia } from 'elysia'
import { staticPlugin } from '@elysiajs/static'
import { spawn } from 'child_process'
import path from 'path'
import { TursoService } from '../services/turso'

const tursoService = new TursoService()

export const adminRoutes = new Elysia()
  // Protect admin routes
  .guard({
    beforeHandle: ({ request, set }) => {
      // Add your admin authentication logic here
      const isAdmin = true // Replace with actual admin check
      if (!isAdmin) {
        set.status = 401
        return 'Unauthorized'
      }
    }
  })
  // Serve admin portal static files
  .use(staticPlugin({
    assets: '../admin-portal/dist',
    prefix: '/admin'
  }))
  // Terminal WebSocket endpoint
  .ws('/admin/terminal', {
    open(ws) {
      ws.send('Connected to admin terminal')
    },
    message(ws, message) {
      const { command, args } = JSON.parse(message as string)
      
      const scripts = {
        'add-agent': '../scripts/add-agent.ts',
        'manage-recommendations': '../scripts/manage-recommendations.ts'
      }

      if (!scripts[command]) {
        ws.send(JSON.stringify({ error: 'Invalid command' }))
        return
      }

      const script = spawn('bun', [path.resolve(__dirname, scripts[command]), ...args], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      script.stdout.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'output', data: data.toString() }))
      })

      script.stderr.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'error', data: data.toString() }))
      })

      script.on('close', (code) => {
        ws.send(JSON.stringify({ type: 'exit', code }))
      })
    }
  })

// In your create organization endpoint:
app.post('/api/organizations', async (req, res) => {
  const { name, /* other org fields */ } = req.body
  
  try {
    // Create org in central DB
    const org = await db.one(`
      INSERT INTO organizations (name) 
      VALUES ($1) 
      RETURNING id`, 
      [name]
    )

    // Create Turso DB for org
    const { url, token } = await tursoService.createOrganizationDatabase(org.id)

    // Update org with Turso credentials
    await db.none(`
      UPDATE organizations 
      SET turso_db_url = $1, turso_auth_token = $2
      WHERE id = $3`,
      [url, token, org.id]
    )

    res.json({ success: true, organization: org })
  } catch (err) {
    res.status(500).json({ success: false, error: err.message })
  }
})

================
File: src/routes/auth.ts
================
import { Elysia } from 'elysia';
import { cookie } from '@elysiajs/cookie';
import { AuthService } from '../services/auth';
import { EmailService } from '../services/email';
import { logger } from '../logger';
import { randomBytes } from 'crypto';
import { config } from '../config';
import crypto from 'crypto';
import { db } from '../database';
import { Database } from '../database';
import { getUserFromSession } from '../services/auth';
import type { User } from '../types';

const dbInstance = new Database();

export function createAuthRoutes() {
  const auth = new AuthService();
  const emailService = new EmailService();

  return new Elysia()
    .use(cookie())
    .post('/api/auth/login', async ({ body, set }) => {
      try {
        const { email } = body as { email: string };
        logger.info(`Login request for email: ${email}`);

        // Check if user exists
        const client = dbInstance.getClient();
        const userResult = await client.execute({
          sql: 'SELECT id, email FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        if (userResult.rows.length === 0) {
          // Don't reveal if user exists or not
          logger.info(`No active user found for email: ${email}`);
          return { success: true };
        }

        // Generate and send magic link
        const magicLink = await auth.createMagicLink(
          email,
          'default', // Default organization for now
          { redirectUrl: '/walkthrough' }
        );

        // Always send the email, but also log in development
        if (process.env.NODE_ENV === 'development') {
          logger.info(`Development mode - Magic link: ${magicLink}`);
        }
        
        // Send the email
        await emailService.sendMagicLink(email, magicLink, 'default');

        return { success: true };

      } catch (e) {
        logger.error(`Login error: ${e}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Internal server error'
        };
      }
    })

    .get('/api/auth/verify/:organizationSlug/:token', async ({ params, cookie, setCookie }) => {
      const { token, organizationSlug } = params;
      
      logger.info(`Starting verification for org ${organizationSlug}`);

      try {
        logger.info('Verifying magic link');
        const result = await auth.verifyMagicLink(token, organizationSlug);
        logger.info(`Magic link verification result: ${JSON.stringify(result)}`);
        
        if (!result.valid) {
          logger.error('Magic link validation failed');
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        // Create session ID
        const sessionId = crypto.randomBytes(32).toString('hex');
        logger.info(`Created session ID: ${sessionId}`);

        // First find user by email
        const user = await db.fetchOne<User>(
          `SELECT u.*, o.slug as organization_slug 
           FROM users u 
           JOIN organizations o ON u.organization_id = o.id 
           WHERE LOWER(u.email) = LOWER(?) AND u.is_active = 1`,
          [result.email]
        );

        if (!user) {
          logger.error(`No active user found for email: ${result.email}`);
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        logger.info(`Found user: ${JSON.stringify(user)}`);

        // Create session in database
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

        await db.execute(
          'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
          [sessionId, user.id, expiresAt.toISOString()]
        );

        logger.info(`Created session in database for user ${user.id}`);

        // Set session cookie
        setCookie('session', sessionId, {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7 // 7 days
        });

        const verificationResult = {
          success: true,
          redirectUrl: '/walkthrough',  // Always redirect to walkthrough page instead of dashboard
          session: sessionId,
          email: result.email,
          orgSlug: user.organization_id.toString()  // Use organization_id since organization_slug may not exist
        };
        logger.info(`Sending verification response: ${JSON.stringify(verificationResult)}`);
        return verificationResult;

      } catch (error) {
        logger.error(`Verification error: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return {
          success: false,
          redirectUrl: "/login",
          session: "",
          email: ""
        };
      }
    })

    .get('/api/auth/session', async ({ cookie }) => {
      const sessionId = cookie.session;
      logger.info(`Session check - Cookie session ID: ${sessionId}`);
      
      if (!sessionId) {
        logger.info('No session cookie found');
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: ""
        };
      }

      try {
        // Get user and organization info from session
        logger.info(`Looking up session in database: ${sessionId}`);
        const sessionUser = await db.fetchOne<{
          id: number;
          email: string;
          first_name: string;
          last_name: string;
          organization_slug: string;
        }>(
          `SELECT u.id, u.email, u.first_name, u.last_name, o.slug as organization_slug
           FROM sessions s
           JOIN users u ON s.user_id = u.id
           JOIN organizations o ON u.organization_id = o.id
           WHERE s.id = ?`,
          [sessionId]
        );

        if (!sessionUser) {
          logger.info(`No session found in database for ID: ${sessionId}`);
          return { 
            valid: false,
            session: "",
            email: "",
            organizationSlug: "",
            first_name: "",
            last_name: "",
            id: ""
          };
        }

        logger.info(`Found valid session for user: ${sessionUser.email}`);
        logger.info(`Session details: ${JSON.stringify(sessionUser, null, 2)}`);

        return { 
          valid: true,
          session: sessionId,
          email: sessionUser.email,
          organizationSlug: sessionUser.organization_slug,
          first_name: sessionUser.first_name,
          last_name: sessionUser.last_name,
          id: sessionUser.id
        };
      } catch (error) {
        logger.error(`Error getting session info: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: ""
        };
      }
    })

    .post('/api/auth/logout', async ({ set }) => {
      set.headers['Set-Cookie'] = 'session=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT';
      return { success: true };
    });
}

================
File: src/routes/brand.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';

const db = new Database();

interface Organization {
  id: number;
}

interface BrandSettings {
  brand_name: string;
  primary_color: string;
  secondary_color: string;
  logo_data: string | null;
}

export function createBrandRoutes() {
  return new Elysia()
    .get('/api/organizations/:orgSlug/brand', async ({ params }) => {
      try {
        const { orgSlug } = params;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Get brand settings
        const settings = await db.fetchOne<BrandSettings>(
          'SELECT brand_name, primary_color, secondary_color, logo_data FROM brand_settings WHERE organization_id = ?',
          [org.id]
        );

        if (!settings) {
          // Return defaults if no settings exist
          return {
            brand_name: '',
            primary_color: '#6B46C1',
            secondary_color: '#9F7AEA',
            logo: null
          };
        }

        return {
          brand_name: settings.brand_name,
          primary_color: settings.primary_color,
          secondary_color: settings.secondary_color,
          logo: settings.logo_data
        };
      } catch (error) {
        logger.error('Error fetching brand settings', error);
        return {
          success: false,
          error: 'Failed to fetch brand settings'
        };
      }
    })
    .put('/api/organizations/:orgSlug/brand', async ({ params, body }) => {
      try {
        const { orgSlug } = params;
        const { brand_name, primary_color, secondary_color, logo } = body as any;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Upsert brand settings
        await db.execute(`
          INSERT INTO brand_settings 
            (organization_id, brand_name, primary_color, secondary_color, logo_data)
          VALUES (?, ?, ?, ?, ?)
          ON CONFLICT(organization_id) DO UPDATE SET
            brand_name = excluded.brand_name,
            primary_color = excluded.primary_color,
            secondary_color = excluded.secondary_color,
            logo_data = excluded.logo_data
        `, [org.id, brand_name, primary_color, secondary_color, logo]);

        return {
          success: true
        };
      } catch (error) {
        logger.error('Error saving brand settings', error);
        return {
          success: false,
          error: 'Failed to save brand settings'
        };
      }
    });
}

================
File: src/routes/contacts.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import type { ContactCreate } from '../types';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

type User = {
  id: number;
  organization_id: number;
  is_admin: boolean;
};

type Store = {
  user: User;
};

type Context = {
  request: Request;
  store: Store;
  set: { status: number };
  body: { overwriteExisting?: boolean };
  params: { orgId: string };
  query: Record<string, string | undefined>;
};

/**
 * Contacts API endpoints
 */
export const contactsRoutes = new Elysia({ prefix: '/api/contacts' })
  .guard({
    beforeHandle: [
      async ({ request, store }) => {
        const user = await Database.getUserFromSession(request);
        if (user) {
          store.user = user;
        }
      }
    ]
  }, app => app
    
    // Get paginated contacts with filtering
    .get('/', async ({ query, store, set }: Context) => {
      const user = store.user;
      if (!user || !user.organization_id) {
        set.status = 401;
        return { error: 'Not authorized' };
      }

      try {
        // Get parameters from query
        const page = parseInt(query?.page as string) || 1;
        const limit = parseInt(query?.limit as string) || 50;
        
        // Handle filters - either from a JSON string or from individual parameters
        let filters = {};
        if (query?.filters) {
          try {
            filters = JSON.parse(query.filters as string);
          } catch (e) {
            logger.warn(`Failed to parse filters JSON: ${query.filters}`);
          }
        }
        
        // Also handle individual filter parameters
        const search = query?.search;
        const statesParam = query?.states;
        const carriersParam = query?.carriers;
        const agentsParam = query?.agents;
        
        if (search) filters.name = search;
        if (statesParam) filters.state = statesParam;
        if (carriersParam) filters.carrier = carriersParam;
        
        logger.info(`GET /api/contacts - Fetching page ${page}, limit ${limit}, filters: ${JSON.stringify(filters)}, search: ${search}, states: ${statesParam}, carriers: ${carriersParam}, agents: ${agentsParam}`);
        
        // Get organization database
        const orgDb = await Database.getOrgDb(user.organization_id.toString());
        logger.info(`GET /api/contacts - Connected to organization database for org ${user.organization_id}`);
        
        // Implement pagination directly with SQL
        const offsetValue = (page - 1) * limit;
        
        // Build the WHERE clause based on provided filters
        let whereClause = '1=1'; // Default condition (all records)
        const queryParams: any[] = [];
        
        if (filters) {
          // Handle search/name filter
          if (filters.name) {
            whereClause += ' AND (first_name LIKE ? OR last_name LIKE ?)';
            queryParams.push(`%${filters.name}%`, `%${filters.name}%`);
          }
          
          // Handle email filter
          if (filters.email) {
            whereClause += ' AND email LIKE ?';
            queryParams.push(`%${filters.email}%`);
          }
          
          // Handle state filter (could be a single state or an array)
          if (filters.state) {
            if (Array.isArray(filters.state) && filters.state.length > 0) {
              // For arrays of states, create an IN clause
              const placeholders = filters.state.map(() => '?').join(', ');
              whereClause += ` AND state IN (${placeholders})`;
              queryParams.push(...filters.state);
            } else if (typeof filters.state === 'string' && filters.state.includes(',')) {
              // Handle comma-separated string of states
              const states = filters.state.split(',').map(s => s.trim()).filter(Boolean);
              if (states.length > 0) {
                const placeholders = states.map(() => '?').join(', ');
                whereClause += ` AND state IN (${placeholders})`;
                queryParams.push(...states);
              }
            } else if (typeof filters.state === 'string' && filters.state.trim() !== '') {
              // Handle single state
              whereClause += ' AND state = ?';
              queryParams.push(filters.state);
            }
          }
          
          // Handle carrier filter (could be a single carrier or an array)
          if (filters.carrier) {
            if (Array.isArray(filters.carrier) && filters.carrier.length > 0) {
              // For arrays of carriers, we need multiple LIKE conditions
              const likeConditions = filters.carrier.map(() => 'current_carrier LIKE ?').join(' OR ');
              whereClause += ` AND (${likeConditions})`;
              queryParams.push(...filters.carrier.map(c => `%${c}%`));
            } else if (typeof filters.carrier === 'string' && filters.carrier.includes(',')) {
              // Handle comma-separated string of carriers
              const carriers = filters.carrier.split(',').map(c => c.trim()).filter(Boolean);
              if (carriers.length > 0) {
                const likeConditions = carriers.map(() => 'current_carrier LIKE ?').join(' OR ');
                whereClause += ` AND (${likeConditions})`;
                queryParams.push(...carriers.map(c => `%${c}%`));
              }
            } else if (typeof filters.carrier === 'string' && filters.carrier.trim() !== '') {
              // Handle single carrier
              whereClause += ' AND current_carrier LIKE ?';
              queryParams.push(`%${filters.carrier}%`);
            }
          }
          
          // Handle agent filter
          if (filters.agents) {
            if (Array.isArray(filters.agents) && filters.agents.length > 0) {
              // For arrays of agent IDs
              const placeholders = filters.agents.map(() => '?').join(', ');
              whereClause += ` AND agent_id IN (${placeholders})`;
              queryParams.push(...filters.agents);
            } else if (typeof filters.agents === 'string' && filters.agents.includes(',')) {
              // Handle comma-separated string of agent IDs
              const agentIds = filters.agents.split(',').map(a => parseInt(a.trim())).filter(a => !isNaN(a));
              if (agentIds.length > 0) {
                const placeholders = agentIds.map(() => '?').join(', ');
                whereClause += ` AND agent_id IN (${placeholders})`;
                queryParams.push(...agentIds);
              }
            } else if (typeof filters.agents === 'string' || typeof filters.agents === 'number') {
              // Handle single agent ID
              whereClause += ' AND agent_id = ?';
              queryParams.push(parseInt(filters.agents as string));
            }
          }
        }
        
        // Log the final SQL query
        logger.info(`GET /api/contacts - WHERE clause: ${whereClause}, params: ${JSON.stringify(queryParams)}`);
        
        
        // Get total count
        const countResult = await orgDb.fetchOne(
          `SELECT COUNT(*) as total FROM contacts WHERE ${whereClause}`,
          queryParams
        );
        const total = countResult?.total || 0;
        logger.info(`GET /api/contacts - Found total of ${total} contacts`);
        
        // Get paginated contacts
        const contacts = await orgDb.fetchAll(
          `SELECT * FROM contacts WHERE ${whereClause} ORDER BY created_at DESC LIMIT ? OFFSET ?`,
          [...queryParams, limit, offsetValue]
        );
        logger.info(`GET /api/contacts - Retrieved ${contacts.length} contacts for this page`);
        
        // Map contacts to the expected format
        const mappedContacts = contacts.map(contact => ({
          id: contact.id,
          first_name: contact.first_name,
          last_name: contact.last_name,
          email: contact.email,
          current_carrier: contact.current_carrier,
          plan_type: contact.plan_type,
          effective_date: contact.effective_date,
          birth_date: contact.birth_date,
          tobacco_user: Boolean(contact.tobacco_user),
          gender: contact.gender,
          state: contact.state,
          zip_code: contact.zip_code,
          agent_id: contact.agent_id,
          last_emailed: contact.last_emailed,
          phone_number: contact.phone_number || ''
        }));

        // Create filter options from the available data
        const filterOptions = {
          carriers: [...new Set(contacts.map(c => c.current_carrier).filter(Boolean))],
          states: [...new Set(contacts.map(c => c.state).filter(Boolean))]
        };

        // Format the response to match what the frontend expects
        const response = {
          contacts: mappedContacts,
          filterOptions,
          total,
          page,
          limit
        };
        
        logger.info(`GET /api/contacts - Sending response with ${mappedContacts.length} contacts, total: ${total}`);
        return response;
      } catch (error) {
        logger.error(`Error in GET /api/contacts: ${error}`);
        set.status = 500;
        return { error: 'Failed to fetch contacts' };
      }
    })
    
    // Bulk import contacts from CSV
    .post('/bulk-import',
      {
        body: t.Object({
          overwriteExisting: t.Optional(t.Boolean())
        })
      },
      async ({ request, store, set, body }: Context) => {
        const user = store.user;
        if (!user || !user.organization_id || !user.is_admin) {
          set.status = 401;
          return { error: 'Not authorized for bulk import' };
        }

        try {
          const formData = await request.formData();
          const file = formData.get('file');
          if (!file || !(file instanceof File) || path.extname(file.name).toLowerCase() !== '.csv') {
            set.status = 400;
            return { error: 'File must be a CSV' };
          }

          const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'import-'));
          const tempFilePath = path.join(tempDir, 'contacts.csv');
          await fs.writeFile(tempFilePath, Buffer.from(await file.arrayBuffer()));

          logger.info(`CSV file saved to ${tempFilePath}, starting import`);

          // Start the import process in the background with high priority
          const importPromise = Database.bulkImportContacts(
            user.organization_id.toString(), 
            tempFilePath, 
            body.overwriteExisting || false
          );

          // Handle promise completion to clean up temp files and log results
          importPromise
            .then(() => {
              logger.info(`Import completed successfully for organization ${user.organization_id}`);
              return fs.rm(tempDir, { recursive: true, force: true });
            })
            .catch((error: Error) => {
              logger.error(`Background import failed for organization ${user.organization_id}: ${error}`);
              return fs.rm(tempDir, { recursive: true, force: true }).catch(() => {
                logger.error(`Failed to clean up temp directory ${tempDir}`);
              });
            });

          return { 
            success: true, 
            message: 'Started import of contacts',
            organizationId: user.organization_id
          };
        } catch (error) {
          const err = error as Error;
          logger.error(`Error in bulk import: ${err}`);
          set.status = 500;
          return { error: 'Failed to process import: ' + err.message };
        }
      }
    )
    
    // Add route to check import status
    .get('/import-status/:orgId', async ({ params, store, set }: Context) => {
      const user = store.user;
      
      if (!user || !user.organization_id) {
        set.status = 401;
        return { error: 'Not authorized' };
      }
      
      // Only admins can check import status for any org
      // Regular users can only check their own org's status
      if (Number(params.orgId) !== user.organization_id && !user.is_admin) {
        set.status = 403;
        return { error: 'Not authorized to view this organization' };
      }
      
      try {
        // Look for a backup file to indicate an import is in progress
        const backupDir = path.join(process.cwd(), 'backups');
        const files = await fs.readdir(backupDir);
        
        // Filter files for this organization
        const orgBackups = files.filter(file => file.startsWith(`org-${params.orgId}-`));
        
        if (orgBackups.length === 0) {
          return { 
            status: 'none',
            message: 'No import in progress or recently completed' 
          };
        }
        
        // Sort by creation time (most recent first)
        const statPromises = orgBackups.map(async (file) => {
          const stats = await fs.stat(path.join(backupDir, file));
          return { file, stats };
        });
        
        const fileStats = await Promise.all(statPromises);
        fileStats.sort((a, b) => b.stats.mtimeMs - a.stats.mtimeMs);
        
        const latestBackup = fileStats[0];
        const ageInMinutes = (Date.now() - latestBackup.stats.mtimeMs) / 60000;
        
        // If backup file is less than 30 minutes old, consider it active
        if (ageInMinutes < 30) {
          const timestamp = latestBackup.file.split('-').pop()?.split('.')[0] || '';
          
          // Check logs for progress info
          let progress = "unknown";
          try {
            const logs = await fs.readFile(path.join(process.cwd(), 'logs', 'ai-interactions.log'), 'utf-8');
            const progressLines = logs.split('\n').filter(line => 
              line.includes(`org-${params.orgId}-${timestamp}`) && line.includes('contacts')
            );
            
            if (progressLines.length > 0) {
              const lastLine = progressLines[progressLines.length - 1];
              if (lastLine.includes('completed successfully')) {
                progress = "completed";
              } else {
                progress = "in progress";
              }
            }
          } catch (error) {
            // Can't read logs, continue with unknown status
          }
          
          return {
            status: progress,
            message: `Import ${progress === "completed" ? "completed" : "in progress"}`,
            timestamp: new Date(parseInt(timestamp)).toISOString(),
            age: Math.round(ageInMinutes)
          };
        } else {
          return {
            status: 'completed',
            message: 'Import completed',
            timestamp: new Date(latestBackup.stats.mtimeMs).toISOString(),
            age: Math.round(ageInMinutes)
          };
        }
      } catch (error) {
        const err = error as Error;
        logger.error(`Error checking import status: ${err}`);
        return { 
          status: 'error',
          message: `Error checking import status: ${err.message}`
        };
      }
    })
  );

================
File: src/routes/eligibility.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';

interface EligibilityAnswers {
    quote_id?: string;
    contact_id?: string;
    answers: Record<string, {
        question_text: string;
        question_type: string;
        answer: boolean | string | null;
    }>;
}

export const eligibilityRoutes = (app: Elysia) => {
    app
        // Get organization details
        .get('/api/org/:orgId/details', async ({ params }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                // Get organization details from main database
                const mainDb = new Database();
                const orgDetails = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                    'SELECT name, logo_data FROM organizations WHERE id = ?',
                    [orgId]
                );

                if (!orgDetails) {
                    return {
                        success: false,
                        error: 'Organization not found'
                    };
                }

                return {
                    name: orgDetails.name,
                    logo_data: orgDetails.logo_data
                };
            } catch (error) {
                logger.error(`Error getting organization details: ${error}`);
                throw new Error('Failed to get organization details');
            }
        })

        // Get existing eligibility answers for a contact
        .get('/api/org/:orgId/eligibility-answers/:contactId', async ({ params }) => {
            try {
                const { orgId, contactId } = params;
                if (!orgId || !contactId) {
                    return {
                        success: false,
                        error: 'Missing required parameters'
                    };
                }

                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);

                // Get the most recent answers for this contact
                const result = await orgDb.fetchOne<{ answers: string }>(
                    'SELECT answers FROM eligibility_answers WHERE contact_id = ? ORDER BY created_at DESC LIMIT 1',
                    [contactId]
                );

                if (!result) {
                    return {
                        success: false,
                        error: 'No answers found'
                    };
                }

                // Get organization details from main database
                const mainDb = new Database();
                const orgDetails = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                    'SELECT name, logo_data FROM organizations WHERE id = ?',
                    [orgId]
                );

                return {
                    answers: JSON.parse(result.answers),
                    orgName: orgDetails?.name || 'Medicare Max',
                    orgLogo: orgDetails?.logo_data || null
                };
            } catch (error) {
                logger.error(`Error getting eligibility answers: ${error}`);
                throw new Error('Failed to get eligibility answers');
            }
        })

        // Create a temporary contact for collecting eligibility answers
        .post('/api/org/:orgId/temp-contact', async ({ params }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);
                
                // Create a minimal contact record for just eligibility assessment
                const result = await orgDb.execute(
                    `INSERT INTO contacts 
                    (first_name, last_name, email, current_carrier, plan_type, effective_date, birth_date, tobacco_user, gender, state, zip_code, phone_number, status) 
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    [
                        'Temporary', 
                        'Contact', 
                        `temp-${Date.now()}@example.com`, 
                        '', 
                        'G', 
                        '', 
                        '1950-01-01', 
                        0, 
                        'M', 
                        '', 
                        '00000', 
                        '', 
                        'temp'
                    ]
                );

                // Get the inserted ID from the result
                const contactId = result.lastInsertRowid?.toString();
                
                if (!contactId) {
                    throw new Error('Failed to create temporary contact');
                }

                // Add a record to contact_events to track this
                await orgDb.execute(
                    `INSERT INTO contact_events 
                    (contact_id, event_type, metadata) 
                    VALUES (?, ?, ?)`,
                    [
                        contactId,
                        'temp_contact_created',
                        JSON.stringify({ source: 'eligibility_assessment' })
                    ]
                );

                return contactId;
            } catch (error) {
                logger.error(`Error creating temporary contact: ${error}`);
                throw new Error('Failed to create temporary contact');
            }
        })

        // Save eligibility answers
        .post('/api/org/:orgId/eligibility-answers', async ({ params, body }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                const data = body as EligibilityAnswers;
                
                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);
                
                let contactId: string | null = null;
                
                // If quote_id is provided, get the contact_id from it
                if (data.quote_id) {
                    try {
                        const decodedQuoteId = decodeQuoteId(data.quote_id);
                        if (decodedQuoteId) {
                            contactId = decodedQuoteId.contactId.toString();
                            
                            // Verify the org ID matches
                            if (decodedQuoteId.orgId.toString() !== orgId) {
                                return {
                                    success: false,
                                    error: 'Invalid quote ID - organization mismatch'
                                };
                            }
                        }
                    } catch (error) {
                        logger.error(`Error decoding quote ID: ${error}`);
                        return {
                            success: false,
                            error: 'Invalid quote ID'
                        };
                    }
                } else if (data.contact_id) {
                    // If contact_id is provided directly, use it
                    contactId = data.contact_id;
                }
                
                if (!contactId) {
                    return {
                        success: false,
                        error: 'Missing contact ID'
                    };
                }
                
                // Verify contact exists in this org
                const contact = await orgDb.fetchOne(
                    'SELECT id FROM contacts WHERE id = ?',
                    [contactId]
                );
                
                if (!contact) {
                    return {
                        success: false,
                        error: 'Contact not found'
                    };
                }

                // Get organization details from main database
                const mainDb = new Database();
                const orgDetails = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                    'SELECT name, logo_data FROM organizations WHERE id = ?',
                    [orgId]
                );
                
                // Store the eligibility answers
                const answersJson = JSON.stringify(data.answers);
                
                // Check if we already have answers for this contact
                const existingAnswers = await orgDb.fetchOne(
                    'SELECT id FROM eligibility_answers WHERE contact_id = ?',
                    [contactId]
                );
                
                if (existingAnswers) {
                    // Update existing answers
                    await orgDb.execute(
                        'UPDATE eligibility_answers SET answers = ?, quote_id = ?, created_at = CURRENT_TIMESTAMP WHERE contact_id = ?',
                        [answersJson, data.quote_id || null, contactId]
                    );
                } else {
                    // Insert new answers
                    await orgDb.execute(
                        'INSERT INTO eligibility_answers (contact_id, quote_id, answers) VALUES (?, ?, ?)',
                        [contactId, data.quote_id || null, answersJson]
                    );
                }
                
                // Extract analytics data from enhanced answers
                const analyticsData = {
                    answers_count: Object.keys(data.answers).length,
                    source: data.quote_id ? 'quote' : 'direct',
                    main_questions_yes_count: Object.values(data.answers).filter(a => 
                        a.question_type === 'main' && a.answer === true
                    ).length,
                    has_medical_conditions: Object.values(data.answers).some(a => 
                        a.question_type === 'main' && a.answer === true
                    )
                };
                
                // Add a record to contact_events
                await orgDb.execute(
                    `INSERT INTO contact_events 
                    (contact_id, event_type, metadata) 
                    VALUES (?, ?, ?)`,
                    [
                        contactId,
                        'eligibility_answered',
                        JSON.stringify(analyticsData)
                    ]
                );
                
                return {
                    contactId,
                    orgName: orgDetails?.name || 'Medicare Max',
                    orgLogo: orgDetails?.logo_data || null
                };
            } catch (error) {
                logger.error(`Error saving eligibility answers: ${error}`);
                throw new Error('Failed to save eligibility answers');
            }
        });

    return app;
};

================
File: src/routes/onboarding.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'
import { Database } from '../database'
import { config } from '../config'
import { generateToken, getUserFromSession } from '../services/auth'
import { cookie } from '@elysiajs/cookie'

// Define types for onboarding data
interface OnboardingData {
  plan: {
    type: string
    price: number
    billingCycle: string
    extraAgents: number
    extraContacts: number
  }
  user: {
    firstName: string
    lastName: string
    email: string
    phone: string
    bookingLink: string
  }
  company: {
    agencyName: string
    website: string
    phone: string
    primaryColor: string
    secondaryColor: string
    logo?: string
  }
  licensing: {
    stateLicenses: string[]
    carrierContracts: string[]
    stateCarrierSettings: StateCarrierSetting[]
  }
  agents: any[] // Using any for flexibility, could be more specific
}

interface StateCarrierSetting {
  state: string
  carrier: string
  active: boolean
  targetGI: boolean
}

// Helper function for generating random slugs
const generateRandomSlug = () => {
  const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
  const length = 12;
  let result = '';
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
};

export function createOnboardingRoutes() {
  const dbInstance = new Database()

  return new Elysia()
    .use(cookie())
    // Get onboarding settings using cookie
    .get('/api/onboarding/settings', async ({ cookie, set, headers }) => {
      try {
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        const sessionId = cookie.onboardingSession || headers['x-onboarding-session'];
        
        logger.info(`Fetching onboarding settings with cookies - orgSlug: ${orgSlug ? 'present' : 'missing'}, sessionId: ${sessionId ? 'present' : 'missing'}`);
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            error: 'No organization found in session',
            code: 'NO_ORG_SLUG' 
          };
        }
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found',
            code: 'NO_SESSION' 
          };
        }
        
        // Find organization and its admin user
        const orgInfo = await dbInstance.query<{ 
          id: number, 
          name: string,
          onboarding_step: number,
          subscription_tier: string,
          website: string,
          phone: string,
          primary_color: string,
          secondary_color: string
        }>(
          `SELECT id, name, onboarding_step, subscription_tier, website, phone, primary_color, secondary_color
           FROM organizations 
           WHERE slug = ? AND temp_session_id = ? AND onboarding_completed = FALSE
           LIMIT 1`,
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or onboarding already completed: ${orgSlug} (session: ${sessionId})`);
          
          // Try to find the organization without checking the session
          const orgWithoutSession = await dbInstance.query<{ id: number }>(
            `SELECT id FROM organizations WHERE slug = ? AND onboarding_completed = FALSE LIMIT 1`,
            [orgSlug]
          );
          
          if (orgWithoutSession && orgWithoutSession.length > 0) {
            logger.warn(`Organization exists but invalid session for: ${orgSlug}`);
            set.status = 401;
            return { 
              error: 'Invalid session for this organization',
              code: 'INVALID_SESSION' 
            };
          }
          
          set.status = 404;
          return { 
            error: 'Organization not found or onboarding already completed',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Get admin user details
        const userInfo = await dbInstance.query<{
          id: number,
          email: string,
          first_name: string,
          last_name: string,
          phone: string,
          booking_link: string
        }>(
          `SELECT id, email, first_name, last_name, phone, booking_link
           FROM users
           WHERE organization_id = ? AND is_admin = 1
           LIMIT 1`,
          [orgId]
        );
        
        // Get brand settings (for logo)
        const brandInfo = await dbInstance.query<{
          logo_data: string
        }>(
          `SELECT logo_data
           FROM brand_settings
           WHERE organization_id = ?
           LIMIT 1`,
          [orgId]
        );
        
        // Get licensing settings
        const licensingInfo = await dbInstance.query<{
          org_settings: string
        }>(
          `SELECT org_settings
           FROM organizations
           WHERE id = ?
           LIMIT 1`,
          [orgId]
        );
        
        // Parse carrier contracts and SmartSend settings from org_settings
        let carrierContracts = [];
        let useSmartSendForGI = false;
        try {
          if (licensingInfo.length > 0 && licensingInfo[0].org_settings) {
            const settings = JSON.parse(licensingInfo[0].org_settings);
            
            // Check if settings has a licensing property (new structure)
            if (settings.licensing && settings.licensing.carrierContracts) {
              carrierContracts = settings.licensing.carrierContracts;
            } else {
              // Fallback to old structure
              carrierContracts = settings.carrierContracts || [];
            }
            
            // Check for useSmartSendForGI in both places
            useSmartSendForGI = settings.useSmartSendForGI || 
                               (settings.licensing && settings.licensing.useSmartSendForGI) || 
                               false;
          }
        } catch (e) {
          logger.warn(`Error parsing org settings: ${e}`);
        }
        
        // Get agent list
        const agentList = await dbInstance.query<{
          id: number,
          email: string,
          first_name: string,
          last_name: string,
          phone: string,
          is_admin: number
        }>(
          `SELECT id, email, first_name, last_name, phone, is_admin
           FROM users
           WHERE organization_id = ? AND is_agent = 1 AND id NOT IN 
               (SELECT id FROM users WHERE organization_id = ? AND is_admin = 1 LIMIT 1)`,
          [orgId, orgId]
        );
        
        const agents = agentList.map(agent => ({
          id: agent.id,
          firstName: agent.first_name || '',
          lastName: agent.last_name || '',
          email: agent.email || '',
          phone: agent.phone || '',
          isAdmin: Boolean(agent.is_admin),
          isAgent: true
        }));
        
        // Build response structure
        const response = {
          onboardingStep: orgInfo[0].onboarding_step,
          planSelectionModel: {
            selectedPlan: orgInfo[0].subscription_tier || 'basic'
          },
          userDetailsModel: userInfo.length > 0 ? {
            firstName: userInfo[0].first_name || '',
            lastName: userInfo[0].last_name || '',
            email: userInfo[0].email || '',
            phone: userInfo[0].phone || '',
            bookingLink: userInfo[0].booking_link || ''
          } : null,
          companyDetailsModel: {
            agencyName: orgInfo[0].name || '',
            website: orgInfo[0].website || '',
            phone: orgInfo[0].phone || '',
            primaryColor: orgInfo[0].primary_color || '#0A0F4F',
            secondaryColor: orgInfo[0].secondary_color || '#7B61FF',
            logo: brandInfo.length > 0 ? brandInfo[0].logo_data : ''
          },
          licensingSettingsModel: {
            carrierContracts: carrierContracts,
            useSmartSendForGI: useSmartSendForGI
          },
          addAgentsModel: {
            agents: agents
          },
          paymentModel: {
            extraAgents: 0,
            extraContacts: 0
          },
          enterpriseFormModel: null
        };
        
        logger.info(`Retrieved onboarding settings for org ${orgSlug} (ID: ${orgId}), step: ${orgInfo[0].onboarding_step}`);
        
        return response;
        
      } catch (error) {
        logger.error(`Error fetching onboarding settings: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to fetch onboarding settings',
          code: 'SERVER_ERROR'
        };
      }
    })
    // New endpoint for initial account creation without email requirement
    .post('/api/onboarding/initialize', async ({ body, set, setCookie }) => {
      try {
        const { planType } = body as { planType: string };
        
        logger.info(`Initializing onboarding with plan: ${planType}`);
        
        // Generate a completely random slug (12 characters)
        const slug = generateRandomSlug();
        
        // Create temporary session token
        const tempSessionId = generateToken();
        
        // Set session cookie for 24 hours
        setCookie('onboardingSession', tempSessionId, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/',
          sameSite: 'lax'
        });
        
        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/',
          sameSite: 'lax'
        });
        
        // Create organization with minimal info
        const orgResult = await dbInstance.execute(`
          INSERT INTO organizations (
            name, 
            subscription_tier, 
            created_at, 
            onboarding_completed, 
            slug, 
            onboarding_step,
            temp_session_id
          ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
          ['New Organization', planType || 'basic', slug, 1, tempSessionId]
        );
        
        const orgId = Number(orgResult.lastInsertRowid);
        logger.info(`Created initial organization: ${orgId} with slug: ${slug}`);
        
        return {
          organizationId: orgId,
          slug: slug,
          sessionToken: tempSessionId,
          onboardingStep: 1
        };
        
      } catch (error) {
        logger.error(`Error initializing onboarding: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to initialize onboarding' 
        };
      }
    })
    
    // Alias endpoint for '/api/onboarding/initialize' to support frontend expectations
    .post('/api/onboarding/start', async ({ body, set, setCookie }) => {
      try {
        const { planType } = body as { planType: string };
        
        logger.info(`Starting onboarding with plan: ${planType}`);
        
        // Generate a completely random slug (12 characters)
        const slug = generateRandomSlug();
        
        // Create temporary session token
        const tempSessionId = generateToken();
        
        // Set session cookie for 24 hours
        setCookie('onboardingSession', tempSessionId, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/',
          sameSite: 'lax'
        });
        
        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/',
          sameSite: 'lax'
        });
        
        // Create organization with minimal info
        const orgResult = await dbInstance.execute(`
          INSERT INTO organizations (
            name, 
            subscription_tier, 
            created_at, 
            onboarding_completed, 
            slug, 
            onboarding_step,
            temp_session_id
          ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
          ['New Organization', planType || 'basic', slug, 1, tempSessionId]
        );
        
        const orgId = Number(orgResult.lastInsertRowid);
        logger.info(`Created initial organization: ${orgId} with slug: ${slug}`);
        
        // Return the response in the format expected by the frontend
        return {
          sessionId: tempSessionId,
          planType: planType || 'basic',
          step: 1
        };
        
      } catch (error) {
        logger.error(`Error starting onboarding: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to start onboarding' 
        };
      }
    })
    
    // Endpoint to check if an email is available during onboarding
    .post('/api/onboarding/check-email', async ({ body, set }) => {
      try {
        const { email } = body as { email: string, endpoint?: string };
        
        logger.info(`Checking email availability during onboarding: "${email}"`);
        
        if (!email || !email.trim()) {
          set.status = 400;
          return {
            available: false,
            message: 'Email is required'
          };
        }
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          logger.info(`Email validation failed for: "${email}"`);
          return {
            available: false,
            message: 'Invalid email format'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        const count = existingUser[0]?.count || 0;
        logger.info(`Email check query result count: ${count} for email: "${email}"`);
        
        if (count > 0) {
          return {
            available: false,
            message: 'This email address is already registered'
          };
        }
        
        // If we get here, the email is available
        return {
          available: true,
          message: 'Email is available'
        };
        
      } catch (error) {
        logger.error(`Error checking email availability: ${error}`);
        set.status = 500;
        return {
          available: false,
          message: 'Failed to check email availability'
        };
      }
    })
    
    // Endpoint to check if an agent email is available during onboarding
    .post('/api/onboarding/check-agent-email', async ({ body, set }) => {
      try {
        const { email, sessionId } = body as { email: string, sessionId: string };
        
        logger.info(`Checking agent email availability during onboarding: "${email}"`);
        
        if (!email || !email.trim()) {
          set.status = 400;
          return {
            available: false,
            message: 'Email is required'
          };
        }
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          logger.info(`Agent email validation failed for: "${email}"`);
          return {
            available: false,
            message: 'Invalid email format'
          };
        }
        
        // Find the organization based on the session ID
        const orgData = await dbInstance.query<{ id: number }>(
          'SELECT id FROM organizations WHERE temp_session_id = ?',
          [sessionId]
        );
        
        if (!orgData || orgData.length === 0) {
          logger.warn(`No organization found for session: ${sessionId}`);
          set.status = 401;
          return {
            available: false,
            message: 'Invalid session'
          };
        }
        
        const organizationId = orgData[0].id;
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        const count = existingUser[0]?.count || 0;
        logger.info(`Agent email check query result count: ${count} for email: "${email}"`);
        
        if (count > 0) {
          return {
            available: false,
            message: 'This email address is already registered'
          };
        }
        
        // If we get here, the email is available
        return {
          available: true,
          message: 'Email is available'
        };
        
      } catch (error) {
        logger.error(`Error checking agent email availability: ${error}`);
        set.status = 500;
        return {
          available: false,
          message: 'Failed to check email availability'
        };
      }
    })
    
    // New endpoint to resume onboarding by email
    .post('/api/onboarding/resume-onboarding', async ({ body, set, setCookie }) => {
      try {
        const { email } = body as { email: string };
        
        logger.info(`Attempting to resume onboarding for email: ${email}`);
        
        if (!email || !email.trim()) {
          logger.warn('Attempt to resume onboarding with empty email');
          set.status = 400;
          return { 
            error: 'Email is required' 
          };
        }
        
        // Find user and organization by email
        const userData = await dbInstance.query<{ 
          organization_id: number, 
          slug: string, 
          onboarding_step: number,
          temp_session_id: string,
          subscription_tier: string 
        }>(
          `SELECT u.organization_id, o.slug, o.onboarding_step, o.temp_session_id, o.subscription_tier
           FROM users u
           JOIN organizations o ON u.organization_id = o.id
           WHERE LOWER(u.email) = LOWER(?) AND o.onboarding_completed = FALSE`,
          [email]
        );
        
        if (!userData || userData.length === 0) {
          logger.warn(`No in-progress onboarding found for email: ${email}`);
          set.status = 404;
          return { 
            error: 'No onboarding in progress for this email' 
          };
        }
        
        const { organization_id, slug, onboarding_step, temp_session_id, subscription_tier } = userData[0];
        
        // Update session token if needed
        let sessionToken = temp_session_id;
        if (!sessionToken) {
          sessionToken = generateToken();
          await dbInstance.execute(
            'UPDATE organizations SET temp_session_id = ? WHERE id = ?',
            [sessionToken, organization_id]
          );
          logger.info(`Generated new session token for org ${organization_id}`);
        }
        
        // Set session cookie
        setCookie('onboardingSession', sessionToken, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/',
          sameSite: 'lax'
        });
        
        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/',
          sameSite: 'lax'
        });
        
        logger.info(`Resumed onboarding for organization: ${organization_id}, step: ${onboarding_step}, plan: ${subscription_tier}`);
        
        return {
          organizationId: organization_id,
          slug: slug,
          sessionToken: sessionToken,
          onboardingStep: onboarding_step,
          planType: subscription_tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error resuming onboarding: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to resume onboarding' 
        };
      }
    })
    
    // Endpoint to update user details
    .post('/api/onboarding/user-details', async ({ body, cookie, set, setCookie, request }) => {
      try {
        // Extract all fields from the request body
        const { firstName, lastName, email, phone, bookingLink, planType } = body as { 
          firstName: string, 
          lastName: string, 
          email: string,
          phone: string,
          bookingLink?: string,
          planType?: string // New optional parameter
        };
        
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        let orgId: number;
        
        // Handle case where no cookie exists but planType is provided - create a new organization
        if ((!orgSlug || !sessionId) && planType) {
          logger.info(`No existing organization found, creating new one with plan: ${planType}`);
          
          // Generate a new slug and session token
          const slug = generateRandomSlug();
          const tempSessionId = generateToken();
          
          // Set cookies
          setCookie('onboardingSession', tempSessionId, {
            httpOnly: true,
            maxAge: 60 * 60 * 24, // 24 hours
            path: '/',
            sameSite: 'lax'
          });
          
          setCookie('orgSlug', slug, {
            httpOnly: false,
            maxAge: 60 * 60 * 24 * 30, // 30 days
            path: '/',
            sameSite: 'lax'
          });
          
          // Create organization with minimal info
          const orgResult = await dbInstance.execute(`
            INSERT INTO organizations (
              name, 
              subscription_tier, 
              created_at, 
              onboarding_completed, 
              slug, 
              onboarding_step,
              temp_session_id
            ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
            ['New Organization', planType || 'basic', slug, 1, tempSessionId]
          );
          
          orgId = Number(orgResult.lastInsertRowid);
          logger.info(`Created initial organization: ${orgId} with slug: ${slug} for user ${email}`);
          
          // Create the user immediately
          await dbInstance.execute(
            `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone, 
              booking_link,
              is_admin, 
              is_agent, 
              organization_id, 
              created_at,
              is_active
            ) VALUES (?, ?, ?, ?, ?, 1, 1, ?, datetime('now'), 0)`,
            [email, firstName, lastName, phone, bookingLink || '', orgId]
          );
          
          // Update onboarding step
          await dbInstance.execute(
            'UPDATE organizations SET onboarding_step = 2 WHERE id = ?',
            [orgId]
          );
          
          logger.info(`Created user for new org ${slug} - Name: ${firstName} ${lastName}, Email: ${email}`);
          
          return {
            success: true,
            message: 'User details saved successfully',
            onboardingStep: 2,
            userEmail: email,
            slug: slug,
            sessionToken: tempSessionId
          };
        }
        
        // Handle the existing case where org slug exists
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            error: 'No organization found in session' 
          };
        }
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found' 
          };
        }
        
        logger.info(`Updating user details for organization ${orgSlug} with session ID ${sessionId}`);
        
        // Find organization from slug and session ID
        const orgInfo = await dbInstance.query<{ id: number, subscription_tier: string }>(
          'SELECT id, subscription_tier FROM organizations WHERE slug = ? AND temp_session_id = ? AND onboarding_completed = FALSE',
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or session invalid for slug: ${orgSlug}`);
          set.status = 404;
          return { 
            error: 'Organization not found or invalid session' 
          };
        }
        
        orgId = orgInfo[0].id;
        
        // Check if user already exists for this email but different org
        const existingUserCheck = await dbInstance.query<{ count: number, org_id: number | null }>(
          `SELECT COUNT(*) as count, organization_id as org_id
           FROM users 
           WHERE LOWER(email) = LOWER(?) AND organization_id != ?
           LIMIT 1`,
          [email, orgId]
        );
        
        if (existingUserCheck[0]?.count > 0) {
          logger.warn(`Email ${email} is already in use by another organization`);
          set.status = 400;
          return { 
            success: false, 
            message: 'This email address is already registered with another account' 
          };
        }
        
        // Check if user exists for this org
        const adminUserCheck = await dbInstance.query<{ id: number | null }>(
          `SELECT id FROM users WHERE organization_id = ? AND is_admin = 1 LIMIT 1`,
          [orgId]
        );
        
        if (adminUserCheck.length > 0 && adminUserCheck[0].id) {
          // Update existing user
          await dbInstance.execute(
            `UPDATE users 
             SET first_name = ?, last_name = ?, email = ?, phone = ?, booking_link = ?
             WHERE id = ?`,
            [firstName, lastName, email, phone, bookingLink || '', adminUserCheck[0].id]
          );
        } else {
          // Create new user
          await dbInstance.execute(
            `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone, 
              booking_link,
              is_admin, 
              is_agent, 
              organization_id, 
              created_at,
              is_active
            ) VALUES (?, ?, ?, ?, ?, 1, 1, ?, datetime('now'), 0)`,
            [email, firstName, lastName, phone, bookingLink || '', orgId]
          );
        }
        
        // Update subscription tier if planType is provided and different from current
        if (planType) {
          await dbInstance.execute(
            'UPDATE organizations SET subscription_tier = ? WHERE id = ?',
            [planType, orgId]
          );
        }
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_step = 2 WHERE id = ?',
          [orgId]
        );
        
        logger.info(`Updated user details for org ${orgSlug} - Name: ${firstName} ${lastName}, Email: ${email}`);
        
        return {
          success: true,
          message: 'User details updated successfully',
          onboardingStep: 2,
          userEmail: email,
          slug: orgSlug,
          sessionToken: sessionId,
          planType: orgInfo[0].subscription_tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error updating user details: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to update user details' 
        };
      }
    })
    
    // Endpoint to update company details
    .post('/api/onboarding/company-details', async ({ body, cookie, set, request }) => {
      try {
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            error: 'No organization found in session',
            success: false
          };
        }
        
        // Get session ID from cookie or header (prefer cookie)
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found',
            success: false
          };
        }
        
        logger.info(`Updating company details for organization ${orgSlug} with session ID ${sessionId}`);
        
        const { 
          agencyName, 
          website, 
          phone, 
          primaryColor, 
          secondaryColor,
          logo
        } = body as { 
          agencyName: string,
          website: string,
          phone: string,
          primaryColor: string,
          secondaryColor: string,
          logo?: string
        };
        
        // Find organization from slug and session ID
        const orgInfo = await dbInstance.query<{ id: number, subscription_tier: string }>(
          'SELECT id, subscription_tier FROM organizations WHERE slug = ? AND temp_session_id = ? AND onboarding_completed = FALSE',
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or session invalid for slug: ${orgSlug}`);
          set.status = 404;
          return { 
            error: 'Organization not found or invalid session',
            success: false
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Update organization info with default values if empty
        await dbInstance.execute(`
          UPDATE organizations 
          SET name = COALESCE(NULLIF(?, ''), name, 'New Organization'), 
              website = COALESCE(NULLIF(?, ''), website, ''), 
              phone = COALESCE(NULLIF(?, ''), phone, ''), 
              primary_color = COALESCE(NULLIF(?, ''), primary_color, '#6B46C1'), 
              secondary_color = COALESCE(NULLIF(?, ''), secondary_color, '#9F7AEA')
          WHERE id = ?`,
          [agencyName, website, phone, primaryColor, secondaryColor, orgId]
        );
        
        // Store logo if provided
        if (logo) {
          // Check if brand settings already exist
          const brandCheck = await dbInstance.query<{ count: number }>(
            'SELECT COUNT(*) as count FROM brand_settings WHERE organization_id = ?',
            [orgId]
          );
          
          if (brandCheck[0]?.count > 0) {
            // Update existing brand settings
            await dbInstance.execute(`
              UPDATE brand_settings 
              SET brand_name = COALESCE(NULLIF(?, ''), brand_name, 'New Organization'),
                  primary_color = COALESCE(NULLIF(?, ''), primary_color, '#6B46C1'),
                  secondary_color = COALESCE(NULLIF(?, ''), secondary_color, '#9F7AEA'),
                  logo_data = ?
              WHERE organization_id = ?`,
              [agencyName, primaryColor, secondaryColor, logo, orgId]
            );
          } else {
            // Create new brand settings
            await dbInstance.execute(`
              INSERT INTO brand_settings (
                organization_id, brand_name, primary_color, secondary_color, logo_data
              ) VALUES (?, ?, ?, ?, ?)`,
              [orgId, 
               agencyName || 'New Organization', 
               primaryColor || '#6B46C1', 
               secondaryColor || '#9F7AEA', 
               logo]
            );
          }
        }
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_step = 3 WHERE id = ?',
          [orgId]
        );
        
        logger.info(`Updated company details for org ${orgSlug} - Name: ${agencyName}`);
        
        return {
          success: true,
          message: 'Company details updated successfully',
          onboardingStep: 3,
          slug: orgSlug,
          sessionToken: sessionId,
          planType: orgInfo[0].subscription_tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error updating company details: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to update company details',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to update licensing settings
    .post('/api/onboarding/licensing-settings', async ({ body, cookie, set, request }) => {
      try {
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            error: 'No organization found in session',
            success: false,
            slug: ""
          };
        }
        
        // Get session ID from cookie or header (prefer cookie)
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found',
            success: false,
            slug: orgSlug
          };
        }
        
        logger.info(`Updating licensing settings for organization ${orgSlug} with session ID ${sessionId}`);
        
        const { 
          carrierContracts,
          useSmartSendForGI,
          stateLicenses = [],
          stateCarrierSettings = []
        } = body as { 
          carrierContracts: string[],
          useSmartSendForGI: boolean,
          stateLicenses?: string[],
          stateCarrierSettings?: StateCarrierSetting[]
        };
        
        // Find organization from slug and session ID
        const orgInfo = await dbInstance.query<{ id: number, tier: string, org_settings: string | null }>(
          'SELECT id, subscription_tier as tier, org_settings FROM organizations WHERE slug = ? AND temp_session_id = ? AND onboarding_completed = FALSE',
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or session invalid for slug: ${orgSlug}`);
          set.status = 404;
          return { 
            error: 'Organization not found or invalid session',
            success: false,
            slug: orgSlug
          };
        }
        
        const orgId = orgInfo[0].id;
        
        try {
          // Get existing org_settings if any
          let orgSettings = {};
          if (orgInfo[0].org_settings) {
            try {
              orgSettings = JSON.parse(orgInfo[0].org_settings);
            } catch (parseError) {
              logger.warn(`Error parsing existing org_settings: ${parseError}`);
              // Continue with empty object if parse fails
            }
          }
          
          // Update org_settings with new licensing data
          const updatedSettings = {
            ...orgSettings,
            useSmartSendForGI,
            licensing: {
              carrierContracts,
              stateLicenses,
              stateCarrierSettings
            }
          };
          
          // Store updated settings in org_settings column
          await dbInstance.execute(
            'UPDATE organizations SET org_settings = ? WHERE id = ?',
            [JSON.stringify(updatedSettings), orgId]
          );
          
          logger.info(`Saved licensing settings for org ${orgSlug} (ID: ${orgId}) - Carriers: ${carrierContracts.length}`);
        } catch (settingsError) {
          logger.error(`Error saving licensing settings: ${settingsError}`);
          // Continue execution even if this fails - non-critical
        }
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_step = 4 WHERE id = ?',
          [orgId]
        );
        
        const isBasicPlan = orgInfo[0]?.tier === 'basic';
        const nextStep = isBasicPlan ? 5 : 4; // Skip agents step if basic plan
        
        return {
          success: true,
          message: 'Licensing settings updated successfully',
          onboardingStep: 4,
          nextStep: nextStep,
          isBasicPlan: isBasicPlan,
          sessionToken: sessionId,
          slug: orgSlug,
          planType: orgInfo[0].tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error updating licensing settings: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to update licensing settings',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to add agents
    .post('/api/onboarding/agents', async ({ body, cookie, set, request }) => {
      try {
        // Get org slug and session ID from cookies
        const orgSlug = cookie.orgSlug;
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            success: false,
            message: 'No organization found in session',
            code: 'NO_ORG_SLUG'
          };
        }
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            success: false,
            message: 'Invalid session',
            code: 'NO_SESSION'
          };
        }
        
        logger.info(`Adding agents for organization ${orgSlug} with session ID ${sessionId}`);
        
        const { agents } = body as { 
          agents: Array<{
            firstName: string,
            lastName: string,
            email: string,
            phone: string,
            isAdmin: boolean,
            isAgent: boolean
          }>
        };
        
        // Find organization from slug and session token
        const orgInfo = await dbInstance.query<{ id: number, subscription_tier: string }>(
          'SELECT id, subscription_tier FROM organizations WHERE slug = ? AND temp_session_id = ?',
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Invalid session or organization slug: ${orgSlug}`);
          set.status = 401;
          return { 
            success: false, 
            message: 'Unauthorized: Invalid session',
            code: 'INVALID_SESSION'
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Process agents in transaction to ensure all-or-nothing
        const addedAgents = await dbInstance.transaction(async (db) => {
          const addedEmails = [];
          
          for (const agent of agents) {
            // Check if email already exists
            const emailCheck = await db.query<{ count: number }>(
              'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
              [agent.email]
            );
            
            if (emailCheck[0]?.count > 0) {
              logger.warn(`Skip adding agent with email ${agent.email} - already exists`);
              continue; // Skip this agent, email already exists
            }
            
            // Insert new agent
            await db.execute(`
              INSERT INTO users (
                email,
                first_name,
                last_name,
                phone,
                is_admin,
                is_agent,
                organization_id,
                created_at,
                is_active
              ) VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), 1)`,
              [
                agent.email,
                agent.firstName,
                agent.lastName,
                agent.phone || '',
                agent.isAdmin ? 1 : 0,
                agent.isAgent ? 1 : 0,
                orgId
              ]
            );
            
            logger.info(`Added agent: ${agent.firstName} ${agent.lastName} (${agent.email})`);
            addedEmails.push(agent.email);
          }
          
          return addedEmails;
        });
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_step = 5 WHERE id = ?',
          [orgId]
        );
        
        return {
          success: true,
          message: `Added ${addedAgents.length} agents successfully`,
          addedAgents: addedAgents,
          onboardingStep: 5,
          sessionToken: sessionId,
          slug: orgSlug,
          planType: orgInfo[0].subscription_tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error adding agents: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to add agents',
          code: 'SERVER_ERROR',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to process payment and complete subscription
    .post('/api/onboarding/payment', async ({ body, cookie, set }) => {
      try {
        // Get org slug and session ID from cookies
        const orgSlug = cookie.orgSlug;
        const tempSessionId = cookie.onboardingSession;
        
        if (!orgSlug || !tempSessionId) {
          logger.warn('No organization slug or session ID found in cookie');
          set.status = 401;
          return { 
            success: false,
            message: 'No organization found in session or invalid session',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        logger.info(`Processing payment for organization ${orgSlug} from cookie`);
        
        const { 
          tierId, 
          extraAgents, 
          extraContacts 
        } = body as {
          tierId: string,
          extraAgents: number,
          extraContacts: number
        };
        
        // Find organization from slug and session token
        const orgInfo = await dbInstance.query<{ id: number, email: string }>(
          `SELECT o.id, (SELECT email FROM users WHERE organization_id = o.id AND is_admin = 1 LIMIT 1) as email 
           FROM organizations o WHERE o.slug = ? AND o.temp_session_id = ?`,
          [orgSlug, tempSessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Invalid session or organization slug: ${orgSlug}`);
          set.status = 401;
          return { 
            success: false, 
            message: 'Unauthorized: Invalid session',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Import the Stripe service here
        const { createOrUpdateSubscription } = await import('../services/stripe');
        
        try {
          // Get admin user's email for Stripe customer
          const userEmail = orgInfo[0]?.email;
          if (!userEmail) {
            throw new Error('Admin user email not found');
          }
          
          // Create or update the Stripe subscription
          const stripeResult = await createOrUpdateSubscription({
            tierId: tierId as 'basic' | 'pro' | 'enterprise',
            organizationId: orgId,
            email: userEmail,
            extraAgents: extraAgents || 0,
            extraContacts: extraContacts || 0
          });
          
          // Update organization with Stripe IDs and subscription tier
          await dbInstance.execute(`
            UPDATE organizations 
            SET subscription_tier = ?,
                stripe_customer_id = ?,
                stripe_subscription_id = ?,
                onboarding_completed = TRUE,
                onboarding_step = 6,
                extra_agents = ?,
                extra_contacts = ?,
                temp_session_id = NULL
            WHERE id = ?`,
            [
              tierId, 
              stripeResult.customerId, 
              stripeResult.subscriptionId, 
              extraAgents || 0,
              extraContacts || 0,
              orgId
            ]
          );
          
          // Activate the admin user
          await dbInstance.execute(`
            UPDATE users
            SET is_active = 1
            WHERE organization_id = ? AND is_admin = 1`,
            [orgId]
          );
          
          // Set up the database for the organization
          const { TursoService } = await import('../services/turso');
          const turso = new TursoService();
          
          try {
            const { url, token } = await turso.createOrganizationDatabase(orgId.toString());
            
            // Update organization with Turso database credentials
            await dbInstance.execute(
              'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ? WHERE id = ?',
              [url, token, orgId]
            );
            
            logger.info(`Created Turso database for organization ${orgId}`);
          } catch (dbError) {
            logger.error(`Error creating database: ${dbError}`);
            // Continue execution even if this fails - can be set up later
          }
          
          logger.info(`Successfully completed payment for org ${orgSlug} (ID: ${orgId}) with plan ${tierId}`);
          
          // Return the client secret for frontend payment completion
          return {
            success: true,
            message: 'Subscription activated successfully',
            clientSecret: stripeResult.clientSecret,
            publishableKey: config.stripe.publishableKey,
            organizationId: orgId
          };
          
        } catch (stripeError) {
          logger.error(`Stripe subscription error: ${stripeError}`);
          set.status = 400;
          return {
            success: false,
            error: 'Failed to process subscription payment',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
      } catch (error) {
        logger.error(`Error processing payment: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to process payment',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to handle enterprise plan inquiries
    .post('/api/onboarding/enterprise', async ({ body, cookie, set }) => {
      try {
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            success: false,
            message: 'No organization found in session',
            slug: ""  // Include an empty slug in error responses for decoder compatibility
          };
        }
        
        logger.info(`Processing enterprise inquiry for organization ${orgSlug}`);
        
        const { 
          companyName,
          contactName,
          email,
          phone,
          message
        } = body as { 
          companyName: string, 
          contactName: string, 
          email: string,
          phone: string,
          message?: string
        };
        
        // Find organization by slug
        const orgInfo = await dbInstance.query<{ id: number }>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found: ${orgSlug}`);
          set.status = 404;
          return { 
            success: false, 
            message: 'Organization not found',
            slug: orgSlug  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Update organization to enterprise tier
        await dbInstance.execute(
          'UPDATE organizations SET subscription_tier = ?, onboarding_step = 6 WHERE id = ?',
          ['enterprise', orgId]
        );
        
        // Import SendGrid to send enterprise request email
        const sgMail = await import('@sendgrid/mail');
        sgMail.default.setApiKey(process.env.SENDGRID_API_KEY || '');
        
        const emailContent = `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">New Enterprise Plan Inquiry (Onboarding)</h2>
            
            <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
              <p><strong>Company:</strong> ${companyName}</p>
              <p><strong>Contact Name:</strong> ${contactName}</p>
              <p><strong>Email:</strong> ${email}</p>
              <p><strong>Phone:</strong> ${phone}</p>
              <p><strong>Message:</strong></p>
              <p style="white-space: pre-line;">${message || 'No message provided'}</p>
            </div>
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
              <p><strong>Organization Info:</strong></p>
              <p>Organization ID: ${orgId}</p>
              <p>Organization Slug: ${orgSlug}</p>
            </div>
            
            <p style="color: #666; font-size: 14px;">
              This inquiry was submitted through the Enterprise Form during the onboarding process on MedicareMax.
            </p>
          </div>
        `;
        
        try {
          // Send email notification
          const emailMsg = {
            to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
            from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
            subject: `Enterprise Plan Inquiry from ${contactName} at ${companyName} (Onboarding)`,
            text: `New Enterprise Plan Inquiry (Onboarding):\n\nCompany: ${companyName}\nContact Name: ${contactName}\nEmail: ${email}\nPhone: ${phone}\n\nMessage: ${message || 'No message provided'}\n\nOrganization ID: ${orgId}\nOrganization Slug: ${orgSlug}\n\nThis inquiry was submitted through the Enterprise Form during onboarding on MedicareMax.`,
            html: emailContent
          };
          
          await sgMail.default.send(emailMsg);
          logger.info(`Enterprise inquiry email sent for organization ${orgSlug}`);
        } catch (emailError) {
          logger.error(`Error sending enterprise inquiry email: ${emailError}`);
          // Continue execution even if email fails
        }
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_completed = TRUE, onboarding_step = 6 WHERE id = ?',
          [orgId]
        );
        
        // Activate the admin user
        await dbInstance.execute(
          'UPDATE users SET is_active = 1 WHERE organization_id = ? AND is_admin = 1',
          [orgId]
        );
        
        logger.info(`Successfully submitted enterprise inquiry for org ${orgSlug}`);
        
        return {
          success: true,
          message: 'Enterprise inquiry submitted successfully. Our sales team will contact you shortly.'
        };
        
      } catch (error) {
        logger.error(`Error processing enterprise inquiry: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to process enterprise inquiry',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to complete the onboarding process
    .post('/api/onboarding/complete', async ({ cookie, set }) => {
      try {
        // Get org slug and session ID from cookies
        const orgSlug = cookie.orgSlug;
        const sessionToken = cookie.onboardingSession;
        
        if (!orgSlug || !sessionToken) {
          logger.warn('No organization slug or session ID found in cookie');
          set.status = 401;
          return { 
            success: false,
            message: 'No organization found in session or invalid session',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        logger.info(`Finalizing onboarding for organization ${orgSlug}`);
        
        // Find organization by slug and session token
        const orgInfo = await dbInstance.query<{ id: number }>(
          'SELECT id FROM organizations WHERE slug = ? AND temp_session_id = ?',
          [orgSlug, sessionToken]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Invalid session or organization slug: ${orgSlug}`);
          set.status = 401;
          return { 
            success: false, 
            message: 'Unauthorized: Invalid session',
            slug: orgSlug  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Mark onboarding as completed and clear temp session
        await dbInstance.execute(`
          UPDATE organizations 
          SET onboarding_completed = TRUE,
              onboarding_step = 6,
              temp_session_id = NULL
          WHERE id = ?`,
          [orgId]
        );
        
        // Activate the admin user
        await dbInstance.execute(`
          UPDATE users
          SET is_active = 1
          WHERE organization_id = ? AND is_admin = 1`,
          [orgId]
        );
        
        logger.info(`Successfully finalized onboarding for org ${orgSlug} (ID: ${orgId})`);
        
        return {
          success: true,
          message: 'Onboarding completed successfully'
        };
        
      } catch (error) {
        logger.error(`Error finalizing onboarding: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to finalize onboarding process',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })

    // New endpoint to get all onboarding settings for an organization
    .get('/api/organizations/:orgSlug/onboarding-settings', async ({ params, set, request }) => {
      try {
        const { orgSlug } = params;
        
        logger.info(`Fetching onboarding settings for organization ${orgSlug}`);
        
        // Find organization and its admin user
        const orgInfo = await dbInstance.query<{ 
          id: number, 
          name: string,
          onboarding_step: number,
          subscription_tier: string,
          website: string,
          phone: string,
          primary_color: string,
          secondary_color: string
        }>(
          `SELECT id, name, onboarding_step, subscription_tier, website, phone, primary_color, secondary_color
           FROM organizations 
           WHERE slug = ? AND onboarding_completed = FALSE
           LIMIT 1`,
          [orgSlug]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or onboarding already completed: ${orgSlug}`);
          set.status = 404;
          return { 
            error: 'Organization not found or onboarding already completed',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Get admin user details
        const userInfo = await dbInstance.query<{
          id: number,
          email: string,
          first_name: string,
          last_name: string,
          phone: string,
          booking_link: string
        }>(
          `SELECT id, email, first_name, last_name, phone, booking_link
           FROM users
           WHERE organization_id = ? AND is_admin = 1
           LIMIT 1`,
          [orgId]
        );
        
        // Get brand settings (for logo)
        const brandInfo = await dbInstance.query<{
          logo_data: string
        }>(
          `SELECT logo_data
           FROM brand_settings
           WHERE organization_id = ?
           LIMIT 1`,
          [orgId]
        );
        
        // Get licensing settings
        const licensingInfo = await dbInstance.query<{
          org_settings: string
        }>(
          `SELECT org_settings
           FROM organizations
           WHERE id = ?
           LIMIT 1`,
          [orgId]
        );
        
        // Parse carrier contracts and SmartSend settings from org_settings
        let carrierContracts = [];
        let useSmartSendForGI = false;
        try {
          if (licensingInfo.length > 0 && licensingInfo[0].org_settings) {
            const settings = JSON.parse(licensingInfo[0].org_settings);
            
            // Check if settings has a licensing property (new structure)
            if (settings.licensing && settings.licensing.carrierContracts) {
              carrierContracts = settings.licensing.carrierContracts;
            } else {
              // Fallback to old structure
              carrierContracts = settings.carrierContracts || [];
            }
            
            // Check for useSmartSendForGI in both places
            useSmartSendForGI = settings.useSmartSendForGI || 
                               (settings.licensing && settings.licensing.useSmartSendForGI) || 
                               false;
          }
        } catch (e) {
          logger.warn(`Error parsing org settings: ${e}`);
        }
        
        // Get agent list
        const agentList = await dbInstance.query<{
          id: number,
          email: string,
          first_name: string,
          last_name: string,
          phone: string,
          is_admin: number
        }>(
          `SELECT id, email, first_name, last_name, phone, is_admin
           FROM users
           WHERE organization_id = ? AND is_agent = 1 AND id NOT IN 
               (SELECT id FROM users WHERE organization_id = ? AND is_admin = 1 LIMIT 1)`,
          [orgId, orgId]
        );
        
        const agents = agentList.map(agent => ({
          id: agent.id,
          firstName: agent.first_name || '',
          lastName: agent.last_name || '',
          email: agent.email || '',
          phone: agent.phone || '',
          isAdmin: Boolean(agent.is_admin),
          isAgent: true
        }));
        
        // Build response structure
        const response = {
          onboardingStep: orgInfo[0].onboarding_step,
          planSelectionModel: {
            selectedPlan: orgInfo[0].subscription_tier || 'basic'
          },
          userDetailsModel: userInfo.length > 0 ? {
            firstName: userInfo[0].first_name || '',
            lastName: userInfo[0].last_name || '',
            email: userInfo[0].email || '',
            phone: userInfo[0].phone || '',
            bookingLink: userInfo[0].booking_link || ''
          } : null,
          companyDetailsModel: {
            agencyName: orgInfo[0].name || '',
            website: orgInfo[0].website || '',
            phone: orgInfo[0].phone || '',
            primaryColor: orgInfo[0].primary_color || '#0A0F4F',
            secondaryColor: orgInfo[0].secondary_color || '#7B61FF',
            logo: brandInfo.length > 0 ? brandInfo[0].logo_data : ''
          },
          licensingSettingsModel: {
            carrierContracts: carrierContracts,
            useSmartSendForGI: useSmartSendForGI
          },
          addAgentsModel: {
            agents: agents
          },
          paymentModel: {
            extraAgents: 0,
            extraContacts: 0
          },
          enterpriseFormModel: null
        };
        
        logger.info(`Retrieved onboarding settings for org ${orgSlug} (ID: ${orgId})`);
        
        return response;
        
      } catch (error) {
        logger.error(`Error fetching onboarding settings: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to fetch onboarding settings' 
        };
      }
    })

    // New endpoint to get user details for an organization
    .get('/api/onboarding/user-details', async ({ cookie, set, request }) => {
      try {
        // Get session ID from cookie or header (prefer cookie)
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found',
            success: false
          };
        }
        
        logger.info(`Fetching user details with session ID ${sessionId}`);
        
        // Find organization from session ID
        const orgInfo = await dbInstance.query<{ id: number, slug: string }>(
          'SELECT id, slug FROM organizations WHERE temp_session_id = ?',
          [sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found for session ID: ${sessionId}`);
          set.status = 404;
          return { 
            error: 'Organization not found or invalid session',
            success: false
          };
        }
        
        const orgId = orgInfo[0].id;
        const orgSlug = orgInfo[0].slug;
        
        // Get user details
        const userInfo = await dbInstance.query<{
          first_name: string,
          last_name: string,
          email: string,
          phone: string
        }>(
          `SELECT first_name, last_name, email, phone
           FROM users
           WHERE organization_id = ? AND is_admin = 1
           LIMIT 1`,
          [orgId]
        );
        
        if (!userInfo || userInfo.length === 0) {
          logger.warn(`No user found for organization ID: ${orgId}`);
          set.status = 404;
          return { 
            error: 'No user found for this organization',
            success: false
          };
        }
        
        // Return user details
        return {
          firstName: userInfo[0].first_name || '',
          lastName: userInfo[0].last_name || '',
          email: userInfo[0].email || '',
          phone: userInfo[0].phone || '',
          success: true,
          slug: orgSlug // Include slug for frontend reference
        };
        
      } catch (error) {
        logger.error(`Error fetching user details: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to fetch user details',
          success: false
        };
      }
    })
}

// Function to clean up old organizations that haven't completed onboarding
export async function cleanupOldOrganizations() {
  const dbInstance = new Database();
  
  try {
    logger.info('Running cleanup job for old organizations');
    
    // Find organizations older than 7 days
    const oldOrgs = await dbInstance.query<{ id: number }>(
      `SELECT id FROM organizations 
       WHERE created_at < datetime('now', '-7 days') 
       AND onboarding_completed = FALSE`
    );
    
    if (!oldOrgs || oldOrgs.length === 0) {
      logger.info('No old organizations to clean up');
      return;
    }
    
    logger.info(`Found ${oldOrgs.length} old organizations to check for cleanup`);
    
    for (const org of oldOrgs) {
      // Check if the organization has users
      const userCount = await dbInstance.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE organization_id = ?',
        [org.id]
      );
      
      // Check if the organization has a contact database
      const contactDbCount = await dbInstance.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM contact_databases WHERE organization_id = ?',
        [org.id]
      );
      
      // If no users and no contact database, delete the organization
      if (userCount[0]?.count === 0 && contactDbCount[0]?.count === 0) {
        logger.info(`Deleting old organization: ${org.id}`);
        await dbInstance.execute(
          'DELETE FROM organizations WHERE id = ?',
          [org.id]
        );
      }
    }
    
    logger.info('Completed cleanup job for old organizations');
  } catch (error) {
    logger.error(`Error in cleanup job: ${error}`);
  }
}

export default createOnboardingRoutes

================
File: src/routes/organizations.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { TursoService } from '../services/turso';
import { z } from 'zod';
import { sendMagicLink } from '../services/email';
import { generateToken, getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { AuthService } from '../services/auth';
import { config } from '../config';
import sgMail from '@sendgrid/mail';
import { cookie } from '@elysiajs/cookie';

// Update the validation schema to include slug rules
const signupSchema = z.object({
  organizationName: z.string()
    .min(1, "Organization name is required")
    .max(100, "Organization name must be less than 100 characters")
    .regex(/^[a-zA-Z0-9\s\-_.]+$/, "Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores"),
  adminFirstName: z.string().min(1, "First name is required"),
  adminLastName: z.string().min(1, "Last name is required"),
  adminEmail: z.string().email("Invalid email address"),
  phone: z.string().optional(),
  planType: z.string().optional(),
});

// Enhanced slug generation with uniqueness check
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

export const organizationRoutes = new Elysia({ prefix: '/api' })
  .post('/organizations/signup', async ({ body, set }) => {
    const db = new Database();
    const turso = new TursoService();
    const auth = new AuthService();

    try {
      logger.info(`Attempting to create organization with data: ${JSON.stringify(body)}`);
      const data = signupSchema.parse(body);
      
      // Generate unique slug
      const slug = await generateUniqueSlug(db, data.organizationName);
      logger.info(`Generated unique slug: ${slug}`);
      
      // Check if email is already registered in any organization
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
        [data.adminEmail]
      );

      logger.info(`Existing user check result: ${JSON.stringify(existingUser)}`);

      if (existingUser[0]?.count > 0) {
        logger.warn(`Email ${data.adminEmail} is already registered`);
        set.status = 400;
        return {
          success: false,
          message: 'This email address is already registered. Please use a different email or contact support.'
        };
      }

      // Check if organization name or slug is taken
      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [data.organizationName, slug]
      );

      logger.info(`Existing org check result: ${JSON.stringify(existingOrg)}`);

      if (existingOrg[0]?.count > 0) {
        logger.warn(`Organization name ${data.organizationName} or slug ${slug} is already taken`);
        set.status = 400;
        return {
          success: false,
          message: 'Organization name is already taken'
        };
      }

      // Wrap all database operations in a transaction
      const orgId = await db.transaction('write', async (transactionDb) => {
        // Create organization
        logger.info('Creating organization');
        const org = await transactionDb.execute(
          `INSERT INTO organizations (
            name,
            slug,
            subscription_tier,
            agent_limit,
            contact_limit
          ) VALUES (?, ?, 'basic', 5, 100) RETURNING id`,
          [data.organizationName, slug]
        );

        const orgId = org.rows?.[0]?.id;
        if (!orgId) {
          throw new Error('Failed to create organization');
        }

        logger.info(`Organization created with ID: ${orgId}`);

        // Create inactive admin user
        logger.info('Creating admin user');
        await transactionDb.execute(
          `INSERT INTO users (
            email,
            organization_id,
            is_admin,
            is_agent,
            is_active,
            first_name,
            last_name,
            created_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            data.adminEmail,
            orgId,
            1, // is_admin
            1, // is_agent - Set to 1 for basic tier since admin is also an agent
            1, // is_active
            data.adminFirstName,
            data.adminLastName,
            new Date().toISOString()
          ]
        );

        return orgId;
      });

      // Return success response without sending magic link
      set.status = 201;
      return { 
        success: true,
        message: 'Organization created successfully',
        slug: slug
      };

    } catch (error) {
      logger.error(`Organization creation error: ${error}`);
      set.status = 400;
      return {
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Failed to create organization. Please try again.'
      };
    }
  })
  .get('/organizations/check-name/:name', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedName = decodeURIComponent(params.name);
      const potentialSlug = decodedName
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');

      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [decodedName, potentialSlug]
      );

      const count = existingOrg[0]?.count || 0;

      if (count > 0) {
        return {
          available: false,
          message: 'Organization name is already taken'
        };
      }

      // Validate name format
      if (!/^[a-zA-Z0-9\s\-_.]+$/.test(decodedName)) {
        return {
          available: false,
          message: 'Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores'
        };
      }

      return {
        available: true,
        message: 'Organization name is available'
      };

    } catch (error) {
      logger.error(`Error checking organization name: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check organization name'
      };
    }
  })
  .get('/organizations/check-email/:email', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedEmail = decodeURIComponent(params.email);
      logger.info(`Checking email availability for: "${decodedEmail}"`);
      
      // Basic email format validation
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(decodedEmail)) {
        logger.info(`Email validation failed for: "${decodedEmail}"`);
        return {
          available: false,
          message: 'Invalid email format'
        };
      }

      // Use LOWER() for case-insensitive comparison to match unique constraint behavior
      logger.info(`Running SQL query: SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER('${decodedEmail}')`);
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
        [decodedEmail]
      );

      const count = existingUser[0]?.count || 0;
      logger.info(`Email check query result count: ${count} for email: "${decodedEmail}"`);

      if (count > 0) {
        logger.info(`Email "${decodedEmail}" is already registered`);
        return {
          available: false,
          message: 'This email address is already registered'
        };
      }

      logger.info(`Email "${decodedEmail}" is available`);
      return {
        available: true,
        message: 'Email is available'
      };

    } catch (error) {
      logger.error(`Error checking email: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check email availability'
      };
    }
  })
  .get('/organizations/subscription-tiers', async ({ set }) => {
    const db = new Database();
    try {
      const tiersResult = await db.query<{
        id: string,
        name: string,
        agent_limit: number,
        contact_limit: number,
        price_monthly: number,
        features: string
      }>('SELECT id, name, agent_limit, contact_limit, price_monthly, features FROM subscription_tiers');

      const tiers = tiersResult.map(tier => ({
        id: tier.id,
        name: tier.name,
        price: `$${(tier.price_monthly / 100).toFixed(0)}/mo`,
        agentLimit: tier.agent_limit,
        contactLimit: tier.contact_limit,
        features: JSON.parse(tier.features)
      }));

      return { success: true, tiers };
    } catch (error) {
      logger.error(`Error fetching subscription tiers: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to fetch subscription tiers' };
    }
  })
  .get('/organizations/:orgSlug/subscription', async ({ params, request, set }) => {
    try {
      const db = new Database();
      const orgSlug = params.orgSlug;
      
      logger.info(`GET /organizations/${orgSlug}/subscription - Request received`);
      
      // Get session cookie for debugging
      const sessionCookie = request.headers.get('cookie');
      logger.info(`Session cookie: ${sessionCookie ? 'Present' : 'Missing'}`);
      
      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('Subscription fetch failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Log request information for debugging
      logger.info(`Fetching subscription - orgSlug: ${orgSlug}, userId: ${currentUser.id}, orgId: ${currentUser.organization_id}`);
      
      // Get organization details
      const orgResult = await db.query<{ 
        id: number,
        subscription_tier: string,
        agent_limit: number,
        contact_limit: number
      }>(
        'SELECT id, subscription_tier, agent_limit, contact_limit FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`Subscription fetch failed: Organization not found - ${orgSlug}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Verify user has permission for this org
      if (organization.id !== currentUser.organization_id) {
        logger.error(`Subscription fetch failed: Permission denied - User from org ${currentUser.organization_id} attempted to access org ${organization.id}`);
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to view this organization'
        };
      }
      
      // Set up the response with subscription details
      const response = {
        success: true,
        tierId: organization.subscription_tier,
        agentLimit: organization.agent_limit,
        contactLimit: organization.contact_limit
      };

      logger.info(`Successfully fetched subscription for org ${organization.id}: tier=${organization.subscription_tier}, agents=${organization.agent_limit}, contacts=${organization.contact_limit}`);
      
      return response;
      
    } catch (error) {
      logger.error(`Error fetching organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to fetch subscription details'
      };
    }
  })
  .get('/organizations/my-subscription', async ({ request, set }) => {
    try {
      const db = new Database();
      
      logger.info('GET /organizations/my-subscription - Request received');
      
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('My subscription fetch failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Get organization details using user's organization_id
      const orgResult = await db.query<{ 
        id: number,
        name: string,
        slug: string,
        subscription_tier: string,
        agent_limit: number,
        contact_limit: number,
        stripe_subscription_id: string | null
      }>(
        'SELECT id, name, slug, subscription_tier, agent_limit, contact_limit, stripe_subscription_id FROM organizations WHERE id = ?',
        [currentUser.organization_id]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`My subscription fetch failed: Organization not found for user ${currentUser.id}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Get subscription tier details from subscription_tiers table
      const tierResult = await db.query<{
        name: string,
        agent_limit: number,
        contact_limit: number,
        features: string
      }>(
        'SELECT name, agent_limit, contact_limit, features FROM subscription_tiers WHERE id = ?',
        [organization.subscription_tier]
      );
      
      const tier = tierResult[0] || null;
      
      // Determine subscription status based on Stripe subscription
      const subscriptionStatus = organization.stripe_subscription_id ? 'active' : 'inactive';
      
      // Set up the response with complete subscription details
      const response = {
        success: true,
        organization: {
          id: organization.id,
          name: organization.name,
          slug: organization.slug
        },
        subscription: {
          tierId: organization.subscription_tier,
          tierName: tier?.name || organization.subscription_tier,
          status: subscriptionStatus,
          agentLimit: organization.agent_limit,
          contactLimit: organization.contact_limit,
          features: tier ? JSON.parse(tier.features) : []
        }
      };

      logger.info(`Successfully fetched my subscription for org ${organization.id}: tier=${organization.subscription_tier}, agents=${organization.agent_limit}, contacts=${organization.contact_limit}`);
      
      return response;
      
    } catch (error) {
      logger.error(`Error fetching my organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to fetch subscription details'
      };
    }
  })
  .post('/organizations/:orgSlug/subscription', async ({ params: { orgSlug }, body, request, set }) => {
    try {
      const db = new Database();

      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request)
      if (!currentUser) {
        set.status = 401
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        }
      }

      // Add more detailed logging
      logger.info(`Updating subscription - orgSlug: ${orgSlug}, userId: ${currentUser.organization_id}, body: ${JSON.stringify(body)}`);

      // First verify this user belongs to the organization they're trying to update
      const orgResult = await db.query<{ 
        id: number,
        stripe_customer_id: string | null,
        stripe_subscription_id: string | null,
        name: string
      }>(
        'SELECT id, stripe_customer_id, stripe_subscription_id, name FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404
        return {
          success: false,
          error: 'Organization not found'
        }
      }

      const organization = orgResult[0];

      // Verify user has permission for this org
      if (organization.id !== currentUser.organization_id) {
        logger.error(`User from org ${currentUser.organization_id} attempted to update org ${organization.id}`)
        set.status = 403
        return {
          success: false,
          error: 'You do not have permission to update this organization'
        }
      }

      // Parse the request body
      const { tierId, extraAgents = 0, extraContacts = 0 } = body as { 
        tierId: string, 
        extraAgents?: number, 
        extraContacts?: number 
      };
      
      // Import the Stripe service here to avoid circular dependencies
      const { createOrUpdateSubscription } = await import('../services/stripe');
      
      try {
        // Get user's email for Stripe customer
        const userResult = await db.query<{ email: string }>(
          'SELECT email FROM users WHERE id = ?',
          [currentUser.id]
        );
        
        if (!userResult || userResult.length === 0) {
          throw new Error('User not found');
        }
        
        // Create or update the Stripe subscription
        const stripeResult = await createOrUpdateSubscription({
          tierId: tierId as 'basic' | 'pro' | 'enterprise',
          organizationId: organization.id,
          email: userResult[0].email,
          extraAgents,
          extraContacts,
          stripeCustomerId: organization.stripe_customer_id || undefined
        });
        
        // Update organization with Stripe IDs and subscription tier
        await db.execute(
          `UPDATE organizations 
           SET subscription_tier = ?, 
               stripe_customer_id = ?, 
               stripe_subscription_id = ?
           WHERE id = ?`,
          [tierId, stripeResult.customerId, stripeResult.subscriptionId, organization.id]
        );
        
        // Set up the Turso database after subscription is saved
        const baseUrl = process.env.PUBLIC_URL || 'http://localhost:5173';
        const setupDbResponse = await fetch(`${baseUrl}/api/organizations/${orgSlug}/setup-database`, {
          method: 'POST',
          headers: {
            'Cookie': request.headers.get('cookie') || ''
          }
        });

        if (!setupDbResponse.ok) {
          logger.error(`Failed to set up database for org ${organization.id}`);
        } else {
          logger.info(`Successfully set up database for org ${organization.id}`);
        }

        logger.info(`Successfully updated subscription for org ${organization.id} to tier ${tierId}`);

        // Return the client secret for frontend payment completion
        return {
          success: true,
          message: 'Subscription updated successfully',
          clientSecret: stripeResult.clientSecret,
          publishableKey: config.stripe.publishableKey
        };
        
      } catch (stripeError) {
        logger.error(`Stripe subscription error: ${stripeError}`);
        set.status = 400;
        return {
          success: false,
          error: 'Failed to process subscription payment'
        };
      }

    } catch (e) {
      logger.error(`Error updating subscription: ${e}`)
      set.status = 500
      return {
        success: false,
        error: String(e)
      }
    }
  })
  // Add new endpoint to create Turso database after plan selection
  .post('/organizations/:orgSlug/setup-database', async ({ params, set }) => {
    const db = new Database();
    const turso = new TursoService();

    try {
      const orgSlug = params.orgSlug;

      // Get organization ID from slug
      const orgResult = await db.query<{ id: number, has_db: number }>(
        'SELECT id, CASE WHEN turso_db_url IS NOT NULL THEN 1 ELSE 0 END as has_db FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        return {
          success: false,
          message: 'Organization not found'
        };
      }

      const orgId = orgResult[0].id;

      if (orgResult[0].has_db === 1) {
        set.status = 400;
        return {
          success: false,
          message: 'Organization already has a database'
        };
      }

      // Create Turso database for the organization
      const { url, token } = await turso.createOrganizationDatabase(orgId.toString());

      // Update organization with Turso database credentials
      await db.execute(
        'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ? WHERE id = ?',
        [url, token, orgId]
      );

      logger.info(`Successfully created Turso database for organization ${orgId}`);

      return {
        success: true,
        message: 'Database created successfully'
      };

    } catch (error) {
      logger.error(`Error creating database for organization ${params.orgSlug}: ${error}`);
      set.status = 500;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return {
        success: false,
        message: `Failed to create database: ${errorMessage}`
      };
    }
  })
  // Get organization account status
  .get('/organizations/:orgSlug/account-status', async ({ params, set, request }) => {
    try {
      const db = new Database();
      
      // Authenticate the request
      const currentUser = await getUserFromSession(request);
      if (!currentUser) {
        set.status = 401;
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }
      
      // Get organization ID from slug
      const orgResult = await db.query<{ id: number }>(
        'SELECT id FROM organizations WHERE slug = ?',
        [params.orgSlug]
      );
      
      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        return {
          success: false,
          error: 'Organization not found'
        };
      }
      
      const organizationId = orgResult[0].id;
      
      // Verify user has permission to access this organization
      if (organizationId !== currentUser.organization_id) {
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to access this organization'
        };
      }
      
      // Import the subscription service
      const { checkAccountStatus } = await import('../services/subscription');
      
      // Check account status
      const statusDetails = await checkAccountStatus(organizationId);
      
      return {
        success: true,
        status: statusDetails
      };
      
    } catch (error) {
      logger.error(`Error checking account status: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  
  // Stripe webhook handler
  .post('/stripe-webhook', async ({ body, set, request }) => {
    try {
      const signature = request.headers.get('stripe-signature');
      
      if (!signature) {
        set.status = 400;
        return { success: false, error: 'Stripe signature missing' };
      }
      
      // Import Stripe to verify the webhook
      const Stripe = await import('stripe');
      const stripe = new Stripe.default(config.stripe.secretKey, {
        apiVersion: '2025-02-24.acacia',
      });
      
      const event = stripe.webhooks.constructEvent(
        JSON.stringify(body),
        signature,
        config.stripe.webhookSecret
      );
      
      // Import the Stripe service to handle the webhook
      const { handleStripeWebhook } = await import('../services/stripe');
      await handleStripeWebhook(event);
      
      logger.info(`Processed Stripe webhook: ${event.type}`);
      return { success: true };
      
    } catch (error) {
      logger.error(`Error processing Stripe webhook: ${error}`);
      set.status = 400;
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  // Add interface for enterprise contact form data
  .post('/enterprise-contact', async ({ body, set, request }: { 
    body: { name: string; email: string; phone: string; company: string; companySize?: string; message?: string }, 
    set: { status: number },
    request: Request 
  }) => {
    try {
      const { name, email, phone, company, companySize, message } = body;
      
      // Validate required fields
      if (!name || !email || !phone || !company) {
        set.status = 400;
        return { success: false, error: 'Missing required fields' };
      }
      
      // Try to get user/organization info from session if available
      let orgInfo = "";
      try {
        const user = await getUserFromSession(request);
        if (user) {
          orgInfo = `
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <p><strong>User is logged in with the following details:</strong></p>
            <p>Organization: ${user.organization_name} (ID: ${user.organization_id})</p>
            <p>User: ${user.first_name} ${user.last_name} (${user.email})</p>
          </div>`;
        }
      } catch (sessionError) {
        // Just log the error but continue - the session info is optional
        logger.warn(`Unable to get session info: ${sessionError}`);
      }
      
      // Format the email content
      const emailContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">New Enterprise Plan Inquiry</h2>
          
          <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
            <p><strong>Name:</strong> ${name}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Phone:</strong> ${phone}</p>
            <p><strong>Company:</strong> ${company}</p>
            <p><strong>Company Size:</strong> ${companySize || 'Not specified'}</p>
            <p><strong>Message:</strong></p>
            <p style="white-space: pre-line;">${message || 'No message provided'}</p>
          </div>
          ${orgInfo}
          <p style="color: #666; font-size: 14px;">
            This inquiry was submitted through the Enterprise Contact form on the MedicareMax portal.
          </p>
        </div>
      `;
      
      // Configure email
      const msg = {
        to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: `Enterprise Plan Inquiry from ${name} at ${company}`,
        text: `New Enterprise Plan Inquiry:\n\nName: ${name}\nEmail: ${email}\nPhone: ${phone}\nCompany: ${company}\nCompany Size: ${companySize || 'Not specified'}\n\nMessage: ${message || 'No message provided'}\n\n${orgInfo ? `User is logged in from organization: ${orgInfo}` : ''}\n\nThis inquiry was submitted through the Enterprise Contact form on the MedicareMax portal.`,
        html: emailContent
      };
      
      // Send the email
      await sgMail.send(msg);
      
      // Log successful submission
      logger.info(`Enterprise plan inquiry submitted by ${name} from ${company}`);
      
      // Return success response
      return { success: true };
    } catch (error) {
      logger.error(`Error processing enterprise contact submission: ${error}`);
      set.status = 500;
      return { 
        success: false, 
        error: 'Failed to process your request. Please try again later.' 
      };
    }
  })
  // Add endpoint for enterprise inquiry during onboarding
  .post('/enterprise-inquiry', async ({ body, set, request }: { 
    body: { companyName: string; contactName: string; email: string; phone: string; message?: string }, 
    set: { status: number },
    request: Request 
  }) => {
    try {
      const { companyName, contactName, email, phone, message } = body;
      
      // Validate required fields
      if (!companyName || !contactName || !email || !phone) {
        set.status = 400;
        return { success: false, error: 'Missing required fields' };
      }
      
      // Try to get user/organization info from session if available
      let orgInfo = "";
      try {
        const user = await getUserFromSession(request);
        if (user) {
          orgInfo = `
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <p><strong>User is logged in with the following details:</strong></p>
            <p>Organization: ${user.organization_name} (ID: ${user.organization_id})</p>
            <p>User: ${user.first_name} ${user.last_name} (${user.email})</p>
          </div>`;
        }
      } catch (sessionError) {
        // Just log the error but continue - the session info is optional
        logger.warn(`Unable to get session info: ${sessionError}`);
      }
      
      // Format the email content
      const emailContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">New Enterprise Plan Inquiry (Onboarding)</h2>
          
          <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
            <p><strong>Company:</strong> ${companyName}</p>
            <p><strong>Contact Name:</strong> ${contactName}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Phone:</strong> ${phone}</p>
            <p><strong>Message:</strong></p>
            <p style="white-space: pre-line;">${message || 'No message provided'}</p>
          </div>
          ${orgInfo}
          <p style="color: #666; font-size: 14px;">
            This inquiry was submitted through the Enterprise Form during the onboarding process on MedicareMax.
          </p>
        </div>
      `;
      
      // Configure email
      const msg = {
        to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: `Enterprise Plan Inquiry from ${contactName} at ${companyName} (Onboarding)`,
        text: `New Enterprise Plan Inquiry (Onboarding):\n\nCompany: ${companyName}\nContact Name: ${contactName}\nEmail: ${email}\nPhone: ${phone}\n\nMessage: ${message || 'No message provided'}\n\n${orgInfo ? `User is logged in from organization: ${orgInfo}` : ''}\n\nThis inquiry was submitted through the Enterprise Form during onboarding on MedicareMax.`,
        html: emailContent
      };
      
      // Send the email
      await sgMail.send(msg);
      
      // Log successful submission
      logger.info(`Enterprise plan inquiry (onboarding) submitted by ${contactName} from ${companyName}`);
      
      // Return success response
      return { success: true };
    } catch (error) {
      logger.error(`Error processing enterprise inquiry submission: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to process inquiry' };
    }
  });

export function createOrganizationRoutes() {
  const dbInstance = new Database();
  const authService = new AuthService();

  return new Elysia()
    .use(cookie())
    // Add a new endpoint for direct signup from UserDetails page
    .post('/api/organizations/signup', async ({ body, set, setCookie }) => {
      try {
        const { adminFirstName, adminLastName, adminEmail, phone, organizationName, planType } = body as {
          adminFirstName: string;
          adminLastName: string;
          adminEmail: string;
          phone?: string;
          organizationName: string;
          planType?: string;
        };

        // Validate input
        const validation = signupSchema.safeParse(body);
        if (!validation.success) {
          set.status = 400;
          return {
            success: false,
            message: validation.error.errors[0].message
          };
        }

        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [adminEmail]
        );

        if (existingUser[0]?.count > 0) {
          set.status = 400;
          return {
            success: false,
            message: 'This email address is already registered'
          };
        }

        // Generate a unique slug from the organization name
        const slug = await generateUniqueSlug(dbInstance, organizationName);

        // Create temporary session token
        const tempSessionId = generateToken();

        // Set session cookie for 24 hours
        setCookie('onboardingSession', tempSessionId, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/'
        });

        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/'
        });

        // Create organization
        const orgResult = await dbInstance.execute(`
          INSERT INTO organizations (
            name, 
            subscription_tier, 
            created_at, 
            onboarding_completed, 
            slug, 
            onboarding_step,
            temp_session_id
          ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
          [organizationName, planType || 'basic', slug, 2, tempSessionId]
        );

        const orgId = Number(orgResult.lastInsertRowid);
        logger.info(`Created organization: ${orgId} with slug: ${slug}`);

        // Create admin user
        await dbInstance.execute(
          `INSERT INTO users (
            email, 
            first_name, 
            last_name, 
            phone, 
            is_admin, 
            is_agent, 
            organization_id, 
            created_at,
            is_active
          ) VALUES (?, ?, ?, ?, 1, 1, ?, datetime('now'), 0)`,
          [adminEmail, adminFirstName, adminLastName, phone || '', orgId]
        );

        logger.info(`Created admin user for org ${slug} - Name: ${adminFirstName} ${adminLastName}, Email: ${adminEmail}`);

        // Generate a magic link for verification
        const magicLink = `${config.clientUrl}/auth/verify/${slug}/${tempSessionId}`;

        // Send welcome email
        try {
          await sendMagicLink({
            email: adminEmail,
            magicLink: magicLink,
            name: adminFirstName
          });
          logger.info(`Sent welcome email to ${adminEmail}`);
        } catch (emailError) {
          logger.error(`Failed to send welcome email: ${emailError}`);
          // Continue even if email fails
        }

        return {
          success: true,
          message: 'Organization and admin user created successfully',
          slug: slug
        };

      } catch (error) {
        logger.error(`Error creating organization: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to create organization'
        };
      }
    })
    
    // Add a new endpoint to check email availability
    .get('/api/organizations/check-email/:email', async ({ params, set }) => {
      try {
        const { email } = params;
        
        if (!email || !email.trim()) {
          set.status = 400;
          return {
            available: false,
            message: 'Email is required'
          };
        }
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          return {
            available: false,
            message: 'Invalid email format'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        const count = existingUser[0]?.count || 0;
        
        if (count > 0) {
          return {
            available: false,
            message: 'This email address is already registered'
          };
        }
        
        // If we get here, the email is available
        return {
          available: true,
          message: 'Email is available'
        };
        
      } catch (error) {
        logger.error(`Error checking email availability: ${error}`);
        set.status = 500;
        return {
          available: false,
          message: 'Error checking email availability'
        };
      }
    });
}

================
File: src/routes/quotes.ts
================
import { Elysia } from 'elysia';
import axios from 'axios';
import { config } from '../config';
import { logger } from '../logger';
import { Database } from '../database';
import { generateQuoteId, decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';
import { readFile } from 'fs/promises';
import { join } from 'path';
import { readFileSync } from 'fs';


interface ZipInfo {
  state: string;
  counties: string[];
  // Add other ZIP info properties as needed
}


// Update ZIP_DATA declaration
let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'))
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}


interface Quote {
    age: number;
    gender: string;
    plan: string;
    tobacco: number;
    rate: number;
    discount_rate: number;
    discount_category: string;
}

interface QuoteResponse {
    naic: string;
    group: number;
    company_name: string;
    quotes: Quote[];
}

interface QuoteRequestBody {
    zip_code: string;
    state: string;
    age: string | number;
    tobacco: string | boolean;
    gender: string;
    county?: string;
}

interface QuoteRequest {
    zip_code: string;
    state: string;
    age: number;
    tobacco: boolean;
    gender: string;
    plans: string[];
    carriers: string;
    county?: string;
}

interface ContactQuoteInfo {
    zip_code: string;
    birth_date: string;
    age: number;
    tobacco_user: number;
    gender: string;
    email: string;
    first_name: string;
    last_name: string;
    current_carrier: string;
    phone_number: string;
    plan_type: string;
}

// Add new interface for org info response
interface OrgRedirectInfo {
    redirect_url: string | null;
    agent_name: string;
}

function calculateAgeOnFirstOfNextMonth(birthDate: string, currentDate: string): number {
    const birth = new Date(birthDate);
    const current = new Date(currentDate);
    
    // Get first day of next month
    const nextMonth = new Date(current.getFullYear(), current.getMonth() + 1, 1);
    
    // Calculate age based on year difference
    let age = nextMonth.getFullYear() - birth.getFullYear();
    
    // Adjust age if birthday hasn't occurred yet in the target month
    if (
        nextMonth.getMonth() < birth.getMonth() || 
        (nextMonth.getMonth() === birth.getMonth() && 1 < birth.getDate())
    ) {
        age--;
    }
    
    return age;
}


export const quotesRoutes = (app: Elysia) => {
    app
    .get('/api/quotes/generate/:contactId', async ({ params, request }) => {
        try {
            const user = await getUserFromSession(request);
            if (!user?.organization_id) {
                throw new Error('No organization ID found in session');
            }

            const contactId = parseInt(params.contactId);
            if (isNaN(contactId)) {
                throw new Error('Invalid contact ID');
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
            
            // Verify contact exists and belongs to this org
            const contact = await orgDb.fetchOne(
                'SELECT id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                throw new Error('Contact not found');
            }

            // Generate quote ID
            const quoteId = generateQuoteId(user.organization_id, contactId);

            return {
                success: true,
                quoteId,
                redirectUrl: `${process.env.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`
            };
        } catch (e) {
            logger.error(`Error generating quote ID: ${e}`);
            throw new Error(String(e));
        }
    })
    .get('/api/quotes/decode/:quoteId', async ({ params, set }) => {
        try {
            logger.info(`Decoding quote ID: ${params.quoteId}`);
            
            const decoded = decodeQuoteId(params.quoteId);
            if (!decoded) {
                logger.error(`Invalid quote ID format: ${params.quoteId}`);
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID format'
                };
            }
            
            logger.info(`Decoded quote ID: orgId=${decoded.orgId}, contactId=${decoded.contactId}`);

            // Get org-specific database
            logger.info(`Getting database for org: ${decoded.orgId}`);
            const orgDb = await Database.getOrInitOrgDb(decoded.orgId.toString());
            
            const mainDb = new Database();
            logger.info(`Fetching organization details for orgId: ${decoded.orgId}`);
            const result = await mainDb.fetchOne<{ slug: string, org_settings: string, name: string, logo_data: string }>(
                'SELECT slug, org_settings, name, logo_data FROM organizations WHERE id = ?',
                [decoded.orgId]
            );

            if (!result) {
                logger.error(`Organization not found: ${decoded.orgId}`);
                set.status = 404;
                return {
                    success: false,
                    error: 'Organization not found'
                };
            }

            const orgSlug = result.slug;
            logger.info(`Found organization: ${orgSlug} (ID: ${decoded.orgId})`);
            
            let orgSettings;
            try {
                orgSettings = JSON.parse(result.org_settings || '{}');
            } catch (e) {
                logger.warn(`Error parsing org settings for ${decoded.orgId}: ${e}`);
                orgSettings = {};
            }
            
            const carrierContracts = orgSettings?.carrierContracts || [];

            // First try to get the assigned agent from the contact
            const contactQuery = 'SELECT zip_code, birth_date, tobacco_user, gender, email, first_name, last_name, current_carrier, phone_number, plan_type, agent_id FROM contacts WHERE id = ?';
            const contactParams = [decoded.contactId];
            
            logger.info(`Executing contact query: ${contactQuery} with params: [${contactParams}]`);
            
            const contact = await orgDb.fetchOne<ContactQuoteInfo & { agent_id: number | null }>(contactQuery, contactParams);

            if (!contact) {
                logger.error(`Contact not found: contactId=${decoded.contactId} in orgId=${decoded.orgId}`);
                
                // Additional debugging: List all contacts in this org
                try {
                    const allContacts = await orgDb.query('SELECT id, email, first_name, last_name FROM contacts LIMIT 5');
                    logger.info(`First 5 contacts in org ${decoded.orgId}: ${JSON.stringify(allContacts)}`);
                } catch (e) {
                    logger.error(`Error listing contacts: ${e}`);
                }
                
                set.status = 404;
                return {
                    success: false,
                    error: `Contact not found: ID=${decoded.contactId}`
                };
            }

            // Get agent info - first try assigned agent, then fall back to first user
            const agent = contact.agent_id 
                ? await mainDb.fetchOne<{ first_name: string, last_name: string, email: string, phone: string }>(
                    'SELECT first_name, last_name, email, phone FROM users WHERE id = ?',
                    [contact.agent_id]
                  )
                : await mainDb.fetchOne<{ first_name: string, last_name: string, email: string, phone: string }>(
                    'SELECT first_name, last_name, email, phone FROM users WHERE organization_id = ? ORDER BY id ASC LIMIT 1',
                    [decoded.orgId]
                  );

            if (!agent) {
                logger.error(`No users found for organization: ${decoded.orgId}`);
                set.status = 404;
                return {
                    success: false,
                    error: 'No users found for organization'
                };
            }

            logger.info(`Found contact: ${contact.first_name} ${contact.last_name} (ID: ${decoded.contactId})`);
            
            const zipInfo = ZIP_DATA[contact.zip_code];
            const contactState = zipInfo?.state;
            
            if (!contactState) {
                logger.warn(`No state found for zip code: ${contact.zip_code}`);
            }

            const output = {
                success: true,
                orgId: decoded.orgId.toString(),
                orgSlug: orgSlug || null,
                orgName: result.name,
                orgLogo: result.logo_data || null,
                carrierContracts: carrierContracts || null,
                agent: {
                    firstName: agent.first_name,
                    lastName: agent.last_name,
                    email: agent.email,
                    phone: agent.phone
                },
                contact: {
                    id: decoded.contactId,
                    zipCode: contact.zip_code,
                    state: contactState,
                    dateOfBirth: contact.birth_date,
                    age: calculateAgeOnFirstOfNextMonth(contact.birth_date, new Date().toISOString()),
                    tobacco: Boolean(contact.tobacco_user),
                    gender: contact.gender,
                    email: contact.email,
                    firstName: contact.first_name,
                    lastName: contact.last_name,
                    currentCarrier: contact.current_carrier,
                    planType: contact.plan_type,
                    phoneNumber: contact.phone_number
                }
            };

            logger.info(`Returning success response for quote ID: ${params.quoteId}`);
            logger.info(`Output: ${JSON.stringify(output, null, 2)}`);
            return output;
        } catch (e) {
            logger.error(`Error decoding quote ID: ${e}`);
            set.status = 500;
            return {
                success: false,
                error: String(e)
            };
        }
    })
    .post('/api/quotes', async ({ body }: { body: QuoteRequestBody }) => {
        try {
            // Format request body
            const requestBody: QuoteRequest = {
                zip_code: body.zip_code,
                state: body.state,
                age: Number(body.age),
                tobacco: body.tobacco === 'true' || body.tobacco === true,
                gender: body.gender,
                plans: ['G', 'N'],
                carriers: 'supported',
                county: body.county
            };

            // Log incoming request details
            logger.info(`Incoming quote request body: ${JSON.stringify(requestBody, null, 2)}`);
            
            // Construct request config
            const quoteEngineUrl = 'https://quote-engine.replit.app/quotes/';
            const requestConfig = {
                url: quoteEngineUrl,
                method: 'POST' as const,
                headers: {
                    'X-API-Key': config.quoteApiKey,
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                data: requestBody
            };

            // Make request to quote engine API
            const response = await axios(requestConfig);
            
            logger.info(`Quote engine response status: ${response.status}`);
            //logger.info(`Quote engine response data: ${JSON.stringify(response.data, null, 2)}`);
            
            // Return quotes from response data
            return response.data;
        } catch (error) {
            logger.error(`Error fetching quotes: ${error}`);
            throw new Error(String(error));
        }
    })
    .get('/api/contact-request/org-info/:orgId', async ({ params }) => {
        try {
            const db = new Database();
            
            // Get organization info including redirect URL
            const orgResult = await db.fetchOne<{ redirect_url: string | null }>(
                'SELECT redirect_url FROM organizations WHERE id = ?',
                [params.orgId]
            );

            if (!orgResult) {
                throw new Error('Organization not found');
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(params.orgId);

            // Try to get default agent (first admin or agent)
            const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                `SELECT first_name, last_name 
                FROM users 
                WHERE (is_admin = 1 OR is_agent = 1) 
                AND is_active = 1 
                ORDER BY is_admin DESC, id ASC 
                LIMIT 1`
            );

            if (!defaultAgent) {
                throw new Error('No active agents or admins found');
            }

            return {
                success: true,
                redirect_url: orgResult.redirect_url,
                agent_name: `${defaultAgent.first_name} ${defaultAgent.last_name}`
            };
        } catch (e) {
            logger.error(`Error getting org redirect info: ${e}`);
            throw new Error(String(e));
        }
    })
    .post('/api/contact-request', async ({ body }) => {
        try {
            const { name, email, type, quoteId } = body as { 
                name: string;
                email: string;
                type: 'accept' | 'decline' | 'generic';
                quoteId?: string;
            };

            // Get contact info from quoteId if available
            let orgId: number | undefined;
            let contactId: number | undefined;
            let agentName: string | undefined;

            if (!quoteId) {
                throw new Error('Quote ID is required');
            }

            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                throw new Error('Invalid quote ID');
            }

            orgId = decoded.orgId;
            contactId = decoded.contactId;

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // If we have a contact ID, try to get the assigned agent's name
            if (contactId) {
                const contact = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT u.first_name, u.last_name 
                    FROM contacts c
                    JOIN users u ON c.agent_id = u.id
                    WHERE c.id = ? AND u.is_active = 1`,
                    [contactId]
                );
                if (contact) {
                    agentName = `${contact.first_name} ${contact.last_name}`;
                }
            }

            // If no agent assigned to contact, get default agent
            if (!agentName) {
                const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT first_name, last_name 
                    FROM users 
                    WHERE (is_admin = 1 OR is_agent = 1) 
                    AND is_active = 1 
                    ORDER BY is_admin DESC, id ASC 
                    LIMIT 1`
                );
                if (defaultAgent) {
                    agentName = `${defaultAgent.first_name} ${defaultAgent.last_name}`;
                }
            }

            // Store request in org-specific database
            await orgDb.execute(
                `INSERT INTO contact_requests (
                    name, email, request_type, contact_id, status, agent_name, created_at
                ) VALUES (?, ?, ?, ?, 'new', ?, CURRENT_TIMESTAMP)`,
                [name, email, type, contactId || null, agentName || null]
            );

            // Get org redirect URL from central database
            const db = new Database();
            const orgResult = await db.fetchOne<{ redirect_url: string | null }>(
                'SELECT redirect_url FROM organizations WHERE id = ?',
                [orgId]
            );

            return { 
                success: true,
                redirect: orgResult?.redirect_url ? { redirect_url: orgResult.redirect_url } : null
            };
        } catch (e) {
            logger.error(`Error saving contact request: ${e}`);
            throw new Error(String(e));
        }
    })
    // Add new endpoint for zip code information
    .get('/api/zipinfo/:zipCode', async ({ params }) => {
        try {
            const { zipCode } = params;
            
            // Read the zip data file from the ROOT directory, not the backend directory
            const zipDataPath = join(process.cwd(), '..', 'zipData.json');
            logger.info(`Looking for zip data at: ${zipDataPath}`);
            const zipDataContent = await readFile(zipDataPath, 'utf-8');
            const zipData = JSON.parse(zipDataContent);
            
            // Look up the zip code
            if (zipData[zipCode]) {
                return {
                    success: true,
                    data: zipData[zipCode]
                };
            } else {
                return {
                    success: false,
                    error: 'Zip code not found'
                };
            }
        } catch (error) {
            logger.error(`Error fetching zip code info: ${error}`);
            return {
                success: false,
                error: 'Failed to fetch zip code information'
            };
        }
    })
    .get('/api/quotes/debug-generate/:orgId/:contactId', async ({ params }) => {
        try {
            logger.info(`Debug endpoint - generating quote ID for org: ${params.orgId}, contact: ${params.contactId}`);
            
            const orgId = parseInt(params.orgId);
            const contactId = parseInt(params.contactId);
            
            if (isNaN(orgId) || isNaN(contactId)) {
                return {
                    success: false,
                    error: 'Invalid organization or contact ID'
                };
            }
            
            // Get org-specific database to verify the contact exists
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());
            
            // Verify contact exists
            const contact = await orgDb.fetchOne(
                'SELECT id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                // List first 5 contacts in this org for debugging
                const contacts = await orgDb.query('SELECT id FROM contacts LIMIT 5');
                logger.info(`Available contacts in org ${orgId}: ${JSON.stringify(contacts)}`);
                
                return {
                    success: false,
                    error: 'Contact not found',
                    availableContacts: contacts
                };
            }
            
            // Generate quote ID
            const quoteId = generateQuoteId(orgId, contactId);
            
            logger.info(`Generated debug quote ID: ${quoteId} for orgId: ${orgId}, contactId: ${contactId}`);

            return {
                success: true,
                quoteId,
                redirectUrl: `${process.env.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`
            };
        } catch (e) {
            logger.error(`Error in debug quote generation: ${e}`);
            return {
                success: false,
                error: String(e)
            };
        }
    });

    return app;
};

================
File: src/routes/schedule.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { decodeQuoteId } from '../utils/quoteId';

export const scheduleRoutes = (app: Elysia) => {
    app.get('/api/schedule/info/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get main database instance
            const mainDb = new Database();
            
            // Get organization info including slug
            const orgResult = await mainDb.fetchOne<{ name: string, logo_data: string | null, slug: string }>(
                'SELECT name, logo_data, slug FROM organizations WHERE id = ?',
                [orgId]
            );

            if (!orgResult) {
                set.status = 404;
                return {
                    success: false,
                    error: 'Organization not found'
                };
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Get contact information and agent_id in a single query
            const contact = await orgDb.fetchOne<{ 
                first_name: string, 
                last_name: string, 
                email: string, 
                phone_number: string, 
                agent_id: number | null 
            }>(
                'SELECT first_name, last_name, email, phone_number, agent_id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                set.status = 404;
                return {
                    success: false,
                    error: 'Contact not found'
                };
            }

            // Get agent info - first try assigned agent, then fall back to first user
            const agent = contact.agent_id 
                ? await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE id = ? AND is_active = 1',
                    [contact.agent_id]
                  )
                : await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE organization_id = ? AND is_active = 1 ORDER BY id ASC LIMIT 1',
                    [orgId]
                  );

            if (!agent) {
                set.status = 404;
                return {
                    success: false,
                    error: 'No active agents found for organization'
                };
            }

            // Return all information in a single response
            return {
                success: true,
                contact: {
                    firstName: contact.first_name,
                    lastName: contact.last_name,
                    email: contact.email,
                    phoneNumber: contact.phone_number
                },
                organization: {
                    name: orgResult.name,
                    logo: orgResult.logo_data,
                    slug: orgResult.slug
                },
                agent: {
                    name: `${agent.first_name} ${agent.last_name}`,
                    firstName: agent.first_name,
                    phone: agent.phone || ""
                }
            };

        } catch (error) {
            logger.error(`Error getting schedule info: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    // Keep the original endpoint for backward compatibility
    app.get('/api/schedule/org-info/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get main database instance
            const mainDb = new Database();
            
            // Get organization info
            const orgResult = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                'SELECT name, logo_data FROM organizations WHERE id = ?',
                [orgId]
            );

            if (!orgResult) {
                set.status = 404;
                return {
                    success: false,
                    error: 'Organization not found'
                };
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Try to get the assigned agent from the contact
            const contact = await orgDb.fetchOne<{ agent_id: number | null }>(
                'SELECT agent_id FROM contacts WHERE id = ?',
                [contactId]
            );

            // Get agent info - first try assigned agent, then fall back to first user
            const agent = contact?.agent_id 
                ? await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE id = ? AND is_active = 1',
                    [contact.agent_id]
                  )
                : await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE organization_id = ? AND is_active = 1 ORDER BY id ASC LIMIT 1',
                    [orgId]
                  );

            if (!agent) {
                set.status = 404;
                return {
                    success: false,
                    error: 'No active agents found for organization'
                };
            }

            return {
                success: true,
                orgName: orgResult.name,
                orgLogo: orgResult.logo_data,
                agentName: `${agent.first_name} ${agent.last_name}`,
                agentPhone: agent.phone || ""
            };

        } catch (error) {
            logger.error(`Error getting schedule org info: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    app.post('/api/schedule/aep-request/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Update the contact with AEP request
            await orgDb.execute(
                'UPDATE contacts SET aep_request = TRUE, aep_request_date = CURRENT_TIMESTAMP WHERE id = ?',
                [contactId]
            );

            return {
                success: true,
                message: 'AEP request recorded successfully'
            };

        } catch (error) {
            logger.error(`Error recording AEP request: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    app.post('/api/schedule/request-follow-up/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Update the contact status to requested_follow_up
            await orgDb.execute(
                'UPDATE contacts SET status = ? WHERE id = ?',
                ['requested_follow_up', contactId]
            );

            return {
                success: true,
                message: 'Follow-up request recorded successfully'
            };

        } catch (error) {
            logger.error(`Error recording follow-up request: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    return app;
};

================
File: src/routes/self-service.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import crypto from 'crypto';
import { config } from '../config';
import { generateQuoteId, decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';
import { readFileSync } from 'fs';

// Import ZIP_DATA
interface ZipInfo {
  state: string;
  counties: string[];
}

// Load ZIP data
let ZIP_DATA: Record<string, ZipInfo> = {};
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'));
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`);
}

// Import generateHash function - reimplementing it since it's not exported from email.ts
function generateHash(orgId: string, email: string): string {
  const SECRET = process.env.HASH_SECRET || 'default-hash-secret';
  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
}

export function createSelfServiceRoutes() {
  return new Elysia()
    .get('/api/self-service/init', async ({ query, set }) => {
      // Extract query parameters
      const { orgId, email, hash } = query as { 
        orgId?: string; 
        email?: string; 
        hash?: string;
      };

      // Validate required parameters
      if (!orgId) {
        set.status = 400;
        return { error: 'orgId is required' };
      }

      // Validate hash if email is provided
      if (email && hash) {
        const expectedHash = generateHash(orgId, email);
        if (hash !== expectedHash) {
          logger.warn(`Invalid hash for email ${email} and orgId ${orgId}`);
          set.status = 403;
          return { error: 'Invalid email or hash' };
        }
      }

      try {
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        
        // If email is provided, check for existing contact
        if (email) {
          const client = orgDb.getClient();
          const result = await client.execute({
            sql: `SELECT 
                  email, 
                  first_name AS firstName, 
                  last_name AS lastName
                FROM contacts 
                WHERE email = ?`,
            args: [email]
          });

          // If contact exists, return contact details
          if (result.rows.length > 0) {
            const contact = result.rows[0];
            logger.info(`Contact found for email ${email} in organization ${orgId}`);
            return { 
              contact, 
              email, 
              emailReadOnly: true 
            };
          }

          // If no contact exists but email is provided
          logger.info(`No contact found for email ${email} in organization ${orgId}`);
          return { 
            email, 
            emailReadOnly: true 
          };
        }

        // If no email is provided
        return { emailReadOnly: false };

      } catch (error) {
        logger.error(`Error in self-service init endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    .post('/api/self-service/signup', async ({ body, set }) => {
      const { orgId, email, firstName, lastName, optInQuarterlyUpdates, zipCode, dateOfBirth, gender, tobacco, phoneNumber, currentPremium, currentCarrier, state, county } = body as {
        orgId: string;
        email: string;
        firstName: string;
        lastName: string;
        optInQuarterlyUpdates: boolean;
        zipCode: string;
        dateOfBirth: string;
        gender: string;
        tobacco: boolean;
        phoneNumber: string;
        currentPremium: string;
        currentCarrier: string;
        state: string;
        county: string;
      };

      // Validate required parameters
      if (!orgId || !email || !firstName || !lastName || !zipCode || !dateOfBirth || !gender || !state) {
        set.status = 400;
        return { error: 'Missing required fields' };
      }
      
      // Only proceed if the user has agreed to receive updates
      if (!optInQuarterlyUpdates) {
        set.status = 400;
        return { error: 'You must agree to receive updates to continue' };
      }

      try {
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        const client = orgDb.getClient();
        
        // Check if contact already exists
        const existingContact = await client.execute({
          sql: 'SELECT id FROM contacts WHERE email = ?',
          args: [email]
        });

        if (existingContact.rows.length > 0) {
          // Update existing contact
          const contactId = existingContact.rows[0].id;
          await client.execute({
            sql: `UPDATE contacts SET 
                  first_name = ?, 
                  last_name = ?,
                  phone_number = ?,
                  zip_code = ?,
                  state = ?,
                  gender = ?,
                  birth_date = ?,
                  tobacco_user = ?,
                  current_carrier = ?
                  WHERE id = ?`,
            args: [
              firstName, 
              lastName, 
              phoneNumber || '', 
              zipCode, 
              state,
              gender,
              dateOfBirth,
              tobacco ? 1 : 0,
              currentCarrier || '', 
              contactId
            ]
          });
          
          logger.info(`Updated contact ${contactId} for email ${email} in organization ${orgId}`);
          
          return { 
            success: true,
            contactId,
            email
          };
        } else {
          // Create new contact with required fields
          const result = await client.execute({
            sql: `INSERT INTO contacts (
                  email, 
                  first_name, 
                  last_name,
                  phone_number,
                  zip_code,
                  state,
                  gender,
                  birth_date,
                  tobacco_user,
                  current_carrier,
                  effective_date
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            args: [
              email, 
              firstName, 
              lastName, 
              phoneNumber || '', 
              zipCode, 
              state,
              gender,
              dateOfBirth,
              tobacco ? 1 : 0,
              currentCarrier || null, // Default plan type
              new Date().toISOString().split('T')[0] // Today as effective date
            ]
          });
          
          // Get the ID of the newly created contact
          const newContactResult = await client.execute({
            sql: 'SELECT id FROM contacts WHERE email = ?',
            args: [email]
          });
          
          const contactId = newContactResult.rows[0]?.id;
          
          logger.info(`Created new contact ${contactId} for email ${email} in organization ${orgId}`);
          
          return { 
            success: true,
            contactId,
            email
          };
        }
      } catch (error) {
        logger.error(`Error in self-service signup endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    .post('/api/self-service/update-location', async ({ body, set }) => {
      const { orgSlug, contactId, zipCode } = body as {
        orgSlug: string;
        contactId: string;
        zipCode: string;
      };

      // Validate required parameters
      if (!orgSlug || !contactId || !zipCode) {
        set.status = 400;
        return { error: 'Missing required fields' };
      }

      try {
        // Get state and county from ZIP_DATA
        const zipInfo = ZIP_DATA[zipCode];
        if (!zipInfo) {
          set.status = 400;
          return { error: 'Invalid zip code' };
        }
        logger.info(`Zip info: ${JSON.stringify(zipInfo)}`);

        // Get organization ID from slug
        const db = new Database();
        const orgResult = await db.fetchOne<{ id: number }>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!orgResult) {
          set.status = 404;
          return { error: 'Organization not found' };
        }

        // Get organization database
        const orgDb = await Database.getOrgDb(orgResult.id.toString());
        const client = orgDb.getClient();

  

        // Use provided county or first county if only one available

        // Update contact's zip code, state and county
        await client.execute({
          sql: `UPDATE contacts SET 
                zip_code = ?
                WHERE id = ?`,
          args: [
            zipCode,
            contactId
          ]
        });

        logger.info(`Updated location for contact ${contactId} in organization ${orgSlug} to ${zipCode}, ${zipInfo.state}`);

        let output = {
          success: true,
          zipCode,
          state: zipInfo.state,
          counties: zipInfo.counties
        };

        logger.info(`Output: ${JSON.stringify(output)}`);
        return output;

      } catch (error) {
        logger.error(`Error updating location: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    // Add a new endpoint to generate a quote for a contact
    .post('/api/self-service/generate-quote', async ({ body, set }) => {
      const { orgId, contactEmail } = body as {
        orgId: string;
        contactEmail: string;
      };

      logger.info(`Generate quote request received: orgId=${orgId}, contactEmail=${contactEmail}`);

      // Validate required parameters
      if (!orgId || !contactEmail) {
        logger.error(`Missing required fields: orgId=${orgId}, contactEmail=${contactEmail}`);
        set.status = 400;
        return { error: 'Missing required fields (orgId and contactEmail)' };
      }

      try {
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        const client = orgDb.getClient();
        
        // Lookup contact by email
        const contactResult = await client.execute({
          sql: 'SELECT id FROM contacts WHERE email = ?',
          args: [contactEmail]
        });

        if (contactResult.rows.length === 0) {
          logger.error(`Contact not found for email ${contactEmail} in organization ${orgId}`);
          set.status = 404;
          return { error: 'Contact not found' };
        }

        const contactId = contactResult.rows[0].id;
        logger.info(`Found contact ID ${contactId} for email ${contactEmail} in organization ${orgId}`);
        
        // Generate quote ID using the proper utility function (with base36 encoding)
        const quoteId = generateQuoteId(parseInt(orgId), contactId);
        
        // Get plan type from contact
        let planType = 'MedSupp';
        try {
          const planTypeResult = await client.execute({
            sql: 'SELECT plan_type FROM contacts WHERE id = ?',
            args: [contactId]
          });
          
          if (planTypeResult.rows.length > 0 && planTypeResult.rows[0].plan_type) {
            planType = planTypeResult.rows[0].plan_type;
          }
          logger.info(`Found plan type ${planType} for contact ${contactId}`);
        } catch (error) {
          logger.warn(`Could not get plan type for contact ${contactId}: ${error}`);
          // Continue with default plan type
        }
        
        // Build redirect URL with just the quote ID
        const redirectUrl = `${config.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`;
        
        // Log response details
        logger.info(`Generated quote ID: ${quoteId}`);
        logger.info(`Redirect URL: ${redirectUrl}`);

        // Return successful response with quote information
        return {
          success: true,
          contactId,
          quoteId,
          redirectUrl
        };
      } catch (error) {
        logger.error(`Error generating quote ID: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    .get('/api/self-service/:orgSlug', async ({ params, query, set, request }) => {
      const { orgSlug } = params;
      const { email, id } = query as { email?: string; id?: string };
      
      logger.info(`Self-service request for orgSlug=${orgSlug}, email=${email || 'none'}, quoteId=${id || 'none'}`);
      
      try {
        // For the 'latest' slug, get the current user's organization
        if (orgSlug === 'latest') {
          const userFromSession = await getUserFromSession(request);
          if (!userFromSession || !userFromSession.organization_id) {
            set.status = 401;
            return { success: false, error: 'Unauthorized' };
          }
          
          // Get organization from central database
          const db = new Database();
          const orgResult = await db.fetchOne<{ id: number, slug: string, logo_data: string | null }>(
            'SELECT id, slug, logo_data FROM organizations WHERE id = ?',
            [userFromSession.organization_id]
          );
          
          if (!orgResult) {
            set.status = 404;
            return { success: false, message: 'Organization not found' };
          }
          
          return {
            success: true,
            orgId: userFromSession.organization_id.toString(),
            orgSlug: orgResult.slug,
            selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgResult.slug}`,
            logo: orgResult.logo_data
          };
        }
        
        // Regular slug lookup
        const db = new Database();
        const result = await db.query(
          'SELECT id, name, logo_data FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!result || result.length === 0) {
          set.status = 404;
          return { success: false, message: 'Organization not found' };
        }

        const orgId = result[0].id;
        const orgIdStr = orgId.toString();
        const logo = result[0].logo_data;
        const orgName = result[0].name;
        // Create response object with organization info
        const response = {
          success: true,
          orgId: orgIdStr,
          orgSlug,
          selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgSlug}`,
          logo,
          orgName
        };
        
        // Try to find contact information if email or quoteId provided
        if (email || id) {
          try {
            const orgDb = await Database.getOrgDb(orgIdStr);
            const client = orgDb.getClient();
            let contactResult;
            
            // First try by email if provided
            if (email) {
              logger.info(`Looking up contact by email: ${email}`);
              contactResult = await client.execute({
                sql: `SELECT 
                  id,
                  email, 
                  first_name AS firstName, 
                  last_name AS lastName,
                  phone_number AS phone,
                  zip_code AS zipCode,
                  state,
                  gender,
                  birth_date AS dateOfBirth,
                  tobacco_user AS tobacco,
                  current_carrier AS currentCarrier,
                  plan_type AS planType
                FROM contacts 
                WHERE email = ?`,
                args: [email]
              });
            }
            
            // If no results and we have a quoteId, try that
            if ((!contactResult || contactResult.rows.length === 0) && id) {
              try {
                logger.info(`Looking up contact by quoteId: ${id}`);
                // Decode the quoteId using our utility function
                const decoded = decodeQuoteId(id);
                if (decoded) {
                  const contactId = decoded.contactId;
                  
                  contactResult = await client.execute({
                    sql: `SELECT 
                      id,
                      email, 
                      first_name AS firstName, 
                      last_name AS lastName,
                      phone_number AS phone,
                      zip_code AS zipCode,
                      state,
                      gender,
                      birth_date AS dateOfBirth,
                      tobacco_user AS tobacco,
                      current_carrier AS currentCarrier,
                      plan_type AS planType
                    FROM contacts 
                    WHERE id = ?`,
                    args: [contactId]
                  });
                }
              } catch (err) {
                logger.warn(`Error decoding quoteId ${id}: ${err}`);
              }
            }
            
            // If we found a contact, add it to the response
            if (contactResult && contactResult.rows.length > 0) {
              const contact = contactResult.rows[0];
              // Convert tobacco_user from number to boolean
              contact.tobacco = contact.tobacco === 1;
              
              logger.info(`Found contact for ${email || id}`);
              let output = {
                ...response,
                contact: {
                  ...contact,
                  id: contactResult.rows[0].id
                }
              };
              logger.info(`Output: ${JSON.stringify(output)}`);
              return output;
            }
          } catch (contactError) {
            logger.error(`Error looking up contact: ${contactError}`);
            // Continue without contact info
          }
        }
        
        // Return basic organization info for the frontend if no contact was found
        return response;
      } catch (error) {
        logger.error(`Error in self-service org slug endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    });
}

================
File: src/routes/settings.ts
================
import { Elysia } from 'elysia';
import { validateSession } from '../services/auth';
import { Database } from '../database';
import { type User } from '../types';
import { logger } from '../logger';
import { type Cookie } from '@elysiajs/cookie';
import { type BaseSettings } from '../types';

interface StateCarrierSetting {
  state: string;
  carrier: string;
  active: boolean;
  targetGI: boolean;
}

interface SettingsBody {
    settings?: BaseSettings;
    inheritOrgSettings?: boolean;
}

interface AgentSettingsResponse {
  orgSettings: BaseSettings;
  agentSettings: {
    inheritOrgSettings: boolean;
    settings: BaseSettings;
  } | null;
  canEditOrgSettings: boolean;
}

const defaultSettings: BaseSettings = {
  stateLicenses: [],
  carrierContracts: [],
  stateCarrierSettings: [],
  allowAgentSettings: true,
  emailSendBirthday: true,
  emailSendPolicyAnniversary: true,
  emailSendAep: true,
  smartSendEnabled: false
};

// Helper function to generate default state/carrier settings
function generateDefaultStateCarrierSettings(states: string[], carriers: string[]): StateCarrierSetting[] {
  return states.flatMap(state => 
    carriers.map(carrier => ({
      state,
      carrier,
      active: true,  // Default to active
      targetGI: false  // Default to no GI
    }))
  );
}

export const settingsRoutes = new Elysia()
  .get('/api/settings', async ({ cookie }) => {
    logger.info('GET /api/settings - Starting');
    
    const user = await validateSession(cookie.session);
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization settings and logo
        const orgRow = await db.fetchOne<{ org_settings: string | null, logo_data: string | null }>(
            'SELECT org_settings, logo_data FROM organizations WHERE id = ?',
            [user.organization_id]
        );
        
        logger.info(`Retrieved org settings row`);

        // Parse the JSON string into an object
        let orgSettings: BaseSettings;
        try {
            orgSettings = orgRow?.org_settings 
                ? { ...defaultSettings, ...JSON.parse(orgRow.org_settings) }
                : { ...defaultSettings };

            // If we have states and carriers but no settings array, generate them
            if (orgSettings.stateLicenses.length > 0 && 
                orgSettings.carrierContracts.length > 0 && 
                !Array.isArray(orgSettings.stateCarrierSettings)) {
                
                logger.info('Generating default state/carrier settings');
                orgSettings.stateCarrierSettings = generateDefaultStateCarrierSettings(
                    orgSettings.stateLicenses,
                    orgSettings.carrierContracts
                );
            }
        } catch (parseError) {
            logger.error(`Error parsing org settings: ${parseError}`);
            orgSettings = { ...defaultSettings };
        }

        // Get agent settings if they exist
        const agentSettingsRow = await db.fetchOne<{ inherit_org_settings: boolean, settings: string | null }>(
            'SELECT inherit_org_settings, settings FROM agent_settings WHERE agent_id = ?',
            [user.id]
        );

        // Parse agent settings
        let agentSettings = null;
        if (agentSettingsRow) {
            try {
                const parsedSettings = agentSettingsRow.settings 
                    ? { ...defaultSettings, ...JSON.parse(agentSettingsRow.settings) }
                    : { ...defaultSettings };

                agentSettings = {
                    inheritOrgSettings: agentSettingsRow.inherit_org_settings,
                    settings: parsedSettings
                };
            } catch (parseError) {
                logger.error(`Error parsing agent settings: ${parseError}`);
            }
        }

        const canEditOrgSettings = user.is_admin;

        const response = {
            success: true,
            orgSettings,
            logo: orgRow?.logo_data || null,
            agentSettings,
            canEditOrgSettings
        };

        logger.info(`Sending response`);
        return response;

    } catch (error) {
        logger.error(`Error fetching settings: ${error}`);
        return {
            success: false,
            error: 'Failed to load settings'
        };
    }
  })

  .put('/api/settings/:scope', async ({ cookie, body, params }) => {
    const { scope } = params;
    logger.info(`PUT /api/settings/${scope} - Starting`);
    
    const user = await validateSession(cookie?.session?.toString() || '');
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization's subscription tier
        const orgRow = await db.fetchOne<{ subscription_tier: string }>(
            'SELECT subscription_tier FROM organizations WHERE id = ?',
            [user.organization_id]
        );

        const isBasicTier = orgRow?.subscription_tier === 'basic';
        const typedBody = body as SettingsBody;

        if (scope === 'org') {
            logger.info('Updating organization settings');
            
            // Extract logo from settings if it exists
            const { logo, ...settingsWithoutLogo } = typedBody.settings || typedBody;
            
            // Update organization settings and logo separately
            await db.execute(
                'UPDATE organizations SET org_settings = ?, logo_data = ? WHERE id = ?',
                [JSON.stringify(settingsWithoutLogo), logo || null, user.organization_id]
            );

            // For basic tier, also update the admin agent's settings
            if (isBasicTier) {
                logger.info('Basic tier detected - syncing settings to admin agent');
                
                // Get the admin agent's ID
                const adminAgentRow = await db.fetchOne<{ id: number }>(
                    'SELECT id FROM users WHERE organization_id = ? AND is_admin = 1 AND is_agent = 1 LIMIT 1',
                    [user.organization_id]
                );

                if (adminAgentRow) {
                    // Update agent settings with organization settings and set inherit_org_settings to true
                    await db.execute(
                        `INSERT INTO agent_settings (agent_id, inherit_org_settings, settings)
                         VALUES (?, true, ?)
                         ON CONFLICT (agent_id) DO UPDATE
                         SET inherit_org_settings = true, settings = ?`,
                        [adminAgentRow.id, JSON.stringify(settingsWithoutLogo), JSON.stringify(settingsWithoutLogo)]
                    );
                }
            }
        } else if (scope === 'agent') {
            // For basic tier, don't allow direct agent settings updates
            if (isBasicTier) {
                return {
                    success: false,
                    error: 'Agent settings cannot be modified directly in basic tier - update organization settings instead'
                };
            }

            logger.info('Updating agent settings');
            logger.info(`Agent settings body: ${JSON.stringify(typedBody, null, 2)}`);

            try {
                await db.execute(
                    `INSERT INTO agent_settings (agent_id, inherit_org_settings, settings)
                     VALUES (?, ?, ?)
                     ON CONFLICT (agent_id) DO UPDATE
                     SET inherit_org_settings = ?, settings = ?`,
                    [
                        user.id,
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings),
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings)
                    ]
                );
                logger.info('Agent settings updated successfully');
            } catch (dbError) {
                logger.error(`Database execute error details: ${JSON.stringify(dbError, null, 2)}`);
                throw dbError;
            }
        }

        return {
            success: true,
            settings: typedBody.settings || typedBody
        };
    } catch (error) {
        logger.error(`Error updating settings: ${error}`);
        logger.error(`Error stack: ${(error as Error).stack}`);
        return {
            success: false,
            error: 'Failed to update settings'
        };
    }
  })

  // Update the GI recommendations endpoint to use Elysia style
  .get('/api/settings/gi-recommendations', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const recommendations = await db.fetchAll<{ state: string; carrier: string }>(
        `SELECT state, carrier
         FROM guaranteed_issue_recommendations
         ORDER BY carrier, state`
      );

      // Transform the results to match the expected format
      const formattedRecommendations = recommendations.map(rec => ({
        state: rec.state,
        carrier: rec.carrier,
        active: true,
        targetGI: true
      }));

      return formattedRecommendations;

    } catch (error) {
      logger.error('Error fetching GI recommendations:', error);
      return { success: false, error: 'Failed to fetch GI recommendations' };
    }
  })

  // Fetch the logo for the organization
  .get('/api/settings/logo', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const logo = await db.fetchOne<{ logo_data: string | null }>(
        'SELECT logo_data FROM organizations WHERE id = ?',
        [user.organization_id]
      );

      if (!logo) {
        return { success: false, error: 'Organization not found' };
      }

      return {
        success: true,
        logo: logo.logo_data
      };

    } catch (error) {
      logger.error('Error fetching organization logo:', error);
      return { success: false, error: 'Failed to fetch organization logo' };
    }
  })
  .get('/api/settings/:orgId/logo', async ({ params }) => {
    const { orgId } = params;
    const db = new Database();

    try {
      const logo = await db.fetchOne<{ logo_data: string | null }>(
        'SELECT logo_data FROM organizations WHERE id = ?',
        [orgId]
      );

      if (!logo) {
        return { success: false, error: 'Organization logo not found' }; 
      }

      return {
        success: true,
        logo: logo.logo_data
      };
    } catch (error) {
      logger.error('Error fetching organization logo:', error);
      return { success: false, error: 'Failed to fetch organization logo' };
    }
  })
  

  // Update carriers endpoint to use Elysia style
  .get('/api/settings/carriers', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll<{ name: string }>(
        `SELECT name
         FROM carriers
         ORDER BY name`
      );

      return carriers;

    } catch (error) {
      logger.error('Error fetching carriers:', error);
      return { success: false, error: 'Failed to fetch carriers' };
    }
  })

  .get('/api/settings/carriers-with-aliases', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll<{ name: string, aliases: string | null }>(
        `SELECT name, aliases
         FROM carriers
         ORDER BY name`
      );

      return carriers.map(carrier => ({
        name: carrier.name,
        aliases: carrier.aliases ? JSON.parse(carrier.aliases) : []
      }));

    } catch (error) {
      logger.error('Error fetching carriers with aliases:', error);
      return { success: false, error: 'Failed to fetch carriers with aliases' };
    }
  });

================
File: src/routes/stripe.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { config } from '../config';
import { getUserFromSession } from '../services/auth';

// Mock Stripe if not available
let stripe: any;
try {
  if (config.stripeApiKey) {
    // @ts-ignore - Dynamic import for Stripe
    stripe = require('stripe')(config.stripeApiKey);
  } else {
    // Mock Stripe for development
    stripe = {
      checkout: {
        sessions: {
          create: async () => ({ id: `test_session_id_${Date.now()}` })
        }
      },
      webhooks: {
        constructEvent: () => ({ 
          type: 'test.event', 
          data: { object: {} } 
        })
      }
    };
    logger.info('Using mock Stripe implementation');
  }
} catch (error) {
  logger.error(`Error loading Stripe: ${error}`);
  // Create a mock implementation
  stripe = {
    checkout: {
      sessions: {
        create: async () => ({ id: `test_session_id_${Date.now()}` })
      }
    },
    webhooks: {
      constructEvent: () => ({ 
        type: 'test.event', 
        data: { object: {} } 
      })
    }
  };
  logger.info('Using mock Stripe implementation due to error');
}

export const createStripeRoutes = () => {
  return new Elysia({ prefix: '/api/stripe' })
    // Create a Stripe checkout session
    .post('/create-checkout-session', async ({ body, set, request }) => {
      const db = new Database();
      
      try {
        const user = await getUserFromSession(request);
        if (!user) {
          set.status = 401;
          return { error: 'Unauthorized' };
        }
        
        const { orgSlug, tierId, extraAgents, extraContacts } = body as {
          orgSlug: string;
          tierId: string;
          extraAgents: number;
          extraContacts: number;
        };
        
        // Get the organization
        const organization = await db.query(
          'SELECT id, name, stripe_customer_id FROM organizations WHERE slug = ?',
          [orgSlug]
        ).then(rows => rows[0]);
        
        if (!organization) {
          set.status = 404;
          return { error: 'Organization not found' };
        }
        
        // Get the subscription tier pricing
        const tier = await db.query(
          'SELECT id, name, price_monthly, agent_limit, contact_limit FROM subscription_tiers WHERE id = ?',
          [tierId]
        ).then(rows => rows[0]);
        
        if (!tier) {
          set.status = 404;
          return { error: 'Subscription tier not found' };
        }
        
        // Calculate the total price
        const basePriceInCents = Number(tier.price_monthly);
        const extraAgentPriceInCents = extraAgents * 2000; // $20 per agent
        const extraContactsPackages = Math.ceil(extraContacts / 5000);
        const extraContactsPriceInCents = extraContactsPackages * 5000; // $50 per 5000 contacts
        
        const totalPriceInCents = basePriceInCents + extraAgentPriceInCents + extraContactsPriceInCents;
        
        let sessionConfig: any = {
          payment_method_types: ['card'],
          line_items: [
            {
              price_data: {
                currency: 'usd',
                product_data: {
                  name: tier.name + ' Plan',
                  description: `Includes ${tier.agent_limit} agents and ${tier.contact_limit} contacts`
                },
                unit_amount: basePriceInCents
              },
              quantity: 1
            }
          ],
          mode: 'subscription',
          success_url: config.clientUrl + '/dashboard?payment_success=true',
          cancel_url: config.clientUrl + '/change-plan?payment_canceled=true',
        };
        
        // Add extra agents if any
        if (extraAgents > 0) {
          sessionConfig.line_items.push({
            price_data: {
              currency: 'usd',
              product_data: {
                name: 'Extra Agents',
                description: `${extraAgents} additional agents at $20/agent/month`
              },
              unit_amount: 2000,
            },
            quantity: extraAgents
          });
        }
        
        // Add extra contacts if any
        if (extraContacts > 0) {
          sessionConfig.line_items.push({
            price_data: {
              currency: 'usd',
              product_data: {
                name: 'Extra Contacts',
                description: `${extraContactsPackages} packages of 5,000 contacts at $50/package/month`
              },
              unit_amount: 5000,
            },
            quantity: extraContactsPackages
          });
        }
        
        // If organization already has a Stripe customer ID, use it
        if (organization.stripe_customer_id) {
          sessionConfig.customer = organization.stripe_customer_id;
        } else {
          sessionConfig.customer_email = user.email;
        }

        // Create the checkout session
        let session;
        if (config.stripeApiKey) {
          session = await stripe.checkout.sessions.create(sessionConfig);
        } else {
          // For development without Stripe API key
          logger.info('Creating test checkout session with config:', sessionConfig);
          session = { id: 'test_session_id_' + Date.now() };
        }
        
        // Store the checkout session ID in the database for later verification
        await db.execute(
          `UPDATE organizations 
           SET stripe_checkout_session = ? 
           WHERE id = ?`,
          [session.id, organization.id]
        );
        
        // Return the session ID to the client
        return { sessionId: session.id };
        
      } catch (error) {
        logger.error('Error creating checkout session:', error);
        set.status = 500;
        return { error: 'Failed to create checkout session' };
      }
    })
    
    // Redirect to Stripe checkout
    .get('/redirect-to-checkout', async ({ query, set }) => {
      const sessionId = query.session_id as string;
      
      if (!sessionId) {
        set.status = 400;
        return { error: 'Session ID is required' };
      }
      
      // In production, you would use Stripe's client-side SDK to redirect
      // For this demo, we'll simulate by redirecting to a success page
      if (config.stripeApiKey) {
        set.redirect = `https://checkout.stripe.com/pay/${sessionId}`;
      } else {
        // Simulate successful payment in development
        set.redirect = '/dashboard?payment_success=true&test_mode=true';
      }
      
      return {};
    })
    
    // Webhook for Stripe events (payment completion, etc.)
    .post('/webhook', async ({ body, request, set }) => {
      let event;
      const db = new Database();
      
      try {
        const signature = request.headers.get('stripe-signature');
        
        if (config.stripeWebhookSecret && config.stripeApiKey && signature) {
          event = stripe.webhooks.constructEvent(
            body, // Raw body needed here
            signature,
            config.stripeWebhookSecret
          );
        } else {
          // For development without Stripe
          event = { 
            type: 'checkout.session.completed',
            data: { object: body } 
          };
        }
        
        // Handle the event
        if (event.type === 'checkout.session.completed') {
          await handleCheckoutComplete(event.data.object, db);
        } else {
          logger.info(`Unhandled event type ${event.type}`);
        }
        
        set.status = 200;
        return { received: true };
      } catch (error) {
        logger.error('Error processing webhook:', error);
        set.status = 400;
        return { error: `Webhook Error: ${error instanceof Error ? error.message : 'Unknown error'}` };
      }
    });
};

async function handleCheckoutComplete(session: any, db: Database): Promise<void> {
  try {
    // Find the organization by checkout session ID
    const organization = await db.query(
      `SELECT id, slug FROM organizations WHERE stripe_checkout_session = ?`,
      [session.id]
    ).then(rows => rows[0]);
    
    if (!organization) {
      logger.error('Organization not found for checkout session:', session.id);
      return;
    }
    
    // Update the organization with the subscription info
    await db.execute(
      `UPDATE organizations 
       SET stripe_subscription_id = ?, 
           stripe_customer_id = ?,
           stripe_checkout_session = NULL,
           agent_limit = (SELECT agent_limit FROM subscription_tiers WHERE id = ?) + ?,
           contact_limit = (SELECT contact_limit FROM subscription_tiers WHERE id = ?) + ?,
           subscription_tier = ?
       WHERE id = ?`,
      [
        session.subscription, 
        session.customer, 
        session.metadata?.tierId || 'basic',
        Number(session.metadata?.extraAgents || 0),
        session.metadata?.tierId || 'basic',
        Number(session.metadata?.extraContacts || 0),
        session.metadata?.tierId || 'basic',
        organization.id
      ]
    );
    
    logger.info(`Subscription updated for organization: ${organization.slug}`);
  } catch (error) {
    logger.error('Error handling checkout completion:', error);
  }
}

================
File: src/services/agentSettings.ts
================
import { db } from '../database';
import { NotFoundError } from '../errors';
import { logger } from '../logger';

export interface StateCarrierSetting {
  active: boolean;
  targetGI: boolean;
}

export interface AgentSettings {
  id: number;
  agentId: number;
  stateLicenses: string[];
  carrierContracts: string[];
  stateCarrierSettings: {
    [state: string]: {
      [carrier: string]: StateCarrierSetting;
    };
  };
  emailSendBirthday: boolean;
  emailSendPolicyAnniversary: boolean;
  emailSendAep: boolean;
  smartSendEnabled: boolean;
}

export async function getAgentSettings(agentId: number): Promise<AgentSettings> {
  try {
    const result = await db.oneOrNone(
      'SELECT * FROM agent_settings WHERE agent_id = $1',
      [agentId]
    )

    if (!result) {
      // Return default settings instead of creating them
      return {
        id: 0,
        agentId: agentId,
        stateLicenses: [],
        carrierContracts: [],
        stateCarrierSettings: {},
        emailSendBirthday: false,
        emailSendPolicyAnniversary: false,
        emailSendAep: false,
        smartSendEnabled: false
      }
    }

    return {
      id: result.id,
      agentId: result.agent_id,
      stateLicenses: result.state_licenses || [],
      carrierContracts: result.carrier_contracts || [],
      stateCarrierSettings: result.state_carrier_settings || {},
      emailSendBirthday: result.email_send_birthday || false,
      emailSendPolicyAnniversary: result.email_send_policy_anniversary || false,
      emailSendAep: result.email_send_aep || false,
      smartSendEnabled: result.smart_send_enabled || false,
    }
  } catch (error) {
    logger.error(`Error fetching agent settings: ${error}`)
    // Return default settings on error
    return {
      id: 0,
      agentId: agentId,
      stateLicenses: [],
      carrierContracts: [],
      stateCarrierSettings: {},
      emailSendBirthday: false,
      emailSendPolicyAnniversary: false,
      emailSendAep: false,
      smartSendEnabled: false
    }
  }
}

async function createDefaultSettings(agentId: number): Promise<AgentSettings> {
  const result = await db.one(
    `INSERT INTO agent_settings 
     (agent_id, state_licenses, carrier_contracts, state_carrier_settings)
     VALUES ($1, $2, $3, $4)
     RETURNING *`,
    [agentId, [], [], {}]
  );

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

export async function updateAgentSettings(
  agentId: number,
  settings: Partial<AgentSettings>
): Promise<AgentSettings> {
  const result = await db.oneOrNone(
    `UPDATE agent_settings
     SET state_licenses = COALESCE($1, state_licenses),
         carrier_contracts = COALESCE($2, carrier_contracts),
         state_carrier_settings = COALESCE($3, state_carrier_settings),
         email_send_birthday = COALESCE($4, email_send_birthday),
         email_send_policy_anniversary = COALESCE($5, email_send_policy_anniversary),
         email_send_aep = COALESCE($6, email_send_aep),
         smart_send_enabled = COALESCE($7, smart_send_enabled)
     WHERE agent_id = $8
     RETURNING *`,
    [
      settings.stateLicenses,
      settings.carrierContracts,
      settings.stateCarrierSettings,
      settings.emailSendBirthday,
      settings.emailSendPolicyAnniversary,
      settings.emailSendAep,
      settings.smartSendEnabled,
      agentId,
    ]
  );

  if (!result) {
    throw new NotFoundError('Agent settings not found');
  }

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

================
File: src/services/auth.ts
================
import crypto from 'crypto';
import { logger } from '../logger';
import { db } from '../database';
import { Database } from '../database';
import type { User } from '../types';
import { config } from '../config';

const algorithm = "aes-256-gcm";
const IV_LENGTH = 12;
const UTF8 = "utf8";
const HEX = "hex";

// Initialize encryption key
let secret = process.env.MAGIC_LINK_SECRET;
if (!secret) {
  if (process.env.NODE_ENV === "production") {
    throw new Error("Must set MAGIC_LINK_SECRET in production");
  }
  secret = "dev-secret-key";
}

const ENCRYPTION_KEY = crypto.scryptSync(secret, "salt", 32);

interface MagicLinkPayload {
  email: string;
  organizationSlug: string;
  expiresAt: number;
  redirectUrl: string;
  orgId?: number;
  name?: string;
}

export class AuthService {
  constructor(private baseUrl?: string) {
    // If no baseUrl is provided, get it from config
    if (!baseUrl) {
      this.baseUrl = config.PUBLIC_URL;
    } else {
      // Ensure baseUrl doesn't end with a slash
      this.baseUrl = baseUrl.replace(/\/$/, '');
    }
    
    logger.info(`AuthService initialized with baseUrl: ${this.baseUrl}`);
  }

  async createMagicLink(
    email: string, 
    organizationSlug: string, 
    options?: { 
      redirectUrl?: string;
      orgId?: number;
      name?: string;
    }
  ): Promise<string> {
    const payload: MagicLinkPayload = {
      email,
      organizationSlug,
      expiresAt: Date.now() + (30 * 60 * 1000), // 30 minutes
      redirectUrl: options?.redirectUrl || '/dashboard',
      ...(options?.orgId && { orgId: options.orgId }),
      ...(options?.name && { name: options.name })
    };

    logger.info(`Creating magic link with payload: ${JSON.stringify(payload)}`);
    const token = this.encrypt(JSON.stringify(payload));
    // URL encode the entire token
    const encodedToken = encodeURIComponent(token);
    logger.info(`Generated magic link token: ${token}`);
    return `${this.baseUrl}/auth/verify/${organizationSlug}/${encodedToken}`;
  }

  async verifyMagicLink(token: string, organizationSlug: string): Promise<{
    valid: boolean;
    email?: string;
    redirectUrl?: string;
  }> {
    try {
      logger.info('Starting magic link verification');
      logger.info(`Organization slug: ${organizationSlug}`);

      const decodedToken = decodeURIComponent(token);
      const decrypted = this.decrypt(decodedToken);
      const payload: MagicLinkPayload = JSON.parse(decrypted);

      // Verify organization and expiration
      if (payload.organizationSlug !== organizationSlug) {
        logger.error(`Organization slug mismatch: ${payload.organizationSlug} !== ${organizationSlug}`);
        return { valid: false };
      }

      if (payload.expiresAt < Date.now()) {
        logger.error(`Token expired: ${new Date(payload.expiresAt)} < ${new Date()}`);
        return { valid: false };
      }

      // No need to check agent status here since we only send links to valid agents

      logger.info('Verification successful, returning payload');
      return {
        valid: true,
        email: payload.email,
        redirectUrl: payload.redirectUrl
      };

    } catch (error) {
      logger.error(`Magic link verification failed: ${error}`);
      return { valid: false };
    }
  }

  private encrypt(text: string): string {
    try {
      const iv = crypto.randomBytes(IV_LENGTH);
      const cipher = crypto.createCipheriv(algorithm, ENCRYPTION_KEY, iv);
      let encrypted = cipher.update(text, UTF8, HEX);
      encrypted += cipher.final(HEX);
      const authTag = cipher.getAuthTag();
      
      const token = `${iv.toString(HEX)}:${authTag.toString(HEX)}:${encrypted}`;
      return token;
    } catch (error) {
      logger.error(`Encryption failed: ${error}`);
      throw error;
    }
  }

  private decrypt(text: string): string {
    try {
      const [ivPart, authTagPart, encryptedText] = text.split(":");
      if (!ivPart || !authTagPart || !encryptedText) {
        throw new Error("Invalid token format - missing parts");
      }

      logger.info('Decrypting token parts:');
      logger.info(`IV length: ${ivPart.length}`);
      logger.info(`Auth tag length: ${authTagPart.length}`);
      logger.info(`Encrypted text length: ${encryptedText.length}`);

      const iv = Buffer.from(ivPart, HEX);
      const authTag = Buffer.from(authTagPart, HEX);
      const decipher = crypto.createDecipheriv(algorithm, ENCRYPTION_KEY, iv);
      decipher.setAuthTag(authTag);
      let decrypted = decipher.update(encryptedText, HEX, UTF8);
      decrypted += decipher.final(UTF8);
      return decrypted;
    } catch (error) {
      logger.error(`Decryption failed: ${error}`);
      throw error;
    }
  }
}

export async function validateSession(sessionId: string): Promise<User | null> {
  logger.info(`Validating session: ${sessionId}`);
  
  const db = new Database();

  // Get the session
  const session = await db.fetchOne<{
    id: string;
    user_id: number;
    expires_at: string;
  }>('SELECT * FROM sessions WHERE id = ?', [sessionId]);

  logger.info(`Session lookup result: ${session ? JSON.stringify(session) : 'not found'}`);

  if (!session) {
    logger.warn('No session found in database');
    return null;
  }

  // Check if session is expired
  const expiresAt = new Date(session.expires_at);
  const now = new Date();
  logger.info(`Session expires: ${expiresAt}, current time: ${now}`);

  if (expiresAt < now) {
    logger.warn('Session is expired');
    await db.execute('DELETE FROM sessions WHERE id = ?', [sessionId]);
    return null;
  }

  // Get the user associated with this session with updated columns
  const user = await db.fetchOne<User>(
    `SELECT 
      u.id,
      u.email,
      u.organization_id,
      u.is_admin,
      u.is_agent,
      u.first_name,
      u.last_name,
      u.is_active,
      u.phone,
      o.name as organization_name 
     FROM users u
     JOIN organizations o ON u.organization_id = o.id 
     WHERE u.id = ?`,
    [session.user_id]
  );

  logger.info(`User lookup result: ${user ? JSON.stringify(user) : 'not found'}`);

  return user;
}

export function generateToken(): string {
  return crypto.randomBytes(32).toString('hex');
}

export async function getUserFromSession(request: Request) {
  try {
    // Get session cookie
    const sessionId = request.headers.get('cookie')?.split('session=')[1]?.split(';')[0];
    
    if (!sessionId) {
      logger.warn('No session cookie found');
      return null;
    }

    // Initialize database
    const db = new Database();

    // Get session data
    const sessionResult = await db.fetchAll(
      'SELECT user_id FROM sessions WHERE id = ?',
      [sessionId]
    );

    if (!sessionResult || sessionResult.length === 0) {
      logger.warn(`No session found for ID: ${sessionId}`);
      return null;
    }

    const userId = sessionResult[0][0];

    // Updated query to use is_admin and is_agent
    const userResult = await db.fetchAll(
      `SELECT 
        u.id,
        u.email,
        u.organization_id,
        u.is_admin,
        u.is_agent,
        u.first_name,
        u.last_name,
        u.is_active,
        u.phone,
        o.name as organization_name
       FROM users u
       JOIN organizations o ON u.organization_id = o.id 
       WHERE u.id = ?`,
      [userId]
    );

    if (!userResult || userResult.length === 0) {
      logger.warn('No user found for session');
      return null;
    }

    const user = {
      id: userResult[0][0],
      email: userResult[0][1],
      organization_id: userResult[0][2],
      is_admin: Boolean(userResult[0][3]),
      is_agent: Boolean(userResult[0][4]),
      first_name: userResult[0][5],
      last_name: userResult[0][6],
      is_active: userResult[0][7],
      phone: userResult[0][8],
      organization_name: userResult[0][9]
    };

    return user;

  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

================
File: src/services/email.ts
================
import sgMail from '@sendgrid/mail';
import { logger } from '../logger';
import crypto from 'crypto';


interface MagicLinkEmailParams {
  email: string;
  token: string;
  orgId: number;
  name: string;
}

export class EmailService {
  constructor() {
    if (!process.env.SENDGRID_API_KEY) {
      throw new Error('Missing SENDGRID_API_KEY environment variable');
    }
    sgMail.setApiKey(process.env.SENDGRID_API_KEY);
  }

  async sendMagicLink(email: string, magicLink: string, organizationSlug: string) {
    try {
      const msg = {
        to: email,
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: 'Your Login Link',
        text: `Click this link to log in: ${magicLink}\n\nThis link will expire in 30 minutes.`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">Welcome to MedicareMax</h2>
            <p>Click the button below to log in to your account. This link will expire in 30 minutes.</p>
            <div style="margin: 30px 0;">
              <a href="${magicLink}" 
                 style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                        text-decoration: none; border-radius: 4px; display: inline-block;">
                Log In
              </a>
            </div>
            <p style="color: #666; font-size: 14px;">
              If the button doesn't work, copy and paste this link into your browser:
              <br>
              <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
            </p>
          </div>
        `
      };

      await sgMail.send(msg);
      logger.info(`Magic link email sent successfully to ${email}`);
    } catch (error) {
      logger.error(`Error sending magic link email: ${error}`);
      throw new Error('Failed to send magic link email');
    }
  }

  async sendQuoteEmail(params: {
    email: string;
    firstName: string;
    lastName: string;
    quoteUrl: string;
    planType: string;
  }) {
    try {
      const { email, firstName, lastName, quoteUrl, planType } = params;
      const fullName = `${firstName} ${lastName}`;
      
      const msg = {
        to: email,
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: 'Your Personalized Medicare Quote',
        text: `Hello ${fullName},\n\nThank you for your interest in Medicare coverage options. We've prepared a personalized quote for your ${planType} plan. You can view and compare your options by clicking the link below:\n\n${quoteUrl}\n\nIf you have any questions, please don't hesitate to reach out.\n\nThe MedicareMax Team`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">Your Medicare Quote is Ready</h2>
            <p>Hello ${firstName},</p>
            <p>Thank you for your interest in Medicare coverage options. We've prepared a personalized quote for your ${planType} plan.</p>
            <div style="margin: 30px 0;">
              <a href="${quoteUrl}" 
                 style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                        text-decoration: none; border-radius: 4px; display: inline-block;">
                View Your Quote
              </a>
            </div>
            <p>This quote has been tailored specifically for your needs based on the information you provided.</p>
            <p style="color: #666; font-size: 14px;">
              If the button doesn't work, copy and paste this link into your browser:
              <br>
              <a href="${quoteUrl}" style="color: #4F46E5;">${quoteUrl}</a>
            </p>
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
              <p style="color: #888; font-size: 14px;">
                If you have any questions, please don't hesitate to contact us.
                <br>
                The MedicareMax Team
              </p>
            </div>
          </div>
        `
      };

      await sgMail.send(msg);
      logger.info(`Quote email sent successfully to ${email}`);
      return { success: true };
    } catch (error) {
      logger.error(`Error sending quote email: ${error}`);
      throw new Error('Failed to send quote email');
    }
  }
}

// For the organization signup flow
export async function sendMagicLink({ email, magicLink, name }: {
  email: string;
  magicLink: string;
  name: string;
}) {
  try {
    const msg = {
      to: email,
      from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
      subject: 'Verify Your MedicareMax Account',
      text: `Hi ${name},\n\nClick this link to verify your account: ${magicLink}\n\nThis link will expire in 30 minutes.`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Welcome to MedicareMax</h2>
          <p>Hi ${name},</p>
          <p>Click the button below to verify your account and complete your organization setup. This link will expire in 30 minutes.</p>
          <div style="margin: 30px 0;">
            <a href="${magicLink}" 
               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 4px; display: inline-block;">
              Verify Account
            </a>
          </div>
          <p style="color: #666; font-size: 14px;">
            If the button doesn't work, copy and paste this link into your browser:
            <br>
            <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
          </p>
        </div>
      `
    };

    await sgMail.send(msg);
    logger.info('Magic link email sent successfully');
  } catch (error) {
    logger.error(`Failed to send magic link email: ${error}`);
    throw error;
  }
}

// Generate a hash for onboarding link validation
function generateHash(orgId: string, email: string): string {
  const SECRET = process.env.HASH_SECRET || 'default-hash-secret'; // Ensure this is set in your environment
  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
}

/**
 * Sends an onboarding link that includes organizationId, and optionally email and hash
 * @param orgId Organization ID to include in the link
 * @param email Optional email to include in the link and use as recipient
 */
export async function sendOnboardingLink(orgId: string, email?: string) {
  try {
    // Base onboarding URL with orgId
    const baseUrl = process.env.FRONTEND_URL || 'https://medicaremax.ai';
    let onboardingUrl = `${baseUrl}/onboard?orgId=${orgId}`;
    
    // If email is provided, add email and hash to the URL
    if (email) {
      const hash = generateHash(orgId, email);
      onboardingUrl += `&email=${encodeURIComponent(email)}&hash=${hash}`;
    }
    
    // Create email message
    const msg = {
      to: email || process.env.FALLBACK_EMAIL || 'information@medicaremax.ai', // Fallback if no email provided
      from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
      subject: 'Join MedicareMax',
      text: `Click this link to create or update your profile: ${onboardingUrl}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Welcome to MedicareMax</h2>
          <p>Click the button below to create or update your profile:</p>
          <div style="margin: 30px 0;">
            <a href="${onboardingUrl}" 
               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 4px; display: inline-block;">
              Get Started
            </a>
          </div>
          <p style="color: #666; font-size: 14px;">
            If the button doesn't work, copy and paste this link into your browser:
            <br>
            <a href="${onboardingUrl}" style="color: #4F46E5;">${onboardingUrl}</a>
          </p>
          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
            <p style="color: #888; font-size: 14px;">
              If you have any questions, please don't hesitate to contact us.
              <br>
              The MedicareMax Team
            </p>
          </div>
        </div>
      `
    };

    await sgMail.send(msg);
    logger.info(`Onboarding link email sent successfully${email ? ` to ${email}` : ''}`);
    return { success: true };
  } catch (error) {
    logger.error(`Error sending onboarding link email: ${error}`);
    throw new Error('Failed to send onboarding link email');
  }
}

================
File: src/services/stripe.ts
================
import Stripe from 'stripe';
import { config } from '../config';
import { logger } from '../logger';

// Initialize Stripe with the secret key from environment variables
const stripe = new Stripe(config.stripe.secretKey, {
  apiVersion: '2023-10-16',
});

export type PlanTier = 'basic' | 'pro' | 'enterprise';

// Map subscription tier IDs to Stripe price IDs
const PRICE_MAP: Record<PlanTier, string> = {
  basic: config.stripe.prices.basic,
  pro: config.stripe.prices.pro,
  enterprise: config.stripe.prices.enterprise,
};

// Extra resource price IDs
const EXTRA_AGENT_PRICE = config.stripe.prices.extraAgent;
const EXTRA_CONTACT_PRICE = config.stripe.prices.extraContact;

interface CreateSubscriptionOptions {
  tierId: PlanTier;
  organizationId: number;
  email: string;
  extraAgents: number;
  extraContacts: number;
  stripeCustomerId?: string;
}

export interface SubscriptionResult {
  customerId: string;
  subscriptionId: string;
  clientSecret?: string;
}

/**
 * Creates or updates a Stripe subscription for an organization
 */
export async function createOrUpdateSubscription({
  tierId,
  organizationId,
  email,
  extraAgents,
  extraContacts,
  stripeCustomerId,
}: CreateSubscriptionOptions): Promise<SubscriptionResult> {
  try {
    // Get or create a customer
    let customerId = stripeCustomerId;
    
    if (!customerId) {
      const customer = await stripe.customers.create({
        email,
        metadata: {
          organizationId: organizationId.toString(),
        },
      });
      customerId = customer.id;
      logger.info(`Created Stripe customer for organization ${organizationId}: ${customerId}`);
    }

    // Create subscription line items
    const items = [
      {
        price: PRICE_MAP[tierId],
        quantity: 1,
      },
    ];

    // Add extra agents if needed
    if (extraAgents > 0 && EXTRA_AGENT_PRICE) {
      items.push({
        price: EXTRA_AGENT_PRICE,
        quantity: extraAgents,
      });
    }

    // Add extra contacts (subscription is based on 100s of contacts)
    if (extraContacts > 0 && EXTRA_CONTACT_PRICE) {
      items.push({
        price: EXTRA_CONTACT_PRICE,
        // Calculate how many 100s of contacts
        quantity: Math.ceil(extraContacts / 100),
      });
    }

    // Create the subscription
    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items,
      payment_behavior: 'default_incomplete',
      payment_settings: {
        save_default_payment_method: 'on_subscription',
        payment_method_types: ['card'],
      },
      expand: ['latest_invoice.payment_intent'],
      metadata: {
        organizationId: organizationId.toString(),
        tierId,
        extraAgents: extraAgents.toString(),
        extraContacts: extraContacts.toString(),
      },
    });

    // Get the client secret from the subscription
    const invoice = subscription.latest_invoice as Stripe.Invoice;
    const paymentIntent = invoice.payment_intent as Stripe.PaymentIntent;
    const clientSecret = paymentIntent?.client_secret || undefined;

    logger.info(`Created Stripe subscription for organization ${organizationId}: ${subscription.id}`);

    return {
      customerId,
      subscriptionId: subscription.id,
      clientSecret,
    };
  } catch (error) {
    logger.error('Error creating Stripe subscription:', error);
    throw error;
  }
}

/**
 * Webhook handler for Stripe events
 */
export async function handleStripeWebhook(event: Stripe.Event): Promise<void> {
  logger.info(`Processing Stripe webhook: ${event.type}`);
  const db = new Database();

  try {
    switch (event.type) {
      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription;
        // Find organization with this subscription
        const orgResult = await db.query<{ id: number }>(
          'SELECT id FROM organizations WHERE stripe_subscription_id = ?',
          [subscription.id]
        );
        
        if (orgResult && orgResult.length > 0) {
          const organizationId = orgResult[0].id;
          
          // Map Stripe status to our status
          let subscriptionStatus = 'active';
          if (subscription.status === 'active' || subscription.status === 'trialing') {
            subscriptionStatus = 'active';
          } else if (subscription.status === 'past_due') {
            subscriptionStatus = 'past_due';
          } else {
            subscriptionStatus = 'inactive';
          }
          
          // Get extra agents and contacts
          const extraAgents = parseInt(subscription.metadata.extraAgents || '0', 10);
          const extraContacts = parseInt(subscription.metadata.extraContacts || '0', 10);
          
          // Update organization with subscription status
          await db.execute(
            `UPDATE organizations 
             SET subscription_status = ?,
                 billing_cycle_end = ?,
                 trial_end_date = ?,
                 extra_agents = ?,
                 extra_contacts = ?
             WHERE id = ?`,
            [
              subscriptionStatus,
              new Date(subscription.current_period_end * 1000).toISOString(),
              subscription.trial_end ? new Date(subscription.trial_end * 1000).toISOString() : null,
              extraAgents,
              extraContacts,
              organizationId
            ]
          );
          
          logger.info(`Updated organization ${organizationId} with subscription status: ${subscriptionStatus}`);
        } else {
          logger.warn(`No organization found for subscription: ${subscription.id}`);
        }
        break;
      }
      
      case 'invoice.payment_succeeded': {
        const invoice = event.data.object as Stripe.Invoice;
        if (invoice.subscription) {
          // Find organization with this subscription
          const orgResult = await db.query<{ id: number }>(
            'SELECT id FROM organizations WHERE stripe_subscription_id = ?',
            [invoice.subscription]
          );
          
          if (orgResult && orgResult.length > 0) {
            // Update last payment date and reset failure count
            await db.execute(
              `UPDATE organizations 
               SET last_payment_date = ?,
                   payment_failure_count = 0,
                   subscription_status = 'active'
               WHERE id = ?`,
              [new Date().toISOString(), orgResult[0].id]
            );
            
            logger.info(`Payment succeeded for organization ${orgResult[0].id}`);
          }
        }
        break;
      }
      
      case 'invoice.payment_failed': {
        const invoice = event.data.object as Stripe.Invoice;
        if (invoice.subscription) {
          // Find organization with this subscription
          const orgResult = await db.query<{ id: number, payment_failure_count: number }>(
            'SELECT id, payment_failure_count FROM organizations WHERE stripe_subscription_id = ?',
            [invoice.subscription]
          );
          
          if (orgResult && orgResult.length > 0) {
            const org = orgResult[0];
            const newFailureCount = org.payment_failure_count + 1;
            
            // Update payment failure count
            await db.execute(
              `UPDATE organizations 
               SET payment_failure_count = ?,
                   subscription_status = ?
               WHERE id = ?`,
              [
                newFailureCount,
                newFailureCount >= 3 ? 'past_due' : 'active', // Mark as past_due after 3 failures
                org.id
              ]
            );
            
            logger.warn(`Payment failed for organization ${org.id}. Failure count: ${newFailureCount}`);
          }
        }
        break;
      }
      
      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription;
        const orgResult = await db.query<{ id: number }>(
          'SELECT id FROM organizations WHERE stripe_subscription_id = ?',
          [subscription.id]
        );
        
        if (orgResult && orgResult.length > 0) {
          // Mark subscription as canceled
          await db.execute(
            `UPDATE organizations SET subscription_status = 'canceled' WHERE id = ?`,
            [orgResult[0].id]
          );
          
          logger.info(`Subscription canceled for organization ${orgResult[0].id}`);
        }
        break;
      }
    }
  } catch (error) {
    logger.error('Error handling Stripe webhook:', error);
    throw error;
  }
}

================
File: src/services/subscription.ts
================
import { Database } from '../database';
import { logger } from '../logger';
import Stripe from 'stripe';
import { config } from '../config';

// Define possible account statuses
export type AccountStatus = 
  | 'good_standing'           // Everything is fine
  | 'inactive'                // Subscription inactive (canceled, past_due, etc.)
  | 'agent_limit_exceeded'    // Too many agents for current plan
  | 'contact_limit_exceeded'; // Too many contacts for current plan

export interface AccountStatusDetails {
  status: AccountStatus;
  message: string;
  organizationId: number;
  organizationName: string;
  organizationSlug: string;
  subscriptionTier: string;
  subscriptionStatus: string;
  agentLimit: number;
  contactLimit: number;
  currentAgentCount: number;
  currentContactCount: number;
  billingCycleEnd?: Date;
  paymentFailureCount: number;
}

/**
 * Updates organization subscription status from Stripe
 */
export async function syncSubscriptionStatus(organizationId: number): Promise<void> {
  const db = new Database();
  
  try {
    // Get organization details
    const orgResult = await db.execute(
      'SELECT stripe_subscription_id, stripe_customer_id FROM organizations WHERE id = ?', 
      [organizationId]
    );
    
    if (!orgResult.rows || orgResult.rows.length === 0) {
      logger.error(`Organization not found: ${organizationId}`);
      return;
    }
    
    const org = orgResult.rows[0];
    
    // If no Stripe subscription ID, nothing to sync
    if (!org[0]) {
      logger.info(`No Stripe subscription for organization ${organizationId}`);
      return;
    }
    
    // Initialize Stripe client
    const stripe = new Stripe(config.stripe.secretKey, {
      apiVersion: '2025-02-24.acacia' as Stripe.LatestApiVersion,
    });
    
    // Fetch the subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(org[0]);
    
    // Map Stripe status to our status
    let subscriptionStatus = 'active';
    if (subscription.status === 'active' || subscription.status === 'trialing') {
      subscriptionStatus = 'active';
    } else if (subscription.status === 'past_due') {
      subscriptionStatus = 'past_due';
    } else {
      subscriptionStatus = 'inactive';
    }
    
    // Get the billing cycle end
    const billingCycleEnd = new Date(subscription.current_period_end * 1000);
    
    // Get trial end if applicable
    const trialEnd = subscription.trial_end 
      ? new Date(subscription.trial_end * 1000) 
      : null;
    
    // Get extra agents and contacts from subscription metadata
    const extraAgents = parseInt(subscription.metadata.extraAgents || '0', 10);
    const extraContacts = parseInt(subscription.metadata.extraContacts || '0', 10);
    
    // Update the organization with Stripe data
    await db.execute(`
      UPDATE organizations 
      SET 
        subscription_status = ?,
        billing_cycle_end = ?,
        trial_end_date = ?,
        extra_agents = ?,
        extra_contacts = ?
      WHERE id = ?
    `, [
      subscriptionStatus,
      billingCycleEnd.toISOString(),
      trialEnd?.toISOString() || null,
      extraAgents,
      extraContacts,
      organizationId
    ]);
    
    logger.info(`Updated subscription status for organization ${organizationId}: ${subscriptionStatus}`);
    
  } catch (error) {
    logger.error(`Error syncing subscription status for organization ${organizationId}:`, error);
    throw error;
  }
}

/**
 * Checks if an organization's account is in good standing
 */
export async function checkAccountStatus(organizationId: number): Promise<AccountStatusDetails> {
  const db = new Database();
  
  try {
    // Try to sync with Stripe first
    try {
      await syncSubscriptionStatus(organizationId);
    } catch (error) {
      logger.warn(`Could not sync with Stripe for organization ${organizationId}:`, error);
    }
    
    // Get basic organization info first (this should always work)
    const orgResult = await db.execute(
      'SELECT id, name, slug, subscription_tier, subscription_status, agent_limit, contact_limit, extra_agents, extra_contacts, billing_cycle_end, payment_failure_count FROM organizations WHERE id = ?', 
      [organizationId]
    );
    
    if (!orgResult.rows || orgResult.rows.length === 0) {
      throw new Error(`Organization not found: ${organizationId}`);
    }
    
    const org = orgResult.rows[0];
    
    try {
      // Try to query the organization_status view
      const statusResult = await db.execute(
        'SELECT * FROM organization_status WHERE id = ?', 
        [organizationId]
      );
      
      if (statusResult.rows && statusResult.rows.length > 0) {
        const status = statusResult.rows[0];
        const columns = statusResult.columns || [];
        
        // Create an object from the row array using column names
        const statusObj: any = {};
        columns.forEach((col, i) => {
          statusObj[col] = status[i];
        });
        
        // Prepare status details with appropriate message
        let message = '';
        switch (statusObj.account_status) {
          case 'inactive':
            message = `Your subscription is ${statusObj.subscription_status}. Please update your payment method.`;
            break;
            
          case 'agent_limit_exceeded':
            message = `Your account has ${statusObj.current_agent_count} agents, but your plan only allows for ${statusObj.agent_limit + statusObj.extra_agents}. Please remove some agents or upgrade your plan.`;
            break;
            
          case 'contact_limit_exceeded':
            message = `Your account has ${statusObj.current_contact_count} contacts, but your plan only allows for ${statusObj.contact_limit + statusObj.extra_contacts}. Please remove some contacts or upgrade your plan.`;
            break;
            
          case 'good_standing':
          default:
            message = 'Your account is in good standing.';
            break;
        }
        
        return {
          status: statusObj.account_status,
          message,
          organizationId: statusObj.id,
          organizationName: statusObj.name,
          organizationSlug: statusObj.slug,
          subscriptionTier: statusObj.subscription_tier,
          subscriptionStatus: statusObj.subscription_status,
          agentLimit: statusObj.agent_limit + statusObj.extra_agents,
          contactLimit: statusObj.contact_limit + statusObj.extra_contacts,
          currentAgentCount: statusObj.current_agent_count,
          currentContactCount: statusObj.current_contact_count,
          billingCycleEnd: statusObj.billing_cycle_end ? new Date(statusObj.billing_cycle_end) : undefined,
          paymentFailureCount: statusObj.payment_failure_count
        };
      }
    } catch (viewError) {
      // If there's an error querying the view (e.g., it doesn't exist),
      // we'll fall through to the default implementation below
      logger.warn(`Error querying organization_status view: ${viewError}`);
    }
    
    // If we get here, either the view doesn't exist or there was no result
    // Provide default values based on the organization record
    
    // Default to good standing
    const accountStatus: AccountStatus = 'good_standing';
    const message = 'Your account is in good standing.';
    
    // Extract values from the row array
    const columns = orgResult.columns || [];
    const orgObj: any = {};
    columns.forEach((col, i) => {
      orgObj[col] = org[i];
    });
    
    // Use defaults for missing values
    const subscriptionStatus = orgObj.subscription_status || 'active';
    const agentLimit = orgObj.agent_limit || 5;
    const contactLimit = orgObj.contact_limit || 100;
    const extraAgents = orgObj.extra_agents || 0;
    const extraContacts = orgObj.extra_contacts || 0;
    
    return {
      status: accountStatus,
      message,
      organizationId: orgObj.id,
      organizationName: orgObj.name,
      organizationSlug: orgObj.slug,
      subscriptionTier: orgObj.subscription_tier,
      subscriptionStatus,
      agentLimit: agentLimit + extraAgents,
      contactLimit: contactLimit + extraContacts,
      currentAgentCount: 0, // Default to 0 since we can't query agents table
      currentContactCount: 0, // Default to 0 since we can't query contacts table
      billingCycleEnd: orgObj.billing_cycle_end ? new Date(orgObj.billing_cycle_end) : undefined,
      paymentFailureCount: orgObj.payment_failure_count || 0
    };
    
  } catch (error) {
    logger.error(`Error checking account status for organization ${organizationId}:`, error);
    throw error;
  }
}

================
File: src/services/turso.ts
================
import { createClient } from '@libsql/client';
import { TURSO_CONFIG } from '../config/turso';
import { logger } from '../logger';
import { config } from '../config'
import fetch from 'node-fetch'

// Use non-null assertion since we check these values immediately
const TURSO_DB_URL = config.TURSO_DATABASE_URL!;
const TURSO_AUTH_TOKEN = config.TURSO_AUTH_TOKEN!;

if (!config.TURSO_DATABASE_URL) {
  throw new Error('TURSO_DATABASE_URL is not set');
}

if (!config.TURSO_AUTH_TOKEN) {
  throw new Error('TURSO_AUTH_TOKEN is not set');
}

export const tursoClient = createClient({
  url: TURSO_DB_URL,
  authToken: TURSO_AUTH_TOKEN,
});

export async function getTursoClient() {
  try {
    await tursoClient.execute('SELECT 1');
    return tursoClient;
  } catch (error) {
    logger.error(`Error connecting to Turso: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// Export a function to check if the client is healthy
export async function checkTursoHealth(): Promise<boolean> {
  try {
    await tursoClient.execute('SELECT 1');
    return true;
  } catch (error) {
    logger.error(`Turso health check failed: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

interface TursoResponse {
  databases?: Array<{
    Name: string;
    DbId: string;
    Hostname: string;
    Region: string;
  }>;
  jwt?: string;
  [key: string]: unknown;
}

export class TursoService {
  private apiToken: string
  private client;

  constructor() {
    const token = config.TURSO_API_TOKEN;
    if (!token) {
      throw new Error('TURSO_API_TOKEN is not set');
    }
    this.apiToken = token;
    this.client = tursoClient;
    
    logger.info('TursoService initialized with API token')
  }

  async createOrganizationDatabase(orgId: string): Promise<{url: string, token: string}> {
    const dbName = `org-${orgId}-${Date.now()}`
    
    try {
      // Create database
      logger.info(`Creating Turso database for org ${orgId} with name ${dbName}`)
      const createResponse = await fetch('https://api.turso.tech/v1/databases', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: dbName,
          group: 'default',
        }),
      })

      if (!createResponse.ok) {
        const errorText = await createResponse.text()
        logger.error(`Failed to create database: ${errorText}`)
        throw new Error(`Failed to create database: ${errorText}`)
      }

      const createData = await createResponse.json() as any
      logger.info(`Database creation response: ${JSON.stringify(createData)}`)
      
      const hostname = createData.database?.Hostname
      if (!hostname) {
        logger.error(`Invalid database creation response - missing hostname: ${JSON.stringify(createData)}`)
        throw new Error('Failed to get database hostname')
      }
      logger.info(`Successfully created database with hostname: ${hostname}`)
      
      // Create access token
      logger.info(`Creating access token for database ${dbName}`)
      const tokenUrl = `https://api.turso.tech/v1/databases/${dbName}/auth/tokens`
      logger.info(`Token creation URL: ${tokenUrl}`)
      
      const tokenResponse = await fetch(tokenUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          expiration: 'never',
        }),
      })

      if (!tokenResponse.ok) {
        const errorText = await tokenResponse.text()
        logger.error(`Failed to create token (status ${tokenResponse.status}): ${errorText}`)
        // Log response headers for debugging
        const headers: Record<string, string> = {}
        tokenResponse.headers.forEach((value, key) => {
          headers[key] = value
        })
        logger.error(`Token response headers: ${JSON.stringify(headers)}`)
        throw new Error(`Failed to create token: ${errorText}`)
      }

      const tokenData = await tokenResponse.json() as any
      logger.info(`Token creation response: ${JSON.stringify(tokenData)}`)
      
      const token = tokenData.jwt
      if (!token) {
        logger.error(`Invalid token response - missing jwt: ${JSON.stringify(tokenData)}`)
        throw new Error('Failed to get database access token')
      }
      
      logger.info(`Successfully created token for database ${dbName}`)
      
      return {
        url: hostname,
        token,
      }
    } catch (error) {
      logger.error(`Error creating organization database: ${error instanceof Error ? error.message : String(error)}`)
      if (error instanceof Error && error.stack) {
        logger.error(`Stack trace: ${error.stack}`)
      }
      throw error
    }
  }

  async deleteOrganizationDatabase(dbName: string): Promise<void> {
    try {
      logger.info(`Deleting Turso database ${dbName}`)
      const response = await fetch(`https://api.turso.tech/v1/databases/${dbName}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
        },
      })

      if (!response.ok) {
        const errorText = await response.text()
        logger.error(`Failed to delete database: ${errorText}`)
        throw new Error(`Failed to delete database: ${errorText}`)
      }
      
      logger.info(`Successfully deleted database ${dbName}`)
    } catch (error) {
      logger.error(`Error deleting organization database: ${error}`)
      throw error
    }
  }

  // Helper function to normalize database URLs
  private normalizeDbUrl(url: string): { hostname: string, apiUrl: string, dbUrl: string } {
    // Strip any protocol prefix
    const hostname = url.replace(/(^https?:\/\/)|(^libsql:\/\/)/, '');
    return {
      hostname,  // Raw hostname without protocol
      apiUrl: `https://${hostname}`,  // For API calls
      dbUrl: `libsql://${hostname}`   // For database connections
    };
  }

  async downloadDatabaseDump(dbUrl: string, authToken: string): Promise<string> {
    try {
      const { apiUrl } = this.normalizeDbUrl(dbUrl);
      logger.info(`Downloading database dump from ${apiUrl}/dump`);
      
      const response = await fetch(`${apiUrl}/dump`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`,
        },
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to download dump: ${errorText}`);
      }

      return await response.text();
    } catch (error) {
      logger.error(`Error downloading database dump: ${error}`);
      throw error;
    }
  }

  async createDatabaseFromDump(orgId: string, suffix: string, dumpContent: string): Promise<{url: string, token: string}> {
    const dbName = `org-${orgId}-${suffix}`;

    try {
      logger.info(`Creating new database: ${dbName}`);
      
      // Step 1: Create the database with a unique name
      const createDbResponse = await fetch(
        `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, 
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: dbName,
            group: TURSO_CONFIG.GROUP_NAME
          })
        }
      );

      if (!createDbResponse.ok) {
        const errorText = await createDbResponse.text();
        throw new Error(`Failed to create database: ${errorText}`);
      }

      const dbData = await createDbResponse.json() as { database: { Hostname: string } };
      const { dbUrl, apiUrl } = this.normalizeDbUrl(dbData.database.Hostname);
      logger.info(`Database created: ${dbUrl}`);
      
      // Step 2: Generate an auth token for the database
      logger.info(`Generating auth token for database ${dbName}`);
      const tokenResponse = await fetch(
        `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}/auth/tokens`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      if (!tokenResponse.ok) {
        const errorText = await tokenResponse.text();
        // Try to clean up the created database
        try {
          await this.deleteOrganizationDatabase(dbName);
        } catch (cleanupError) {
          logger.warn(`Failed to delete database after token error: ${cleanupError}`);
        }
        throw new Error(`Failed to create auth token: ${errorText}`);
      }

      const tokenData = await tokenResponse.json() as { jwt: string };
      const token = tokenData.jwt;
      
      logger.info(`Successfully created database ${dbName} with auth token`);
      
      // Create client for the new database using libsql:// URL
      const client = createClient({
        url: dbUrl,
        authToken: token
      });
      
      // Split dump into logical statement groups for more reliable execution
      const statements = dumpContent
        .split(';')
        .map(stmt => stmt.trim())
        .filter(stmt => stmt.length > 0);
      
      logger.info(`Split SQL dump into ${statements.length} statements`);
      
      // Execute statements in phases - first schema statements, then data statements
      // Parse and categorize statements
      const schemaStatements = statements.filter(stmt => 
        stmt.toUpperCase().startsWith('CREATE TABLE')
      );
      
      const indexStatements = statements.filter(stmt => 
        stmt.toUpperCase().startsWith('CREATE INDEX') || 
        stmt.toUpperCase().startsWith('CREATE UNIQUE INDEX')
      );
      
      const insertStatements = statements.filter(stmt => 
        stmt.toUpperCase().startsWith('INSERT')
      );
      
      const otherStatements = statements.filter(stmt => 
        !schemaStatements.includes(stmt) && 
        !indexStatements.includes(stmt) && 
        !insertStatements.includes(stmt)
      );
      
      logger.info(`Processing ${schemaStatements.length} tables, ${indexStatements.length} indexes, ${insertStatements.length} data inserts, and ${otherStatements.length} other statements`);
      
      // Phase 1: Create tables
      for (const tableStatement of schemaStatements) {
        try {
          logger.info(`Creating table: ${tableStatement.substring(0, 60)}...`);
          await client.execute(tableStatement);
        } catch (error) {
          // If there's an error with the contacts table missing updated_at, add it
          if (tableStatement.includes('contacts') && 
              error.toString().includes('no column named updated_at')) {
            logger.warn('Error creating contacts table, attempting to fix missing updated_at column');
            
            // Add the updated_at column if it's missing
            try {
              // First create the table without the updated_at column
              await client.execute(tableStatement);
              
              // Then add the updated_at column
              await client.execute(`
                ALTER TABLE contacts
                ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
              `);
              
              logger.info('Successfully added missing updated_at column to contacts table');
            } catch (altError) {
              logger.error(`Failed to fix contacts table: ${altError}`);
              throw altError;
            }
          } else {
            // For other errors, just throw them
            throw error;
          }
        }
      }
      
      // Phase 2: Execute other statements (drops, alters, etc)
      for (const statement of otherStatements) {
        await client.execute(statement);
      }
      
      // Phase 3: Insert data
      logger.info(`Inserting data (${insertStatements.length} statements)...`);
      let successCount = 0;
      let errorCount = 0;
      
      // Check if we've already detected updated_at missing
      let updatedAtMissing = false;
      let checkedUpdatedAt = false;
      
      for (const insertStatement of insertStatements) {
        try {
          // Skip if we know the statement will fail due to updated_at missing
          if (updatedAtMissing && insertStatement.includes('updated_at')) {
            // Try to fix the insert statement by removing the updated_at column
            const fixedInsert = insertStatement
              .replace(/updated_at\s*,/i, '')  // Remove updated_at from column list
              .replace(/(\w+\s*,\s*)CURRENT_TIMESTAMP(\s*\))/gi, '$1$2')  // Remove corresponding value in VALUES
              .replace(/,\s*\)/g, ')');  // Fix any trailing commas
            
            try {
              await client.execute(fixedInsert);
              successCount++;
              
              // Log progress periodically
              if (successCount % 50 === 0) {
                logger.info(`Imported ${successCount}/${insertStatements.length} data statements (with fixes)`);
              }
            } catch (fixError) {
              errorCount++;
              logger.error(`Error executing fixed INSERT: ${fixError}`);
              // Continue with next statement
            }
            continue;
          }
          
          // Try the original statement
          await client.execute(insertStatement);
          successCount++;
          
          // Log progress periodically
          if (successCount % 50 === 0) {
            logger.info(`Imported ${successCount}/${insertStatements.length} data statements`);
          }
        } catch (error) {
          // Check if this is the updated_at missing error
          if (!checkedUpdatedAt && error.toString().includes('no column named updated_at')) {
            updatedAtMissing = true;
            checkedUpdatedAt = true;
            logger.warn('Detected missing updated_at column in contacts table, will attempt to fix INSERT statements');
            
            // Try to add the column if it's missing
            try {
              await client.execute(`
                ALTER TABLE contacts
                ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
              `);
              logger.info('Added missing updated_at column to contacts table');
              
              // Now we have the column, try the statement again
              try {
                await client.execute(insertStatement);
                successCount++;
                logger.info('Successfully executed INSERT after adding updated_at column');
                
                // We fixed the table, so we don't need to modify statements anymore
                updatedAtMissing = false;
              } catch (retryError) {
                errorCount++;
                logger.error(`Error retrying INSERT after adding column: ${retryError}`);
              }
            } catch (alterError) {
              logger.warn(`Could not add updated_at column: ${alterError}`);
              // Still mark as missing so we can fix the statements
            }
          } else {
            errorCount++;
            logger.error(`Error executing INSERT: ${error}`);
            // Continue with next statement - don't fail everything for one bad insert
          }
        }
      }
      
      // Phase 4: Create indexes (do this last for better performance)
      logger.info(`Creating ${indexStatements.length} indexes...`);
      for (const indexStatement of indexStatements) {
        try {
          await client.execute(indexStatement);
        } catch (error) {
          logger.warn(`Error creating index: ${error}`);
          // Continue with next index - not fatal
        }
      }
      
      // Log summary
      logger.info(`Database import complete: ${successCount} successful inserts, ${errorCount} errors`);
      
      // Verify the database
      try {
        const result = await client.execute('SELECT COUNT(*) as count FROM contacts');
        const count = result.rows?.[0]?.[0];
        logger.info(`Database verification: ${count} contacts found`);
      } catch (error) {
        logger.warn(`Error verifying database: ${error}`);
      }
      
      return { url: dbUrl, token };
    } catch (error) {
      logger.error(`Error creating database from dump: ${error}`);
      throw error;
    }
  }

  private handleError(error: unknown): never {
    logger.error(`Turso service error: ${error instanceof Error ? error.message : String(error)}`);
    throw error instanceof Error ? error : new Error(String(error));
  }

  private validateResponse(data: unknown): TursoResponse {
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid response from Turso API');
    }
    return data as TursoResponse;
  }
}

================
File: src/utils/quoteId.ts
================
import { createHash } from 'crypto';

// Function to generate a unique quote ID from org ID and contact ID
export function generateQuoteId(orgId: number, contactId: number): string {
    // Create a string to hash that includes org, contact, and secret
    const dataToHash = `${orgId}-${contactId}-${process.env.QUOTE_SECRET || 'your-default-secret-key'}`;
    
    // Generate hash using crypto
    const hash = createHash('sha256')
        .update(dataToHash)
        .digest('hex')
        .slice(0, 8); // Take first 8 characters for brevity
    
    // Combine components into quote ID
    return `${orgId}-${contactId}-${hash}`;
}

// Function to decode a quote ID back to org ID and contact ID
export function decodeQuoteId(quoteId: string): { orgId: number; contactId: number } | null {
    try {
        const parts = quoteId.split('-');
        if (parts.length !== 3) {
            return null;
        }

        const [orgId, contactId, providedHash] = parts;
        
        // Recreate hash to validate
        const dataToHash = `${orgId}-${contactId}-${process.env.QUOTE_SECRET || 'your-default-secret-key'}`;
        const expectedHash = createHash('sha256')
            .update(dataToHash)
            .digest('hex')
            .slice(0, 8);

        // Compare hashes
        if (providedHash !== expectedHash) {
            return null;
        }

        return {
            orgId: parseInt(orgId),
            contactId: parseInt(contactId)
        };
    } catch (e) {
        return null;
    }
}

================
File: src/config.ts
================
import { config as dotenvConfig } from 'dotenv'
import { resolve } from 'path'
import { logger } from './logger'
import { existsSync } from 'fs'
import dotenv from 'dotenv'
import fs from 'fs'
import path from 'path'

// Get absolute path to .env file
const envPath = resolve(__dirname, '../.env')

// Check if .env file exists - but don't exit if using Replit Secrets
const envFileExists = existsSync(envPath)
if (!envFileExists) {
  console.log(`⚠️ .env file not found at: ${envPath}, will attempt to use Replit Secrets instead`)
} else {
  // Load .env file with override option only if it exists
  const result = dotenvConfig({ 
    path: envPath,
    override: true // This tells dotenv to override existing env vars
  })

  if (result.error) {
    console.warn('⚠️ Error loading .env file:', result.error)
  } else {
    console.log('📁 Loading .env from:', envPath)
  }
}

// Log environment variables (safely)
console.log('📝 Environment variables available:', {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL ? '[PRESENT]' : '[MISSING]',
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN ? '[PRESENT]' : '[MISSING]',
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH ? '[PRESENT]' : '[MISSING]'
})

// Load environment variables from .env file
if (fs.existsSync(path.join(process.cwd(), '.env'))) {
  dotenv.config()
}

export const config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  TURSO_API_TOKEN: process.env.TURSO_API_TOKEN,
  TURSO_ORG_GROUP: process.env.TURSO_ORG_GROUP || 'medicare-portal',
  TURSO_ORG_SLUG: process.env.TURSO_ORG_SLUG || 'pyrex41',
  quoteApiKey: process.env.QUOTE_API_KEY,
  quoteSecret: process.env.QUOTE_SECRET,
  magicLinkSecret: process.env.MAGIC_LINK_SECRET,
  sendgridApiKey: process.env.SENDGRID_API_KEY,
  sendgridFromEmail: process.env.SENDGRID_FROM_EMAIL,
  PUBLIC_URL: process.env.PUBLIC_URL || (process.env.NODE_ENV === 'development' 
    ? 'http://localhost:5173'
    : 'http://localhost:3000'),
  stripe: {
    secretKey: process.env.STRIPE_SECRET_KEY || '',
    publishableKey: process.env.STRIPE_PUBLISHABLE_KEY || '',
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET || '',
    prices: {
      basic: process.env.STRIPE_PRICE_BASIC || '',
      pro: process.env.STRIPE_PRICE_PRO || '',
      enterprise: process.env.STRIPE_PRICE_ENTERPRISE || '',
      extraAgent: process.env.STRIPE_PRICE_EXTRA_AGENT || '',
      extraContact: process.env.STRIPE_PRICE_EXTRA_CONTACT || '',
    },
    publicKey: process.env.STRIPE_PUBLIC_KEY,
    connectAccount: process.env.STRIPE_CONNECT_ACCOUNT,
  },
  stripeApiKey: process.env.STRIPE_SECRET_KEY,
  stripeWebhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
  clientUrl: process.env.PUBLIC_URL || 'http://localhost:5173',
}

// Log loaded config (safely)
logger.info(`Config loaded ${envFileExists ? `from ${envPath}` : 'from environment'}`)

================
File: src/database.ts
================
import { createClient } from '@libsql/client'
import { config } from './config'
import { logger } from './logger'
import { TursoService } from './services/turso'
import { Database as BunDatabase } from 'bun:sqlite'
import fs from 'fs'
import path from 'path'
import { parse } from 'csv-parse'
import { pipeline } from 'stream/promises'
import fetch from 'node-fetch'
import type { ContactCreate } from './types'

export class Database {
  private client: any
  private url: string
  private isLocal: boolean
  private bunDb: BunDatabase | null = null

  public static normalizeDbUrl(url: string): { hostname: string, apiUrl: string, dbUrl: string, dbName: string } {
    // Strip any protocol prefix
    const hostname = url.replace(/(^https?:\/\/)|(^libsql:\/\/)/, '');
    const dbName = hostname.split('/').pop()?.split('.')[0] || '';
    return {
      hostname,  // Raw hostname without protocol
      apiUrl: `https://${hostname}`,  // For API calls
      dbUrl: `libsql://${hostname}`,   // For database connections
      dbName // For local SQLite files
    };
  }

  constructor(dbUrl?: string, authToken?: string) {
    const url = dbUrl || config.TURSO_DATABASE_URL
    const token = authToken || config.TURSO_AUTH_TOKEN

    if (!url) {
      logger.error('Missing database URL')
      throw new Error('Missing database URL')
    }

    const { dbUrl: normalizedUrl, dbName } = Database.normalizeDbUrl(url)
    this.url = normalizedUrl
    this.isLocal = config.USE_LOCAL_SQLITE

    if (this.isLocal) {
      const dbPath = path.join(process.cwd(), config.LOCAL_DB_PATH, `${dbName}.sqlite`)
      logger.info(`Using local SQLite database at: ${dbPath}`)
      
      // Create directory if it doesn't exist
      const dbDir = path.dirname(dbPath)
      if (!fs.existsSync(dbDir)) {
        fs.mkdirSync(dbDir, { recursive: true })
      }
      
      this.bunDb = new BunDatabase(dbPath)
      this.client = this.bunDb
      
      // Enable foreign keys
      this.bunDb.exec('PRAGMA foreign_keys = ON;')
    } else {
      if (!token) {
        logger.error('Missing database token')
        throw new Error('Missing database token')
      }
      this.client = createClient({
        url: normalizedUrl,
        authToken: token,
        concurrency: 50 // Increase concurrency for higher throughput
      })
    }
    
    logger.info(`Database connected to: ${this.isLocal ? dbName : this.url}`)
  }

  static async getOrgDb(orgId: string): Promise<Database> {
    const mainDb = new Database()
    const org = await mainDb.fetchOne<{ turso_db_url: string; turso_auth_token: string }>(
      'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
      [orgId]
    )
    if (!org?.turso_db_url) {
      logger.error(`No database URL found for org ${orgId}`)
      throw new Error('Organization database not configured')
    }
    
    // If using local SQLite, we don't need the auth token
    if (config.USE_LOCAL_SQLITE) {
      logger.info(`Creating local SQLite client for org ${orgId}`)
      return new Database(org.turso_db_url)
    } else {
      if (!org.turso_auth_token) {
        logger.error(`No auth token found for org ${orgId}`)
        throw new Error('Organization database not configured')
      }
      logger.info(`Creating Turso client for org ${orgId}`)
      return new Database(org.turso_db_url, org.turso_auth_token)
    }
  }

  /**
   * Get organization's database or initialize it if it doesn't exist
   * This method is used as a fallback when the database needs to be created on the fly
   */
  static async getOrInitOrgDb(orgId: string): Promise<Database> {
    try {
      const db = await Database.getOrgDb(orgId)
      await Database.ensureOrgSchema(db)
      return db
    } catch (error) {
      if (error instanceof Error && error.message === 'Organization database not configured') {
        logger.info(`No database found for org ${orgId}, initializing new database`)
        const mainDb = new Database()
        const orgExists = await mainDb.fetchOne<{ id: number }>(
          'SELECT id FROM organizations WHERE id = ?',
          [orgId]
        )
        if (!orgExists) throw new Error('Organization not found')

        const turso = new TursoService()
        logger.info(`Creating new Turso database for org ${orgId}`)
        const { url, token } = await turso.createOrganizationDatabase(orgId)
        logger.info(`Got new database URL: ${url}`)
        logger.info(`Got new database token (length: ${token.length})`)

        // Verify we can connect with the new credentials
        try {
          logger.info('Verifying connection with new credentials...')
          const testDb = new Database(url, token)
          await testDb.execute('SELECT 1')
          logger.info('Successfully verified connection with new credentials')
        } catch (connError) {
          logger.error(`Failed to verify connection with new credentials: ${connError instanceof Error ? connError.message : String(connError)}`)
          throw new Error('Failed to verify connection with new database credentials')
        }

        // Update organization with new credentials
        logger.info(`Updating organization ${orgId} with new database credentials`)
        await mainDb.execute(
          'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ? WHERE id = ?',
          [url, token, orgId]
        )

        // Verify the update
        const updatedOrg = await mainDb.fetchOne<{ turso_db_url: string, turso_auth_token: string }>(
          'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
          [orgId]
        )
        if (!updatedOrg) {
          logger.error('Failed to fetch updated organization after credential update')
          throw new Error('Failed to update organization credentials')
        }
        if (updatedOrg.turso_db_url !== url || updatedOrg.turso_auth_token !== token) {
          logger.error('Organization credentials mismatch after update')
          logger.error(`Expected URL: ${url}, got: ${updatedOrg.turso_db_url}`)
          logger.error(`Expected token length: ${token.length}, got: ${updatedOrg.turso_auth_token.length}`)
          throw new Error('Organization credentials mismatch after update')
        }

        logger.info(`Successfully initialized database for organization ${orgId}`)
        const newDb = new Database(url, token)
        await Database.ensureOrgSchema(newDb)
        return newDb
      }
      logger.error(`Error in getOrInitOrgDb: ${error instanceof Error ? error.message : String(error)}`)
      if (error instanceof Error && error.stack) {
        logger.error(`Stack trace: ${error.stack}`)
      }
      throw error
    }
  }

  /**
   * Ensure that the organization database has all required tables
   * This can be used to add new tables to existing databases when the schema changes
   */
  static async ensureDatabaseSchema(orgId: string): Promise<void> {
    const orgDb = await Database.getOrgDb(orgId);
    
    // Define tables and their schema
    const tables = [
      {
        name: 'contacts',
        createStatement: `
          CREATE TABLE IF NOT EXISTS contacts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            last_name TEXT NOT NULL,
            email TEXT NOT NULL,
            current_carrier TEXT NOT NULL,
            plan_type TEXT NOT NULL,
            effective_date TEXT NOT NULL,
            birth_date TEXT NOT NULL,
            tobacco_user INTEGER NOT NULL,
            gender TEXT NOT NULL,
            state TEXT NOT NULL,
            zip_code TEXT NOT NULL,
            agent_id INTEGER,
            last_emailed DATETIME,
            phone_number TEXT NOT NULL DEFAULT '',
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email)`,
          `CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))`,
        ],
      },
      {
        name: 'eligibility_answers',
        createStatement: `CREATE TABLE IF NOT EXISTS eligibility_answers (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          contact_id INTEGER NOT NULL,
          quote_id TEXT NOT NULL,
          answers TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id)
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_eligibility_answers_contact_id ON eligibility_answers(contact_id)`
        ]
      },
      {
        name: 'contact_events',
        createStatement: `CREATE TABLE IF NOT EXISTS contact_events (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          contact_id INTEGER,
          lead_id INTEGER,
          event_type TEXT NOT NULL,
          metadata TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id),
          FOREIGN KEY (lead_id) REFERENCES leads(id)
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id)`,
          `CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id)`,
          `CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type)`
        ]
      },
      {
        name: 'leads',
        createStatement: `CREATE TABLE IF NOT EXISTS leads (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          email TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          UNIQUE(email)
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email)`
        ]
      }
    ];
    
    // Get all existing tables in one query for efficiency
    const existingTables = await orgDb.fetchAll(
      `SELECT name FROM sqlite_master WHERE type='table' AND name IN (${tables.map(t => `'${t.name}'`).join(', ')})`
    );
    
    // Create a set of existing table names for faster lookup
    const tableSet = new Set(existingTables.map((row: any) => row.name || row[0]));
    
    // Prepare batch operations
    const batchOperations = [];
    
    // Add table creation and index statements for missing tables
    for (const table of tables) {
      if (!tableSet.has(table.name)) {
        logger.info(`Adding schema operations for missing table ${table.name} for org ${orgId}`);
        
        // Add create table statement
        batchOperations.push({
          sql: table.createStatement,
          args: []
        });
        
        // Add index statements
        for (const indexStatement of table.indexStatements) {
          batchOperations.push({
            sql: indexStatement,
            args: []
          });
        }
      }
    }
    
    // Execute all schema operations in a single batch if there are any
    if (batchOperations.length > 0) {
      logger.info(`Executing ${batchOperations.length} schema operations in batch for org ${orgId}`);
      await orgDb.batch(batchOperations, 'write');
      logger.info(`Schema setup completed successfully for org ${orgId}`);
    } else {
      logger.info(`All required tables already exist for org ${orgId}, no schema changes needed`);
    }
  }

  getClient() {
    return this.client
  }

  async execute(sql: string, args: any[] = []) {
    try {
      if (this.isLocal && this.bunDb) {
        // For local SQLite
        const stmt = this.bunDb.prepare(sql)
        const result = stmt.run(...args)
        return {
          rows: Array.isArray(result) ? result : result.changes > 0 ? [result] : [],
          rowsAffected: result.changes
        }
      } else {
        // For Turso
        const result = await this.client.execute({
          sql,
          args
        })
        return result
      }
    } catch (error) {
      logger.error(`Database execute error: ${error}`)
      throw error
    }
  }
  
  /**
   * Execute a batch of SQL statements in an implicit transaction
   * @param statements Array of SQL statements with args
   * @param mode Transaction mode (read or write)
   * @returns Result of the batch operation
   */
  async batch(statements: { sql: string, args: any[] }[], mode: 'read' | 'write' = 'write') {
    try {
      if (this.isLocal && this.bunDb) {
        // For local SQLite, implement batch manually with transaction
        this.bunDb.exec('BEGIN TRANSACTION');
        const results = [];
        
        try {
          for (const { sql, args } of statements) {
            const stmt = this.bunDb.prepare(sql);
            const result = stmt.run(...args);
            results.push({
              rows: Array.isArray(result) ? result : result.changes > 0 ? [result] : [],
              rowsAffected: result.changes
            });
          }
          
          this.bunDb.exec('COMMIT');
          return results;
        } catch (error) {
          this.bunDb.exec('ROLLBACK');
          throw error;
        }
      } else {
        // For Turso, use native batch support
        const batchStatements = statements.map(({ sql, args }) => ({
          sql,
          args: args || []
        }));
        
        return await this.client.batch(batchStatements, mode);
      }
    } catch (error) {
      logger.error(`Database batch error: ${error}`);
      throw error;
    }
  }

  async fetchAll(sql: string, args: any[] = []) {
    try {
      if (this.isLocal && this.bunDb) {
        // For local SQLite
        const stmt = this.bunDb.prepare(sql)
        const rows = stmt.all(...args)
        return rows || []
      } else {
        // For Turso
        const result = await this.client.execute({
          sql,
          args
        })
        return result.rows || []
      }
    } catch (error) {
      logger.error(`Database fetchAll error: ${error}`)
      throw error
    }
  }

  async fetchOne<T>(sql: string, args: any[] = []): Promise<T | null> {
    if (this.isLocal && this.bunDb) {
      // For local SQLite
      const stmt = this.bunDb.prepare(sql)
      const row = stmt.get(...args)
      return row as T || null
    } else {
      // For Turso
      const result = await this.execute(sql, args)
      if (!result.rows || result.rows.length === 0) return null
      const row = result.rows[0]
      const columns = result.columns || []
      const obj: any = {}
      columns.forEach((col: string, i: number) => (obj[col] = row[i]))
      return obj as T
    }
  }

  // Compatibility method for old query interface
  async query<T = any>(sql: string, args: any[] = []): Promise<T[]> {
    return this.fetchAll(sql, args)
  }

  // Add transaction support for local SQLite
  async transaction<T>(callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(mode: 'read' | 'write', callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(
    callbackOrMode: ((tx: Database) => Promise<T>) | 'read' | 'write',
    callback?: (tx: Database) => Promise<T>
  ): Promise<T> {
    let mode: 'read' | 'write' = 'write'
    let fn: ((tx: Database) => Promise<T>) | null = null

    if (typeof callbackOrMode === 'string') {
      mode = callbackOrMode
      fn = callback || null
    } else {
      fn = callbackOrMode
    }
    
    if (!fn) {
      throw new Error('Transaction callback is required')
    }

    if (this.isLocal && this.bunDb) {
      // For local SQLite
      try {
        this.bunDb.exec('BEGIN TRANSACTION')
        const result = await fn(this)
        this.bunDb.exec('COMMIT')
        return result
      } catch (error) {
        this.bunDb.exec('ROLLBACK')
        throw error
      }
    } else {
      // For Turso
      const tx = await this.client.transaction(mode)
      try {
        const txWrapper = new Database()
        txWrapper.client = tx
        const result = await fn(txWrapper)
        await tx.commit()
        return result
      } catch (error) {
        await tx.rollback()
        throw error
      }
    }
  }

  /**
   * Bulk import contacts from CSV directly into the database with high concurrency
   */
  static async bulkImportContacts(orgId: string, csvFilePath: string, overwriteExisting: boolean = false): Promise<void> {
    try {
      logger.info(`Starting bulk import for org ${orgId}`);
      
      // Get database credentials
      const mainDb = new Database();
      const org = await mainDb.fetchOne<{ turso_db_url: string; turso_auth_token: string }>(
        'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
        [orgId]
      );
      
      if (!org?.turso_db_url || !org?.turso_auth_token) {
        throw new Error('Organization database not configured');
      }
      
      // Connect to the organization's database 
      const orgDb = new Database(org.turso_db_url, org.turso_auth_token);
      logger.info(`Connected to organization database: ${org.turso_db_url}`);
      
      // Parse CSV data
      logger.info(`Reading CSV file: ${csvFilePath}`);
      const csvContent = await fs.promises.readFile(csvFilePath, 'utf-8');
      
      // Parse the CSV content
      const records: any[] = [];
      await new Promise<void>((resolve, reject) => {
        parse(csvContent, {
          columns: true,
          skip_empty_lines: true,
          trim: true
        }, (err, output) => {
          if (err) reject(err);
          else {
            records.push(...output);
            resolve();
          }
        });
      });
      
      if (records.length === 0) {
        logger.info('No records found in CSV file, import completed');
        return;
      }
      
      // Log the first record and its keys to help debug column mapping
      const firstRecord = records[0];
      logger.info(`CSV column headers: ${Object.keys(firstRecord).join(', ')}`);
      logger.info(`First record raw data: ${JSON.stringify(firstRecord)}`);
      
      // Column mapping with variations
      const columnMap: Record<string, string> = {
        // First Name variations
        first_name: 'first_name',
        firstName: 'first_name',
        'first name': 'first_name',
        'First Name': 'first_name',
        'FirstName': 'first_name',
        fname: 'first_name',
        'first-name': 'first_name',
        
        // Last Name variations
        last_name: 'last_name',
        lastName: 'last_name',
        'last name': 'last_name',
        'Last Name': 'last_name',
        'LastName': 'last_name',
        lname: 'last_name',
        'last-name': 'last_name',
        
        // Email variations
        email: 'email',
        'Email': 'email',
        'email_address': 'email',
        'emailAddress': 'email',
        'email address': 'email',
        'Email Address': 'email',
        
        // Carrier variations
        current_carrier: 'current_carrier',
        currentCarrier: 'current_carrier',
        'current carrier': 'current_carrier',
        carrier: 'current_carrier',
        'Current Carrier': 'current_carrier',
        'insurance carrier': 'current_carrier',
        'Insurance Carrier': 'current_carrier',
        
        // Plan Type variations
        plan_type: 'plan_type',
        planType: 'plan_type',
        'plan type': 'plan_type',
        'Plan Type': 'plan_type',
        'insurance type': 'plan_type',
        'Insurance Type': 'plan_type',
        
        // Effective Date variations
        effective_date: 'effective_date',
        effectiveDate: 'effective_date',
        'effective date': 'effective_date',
        'Effective Date': 'effective_date',
        'start date': 'effective_date',
        'Start Date': 'effective_date',
        
        // Birth Date variations
        birth_date: 'birth_date',
        birthDate: 'birth_date',
        'birth date': 'birth_date',
        'Birth Date': 'birth_date',
        dob: 'birth_date',
        'DOB': 'birth_date',
        'date of birth': 'birth_date',
        'Date of Birth': 'birth_date',
        
        // Tobacco User variations
        tobacco_user: 'tobacco_user',
        tobaccoUser: 'tobacco_user',
        'tobacco user': 'tobacco_user',
        'Tobacco User': 'tobacco_user',
        'uses tobacco': 'tobacco_user',
        'Uses Tobacco': 'tobacco_user',
        smoker: 'tobacco_user',
        'Smoker': 'tobacco_user',
        
        // Gender variations
        gender: 'gender',
        'Gender': 'gender',
        sex: 'gender',
        'Sex': 'gender',
        
        // State variations
        state: 'state',
        'State': 'state',
        'state code': 'state',
        'State Code': 'state',
        
        // Zip Code variations
        zip_code: 'zip_code',
        zipCode: 'zip_code',
        'zip code': 'zip_code',
        'Zip Code': 'zip_code',
        zip: 'zip_code',
        'ZIP': 'zip_code',
        postal: 'zip_code',
        'Postal': 'zip_code',
        
        // Phone Number variations
        phone_number: 'phone_number',
        phoneNumber: 'phone_number',
        'phone number': 'phone_number',
        'Phone Number': 'phone_number',
        phone: 'phone_number',
        'Phone': 'phone_number',
        tel: 'phone_number',
        'Tel': 'phone_number',
        
        // Agent ID variations
        agent_id: 'agent_id',
        agentId: 'agent_id',
        'agent id': 'agent_id',
        'Agent ID': 'agent_id',
        'agent number': 'agent_id',
        'Agent Number': 'agent_id'
      };
      
      // Log column mapping analysis
      const recordKeys = Object.keys(firstRecord);
      logger.info(`CSV columns found: ${recordKeys.join(', ')}`);
      
      const mappedFields = new Set<string>();
      recordKeys.forEach(key => {
        const mappedTo = columnMap[key];
        if (mappedTo) {
          mappedFields.add(mappedTo);
          logger.info(`Mapped column '${key}' to '${mappedTo}'`);
        } else {
          logger.warn(`No mapping found for column: '${key}'`);
        }
      });
      
      // Check for missing required fields
      const requiredFields = ['first_name', 'last_name', 'email', 'effective_date', 'birth_date'];
      const missingRequired = requiredFields.filter(field => !mappedFields.has(field));
      if (missingRequired.length > 0) {
        logger.warn(`Missing required fields in CSV: ${missingRequired.join(', ')}`);
        if (missingRequired.length >= 3) {
          throw new Error(`Too many required fields missing from CSV: ${missingRequired.join(', ')}`);
        }
      }
      
      // Helper function for normalized field value extraction
      const getValue = (record: any, fieldName: string, defaultValue: string = ''): string => {
        // Try all possible mappings
        for (const [key, mappedField] of Object.entries(columnMap)) {
          if (mappedField === fieldName && record[key] !== undefined) {
            return record[key] || defaultValue;
          }
        }
        // Try direct field name
        return record[fieldName] || defaultValue;
      };
      
      // We don't need to fetch all existing emails anymore since we're using SQL's built-in duplicate handling
      // Just create a set to track emails within each batch to avoid duplicates in the same import batch
      const processedEmails = new Set<string>();
      logger.info("Using SQLite's built-in UPSERT capability to handle duplicates");
      
      // Process in larger batches and execute them concurrently
      const BATCH_SIZE = 1000; // Larger batch size for better throughput
      const totalBatches = Math.ceil(records.length / BATCH_SIZE);
      
      logger.info(`Processing ${records.length} records in ${totalBatches} concurrent batches of up to ${BATCH_SIZE} records each`);
      
      // Prepare batch function to be called concurrently
      const processBatch = async (batchIndex: number): Promise<{added: number, skipped: number}> => {
        const startIdx = batchIndex * BATCH_SIZE;
        const endIdx = Math.min(startIdx + BATCH_SIZE, records.length);
        const batchRecords = records.slice(startIdx, endIdx);
        
        let batchAdded = 0;
        let batchSkipped = 0;
        
        // Prepare batch operations
        const batchOperations: { sql: string, args: any[] }[] = [];
        
        for (const record of batchRecords) {
          try {
            const contact: ContactCreate = {
              first_name: getValue(record, 'first_name'),
              last_name: getValue(record, 'last_name'),
              email: getValue(record, 'email'),
              current_carrier: getValue(record, 'current_carrier'),
              plan_type: getValue(record, 'plan_type'),
              effective_date: getValue(record, 'effective_date'),
              birth_date: getValue(record, 'birth_date'),
              tobacco_user: !!(getValue(record, 'tobacco_user') === '1' || getValue(record, 'tobacco_user').toLowerCase() === 'true'),
              gender: getValue(record, 'gender'),
              state: getValue(record, 'state'),
              zip_code: getValue(record, 'zip_code'),
              phone_number: getValue(record, 'phone_number'),
              agent_id: getValue(record, 'agent_id') ? Number(getValue(record, 'agent_id')) : null,
            };
            
            // Log sample data for first few records
            if (startIdx + batchAdded + batchSkipped < 3) {
              logger.info(`Sample mapped contact data: ${JSON.stringify(contact)}`);
            }
            
            if (!contact.first_name || !contact.last_name || !contact.email || !contact.effective_date || !contact.birth_date) {
              batchSkipped++;
              continue;
            }
            
            const email = contact.email.toLowerCase().trim();
            
            // We still need to prevent duplicates within the same batch or import
            // to avoid constraint violations
            if (processedEmails.has(email)) {
              batchSkipped++;
              continue;
            }
            
            // Add email to the set to prevent duplicates within this import
            processedEmails.add(email);
            
            // Use the faster approach with SQLite's INSERT OR REPLACE/IGNORE
            const insertOp = overwriteExisting ? 'REPLACE' : 'IGNORE';
            
            // Single operation instead of multiple operations
            batchOperations.push({
              sql: `
                INSERT OR ${insertOp} INTO contacts (
                  first_name, last_name, email, current_carrier, plan_type, effective_date,
                  birth_date, tobacco_user, gender, state, zip_code, phone_number, agent_id,
                  created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
              `,
              args: [
                contact.first_name,
                contact.last_name,
                email,
                contact.current_carrier,
                contact.plan_type,
                contact.effective_date,
                contact.birth_date,
                contact.tobacco_user ? 1 : 0,
                contact.gender,
                contact.state,
                contact.zip_code,
                contact.phone_number,
                contact.agent_id === null ? null : Number(contact.agent_id)
              ]
            });
            
            batchAdded++;
          } catch (error) {
            batchSkipped++;
          }
        }
        
        // Execute batch operations with transaction support
        if (batchOperations.length > 0) {
          logger.info(`Executing batch ${batchIndex + 1}/${totalBatches} with ${batchOperations.length} operations`);
          try {
            await orgDb.batch(batchOperations, 'write');
            logger.info(`Batch ${batchIndex + 1}/${totalBatches} completed successfully: added ${batchAdded}, skipped ${batchSkipped}`);
            return { added: batchAdded, skipped: batchSkipped };
          } catch (error) {
            logger.error(`Error executing batch ${batchIndex + 1}/${totalBatches}: ${error}`);
            // Continue with the next batch even if this one failed
            return { added: 0, skipped: batchRecords.length };
          }
        } else {
          logger.info(`Batch ${batchIndex + 1}/${totalBatches} had no operations to execute`);
          return { added: 0, skipped: batchRecords.length };
        }
      };
      
      // Launch all batches concurrently
      const batchPromises: Promise<{added: number, skipped: number}>[] = [];
      for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
        batchPromises.push(processBatch(batchIndex));
      }
      
      // Wait for all batches to complete
      logger.info(`Launched ${batchPromises.length} concurrent batch operations`);
      const results = await Promise.allSettled(batchPromises);
      
      // Compute total results
      let totalAdded = 0;
      let totalSkipped = 0;
      let totalProcessed = 0;
      
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          totalAdded += result.value.added;
          totalSkipped += result.value.skipped;
        } else {
          logger.error(`Batch ${index + 1} failed: ${result.reason}`);
          // Assume all records in this batch were skipped
          const batchSize = Math.min(BATCH_SIZE, records.length - (index * BATCH_SIZE));
          totalSkipped += batchSize;
        }
      });
      
      totalProcessed = totalAdded + totalSkipped;
      
      // Update the organization's last update timestamp
      await mainDb.execute(
        'UPDATE organizations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?',
        [orgId]
      );
      
      // Get final count
      const finalCount = await orgDb.fetchOne<{ count: number }>('SELECT COUNT(*) as count FROM contacts');
      logger.info(`Bulk import completed for org ${orgId}: processed ${totalProcessed}, added ${totalAdded}, skipped ${totalSkipped}, final count: ${finalCount?.count || 'unknown'}`);
      
    } catch (error) {
      logger.error(`Bulk import failed: ${error}`);
      throw error;
    }
  }

  static getUserFromSession = getUserFromSession;
  static getOrganizationById = getOrganizationById;

  static async ensureOrgSchema(orgDb: Database): Promise<void> {
    try {
      // Get all existing tables at once
      const existingTables = await orgDb.fetchAll(
        "SELECT name FROM sqlite_master WHERE type='table' AND name IN ('contacts', 'contact_events', 'leads', 'eligibility_answers')"
      );

      // Create a set of existing table names for faster lookup
      const tableSet = new Set(existingTables.map((row: any) => row.name || row[0]));
      
      // Prepare all schema creation statements
      const schemaOperations = [];
      
      // Contacts table
      if (!tableSet.has('contacts')) {
        logger.info('Creating contacts table schema');
        schemaOperations.push({
          sql: `
            CREATE TABLE IF NOT EXISTS contacts (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              first_name TEXT NOT NULL,
              last_name TEXT NOT NULL,
              email TEXT NOT NULL UNIQUE,
              current_carrier TEXT NOT NULL,
              plan_type TEXT NOT NULL,
              effective_date TEXT NOT NULL,
              birth_date TEXT NOT NULL,
              tobacco_user INTEGER NOT NULL,
              gender TEXT NOT NULL,
              state TEXT NOT NULL,
              zip_code TEXT NOT NULL,
              agent_id INTEGER,
              last_emailed DATETIME,
              phone_number TEXT NOT NULL DEFAULT '',
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
          `,
          args: []
        });
        
        // Indexes for contacts table
        schemaOperations.push({
          sql: `CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email)`,
          args: []
        });
        
        schemaOperations.push({
          sql: `CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))`,
          args: []
        });
      }
      
      // Contact events table
      if (!tableSet.has('contact_events')) {
        logger.info('Creating contact_events table schema');
        schemaOperations.push({
          sql: `
            CREATE TABLE IF NOT EXISTS contact_events (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              contact_id INTEGER,
              lead_id INTEGER,
              event_type TEXT NOT NULL,
              metadata TEXT,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id),
              FOREIGN KEY (lead_id) REFERENCES leads(id)
            )
          `,
          args: []
        });
        
        // Indexes for contact_events table
        schemaOperations.push({
          sql: `CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id)`,
          args: []
        });
        
        schemaOperations.push({
          sql: `CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id)`,
          args: []
        });
        
        schemaOperations.push({
          sql: `CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type)`,
          args: []
        });
      }
      
      // Leads table
      if (!tableSet.has('leads')) {
        logger.info('Creating leads table schema');
        schemaOperations.push({
          sql: `
            CREATE TABLE IF NOT EXISTS leads (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL,
              email TEXT NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              UNIQUE(email)
            )
          `,
          args: []
        });
        
        // Index for leads table
        schemaOperations.push({
          sql: `CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email)`,
          args: []
        });
      }
      
      // Eligibility answers table
      if (!tableSet.has('eligibility_answers')) {
        logger.info('Creating eligibility_answers table schema');
        schemaOperations.push({
          sql: `
            CREATE TABLE IF NOT EXISTS eligibility_answers (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              contact_id INTEGER NOT NULL,
              quote_id TEXT NOT NULL,
              answers TEXT NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id)
            )
          `,
          args: []
        });
        
        // Index for eligibility_answers table
        schemaOperations.push({
          sql: `CREATE INDEX IF NOT EXISTS idx_eligibility_answers_contact_id ON eligibility_answers(contact_id)`,
          args: []
        });
      }
      
      // Execute all schema operations in a single batch if there are any
      if (schemaOperations.length > 0) {
        logger.info(`Executing ${schemaOperations.length} schema operations in batch`);
        await orgDb.batch(schemaOperations, 'write');
        logger.info('Schema setup completed successfully');
      } else {
        logger.info('All required tables already exist, no schema changes needed');
      }
    } catch (error) {
      logger.error(`Error ensuring org schema: ${error}`);
      throw error;
    }
  }

  close() {
    if (this.isLocal && this.bunDb) {
      this.bunDb.close()
    }
  }
}

export const db = new Database() 

/**
 * Get user from session cookie
 */
export async function getUserFromSession(request: any): Promise<any> {
  try {
    const db = new Database();
    let sessionCookie: string | undefined;

    // Handle different request header formats
    if (request.headers) {
      if (typeof request.headers.get === 'function') {
        // Standard Request object
        sessionCookie = request.headers.get('cookie')?.split(';')
          .find((c: string) => c.trim().startsWith('session='))
          ?.split('=')[1];
      } else if (typeof request.headers === 'object') {
        // Raw headers object or Express request
        const cookieHeader = request.headers.cookie || request.headers['cookie'] || request.headers['Cookie'];
        if (typeof cookieHeader === 'string') {
          sessionCookie = cookieHeader.split(';')
            .find((c: string) => c.trim().startsWith('session='))
            ?.split('=')[1];
        }
      }
    }

    if (!sessionCookie) {
      logger.info('No session cookie found');
      return null;
    }

    // Log the session ID for debugging
    logger.info(`Session lookup result: ${JSON.stringify(await db.fetchOne('SELECT * FROM sessions WHERE id = ?', [sessionCookie]))}`);
    
    // Check if the session exists and hasn't expired
    const session = await db.fetchOne<{ id: string, user_id: number, expires_at: string, created_at: string }>(
      'SELECT * FROM sessions WHERE id = ?',
      [sessionCookie]
    );

    if (!session) {
      logger.info('No valid session found');
      return null;
    }

    // Check if session has expired
    const expiresAt = new Date(session.expires_at);
    const now = new Date();
    
    logger.info(`Session expires: ${expiresAt}, current time: ${now}`);
    
    if (expiresAt < now) {
      logger.info('Session has expired');
      return null;
    }

    // Get the user associated with the session
    const user = await db.fetchOne(
      'SELECT u.*, o.name as organization_name FROM users u JOIN organizations o ON u.organization_id = o.id WHERE u.id = ?',
      [session.user_id]
    );

    logger.info(`User lookup result: ${JSON.stringify(user)}`);

    if (!user) {
      logger.info('No user found for session');
      return null;
    }
    
    return user;
  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

/**
 * Get organization by ID
 */
export async function getOrganizationById(orgId: number): Promise<any> {
  try {
    const db = new Database();
    const org = await db.query('SELECT * FROM organizations WHERE id = ?', [orgId]);
    if (!org || org.length === 0) return null;
    return org[0];
  } catch (error) {
    logger.error(`Error getting organization: ${error}`);
    return null;
  }
}

================
File: src/errors.ts
================
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'NotFoundError'
  }
}

export class UnauthorizedError extends Error {
  constructor(message: string = 'Unauthorized') {
    super(message)
    this.name = 'UnauthorizedError'
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'ValidationError'
  }
}

export class DatabaseError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'DatabaseError'
  }
}

================
File: src/index.ts
================
import { Elysia, t } from 'elysia'
import { cors } from '@elysiajs/cors'
import { Database } from './database'
import { logger } from './logger'
import type { ContactCreate, AgentCreate } from './types'
import { readFileSync } from 'fs'
import { staticPlugin } from '@elysiajs/static'
import { parse as csvParse } from 'csv-parse/sync'
import { Readable } from 'stream'
import { Buffer } from 'buffer'
import { createAuthRoutes } from './routes/auth'
import { settingsRoutes } from './routes/settings'
import { organizationRoutes } from './routes/organizations'
import { createBrandRoutes } from './routes/brand'
import { quotesRoutes } from './routes/quotes'
import { createStripeRoutes } from './routes/stripe'
import { createOnboardingRoutes, cleanupOldOrganizations } from './routes/onboarding'
import { errorHandler } from './middleware/error'
import { getUserFromSession } from './services/auth'
import { join } from 'path'
import { existsSync } from 'fs'
import { EmailService } from './services/email'
import * as cron from 'node-cron'
import { eligibilityRoutes } from './routes/eligibility'
import { generateQuoteId } from './utils/quoteId'
import { createSelfServiceRoutes } from './routes/self-service'
import { scheduleRoutes } from './routes/schedule'
import { contactsRoutes } from './routes/contacts'
import * as fs from 'fs/promises'
import * as path from 'path'
import * as os from 'os'

// At the top of the file, add interface for ZIP data
interface ZipInfo {
  state: string;
  // Add other ZIP info properties as needed
}

// Update ZIP_DATA declaration
let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  ZIP_DATA = JSON.parse(readFileSync(path.join(__dirname, '..', 'zipData.json'), 'utf-8'))
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}

// Add with the other type imports
type NewAgentRequest = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

type AgentUpdate = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

interface DbRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  phone: string | null;
  is_admin: number;
  is_agent: number;
  settings: string | null;
}

// Add at the top with other interfaces
interface ContactRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  current_carrier: string;
  plan_type: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: number;
  gender: string;
  state: string;
  zip_code: string;
  agent_id: number | null;
  last_emailed: string | null;
  phone_number: string;
}

interface CarrierRow {
  name: string;
  aliases: string | null;
}

// Add this helper function before startServer
function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
  const digits = phone.replace(/\D/g, '').slice(0, 10);
  return {
    isValid: digits.length === 10,
    standardized: digits
  };
}

// Add this helper function near the other validation functions
function validateEmail(email: string): boolean {
  // RFC 5322 compliant email regex
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  return emailRegex.test(email.trim());
}

// Add this helper function near the other validation functions
function validateISODate(dateStr: string, allowFuture: boolean = false): { isValid: boolean; isoDate: string | null } {
  try {
    const trimmed = dateStr.trim();
    
    // Try to parse the date - will throw if invalid
    const date = new Date(trimmed);
    
    // Check if date is invalid
    if (isNaN(date.getTime())) {
      return { isValid: false, isoDate: null };
    }
    
    // Convert to ISO format (YYYY-MM-DD)
    const isoDate = date.toISOString().split('T')[0];
    
    // Verify the date is not in the future (unless allowed)
    if (!allowFuture && date > new Date()) {
      return { isValid: false, isoDate: null };
    }
    
    return { isValid: true, isoDate };
  } catch (e) {
    return { isValid: false, isoDate: null };
  }
}

// Add this helper function near the other validation functions
async function validateCarrier(carrier: string, db: Database): Promise<{ isValid: boolean; standardizedName: string; wasConverted: boolean }> {
  try {
    // Trim and standardize input
    const trimmedCarrier = carrier.trim();
    logger.info(`Validating carrier: "${trimmedCarrier}"`);
    
    // Create a new instance of the central database
    const centralDb = new Database();
    
    // Get all carriers with their aliases from the central database
    const result = await centralDb.execute<CarrierRow>(
      'SELECT name, aliases FROM carriers'
    );
    
    logger.info(`Found ${result.rows.length} carriers in database`);
    
    // Check each carrier and its aliases
    for (const row of result.rows) {
      logger.info(`Checking against carrier: "${row.name}", aliases: ${row.aliases || '[]'}`);
      
      // Check exact name match (case insensitive)
      if (row.name.toLowerCase() === trimmedCarrier.toLowerCase()) {
        logger.info(`Found exact match with carrier: ${row.name}`);
        return { isValid: true, standardizedName: row.name, wasConverted: false };
      }
      
      // Check aliases if they exist
      if (row.aliases) {
        const aliases = JSON.parse(row.aliases);
        logger.info(`Checking aliases for ${row.name}: ${JSON.stringify(aliases)}`);
        if (Array.isArray(aliases) && aliases.some(alias => alias.toLowerCase() === trimmedCarrier.toLowerCase())) {
          logger.info(`Found match in aliases for carrier: ${row.name}`);
          return { isValid: true, standardizedName: row.name, wasConverted: false };
        }
      }
    }
    
    // If no match found, keep the original carrier name but mark as converted
    logger.info(`No matching carrier found for: "${trimmedCarrier}", keeping original name`);
    return { isValid: true, standardizedName: trimmedCarrier, wasConverted: true };
  } catch (e) {
    logger.error(`Error validating carrier: ${e}`);
    return { isValid: true, standardizedName: carrier.trim(), wasConverted: true };
  }
}

// Interface for validation result
interface ValidationResult {
  isValid: boolean;
  error?: string;
  value?: any;
}

// Validation functions
const validateRow = async (row: any, rowNum: number, carrierMap: Map<string, string>): Promise<ValidationResult> => {
  try {
    logger.info(`Starting validation for row ${rowNum}:`)
    logger.info(`Row data: ${JSON.stringify(row)}`)

    // Required fields check with detailed logging
    const requiredFields = [
      'First Name', 'firstName',
      'Last Name', 'lastName', 
      'Email', 'email',
      'Current Carrier', 'currentCarrier',
      'Plan Type', 'planType',
      'Effective Date', 'effectiveDate',
      'Birth Date', 'birthDate',
      'Tobacco User', 'tobaccoUser',
      'Gender', 'gender',
      'ZIP Code', 'zipCode',
      'Phone Number', 'phoneNumber'
    ]

    logger.info(`Checking required fields: ${requiredFields.join(', ')}`)
    const missingValues = requiredFields.filter(field => {
      const value = row[field]?.trim()
      const isMissing = !value
      if (isMissing) {
        logger.warn(`Missing required field "${field}" in row ${rowNum}`)
      }
      return isMissing
    })

    // Group the missing fields by their base name (e.g. both "First Name" and "firstName" count as one missing field)
    const missingFieldGroups = new Set<string>()
    for (let i = 0; i < missingValues.length; i += 2) {
      if (missingValues[i] && missingValues[i+1]) {
        missingFieldGroups.add(missingValues[i])
      }
    }

    if (missingFieldGroups.size > 0) {
      logger.warn(`Row ${rowNum} missing required fields: ${Array.from(missingFieldGroups).join(', ')}`)
      return {
        isValid: false,
        error: `Missing values for: ${Array.from(missingFieldGroups).join(', ')}`
      }
    }

    // Email validation with logging
    const email = (row['Email'] || row['email'] || '').trim().toLowerCase()
    logger.info(`Validating email: "${email}"`)
    if (!validateEmail(email)) {
      logger.warn(`Row ${rowNum} has invalid email format: ${email}`)
      return {
        isValid: false,
        error: `Invalid email format: ${email}`
      }
    }

    // Phone validation with logging
    logger.info(`Validating phone number: "${row['Phone Number'] || row['phoneNumber']}"`)
    const phoneResult = standardizePhoneNumber(row['Phone Number'] || row['phoneNumber'])
    if (!phoneResult.isValid) {
      logger.warn(`Row ${rowNum} has invalid phone number: ${row['Phone Number'] || row['phoneNumber']}`)
      return {
        isValid: false,
        error: `Invalid phone number: ${row['Phone Number'] || row['phoneNumber']}. Must be exactly 10 digits.`
      }
    }

    // ZIP validation with logging
    const zipCode = (row['ZIP Code'] || row['zipCode'] || '').trim()
    logger.info(`Validating ZIP code: "${zipCode}"`)

    // First check if ZIP code exists and has the right format
    if (!zipCode) {
      logger.warn(`Row ${rowNum} is missing ZIP code`)
      return {
        isValid: false,
        error: `Missing ZIP code. This field is required for determining state coverage and eligibility.`
      }
    }

    // Check if ZIP code is in the correct format (5 digits)
    if (!/^\d{5}$/.test(zipCode)) {
      logger.warn(`Row ${rowNum} has invalid ZIP code format: ${zipCode}`)
      return {
        isValid: false,
        error: `Invalid ZIP code format: ${zipCode}. Must be exactly 5 digits.`
      }
    }

    // Check if ZIP code exists in our database
    const zipInfo = ZIP_DATA[zipCode]
    if (!zipInfo) {
      logger.warn(`Row ${rowNum} has invalid ZIP code: ${zipCode} (not found in database)`)
      return {
        isValid: false,
        error: `Invalid ZIP code: ${zipCode}. This ZIP code is not recognized in our database.`
      }
    }

    // If we get here, we have a valid ZIP code with state information
    logger.info(`Valid ZIP code ${zipCode} maps to state: ${zipInfo.state}`)

    // Gender validation with logging
    const gender = (row['Gender'] || row['gender'] || '').trim().toUpperCase()
    logger.info(`Validating gender: "${gender}"`)
    if (!['M', 'F'].includes(gender)) {
      logger.warn(`Row ${rowNum} has invalid gender: ${gender}`)
      return {
        isValid: false,
        error: `Invalid gender: ${gender}. Must be 'M' or 'F'`
      }
    }

    // Carrier validation with logging
    const carrierInput = (row['Current Carrier'] || row['currentCarrier'] || '').trim().toLowerCase()
    logger.info(`Validating carrier: "${carrierInput}"`)
    const standardizedCarrier = carrierMap.get(carrierInput) || carrierInput
    const wasCarrierConverted = !carrierMap.has(carrierInput)
    if (wasCarrierConverted) {
      logger.warn(`Row ${rowNum} has non-standard carrier: ${carrierInput} (will be kept as-is)`)
    }

    // Date validations with logging
    logger.info(`Validating effective date: "${row['Effective Date'] || row['effectiveDate']}"`)
    const effectiveDateResult = validateISODate(row['Effective Date'] || row['effectiveDate'], true)
    if (!effectiveDateResult.isValid) {
      logger.warn(`Row ${rowNum} has invalid effective date: ${row['Effective Date'] || row['effectiveDate']}`)
      return {
        isValid: false,
        error: `Invalid effective date format: ${row['Effective Date'] || row['effectiveDate']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
      }
    }

    logger.info(`Validating birth date: "${row['Birth Date'] || row['birthDate']}"`)
    const birthDateResult = validateISODate(row['Birth Date'] || row['birthDate'])
    if (!birthDateResult.isValid) {
      logger.warn(`Row ${rowNum} has invalid birth date: ${row['Birth Date'] || row['birthDate']}`)
      return {
        isValid: false,
        error: `Invalid birth date format: ${row['Birth Date'] || row['birthDate']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
      }
    }

    // If all validations pass, return processed data
    logger.info(`Row ${rowNum} passed all validations successfully`)
    return {
      isValid: true,
      value: {
        data: [
          (row['First Name'] || row['firstName'] || '').trim(),
          (row['Last Name'] || row['lastName'] || '').trim(),
          email,
          standardizedCarrier,
          (row['Plan Type'] || row['planType'] || '').trim(),
          effectiveDateResult.isoDate,
          birthDateResult.isoDate,
          ['yes', 'true', '1', 'y'].includes((row['Tobacco User'] || row['tobaccoUser'] || '').trim().toLowerCase()),
          gender,
          zipInfo.state,
          zipCode,
          phoneResult.standardized,
          null // agentId - will be set later
        ],
        carrierConverted: wasCarrierConverted ? {
          Row: rowNum,
          ...row,
          OriginalCarrier: row['Current Carrier'] || row['currentCarrier']
        } : null
      }
    }
  } catch (e) {
    // Log the full error details
    logger.error(`Unexpected error in row ${rowNum}:`)
    logger.error(`Error message: ${e instanceof Error ? e.message : String(e)}`)
    logger.error(`Row data: ${JSON.stringify(row)}`)
    if (e instanceof Error && e.stack) {
      logger.error(`Stack trace: ${e.stack}`)
    }
    return {
      isValid: false,
      error: `Unexpected error processing row ${rowNum}. Please check all fields are in the correct format. Error: ${e instanceof Error ? e.message : String(e)}`
    }
  }
};

const startServer = async () => {
  try {
    // Log environment information at startup
    logger.info(`Environment: NODE_ENV = "${process.env.NODE_ENV}"`)
    logger.info(`Current working directory: ${process.cwd()}`)
    logger.info(`Is production mode: ${process.env.NODE_ENV === 'production'}`)
    
    // Log available environment variables (without values for security)
    logger.info(`Available environment variables: ${Object.keys(process.env).join(', ')}`)
    
    // Try loading directly from process.env
    if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
      logger.warn('Critical environment variables missing. Check Replit Secrets are properly set:')
      logger.warn('Required: TURSO_DATABASE_URL, TURSO_AUTH_TOKEN')
      logger.warn('Available env vars: ' + Object.keys(process.env).join(', '))
    } else {
      logger.info('Required environment variables found')
    }
    
    const db = new Database()
    logger.info('Database initialized successfully')

    const app = new Elysia()
      .use(cors({
        // In development, allow the Vite dev server origin
        origin: process.env.NODE_ENV === 'development' 
          ? 'http://localhost:5173'
          : false, // Disable CORS in production
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Cookie'],  // Add Cookie to allowed headers
        credentials: true,
        preflight: true
      }))
      // Add explicit OPTIONS handler for preflight
      .options('/api/contacts/:id', ({ set }) => {
        set.headers = {
          'Access-Control-Allow-Origin': 'http://localhost:5173',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Allow-Credentials': 'true'
        }
        return new Response(null, { status: 204 })
      })
      // Log all requests
      .onRequest(({ request: { method, url, headers } }) => {
        const path = new URL(url).pathname
        logger.info(`⮕ ${method} ${path}`)
      })
      // Log all responses
      .onResponse((context) => {
        const { request: { method }, path, set } = context
        logger.info(`⬅ ${method} ${path} ${set.status}`)
      })
      // Enhanced error handling
      .onError(({ code, error, request }: {
        code: string;
        error: Error;
        request: { url: string; method: string };
      }) => {
        const path = new URL(request.url).pathname
        const errorMessage = `❌ ${request.method} ${path} - ${error.message}`
        logger.error(errorMessage)

        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), { 
          status: code === 'NOT_FOUND' ? 404 : 500,
          headers: {
            'Content-Type': 'application/json'
          }
        })
      })
      // Add health check endpoint
      .get('/health', () => ({ status: 'OK' }))
      // GET /api/contacts is now handled by the contactsRoutes module
      .get('/api/contacts/check-email/:email', async ({ params: { email }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          const result = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          return {
            exists: result !== null
          }
        } catch (e) {
          logger.error(`Error checking email existence: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/:id', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id} - Fetching contact for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Fetch the contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            logger.info(`GET /api/contacts/${id} - Contact not found`)
            return new Response('Contact not found', { status: 404 })
          }

          // Return the contact with mapped fields
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error fetching contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .post('/api/contacts', async ({ body, request }: { body: ContactCreate, request: Request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contact = body
          logger.info(`Attempting to create contact for org ${user.organization_id}: ${contact.first_name} ${contact.last_name}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Check for existing email
          const existingContact = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [contact.email]
          )

          if (existingContact) {
            throw new Error('A contact with this email already exists')
          }
          
          const query = `
            INSERT INTO contacts (
              first_name, last_name, email, current_carrier, plan_type,
              effective_date, birth_date, tobacco_user, gender,
              state, zip_code, agent_id, phone_number
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `
          
          const params = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            contact.state,
            contact.zip_code,
            contact.agent_id || null,
            contact.phone_number || ''
          ]

          logger.info(`Executing query with params: ${JSON.stringify(params)}`)
          await orgDb.execute(query, params)

          // Fetch the newly created contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE email = ? ORDER BY id DESC LIMIT 1',
            [contact.email]
          )

          if (!result) {
            throw new Error('Failed to fetch created contact')
          }

          // Match response format to schema
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error creating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .put('/api/contacts/:id', async ({ params: { id }, body, request }: { body: ContactCreate, request: Request }) => {
        try {
          // Get user and org info
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          const contact = body as ContactCreate
          logger.info(`PUT /api/contacts/${id} - Updating contact for org ${user.organization_id}`)

          // Get state from ZIP code
          const zipInfo = ZIP_DATA[contact.zip_code]
          if (!zipInfo) {
            throw new Error(`Invalid ZIP code: ${contact.zip_code}`)
          }

          // First update the contact
          const updateQuery = /* sql */ `
            UPDATE contacts SET 
              first_name = ?,
              last_name = ?,
              email = ?,
              current_carrier = ?,
              plan_type = ?,
              effective_date = ?,
              birth_date = ?,
              tobacco_user = ?,
              gender = ?,
              state = ?,
              zip_code = ?,
              phone_number = ?
            WHERE id = ?
          `

          const updateParams = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            zipInfo.state, // Use state from ZIP code
            contact.zip_code,
            contact.phone_number || '',
            id
          ]

          // Execute the update
          await orgDb.execute(updateQuery, updateParams)

          // Then fetch the updated contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            throw new Error(`Contact ${id} not found after update`)
          }

          logger.info(`Successfully updated contact ${id} in org ${user.organization_id}`)

          // Return the updated contact
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number
          }
        } catch (e) {
          logger.error(`Error updating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add DELETE endpoint for contacts
      .delete('/api/contacts', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Parse contact IDs from the request
          const url = new URL(request.url)
          const ids = url.searchParams.get('ids')
          if (!ids) {
            throw new Error('No contact IDs provided')
          }

          const contactIds = ids.split(',').map(id => parseInt(id.trim(), 10))
          
          logger.info(`DELETE /api/contacts - Attempting to delete ${contactIds.length} contacts for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contactIds.map(() => '?').join(',')
          
          const query = `
            DELETE FROM contacts 
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const result = await orgDb.execute(query, contactIds)
          const deletedIds = result.rows?.map(row => row.id) || []

          logger.info(`DELETE /api/contacts - Successfully deleted ${deletedIds.length} contacts from org ${user.organization_id}`)

          return {
            success: true,
            deleted_ids: deletedIds,
            message: `Successfully deleted ${deletedIds.length} contacts`
          }
        } catch (e) {
          logger.error(`Error deleting contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add endpoint for reassigning contacts to a different agent
      .put('/api/contacts/reassign', async ({ request, body }: { request: Request, body: { contact_ids: number[], agent_id: number | null } }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const { contact_ids, agent_id } = body
          if (!contact_ids || !Array.isArray(contact_ids) || contact_ids.length === 0) {
            throw new Error('Invalid or empty contact_ids array')
          }

          logger.info(`PUT /api/contacts/reassign - Reassigning ${contact_ids.length} contacts to agent ${agent_id} for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contact_ids.map(() => '?').join(',')
          
          const query = `
            UPDATE contacts 
            SET agent_id = ?
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const params = [agent_id, ...contact_ids]
          const result = await orgDb.execute(query, params)
          const updatedIds = result.rows?.map(row => row.id) || []

          logger.info(`PUT /api/contacts/reassign - Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`)

            return {
            success: true,
            updated_ids: updatedIds,
            message: `Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`
          }
        } catch (e) {
          logger.error(`Error reassigning contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add file upload endpoint
      .post('/api/contacts/upload', async ({ request, body, set }: { request: Request, body: { file: File, overwrite_duplicates?: boolean | string, duplicateStrategy?: string, agent_id?: string }, set: any }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Extract file and overwrite flag from form data
          const formData = body
          const file = formData.file
          
          // Support both naming conventions - overwrite_duplicates (old) and duplicateStrategy (new)
          let overwriteDuplicates = false
          if (formData.overwrite_duplicates !== undefined) {
            // Convert string 'false'/'true' to boolean
            overwriteDuplicates = formData.overwrite_duplicates === 'true' || formData.overwrite_duplicates === true
          } else if (formData.duplicateStrategy !== undefined) {
            // Support the new 'duplicateStrategy' parameter
            overwriteDuplicates = formData.duplicateStrategy === 'overwrite'
          }

          logger.info(`Processing ${file.name} with overwriteDuplicates=${overwriteDuplicates}`)

          // Save file to temp directory
          const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'import-'));
          const tempFilePath = path.join(tempDir, 'contacts.csv');
          await fs.writeFile(tempFilePath, Buffer.from(await file.arrayBuffer()));

          logger.info(`CSV file saved to ${tempFilePath}, starting import`);

          // Start bulk import process
          const importPromise = Database.bulkImportContacts(
            user.organization_id.toString(),
            tempFilePath,
            overwriteDuplicates
          );

          importPromise
            .then(() => fs.rm(tempDir, { recursive: true, force: true }))
            .catch((error: Error) => {
              logger.error(`Background import failed: ${error}`);
              fs.rm(tempDir, { recursive: true, force: true }).catch(() => {});
            });

          return {
            success: true,
            message: 'Started import of contacts',
            errors: []
          };
        } catch (error) {
          const err = error as Error;
          logger.error(`Error processing CSV upload: ${err}`);
          throw err;
        }
      })
      // Add error handler
      .use(errorHandler)
      // Add explicit debug log for auth routes
      .use(app => {
        logger.info('Registering auth routes...')
        return app.use(createAuthRoutes())
      })
      // Add settings routes
      .use(settingsRoutes)
      // Add organization routes
      .use(organizationRoutes)
      // Add brand routes
      .use(createBrandRoutes())
      // Add quotes routes
      .use(quotesRoutes)
      // Add Stripe routes
      .use(createStripeRoutes())
      // Add onboarding routes
      .use(createOnboardingRoutes())
      // Add eligibility routes
      .use(eligibilityRoutes)
      // Add self-service routes
      .use(createSelfServiceRoutes())
      // Add schedule routes
      .use(scheduleRoutes)
      // Add contacts routes
      .use(contactsRoutes)
      // Serve backend static files from public directory
      .use(staticPlugin({
        assets: './public', 
        prefix: '/'
      }))
      // In production, serve the frontend static files
      .use(process.env.NODE_ENV === 'production' 
        ? async (app) => {
            logger.info(`[Static Files] Running in production mode: NODE_ENV = "${process.env.NODE_ENV}"`)
            const distPath = join(process.cwd(), '../dist');
            logger.info(`[Static Files] Serving from: ${distPath} (exists: ${existsSync(distPath)})`);
            
            // List directory contents for debugging
            try {
              const fs = require('fs');
              const distContents = fs.readdirSync(distPath);
              logger.info(`[Static Files] dist directory contents: ${JSON.stringify(distContents)}`);
              
              // Check if index.html exists
              const indexPath = join(distPath, 'index.html');
              logger.info(`[Static Files] index.html path: ${indexPath} (exists: ${existsSync(indexPath)})`);
              
              // If it exists, log its contents for debugging
              if (existsSync(indexPath)) {
                const indexContent = fs.readFileSync(indexPath, 'utf-8');
                logger.info(`[Static Files] index.html first 100 chars: ${indexContent.substring(0, 100)}...`);
              }
            } catch (error) {
              logger.error(`[Static Files] Error inspecting dist directory: ${error}`);
            }
            
            // Try different approach for static files
            app.get('/*', async ({ request }) => {
              const url = new URL(request.url);
              const path = url.pathname;
              
              logger.info(`[Static Route Handler] Handling request for: ${path}`);
              
              // Skip API routes
              if (path.startsWith('/api/')) {
                logger.info(`[Static Route Handler] Skipping API route: ${path}`);
                return;
              }
              
              // Try to serve the file directly from dist directory
              try {
                const filePath = join(distPath, path === '/' ? 'index.html' : path.slice(1));
                logger.info(`[Static Route Handler] Trying file path: ${filePath} (exists: ${existsSync(filePath)})`);
                
                if (existsSync(filePath)) {
                  logger.info(`[Static Route Handler] File exists, serving: ${filePath}`);
                  const ext = filePath.substring(filePath.lastIndexOf('.') + 1);
                  const mimeTypes: Record<string, string> = {
                    'html': 'text/html',
                    'js': 'application/javascript',
                    'css': 'text/css',
                    'json': 'application/json',
                    'png': 'image/png',
                    'jpg': 'image/jpeg',
                    'svg': 'image/svg+xml',
                    'ico': 'image/x-icon',
                    'csv': 'text/csv',
                  };
                  
                  return new Response(Bun.file(filePath), {
                    headers: { 'Content-Type': mimeTypes[ext] || 'application/octet-stream' }
                  });
                } else if (path !== '/' && !path.includes('.')) {
                  // This is likely a SPA route, serve index.html
                  logger.info(`[Static Route Handler] Likely SPA route, serving index.html for: ${path}`);
                  return new Response(Bun.file(join(distPath, 'index.html')), {
                    headers: { 'Content-Type': 'text/html' }
                  });
                } else if (path === '/') {
                  // Explicitly handle root path
                  logger.info(`[Static Route Handler] Handling root path, serving index.html`);
                  const indexPath = join(distPath, 'index.html');
                  
                  if (existsSync(indexPath)) {
                    logger.info(`[Static Route Handler] Root: index.html exists, serving it`);
                    return new Response(Bun.file(indexPath), {
                      headers: { 'Content-Type': 'text/html' }
                    });
                  } else {
                    logger.error(`[Static Route Handler] Root: index.html doesn't exist at ${indexPath}`);
                    return new Response('index.html not found', { status: 404 });
                  }
                }
                
                // If we get here, the file doesn't exist
                logger.warn(`[Static Route Handler] No matching file found for: ${path}`);
                return new Response('Not found', { status: 404 });
              } catch (error) {
                logger.error(`[Static Route Handler] Error serving file for ${path}: ${error}`);
                return new Response(`Server error: ${error}`, { status: 500 });
              }
            });

            return app;
          }
        : (app) => app
      )
      // Add this endpoint within the app definition
      .post('/api/agents', async ({ body, request, set }) => {
        try {
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent: ${newAgent.email} (org: ${currentUser.organization_id})`)

          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Check if the organization has reached its agent limit
          const orgLimitResult = await client.execute({
            sql: `
              SELECT 
                o.agent_limit, 
                COUNT(u.id) as current_agent_count
              FROM 
                organizations o
              LEFT JOIN 
                users u ON o.id = u.organization_id AND (u.is_agent = 1 OR u.is_admin = 1) AND u.is_active = 1
              WHERE 
                o.id = ?
              GROUP BY 
                o.id
            `,
            args: [currentUser.organization_id]
          })
          
          if (orgLimitResult.rows.length > 0) {
            const { agent_limit, current_agent_count } = orgLimitResult.rows[0]
            
            if (Number(current_agent_count) >= Number(agent_limit)) {
              logger.warn(`Organization ${currentUser.organization_id} has reached its agent limit (${agent_limit}). Cannot create new agent.`)
              set.status = 403
              return {
                success: false,
                error: `You have reached your plan's agent limit (${agent_limit}). Please upgrade your plan to add more agents.`
              }
            }
            
            logger.info(`Organization has ${current_agent_count}/${agent_limit} agents (before adding new agent)`)
          }
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add an alias endpoint for POST /api/agents/create to match frontend expectations
      .post('/api/agents/create', async ({ body, request, set }) => {
        try {
          // Log the request to the alias endpoint
          logger.info(`POST /api/agents/create - Using the same implementation as /api/agents`)
          
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent via /api/agents/create: ${newAgent.email} (org: ${currentUser.organization_id})`)
          
          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent via /api/agents/create: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add this GET endpoint within the app definition, near the POST /api/agents endpoint
      .get('/api/agents', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Remove admin check - allow any authenticated user to fetch agents for their organization
          // All users should be able to see the agent list for assignment purposes
          logger.info(`GET /api/agents - Fetching agents for org ${currentUser.organization_id}`)

          // Get the libSQL client
          const client = db.getClient()

          // Fetch all agents (users) from the organization along with their settings
          const result = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.first_name,
                u.last_name,
                u.email,
                u.phone,
                u.is_admin,
                u.is_agent,
                a.settings
              FROM users u
              LEFT JOIN agent_settings a ON u.id = a.agent_id
              WHERE u.organization_id = ?
              AND u.is_active = 1
              ORDER BY u.first_name, u.last_name
            `,
            args: [currentUser.organization_id]
          })

          logger.info(`GET /api/agents - Found ${result.rows.length} agents`)

          // Map the database results to the expected format with camelCase field names
          const agents = result.rows.map((row: any) => {
            const settings = row.settings ? JSON.parse(row.settings) : {
              stateLicenses: [],
              carrierContracts: [],
              stateCarrierSettings: []
            }

            return {
              id: String(row.id),
              firstName: row.first_name,
              lastName: row.last_name,
              email: row.email,
              phone: row.phone || '',
              isAdmin: Boolean(row.is_admin),
              isAgent: Boolean(row.is_agent),
              carriers: settings.carrierContracts || [],
              stateLicenses: settings.stateLicenses || []
            }
          })

          logger.info(`GET /api/agents - Returning ${agents.length} agents`)
          return agents

        } catch (e) {
          logger.error(`Error fetching agents: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Update PUT endpoint for updating agent details - moved here to be with other agent endpoints
      .put('/api/agents/:id', async ({ params, body, request, set }: {
        params: { id: string },
        body: AgentUpdate,
        request: Request,
        set: any
      }) => {
        console.log('DEBUG: PUT handler hit', { params, path: request.url })
        logger.info(`Starting update for agent ${params.id}`)
        logger.info(`Request body: ${JSON.stringify(body, null, 2)}`)
        
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            logger.error('Authentication failed: No user in session')
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Allow users to update their own details or admins to update any agent
          if (!currentUser.is_admin && currentUser.id.toString() !== params.id) {
            logger.error(`Authorization failed: User ${currentUser.id} is not an admin and trying to update another user`)
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can update other agents'
            }
          }
          
          // Security protection: NEVER allow ANY user to remove their own admin status,
          // even if they are an admin themselves
          if (currentUser.id.toString() === params.id) {
            // If this is a self-update and user is trying to change admin status
            if (body.is_admin !== Boolean(currentUser.is_admin)) {
              // If they're trying to REMOVE admin status
              if (Boolean(currentUser.is_admin) && !body.is_admin) {
                logger.warn(`Security protection: Admin user ${currentUser.id} attempted to remove their own admin status`)
                // Prevent admin from removing their own admin status - keep it as is
                body.is_admin = true;
              }
              // Note: We still allow non-admins to be promoted by an admin
            }
          }

          const agent = body
          logger.info(`Updating agent ${params.id} - Name: ${agent.firstName} ${agent.lastName}, Phone: ${agent.phone}`)

          // Get the libSQL client
          const client = db.getClient()

          // Determine if this is a self-update by a non-admin
          const isSelfUpdate = currentUser.id.toString() === params.id && !currentUser.is_admin
          
          // Create dynamic SQL that excludes is_admin for self-updates
          let sql, args
          if (isSelfUpdate) {
            // For self-updates, exclude is_admin from the update
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
            logger.info(`Self-update detected: excluding admin status from update for user ${params.id}`)
          } else {
            // For admin updates or other users, include all fields
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      is_admin = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.is_admin ? 1 : 0,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
          }

          // Execute the update with the appropriate SQL and args
          const userUpdateResult = await client.execute({
            sql,
            args
          })

          logger.info(`User update result: ${JSON.stringify(userUpdateResult.rows, null, 2)}`)

          if (!userUpdateResult.rows || userUpdateResult.rows.length === 0) {
            logger.error('User update failed: No rows affected')
            throw new Error('User update failed - no rows affected')
          }

          logger.info('User details updated successfully')

          // Update agent settings
          const settings = {
            stateLicenses: agent.stateLicenses,
            carrierContracts: agent.carriers,
            stateCarrierSettings: [],
            emailSendBirthday: false,
            emailSendPolicyAnniversary: false,
            emailSendAep: false,
            smartSendEnabled: false
          }

          logger.info(`Agent settings to update: ${JSON.stringify(settings, null, 2)}`)

          const settingsUpdateResult = await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)
            ON CONFLICT (agent_id) 
            DO UPDATE SET settings = EXCLUDED.settings
            RETURNING *`,
            args: [
              params.id,
              JSON.stringify(settings)
            ]
          })

          logger.info(`Settings update result: ${JSON.stringify(settingsUpdateResult.rows, null, 2)}`)

          if (!settingsUpdateResult.rows || settingsUpdateResult.rows.length === 0) {
            logger.error('Settings update failed: No rows affected')
            throw new Error('Settings update failed - no rows affected')
          }

          logger.info('Settings updated successfully')

          const updatedUser = userUpdateResult.rows[0]
          const updatedSettings = JSON.parse(settingsUpdateResult.rows[0].settings)

          return {
            success: true,
            message: 'Agent updated successfully',
            agent: {
              id: updatedUser.id.toString(),
              firstName: updatedUser.first_name,
              lastName: updatedUser.last_name,
              email: updatedUser.email,
              phone: updatedUser.phone || '',
              is_admin: Boolean(updatedUser.is_admin),
              is_agent: Boolean(updatedUser.is_agent),
              carriers: updatedSettings.carrierContracts,
              stateLicenses: updatedSettings.stateLicenses
            }
          }

        } catch (error: unknown) {
          const dbError = error as Error
          logger.error(`Database error: ${dbError.message}`)
          set.status = 500
          return {
            success: false,
            error: dbError.message
          }
        }
      })
      // Add DELETE endpoint for agent deletion with contact reassignment
      .delete('/api/agents/:id', async ({ params, request, set, query }: {
        params: { id: string },
        request: Request,
        set: any,
        query: { reassignTo?: string }
      }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Only admins can delete agents
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can delete agents'
            }
          }

          const agentId = params.id
          
          // Prevent users from deleting themselves
          if (String(currentUser.id) === agentId) {
            set.status = 403
            return {
              success: false,
              error: 'You cannot delete your own account'
            }
          }
          
          const reassignToAgentId = query.reassignTo

          // Get the main database client for user/agent operations
          const client = db.getClient()

          // Also get the organization-specific database for contact operations
          const orgDb = await Database.getOrgDb(currentUser.organization_id.toString())

          // First handle contact operations in org database
          try {
            // Using the transaction method instead of direct SQL commands
            await orgDb.transaction(async (orgTx) => {
            // If reassignToAgentId is provided, reassign contacts to the new agent
            if (reassignToAgentId && reassignToAgentId !== agentId) {
              logger.info(`Reassigning contacts from agent ${agentId} to agent ${reassignToAgentId}`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = ?
                   WHERE agent_id = ?`,
                  [reassignToAgentId, agentId]
                )
            } else {
              // Set agent_id to NULL for contacts associated with this agent
              logger.info(`Setting contacts from agent ${agentId} to have no assigned agent`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = NULL
                   WHERE agent_id = ?`,
                  [agentId]
                )
              }
            })
            
            logger.info(`Successfully updated contacts for agent ${agentId}`)
            
            // Now handle agent operations in the main database
            await db.transaction(async (tx) => {
              // First, check if the user has any other related records that need to be deleted

            // Delete agent's settings
              await tx.execute(
                `DELETE FROM agent_settings
                 WHERE agent_id = ?`,
                [agentId]
              )
              
              // Check for any related records in other tables that might reference this user
              // For example, delete from sessions table if it exists
              await tx.execute(
                `DELETE FROM sessions
                 WHERE user_id = ?`,
                [agentId]
              )
              
              // IMPORTANT: Add any other related tables that might have foreign keys to users
              
              // Finally, completely delete the user record instead of just marking as inactive
              await tx.execute(
                `DELETE FROM users
                 WHERE id = ?`,
                [agentId]
              )
            })
            
            logger.info(`Successfully deleted agent ${agentId}`)

            return {
              success: true,
              message: 'Agent deleted successfully'
            }
          } catch (error) {
            logger.error(`Error in agent deletion: ${error}`)
            throw error;
          }
        } catch (e) {
          logger.error(`Error deleting agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: 'An error occurred while deleting the agent'
          }
        }
      })
      // Add this endpoint within the app definition
      .get('/api/me', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          logger.info(`GET /api/me - Current user from session: ${JSON.stringify(currentUser)}`)
          
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          // Get user details including agent settings if they exist
          const client = db.getClient()
          const userDetails = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.email,
                u.first_name as firstName,
                u.last_name as lastName,
                u.is_admin,
                u.is_agent,
                u.phone,
                u.organization_id,
                o.slug as organization_slug,
                o.subscription_tier,
                a.settings as agentSettings
              FROM users u
              JOIN organizations o ON u.organization_id = o.id
              LEFT JOIN agent_settings a ON a.agent_id = u.id
              WHERE u.id = ?
            `,
            args: [currentUser.id]
          })

          logger.info(`GET /api/me - Raw user details from DB: (omitted)`)

          if (!userDetails.rows[0]) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          const user = userDetails.rows[0]
          const response = {
            success: true,
            user: {
              id: user.id,
              email: user.email,
              firstName: user.firstName,
              lastName: user.lastName,
              is_admin: Boolean(user.is_admin),
              is_agent: Boolean(user.is_agent),
              phone: user.phone || '',
              organization_id: user.organization_id,
              organization_slug: user.organization_slug,
              subscription_tier: user.subscription_tier,
              agentSettings: user.agentSettings ? JSON.parse(user.agentSettings) : null
            }
          }
          logger.info(`GET /api/me - Sending response`)
          return response

        } catch (e) {
          logger.error(`Error fetching current user: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/:redirect', async ({ params, set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for redirect to: ${params.redirect}`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`

          // Handle redirect
          const redirectPath = params.redirect === 'add-agent' ? 'agents/add' : params.redirect
          set.redirect = `/${redirectPath}`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/login', async ({ set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for login page`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add ZIP lookup endpoint
      .get('/api/zip-lookup/:zipCode', ({ params: { zipCode } }) => {
        try {
          const zipInfo = ZIP_DATA[zipCode]
          if (!zipInfo) {
            return {
              success: false,
              error: `Invalid ZIP code: ${zipCode}`
            }
          }
          return {
            success: true,
            ...zipInfo
          }
        } catch (e) {
          logger.error(`Error looking up ZIP code ${zipCode}: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      
      // Send quote email to contact
      .post('/api/contacts/:contactId/send-quote-email', async ({ params, request, body }) => {
        try {
          const user = await getUserFromSession(request);
          if (!user) {
            return {
              success: false,
              message: 'Authentication required'
            };
          }

          const contactId = Number(params.contactId);
          if (isNaN(contactId)) {
            return {
              success: false,
              message: 'Invalid contact ID'
            };
          }

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString());

          // Fetch contact details
          const contact = await orgDb.fetchOne<{id: number, first_name: string, last_name: string, email: string, plan_type: string}>(
            'SELECT id, first_name, last_name, email, plan_type FROM contacts WHERE id = ?',
            [contactId]
          );

          if (!contact) {
            return {
              success: false,
              message: 'Contact not found'
            };
          }

          // Use the proper generateQuoteId function
          const quoteId = generateQuoteId(user.organization_id, contactId);
          
          // Calculate base URL
          const baseUrl = process.env.PUBLIC_URL || 'http://localhost:5173';
          let quoteUrl = `${baseUrl}/quote?id=${quoteId}&planType=${contact.plan_type}`;

          // Add organization ID to URL
          quoteUrl += `&orgId=${user.organization_id}`;

          // Send the email via SendGrid
          const emailService = new EmailService();
          await emailService.sendQuoteEmail({
            email: contact.email,
            firstName: contact.first_name,
            lastName: contact.last_name,
            quoteUrl,
            planType: contact.plan_type
          });

          // Update last_emailed timestamp
          await orgDb.execute(
            'UPDATE contacts SET last_emailed = CURRENT_TIMESTAMP WHERE id = ?',
            [contactId]
          );

          return {
            success: true,
            message: 'Quote email sent successfully'
          };
        } catch (error) {
          logger.error(`Error sending quote email: ${error}`);
          return {
            success: false,
            message: 'Failed to send quote email',
            error: String(error)
          };
        }
      })
      
      .post('/api/contact-request', async ({ body, request }: { body: { name: string; email: string; type: string; quoteId?: string }, request: Request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contactRequest = body as { name: string, email: string, type: string, quoteId: string }
          const { name, email, type, quoteId } = contactRequest
          logger.info(`Processing contact request for ${email} (type: ${type})`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Check for existing contact
          const existingContact = await orgDb.fetchOne<{ id: number }>(
            'SELECT id FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          let eventTargetId: number
          let isLead = false

          if (existingContact) {
            // Use existing contact
            logger.info(`Found existing contact with ID ${existingContact.id}`)
            eventTargetId = existingContact.id
          } else {
            // Create new lead
            logger.info(`No existing contact found, creating lead for ${email}`)
            const leadResult = await orgDb.execute(
              `INSERT INTO leads (name, email) VALUES (?, ?) RETURNING id`,
              [name, email]
            )
            
            if (!leadResult.rows?.[0]?.id) {
              throw new Error('Failed to create lead')
            }
            
            eventTargetId = leadResult.rows[0].id
            isLead = true
          }

          // Record the event
          const metadata = {
            quoteId,
            requestType: type
          }

          const eventQuery = isLead
            ? `INSERT INTO contact_events (lead_id, event_type, metadata) VALUES (?, 'followup_request', ?)`
            : `INSERT INTO contact_events (contact_id, event_type, metadata) VALUES (?, 'followup_request', ?)`

          await orgDb.execute(eventQuery, [eventTargetId, JSON.stringify(metadata)])
          logger.info(`Recorded followup request event for ${isLead ? 'lead' : 'contact'} ${eventTargetId}`)

          // Return success response
          return {
            success: true,
            message: 'Contact request recorded successfully'
          }

        } catch (e: unknown) {
          logger.error(`Error processing contact request: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      .get('/api/contacts/:id/eligibility', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/eligibility - Fetching eligibility results`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get most recent eligibility answers for this contact
          const result = await orgDb.fetchOne(
            `SELECT answers 
             FROM eligibility_answers 
             WHERE contact_id = ? 
             ORDER BY created_at DESC 
             LIMIT 1`,
            [id]
          ) as { answers: string } | null

          if (!result) {
            return {
              status: "incomplete",
              answers: null
            }
          }

          // Parse answers JSON and determine status
          const answers = JSON.parse(result.answers)
          const allTrue = Object.values(answers).every(value => value === true)

          return {
            status: allTrue ? "pass" : "flagged",
            answers: result.answers  // Return the raw JSON string instead of the parsed object
          }

        } catch (e) {
          logger.error(`Error fetching eligibility results: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add new endpoint to get follow-up requests
      .get('/api/contacts/:id/follow-ups', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/follow-ups - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get follow-up requests from contact_events table
          const result = await orgDb.execute(
            `SELECT 
              event_type,
              metadata,
              created_at
             FROM contact_events 
             WHERE contact_id = ? 
               AND event_type = 'followup_request'
             ORDER BY created_at DESC`,
            [id]
          )

          // Map results to a more friendly format
          const followUps = result.rows?.map((row: { metadata: string, created_at: string }) => {
            const metadata = JSON.parse(row.metadata)
            return {
              type: metadata.requestType,
              quoteId: metadata.quoteId,
              createdAt: row.created_at
            }
          }) || []

          return followUps

        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      // Add profile update endpoint
      .put('/api/profile', async ({ request, body, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          const { firstName, lastName, phone } = body as { 
            firstName: string;
            lastName: string;
            phone: string;
          }

          // Get the libSQL client
          const client = db.getClient()

          // Update only allowed profile fields
          const result = await client.execute({
            sql: `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      phone = ?
                  WHERE id = ?
                  RETURNING *`,
            args: [firstName, lastName, phone, currentUser.id]
          })

          if (!result.rows || result.rows.length === 0) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          return {
            success: true,
            message: 'Profile updated successfully'
          }

        } catch (error) {
          logger.error(`Error updating profile: ${error}`)
          set.status = 500
          return {
            success: false,
            error: String(error)
          }
        }
      })
      .get('/api/agents/:id/contacts', async ({ params, request }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser?.organization_id) {
            throw new Error('No organization ID found in session')
          }
          
          logger.info(`GET /api/agents/${params.id}/contacts - Fetching contacts for agent ${params.id}`)
          
          // Get organization-specific database
          const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())
          
          // Fetch all contacts for the agent
          const result = await orgDb.fetchAll('SELECT * FROM contacts WHERE agent_id = ?', [params.id])
          
          logger.info(`GET /api/agents/${params.id}/contacts - Found ${result.length} contacts`)
          
          // Map the database results to the expected format with camelCase field names
          const contacts = result.map((contact: { 
            id: number;
            first_name: string;
            last_name: string;
            email: string;
            current_carrier: string;
            plan_type: string;
            effective_date: string;
            birth_date: string;
            tobacco_user: number;
            gender: string;
            state: string;
            zip_code: string;
            agent_id: number | null;
            last_emailed: string | null;
            phone_number: string;
          }) => ({
            id: contact.id,
            first_name: contact.first_name,
            last_name: contact.last_name,
            email: contact.email,
            current_carrier: contact.current_carrier,
            plan_type: contact.plan_type,
            effective_date: contact.effective_date,
            birth_date: contact.birth_date,
            tobacco_user: Boolean(contact.tobacco_user),
            gender: contact.gender,
            state: contact.state,
            zip_code: contact.zip_code,
            agent_id: contact.agent_id,
            last_emailed: contact.last_emailed,
            phone_number: contact.phone_number || ''
          }))
          
          return {
            success: true,
            contacts: contacts
          }
        } catch (e: unknown) {
          logger.error(`Error fetching contacts for agent ${params.id}: ${e instanceof Error ? e.message : String(e)}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .get('/api/contact-requests', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contact-requests - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Fetch all follow-up requests
          const result = await orgDb.fetchAll('SELECT * FROM contact_events WHERE event_type = ?', ['followup_request'])
          
          logger.info(`GET /api/contact-requests - Found ${result.length} follow-up requests`)
          
          // Map the database results to the expected format with camelCase field names
          const followUps = result.map(followUp => ({
            id: followUp.id,
            event_type: followUp.event_type,
            metadata: JSON.parse(followUp.metadata),
            created_at: followUp.created_at
          }))
          
          return {
            success: true,
            followUps: followUps
          }
        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .get('/api/contacts/:id/follow-ups', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/follow-ups - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get follow-up requests from contact_events table
          const result = await orgDb.execute(
            `SELECT 
              event_type,
              metadata,
              created_at
             FROM contact_events 
             WHERE contact_id = ? 
               AND event_type = 'followup_request'
             ORDER BY created_at DESC`,
            [id]
          )

          // Map results to a more friendly format
          const followUps = result.rows?.map((row: { metadata: string, created_at: string }) => {
            const metadata = JSON.parse(row.metadata)
            return {
              type: metadata.requestType,
              quoteId: metadata.quoteId,
              createdAt: row.created_at
            }
          }) || []

          return followUps

        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      .listen(8000)

    logger.info('Server started on port 8000')

    // Schedule the cleanup job to run daily at midnight
    cron.schedule('0 0 * * *', () => {
      logger.info('Running scheduled cleanup job for old organizations');
      cleanupOldOrganizations().catch(error => {
        logger.error(`Error in scheduled cleanup job: ${error}`);
      });
    });
    
    logger.info('Scheduled daily cleanup job for old organizations');

    return app
  } catch (error) {
    logger.error(`Error starting server: ${error}`)
    throw error
  }
}

startServer()

================
File: src/logger.ts
================
export const logger = {
  info: (message: string) => {
    const timestamp = new Date().toISOString()
    console.log(`[${timestamp}] [INFO] ${message}`)
  },
  error: (message: string) => {
    const timestamp = new Date().toISOString()
    console.error(`[${timestamp}] [ERROR] ${message}`)
  },
  warn: (message: string) => {
    const timestamp = new Date().toISOString()
    console.warn(`[${timestamp}] [WARN] ${message}`)
  }
}

================
File: src/types.ts
================
export interface ContactCreate {
  first_name: string
  last_name: string
  email: string
  current_carrier: string
  plan_type: string
  effective_date: string
  birth_date: string
  tobacco_user: boolean
  gender: string
  state: string
  zip_code: string
  agent_id?: number | null
  phone_number: string
}

export interface AgentCreate {
  first_name: string
  last_name: string
  email: string
  phone: string
}

export interface User {
  id: number;
  email: string;
  organization_id: number;
  is_admin: boolean;
  is_agent: boolean;
  is_active: boolean;
  first_name: string;
  last_name: string;
  phone: string;
  organization_name?: string;
}



================================================================
End of Codebase
================================================================

This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.ts, **/*.elm
- Files matching these patterns are excluded: node_modules/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
scripts/
  add-agent.ts
  generateQuoteId.ts
  generateQuoteUrl.ts
  manage-recommendations.ts
  manage-turso.ts
src/
  config/
    turso.ts
  middleware/
    account-status.ts
    auth.ts
    error.ts
  routes/
    admin-portal.ts
    admin.ts
    auth.ts
    brand.ts
    contacts.ts
    eligibility.ts
    onboarding.ts
    organizations.ts
    quotes.ts
    self-service.ts
    settings.ts
    stripe.ts
  services/
    agentSettings.ts
    auth.ts
    email.ts
    stripe.ts
    subscription.ts
    turso.ts
  utils/
    quoteId.ts
  config.ts
  database.ts
  errors.ts
  index.ts
  logger.ts
  types.ts

================================================================
Files
================================================================

================
File: scripts/add-agent.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for agent data
const AgentSchema = z.object({
  first_name: z.string().min(1),
  last_name: z.string().min(1),
  email: z.string().email(),
  phone: z.string().min(1),
  organization_id: z.number(),
});

async function main() {
  p.intro(chalk.green('✨ Interactive Agent Creation Tool ✨'));

  const db = new Database();

  // Get all organizations
  const orgs = await db.fetchAll<{ id: number; name: string }>('SELECT id, name FROM organizations');
  
  if (orgs.length === 0) {
    p.outro(chalk.red('No organizations found. Please create an organization first.'));
    exit(1);
  }

  // Gather information
  const firstName = await p.text({
    message: 'Enter agent first name:',
    validate: (value) => {
      if (value.length === 0) return 'First name cannot be empty';
    },
  });

  const lastName = await p.text({
    message: 'Enter agent last name:',
    validate: (value) => {
      if (value.length === 0) return 'Last name cannot be empty';
    },
  });

  const email = await p.text({
    message: 'Enter agent email:',
    validate: (value) => {
      if (!value.includes('@')) return 'Invalid email address';
    },
  });

  const phone = await p.text({
    message: 'Enter agent phone:',
    validate: (value) => {
      if (value.length === 0) return 'Phone cannot be empty';
    },
  });

  const organization = await p.select({
    message: 'Select organization:',
    options: orgs.map(org => ({
      value: org.id,
      label: org.name,
    })),
  });

  if (p.isCancel(firstName) || p.isCancel(lastName) || p.isCancel(email) || p.isCancel(phone) || p.isCancel(organization)) {
    p.outro(chalk.yellow('Operation cancelled'));
    exit(0);
  }

  try {
    // Validate data
    const agentData = AgentSchema.parse({
      first_name: firstName,
      last_name: lastName,
      email,
      phone,
      organization_id: organization,
    });

    // Start a transaction
    await db.execute('BEGIN TRANSACTION');

    try {
      // Insert into agents table
      await db.execute(
        `INSERT INTO agents (first_name, last_name, email, phone, organization_id)
         VALUES (?, ?, ?, ?, ?)`,
        [
          agentData.first_name,
          agentData.last_name,
          agentData.email,
          agentData.phone,
          agentData.organization_id
        ]
      );

      // Insert into users table
      await db.execute(
        `INSERT INTO users (email, organization_id, is_admin, is_agent, is_active)
         VALUES (?, ?, ?, ?, true)`,
        [agentData.email, agentData.organization_id, false, true]
      );

      // Commit the transaction
      await db.execute('COMMIT');

      p.outro(chalk.green('Agent created successfully! 🎉'));

    } catch (error) {
      // Rollback on error
      await db.execute('ROLLBACK');
      throw error;
    }

  } catch (error) {
    if (error instanceof z.ZodError) {
      p.outro(chalk.red(`Validation error: ${error.errors.map(e => e.message).join(', ')}`));
    } else {
      p.outro(chalk.red(`Error creating agent: ${error}`));
    }
    exit(1);
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/generateQuoteId.ts
================
import { generateQuoteId } from '../src/utils/quoteId';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteId.ts <orgId> <contactId>');
  process.exit(1);
}

// Generate quote ID
const quoteId = generateQuoteId(orgId, contactId);

// Output results
console.log('Generated Quote ID:', quoteId);
console.log('Quote URL:', `http://localhost:5173/quote?id=${quoteId}`);

================
File: scripts/generateQuoteUrl.ts
================
import axios, { AxiosError } from 'axios';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteUrl.ts <orgId> <contactId>');
  process.exit(1);
}

// Call the API to generate a quote ID
const generateQuoteUrl = async () => {
  try {
    // First get a session token
    const sessionResponse = await axios.get('http://localhost:8000/api/dev/session/login');
    
    // Then generate the quote ID
    const response = await axios.get(`http://localhost:8000/api/quotes/generate/${contactId}`, {
      headers: {
        Cookie: sessionResponse.headers['set-cookie']?.[0]
      }
    });

    if (response.data.success) {
      console.log('Quote ID:', response.data.quoteId);
      console.log('Quote URL:', response.data.redirectUrl);
    } else {
      console.error('Failed to generate quote ID:', response.data.error);
    }
  } catch (error) {
    if (error instanceof AxiosError) {
      console.error('Error:', error.response?.data || error.message);
    } else {
      console.error('Error:', error);
    }
  }
};

generateQuoteUrl();

================
File: scripts/manage-recommendations.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for GI recommendation data
const RecommendationSchema = z.object({
  state: z.string().length(2),
  carrier: z.string().min(1),
});

async function main() {
  p.intro(chalk.green('✨ Guaranteed Issue Recommendations Manager ✨'));

  const db = new Database();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all GI recommendations' },
        { value: 'add', label: 'Add new GI recommendation' },
        { value: 'remove', label: 'Remove GI recommendation' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listRecommendations(db);
          break;
        case 'add':
          await addRecommendation(db);
          break;
        case 'remove':
          await removeRecommendation(db);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listRecommendations(db: Database) {
  const results = await db.fetchAll<{ state: string; carrier: string; created_at: string }>(
    `SELECT state, carrier, created_at 
     FROM guaranteed_issue_recommendations 
     ORDER BY carrier, state`
  );

  if (results.length === 0) {
    p.note('No GI recommendations found', 'Empty');
    return;
  }

  const groupedByCarrier = results.reduce((acc, curr) => {
    if (!acc[curr.carrier]) {
      acc[curr.carrier] = [];
    }
    acc[curr.carrier].push(curr.state);
    return acc;
  }, {} as Record<string, string[]>);

  p.note(
    Object.entries(groupedByCarrier)
      .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
      .join('\n\n'),
    'Current GI Recommendations'
  );
}

async function addRecommendation(db: Database) {
  // Get available carriers first
  const carriers = await db.fetchAll<{ name: string }>(
    'SELECT name FROM carriers ORDER BY name'
  );

  if (carriers.length === 0) {
    p.note(chalk.red('No carriers found in database'));
    return;
  }

  const carrier = await p.select({
    message: 'Select carrier:',
    options: carriers.map(c => ({
      value: c.name,
      label: c.name,
    })),
  });

  if (p.isCancel(carrier)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const states = await p.text({
    message: 'Enter state codes (comma/space separated, e.g., TX CA FL):',
    validate: (value) => {
      const stateList = value.toUpperCase().split(/[\s,]+/).filter(Boolean);
      if (stateList.length === 0) return 'At least one state code is required';
      const invalidStates = stateList.filter(s => s.length !== 2);
      if (invalidStates.length > 0) {
        return `Invalid state codes: ${invalidStates.join(', ')}`;
      }
    },
  });

  if (p.isCancel(states)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const stateList = states.toUpperCase().split(/[\s,]+/).filter(Boolean);
  const results: { state: string; success: boolean; message: string }[] = [];

  for (const state of stateList) {
    try {
      const data = RecommendationSchema.parse({
        state,
        carrier,
      });

      // Check if recommendation already exists
      const existing = await db.fetchOne(
        'SELECT 1 FROM guaranteed_issue_recommendations WHERE state = ? AND carrier = ?',
        [data.state, data.carrier]
      );

      if (existing) {
        results.push({
          state: data.state,
          success: false,
          message: 'Already exists'
        });
        continue;
      }

      await db.execute(
        'INSERT INTO guaranteed_issue_recommendations (state, carrier) VALUES (?, ?)',
        [data.state, data.carrier]
      );

      results.push({
        state: data.state,
        success: true,
        message: 'Added successfully'
      });

    } catch (error) {
      results.push({
        state,
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Unknown error'
      });
    }
  }

  // Display results summary
  const successful = results.filter(r => r.success);
  const failed = results.filter(r => !r.success);

  if (successful.length > 0) {
    p.note(
      chalk.green(
        `Successfully added GI recommendations for ${carrier}:\n` +
        successful.map(r => `  ${r.state}`).join('\n')
      ),
      'Success'
    );
  }

  if (failed.length > 0) {
    p.note(
      chalk.yellow(
        `Failed to add some recommendations for ${carrier}:\n` +
        failed.map(r => `  ${r.state}: ${r.message}`).join('\n')
      ),
      'Warnings'
    );
  }
}

async function removeRecommendation(db: Database) {
  const recommendations = await db.fetchAll<{ id: number; state: string; carrier: string }>(
    'SELECT id, state, carrier FROM guaranteed_issue_recommendations ORDER BY carrier, state'
  );

  if (recommendations.length === 0) {
    p.note(chalk.yellow('No recommendations to remove'));
    return;
  }

  const selections = await p.multiselect({
    message: 'Select recommendations to remove (space to select/deselect):',
    options: recommendations
      .sort((a, b) => a.carrier.localeCompare(b.carrier) || a.state.localeCompare(b.state))
      .map(rec => ({
        value: rec.id.toString(),
        label: `${rec.carrier} - ${rec.state}`,
      })),
    required: true,
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const idsToRemove = (selections as string[]).map(Number);

  if (idsToRemove.length === 0) {
    p.note(chalk.yellow('No recommendations selected for removal'));
    return;
  }

  await db.execute(
    `DELETE FROM guaranteed_issue_recommendations WHERE id IN (${idsToRemove.join(',')})`,
  );

  const removedItems = recommendations
    .filter(r => idsToRemove.includes(r.id))
    .reduce((acc, curr) => {
      if (!acc[curr.carrier]) {
        acc[curr.carrier] = [];
      }
      acc[curr.carrier].push(curr.state);
      return acc;
    }, {} as Record<string, string[]>);

  p.note(
    chalk.green(
      'Successfully removed recommendations:\n\n' +
      Object.entries(removedItems)
        .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
        .join('\n\n')
    ),
    'Success'
  );
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/manage-turso.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';
import { TURSO_CONFIG } from '../src/config/turso';
import fetch from 'node-fetch';

interface Organization {
  id: number;
  name: string;
  turso_db_url: string | null;
}

class TursoManager {
  private headers = {
    'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
    'Content-Type': 'application/json'
  };

  async listLocations(): Promise<string[]> {
    const response = await fetch(`${TURSO_CONFIG.API_URL}/locations`, {
      headers: this.headers
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch locations: ${await response.text()}`);
    }

    const data = await response.json() as { locations: Array<{ name: string }> };
    return data.locations.map(l => l.name);
  }

  async listDatabases(): Promise<Array<{name: string, hostname: string}>> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`,
      { headers: this.headers }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch databases: ${await response.text()}`);
    }

    const data = await response.json() as { databases: Array<{Name: string, Hostname: string}> };
    return data.databases.map(db => ({
      name: db.Name,
      hostname: db.Hostname
    }));
  }

  async updateGroup(name: string, location: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/groups/${TURSO_CONFIG.GROUP_NAME}`,
      {
        method: 'PATCH',
        headers: this.headers,
        body: JSON.stringify({ name, location })
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to update group: ${await response.text()}`);
    }
  }

  async deleteDatabase(name: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${name}`,
      {
        method: 'DELETE',
        headers: this.headers
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete database: ${await response.text()}`);
    }
  }
}

async function main() {
  p.intro(chalk.green('✨ Turso Database Manager ✨'));

  const db = new Database();
  const turso = new TursoManager();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all databases and organizations' },
        { value: 'update-group', label: 'Update group configuration' },
        { value: 'delete-db', label: 'Delete a customer database' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listDatabasesAndOrgs(db, turso);
          break;
        case 'update-group':
          await updateGroupConfig(turso);
          break;
        case 'delete-db':
          await deleteCustomerDatabase(db, turso);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listDatabasesAndOrgs(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  const mappedDatabases = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      name: database.name,
      hostname: database.hostname,
      organization: org ? org[1] : 'Not associated with any organization'
    };
  });

  if (mappedDatabases.length === 0) {
    p.note('No databases found', 'Empty');
    return;
  }

  p.note(
    mappedDatabases
      .map(db => `${db.name}:\n  URL: ${db.hostname}\n  Organization: ${db.organization}`)
      .join('\n\n'),
    'Current Databases'
  );
}

async function updateGroupConfig(turso: TursoManager) {
  // Get available locations
  const locations = await turso.listLocations();

  p.note(
    `Current Configuration:\n` +
    `  Group Name: ${TURSO_CONFIG.GROUP_NAME}\n` +
    `  Location: ${TURSO_CONFIG.LOCATION}`,
    'Current Settings'
  );

  const newGroupName = await p.text({
    message: 'Enter new group name (or press enter to keep current):',
    initial: TURSO_CONFIG.GROUP_NAME,
  });

  if (p.isCancel(newGroupName)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const newLocation = await p.select({
    message: 'Select new location:',
    options: locations.map(loc => ({
      value: loc,
      label: loc,
    })),
    initialValue: TURSO_CONFIG.LOCATION,
  });

  if (p.isCancel(newLocation)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const confirm = await p.confirm({
    message: `Update group "${TURSO_CONFIG.GROUP_NAME}" to:\n` +
             `  Name: ${newGroupName}\n` +
             `  Location: ${newLocation}\n` +
             `Are you sure?`,
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  await turso.updateGroup(newGroupName, newLocation as string);
  
  p.note(
    chalk.green(
      `Successfully updated group configuration.\n` +
      `Remember to update TURSO_CONFIG in your code!`
    ),
    'Success'
  );
}

async function deleteCustomerDatabase(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  if (databases.length === 0) {
    p.note('No databases found to delete', 'Empty');
    return;
  }

  const options = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      value: database.name,
      label: `${database.name} (${org ? org[1] : 'Unassociated'})`,
    };
  });

  const selections = await p.multiselect({
    message: 'Select databases to delete (space to select, enter to confirm):',
    options,
    required: true
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const selectedDbs = selections as string[];
  if (selectedDbs.length === 0) {
    p.note(chalk.yellow('No databases selected'));
    return;
  }

  const confirm = await p.confirm({
    message: chalk.red(
      `Are you sure you want to delete the following databases?\n` +
      selectedDbs.map(db => `  - ${db}`).join('\n') +
      `\nThis action cannot be undone!`
    ),
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  for (const dbName of selectedDbs) {
    try {
      await turso.deleteDatabase(dbName);

      // Update organization record
      const org = orgs.find((o: any) => 
        o[2] && 
        o[2].toString().includes(
          databases.find(d => d.name === dbName)?.hostname || ''
        )
      );

      if (org) {
        await db.execute(
          'UPDATE organizations SET turso_db_url = NULL, turso_auth_token = NULL WHERE id = ?',
          [org[0]]
        );
      }

      p.note(
        chalk.green(`Successfully deleted database "${dbName}"`),
        'Success'
      );
    } catch (error) {
      p.note(
        chalk.red(`Failed to delete database "${dbName}": ${error}`),
        'Error'
      );
    }
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: src/config/turso.ts
================
export const TURSO_CONFIG = {
  API_URL: 'https://api.turso.tech/v1',
  API_TOKEN: process.env.TURSO_API_TOKEN, // Add this to your .env
  ORG_SLUG: 'pyrex41',
  GROUP_NAME: 'medicare-portal',
  LOCATION: 'aws-us-east-1' // We can update this to your preferred location
}

================
File: src/middleware/account-status.ts
================
import { Elysia } from 'elysia';
import { getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { Database } from '../database';

/**
 * Middleware to check if an organization's account is in good standing
 * This can be used on routes that should be blocked if the account has issues
 */
export const accountStatusMiddleware = new Elysia()
  .derive(async ({ request, set }) => {
    try {
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      if (!currentUser) {
        // If no user, let the auth middleware handle it
        return { accountStatus: null };
      }
      
      const db = new Database();
      
      // Query organization status from the view
      const statusResult = await db.query<{
        account_status: string;
        subscription_status: string;
      }>('SELECT account_status, subscription_status FROM organization_status WHERE id = ?', 
         [currentUser.organization_id]);
      
      if (!statusResult || statusResult.length === 0) {
        logger.error(`Could not find organization status for org ID: ${currentUser.organization_id}`);
        return { accountStatus: null };
      }
      
      const status = statusResult[0];
      
      // If account is not in good standing, block access to certain operations
      if (status.account_status !== 'good_standing') {
        logger.warn(`Blocked access due to account status: ${status.account_status} for org ${currentUser.organization_id}`);
        return { accountStatus: status.account_status, subscription_status: status.subscription_status };
      }
      
      // Account is in good standing
      return { accountStatus: 'good_standing' };
      
    } catch (error) {
      logger.error(`Error in account status middleware:`, error);
      return { accountStatus: null };
    }
  });

================
File: src/middleware/auth.ts
================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { Database } from '../database';

interface AuthenticatedRequest extends Request {
  user?: {
    id: number;
    email: string;
    organization_id: number;
    role: string;
    turso_db_url?: string;
    turso_auth_token?: string;
  };
}

export async function authMiddleware(
  req: AuthenticatedRequest, 
  res: Response, 
  next: NextFunction
) {
  try {
    // Verify JWT token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      res.status(401).json({ error: 'No token provided' });
      return;
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
      userId: number;
    };

    const db = new Database();

    // Get user with organization info from central DB
    const user = await db.execute(
      `SELECT u.*, o.turso_db_url, o.turso_auth_token
       FROM users u
       JOIN organizations o ON u.organization_id = o.id
       WHERE u.id = ?`,
      [decoded.userId]
    );

    if (!user) {
      res.status(401).json({ error: 'User not found' });
      return;
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Unauthorized' });
  }
}

================
File: src/middleware/error.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'

export const errorHandler = new Elysia()
  .onError(({ code, error, set }) => {
    logger.error(`❌ Error: ${code} - ${error.message}`);
    
    switch (code) {
      case 'NOT_FOUND':
        set.status = 404;
        return {
          success: false,
          message: 'Resource not found'
        };
      
      case 'VALIDATION':
        set.status = 400;
        return {
          success: false,
          message: error.message
        };
      
      default:
        set.status = 500;
        return {
          success: false,
          message: 'Internal server error'
        };
    }
  });

================
File: src/routes/admin-portal.ts
================
import { Elysia } from 'elysia'
import { spawn } from 'child_process'
import path from 'path'
import { logger } from '../logger'
import { requireAuth, requireAdmin } from '../middleware/auth'

// Create admin portal routes
export const createAdminPortalRoutes = () => {
  const adminPortal = new Elysia({ prefix: '/api/admin' })
    .use(requireAuth)
    .use(requireAdmin)

    // Get available admin scripts
    .get('/scripts', () => {
      const availableScripts = [
        {
          id: 'add-agent',
          name: 'Add Agent',
          description: 'Interactive tool to add new agents',
          script: 'add-agent.ts'
        },
        {
          id: 'manage-recommendations',
          name: 'Manage GI Recommendations', 
          description: 'Manage guaranteed issue recommendations',
          script: 'manage-recommendations.ts'
        }
      ]
      
      return { scripts: availableScripts }
    })

    // Execute script endpoint
    .post('/execute/:scriptId', ({ params, set, server }) => {
      const { scriptId } = params
      const scriptPath = path.join(__dirname, '../../scripts', `${scriptId}.ts`)

      logger.info(`Executing admin script: ${scriptId}`)

      // Spawn script process
      const process = spawn('bun', ['run', scriptPath], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      // Get WebSocket server instance
      const wss = server.webSocket

      // Handle new WebSocket connections
      wss.on('connection', (ws) => {
        logger.info('Admin terminal WebSocket connected')

        // Handle input from client
        ws.on('message', (data: string) => {
          const parsed = JSON.parse(data)
          if (parsed.type === 'input') {
            process.stdin.write(parsed.data)
          }
        })

        // Send output to client
        process.stdout.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'output', 
            data: data.toString() 
          }))
        })

        process.stderr.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'error', 
            data: data.toString() 
          }))
        })

        // Handle process exit
        process.on('exit', (code) => {
          ws.send(JSON.stringify({ type: 'exit', code }))
          logger.info(`Admin script ${scriptId} exited with code ${code}`)
        })

        // Handle WebSocket close
        ws.on('close', () => {
          logger.info('Admin terminal WebSocket disconnected')
          process.kill()
        })
      })

      set.status = 200
      return { 
        success: true, 
        message: 'Script execution started' 
      }
    })

  return adminPortal
}

================
File: src/routes/admin.ts
================
import { Elysia } from 'elysia'
import { staticPlugin } from '@elysiajs/static'
import { spawn } from 'child_process'
import path from 'path'
import { TursoService } from '../services/turso'

const tursoService = new TursoService()

export const adminRoutes = new Elysia()
  // Protect admin routes
  .guard({
    beforeHandle: ({ request, set }) => {
      // Add your admin authentication logic here
      const isAdmin = true // Replace with actual admin check
      if (!isAdmin) {
        set.status = 401
        return 'Unauthorized'
      }
    }
  })
  // Serve admin portal static files
  .use(staticPlugin({
    assets: '../admin-portal/dist',
    prefix: '/admin'
  }))
  // Terminal WebSocket endpoint
  .ws('/admin/terminal', {
    open(ws) {
      ws.send('Connected to admin terminal')
    },
    message(ws, message) {
      const { command, args } = JSON.parse(message as string)
      
      const scripts = {
        'add-agent': '../scripts/add-agent.ts',
        'manage-recommendations': '../scripts/manage-recommendations.ts'
      }

      if (!scripts[command]) {
        ws.send(JSON.stringify({ error: 'Invalid command' }))
        return
      }

      const script = spawn('bun', [path.resolve(__dirname, scripts[command]), ...args], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      script.stdout.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'output', data: data.toString() }))
      })

      script.stderr.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'error', data: data.toString() }))
      })

      script.on('close', (code) => {
        ws.send(JSON.stringify({ type: 'exit', code }))
      })
    }
  })

// In your create organization endpoint:
app.post('/api/organizations', async (req, res) => {
  const { name, /* other org fields */ } = req.body
  
  try {
    // Create org in central DB
    const org = await db.one(`
      INSERT INTO organizations (name) 
      VALUES ($1) 
      RETURNING id`, 
      [name]
    )

    // Create Turso DB for org
    const { url, token } = await tursoService.createOrganizationDatabase(org.id)

    // Update org with Turso credentials
    await db.none(`
      UPDATE organizations 
      SET turso_db_url = $1, turso_auth_token = $2
      WHERE id = $3`,
      [url, token, org.id]
    )

    res.json({ success: true, organization: org })
  } catch (err) {
    res.status(500).json({ success: false, error: err.message })
  }
})

================
File: src/routes/auth.ts
================
import { Elysia } from 'elysia';
import { cookie } from '@elysiajs/cookie';
import { AuthService } from '../services/auth';
import { EmailService } from '../services/email';
import { logger } from '../logger';
import { randomBytes } from 'crypto';
import { config } from '../config';
import crypto from 'crypto';
import { db } from '../database';
import { Database } from '../database';
import { getUserFromSession } from '../services/auth';
import type { User } from '../types';

const dbInstance = new Database();

export function createAuthRoutes() {
  const auth = new AuthService();
  const emailService = new EmailService();

  return new Elysia()
    .use(cookie())
    .post('/api/auth/login', async ({ body, set }) => {
      try {
        const { email } = body as { email: string };
        logger.info(`Login request for email: ${email}`);

        // Check if user exists
        const client = dbInstance.getClient();
        const userResult = await client.execute({
          sql: 'SELECT id, email FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        if (userResult.rows.length === 0) {
          // Don't reveal if user exists or not
          logger.info(`No active user found for email: ${email}`);
          return { success: true };
        }

        // Generate and send magic link
        const magicLink = await auth.createMagicLink(
          email,
          'default', // Default organization for now
          { redirectUrl: '/walkthrough' }
        );

        // Always send the email, but also log in development
        if (process.env.NODE_ENV === 'development') {
          logger.info(`Development mode - Magic link: ${magicLink}`);
        }
        
        // Send the email
        await emailService.sendMagicLink(email, magicLink, 'default');

        return { success: true };

      } catch (e) {
        logger.error(`Login error: ${e}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Internal server error'
        };
      }
    })

    .get('/api/auth/verify/:organizationSlug/:token', async ({ params, cookie, setCookie }) => {
      const { token, organizationSlug } = params;
      
      logger.info(`Starting verification for org ${organizationSlug}`);

      try {
        logger.info('Verifying magic link');
        const result = await auth.verifyMagicLink(token, organizationSlug);
        logger.info(`Magic link verification result: ${JSON.stringify(result)}`);
        
        if (!result.valid) {
          logger.error('Magic link validation failed');
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        // Create session ID
        const sessionId = crypto.randomBytes(32).toString('hex');
        logger.info(`Created session ID: ${sessionId}`);

        // First find user by email
        const user = await db.fetchOne<User>(
          `SELECT u.*, o.slug as organization_slug 
           FROM users u 
           JOIN organizations o ON u.organization_id = o.id 
           WHERE LOWER(u.email) = LOWER(?) AND u.is_active = 1`,
          [result.email]
        );

        if (!user) {
          logger.error(`No active user found for email: ${result.email}`);
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        logger.info(`Found user: ${JSON.stringify(user)}`);

        // Create session in database
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

        await db.execute(
          'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
          [sessionId, user.id, expiresAt.toISOString()]
        );

        logger.info(`Created session in database for user ${user.id}`);

        // Set session cookie
        setCookie('session', sessionId, {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7 // 7 days
        });

        const verificationResult = {
          success: true,
          redirectUrl: '/walkthrough',  // Always redirect to walkthrough page instead of dashboard
          session: sessionId,
          email: result.email,
          orgSlug: user.organization_id.toString()  // Use organization_id since organization_slug may not exist
        };
        logger.info(`Sending verification response: ${JSON.stringify(verificationResult)}`);
        return verificationResult;

      } catch (error) {
        logger.error(`Verification error: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return {
          success: false,
          redirectUrl: "/login",
          session: "",
          email: ""
        };
      }
    })

    .get('/api/auth/session', async ({ cookie }) => {
      const sessionId = cookie.session;
      logger.info(`Session check - Cookie session ID: ${sessionId}`);
      
      if (!sessionId) {
        logger.info('No session cookie found');
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: ""
        };
      }

      try {
        // Get user and organization info from session
        logger.info(`Looking up session in database: ${sessionId}`);
        const sessionUser = await db.fetchOne<{
          id: number;
          email: string;
          first_name: string;
          last_name: string;
          organization_slug: string;
        }>(
          `SELECT u.id, u.email, u.first_name, u.last_name, o.slug as organization_slug
           FROM sessions s
           JOIN users u ON s.user_id = u.id
           JOIN organizations o ON u.organization_id = o.id
           WHERE s.id = ?`,
          [sessionId]
        );

        if (!sessionUser) {
          logger.info(`No session found in database for ID: ${sessionId}`);
          return { 
            valid: false,
            session: "",
            email: "",
            organizationSlug: "",
            first_name: "",
            last_name: "",
            id: ""
          };
        }

        logger.info(`Found valid session for user: ${sessionUser.email}`);
        logger.info(`Session details: ${JSON.stringify(sessionUser, null, 2)}`);

        return { 
          valid: true,
          session: sessionId,
          email: sessionUser.email,
          organizationSlug: sessionUser.organization_slug,
          first_name: sessionUser.first_name,
          last_name: sessionUser.last_name,
          id: sessionUser.id
        };
      } catch (error) {
        logger.error(`Error getting session info: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: ""
        };
      }
    })

    .post('/api/auth/logout', async ({ set }) => {
      set.headers['Set-Cookie'] = 'session=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT';
      return { success: true };
    });
}

================
File: src/routes/brand.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';

const db = new Database();

interface Organization {
  id: number;
}

interface BrandSettings {
  brand_name: string;
  primary_color: string;
  secondary_color: string;
  logo_data: string | null;
}

export function createBrandRoutes() {
  return new Elysia()
    .get('/api/organizations/:orgSlug/brand', async ({ params }) => {
      try {
        const { orgSlug } = params;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Get brand settings
        const settings = await db.fetchOne<BrandSettings>(
          'SELECT brand_name, primary_color, secondary_color, logo_data FROM brand_settings WHERE organization_id = ?',
          [org.id]
        );

        if (!settings) {
          // Return defaults if no settings exist
          return {
            brand_name: '',
            primary_color: '#6B46C1',
            secondary_color: '#9F7AEA',
            logo: null
          };
        }

        return {
          brand_name: settings.brand_name,
          primary_color: settings.primary_color,
          secondary_color: settings.secondary_color,
          logo: settings.logo_data
        };
      } catch (error) {
        logger.error('Error fetching brand settings', error);
        return {
          success: false,
          error: 'Failed to fetch brand settings'
        };
      }
    })
    .put('/api/organizations/:orgSlug/brand', async ({ params, body }) => {
      try {
        const { orgSlug } = params;
        const { brand_name, primary_color, secondary_color, logo } = body as any;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Upsert brand settings
        await db.execute(`
          INSERT INTO brand_settings 
            (organization_id, brand_name, primary_color, secondary_color, logo_data)
          VALUES (?, ?, ?, ?, ?)
          ON CONFLICT(organization_id) DO UPDATE SET
            brand_name = excluded.brand_name,
            primary_color = excluded.primary_color,
            secondary_color = excluded.secondary_color,
            logo_data = excluded.logo_data
        `, [org.id, brand_name, primary_color, secondary_color, logo]);

        return {
          success: true
        };
      } catch (error) {
        logger.error('Error saving brand settings', error);
        return {
          success: false,
          error: 'Failed to save brand settings'
        };
      }
    });
}

================
File: src/routes/contacts.ts
================
import { createClient } from '@libsql/client';

// Get Turso client for organization
async function getOrgTursoClient(orgId: string) {
  const org = await db.one(`
    SELECT turso_db_url, turso_auth_token 
    FROM organizations 
    WHERE id = $1`,
    [orgId]
  );

  return createClient({
    url: org.turso_db_url,
    authToken: org.turso_auth_token
  });
}

// Update contacts endpoints to use org's Turso DB
app.post('/api/contacts/upload', async (req, res) => {
  const orgId = req.user.organizationId;
  const tursoClient = await getOrgTursoClient(orgId);

  try {
    // Process CSV file
    const contacts = parseCSV(req.file);
    
    // Insert into org's Turso DB
    for (const contact of contacts) {
      await tursoClient.execute(`
        INSERT INTO contacts (
          first_name, last_name, email, /* other fields */
        ) VALUES (?, ?, ?, /* other values */)`,
        [contact.firstName, contact.lastName, contact.email /* other values */]
      );
    }

    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ 
      success: false,
      message: err.message,
      // Include other error details as needed
    });
  }
});

// Similar updates needed for other contact endpoints

================
File: src/routes/eligibility.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';

interface EligibilityAnswers {
    quote_id?: string;
    contact_id?: string;
    answers: Record<string, {
        question_text: string;
        question_type: string;
        answer: boolean | string | null;
    }>;
}

export const eligibilityRoutes = (app: Elysia) => {
    app
        // Create a temporary contact for collecting eligibility answers
        .post('/api/org/:orgId/temp-contact', async ({ params }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);
                
                // Create a minimal contact record for just eligibility assessment
                const result = await orgDb.execute(
                    `INSERT INTO contacts 
                    (first_name, last_name, email, current_carrier, plan_type, effective_date, birth_date, tobacco_user, gender, state, zip_code, phone_number, status) 
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    [
                        'Temporary', 
                        'Contact', 
                        `temp-${Date.now()}@example.com`, 
                        '', 
                        'G', 
                        '', 
                        '1950-01-01', 
                        0, 
                        'M', 
                        '', 
                        '00000', 
                        '', 
                        'temp'
                    ]
                );

                // Get the inserted ID from the result
                const contactId = result.lastInsertRowid?.toString();
                
                if (!contactId) {
                    throw new Error('Failed to create temporary contact');
                }

                // Add a record to contact_events to track this
                await orgDb.execute(
                    `INSERT INTO contact_events 
                    (contact_id, event_type, metadata) 
                    VALUES (?, ?, ?)`,
                    [
                        contactId,
                        'temp_contact_created',
                        JSON.stringify({ source: 'eligibility_assessment' })
                    ]
                );

                return contactId;
            } catch (error) {
                logger.error(`Error creating temporary contact: ${error}`);
                throw new Error('Failed to create temporary contact');
            }
        })

        // Save eligibility answers
        .post('/api/org/:orgId/eligibility-answers', async ({ params, body }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                const data = body as EligibilityAnswers;
                
                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);
                
                let contactId: string | null = null;
                
                // If quote_id is provided, get the contact_id from it
                if (data.quote_id) {
                    try {
                        const decodedQuoteId = decodeQuoteId(data.quote_id);
                        if (decodedQuoteId && decodedQuoteId.contactId) {
                            contactId = decodedQuoteId.contactId.toString();
                        }
                    } catch (error) {
                        logger.error(`Error decoding quote ID: ${error}`);
                        return {
                            success: false,
                            error: 'Invalid quote ID'
                        };
                    }
                } else if (data.contact_id) {
                    // If contact_id is provided directly, use it
                    contactId = data.contact_id;
                }
                
                if (!contactId) {
                    return {
                        success: false,
                        error: 'Missing contact ID'
                    };
                }
                
                // Verify contact exists in this org
                const contact = await orgDb.fetchOne(
                    'SELECT id FROM contacts WHERE id = ?',
                    [contactId]
                );
                
                if (!contact) {
                    return {
                        success: false,
                        error: 'Contact not found'
                    };
                }
                
                // Store the eligibility answers
                const answersJson = JSON.stringify(data.answers);
                
                // Check if we already have answers for this contact
                const existingAnswers = await orgDb.fetchOne(
                    'SELECT id FROM eligibility_answers WHERE contact_id = ?',
                    [contactId]
                );
                
                if (existingAnswers) {
                    // Update existing answers
                    await orgDb.execute(
                        'UPDATE eligibility_answers SET answers = ?, created_at = CURRENT_TIMESTAMP WHERE contact_id = ?',
                        [answersJson, contactId]
                    );
                } else {
                    // Insert new answers
                    await orgDb.execute(
                        'INSERT INTO eligibility_answers (contact_id, answers) VALUES (?, ?)',
                        [contactId, answersJson]
                    );
                }
                
                // Extract analytics data from enhanced answers
                const analyticsData = {
                    answers_count: Object.keys(data.answers).length,
                    source: data.quote_id ? 'quote' : 'direct',
                    main_questions_yes_count: Object.values(data.answers).filter(a => 
                        a.question_type === 'main' && a.answer === true
                    ).length,
                    has_medical_conditions: Object.values(data.answers).some(a => 
                        a.question_type === 'main' && a.answer === true
                    )
                };
                
                // Add a record to contact_events
                await orgDb.execute(
                    `INSERT INTO contact_events 
                    (contact_id, event_type, metadata) 
                    VALUES (?, ?, ?)`,
                    [
                        contactId,
                        'eligibility_answered',
                        JSON.stringify(analyticsData)
                    ]
                );
                
                return contactId;
            } catch (error) {
                logger.error(`Error saving eligibility answers: ${error}`);
                throw new Error('Failed to save eligibility answers');
            }
        });

    return app;
};

================
File: src/routes/onboarding.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'
import { Database } from '../database'
import { config } from '../config'
import { generateToken, getUserFromSession } from '../services/auth'
import { cookie } from '@elysiajs/cookie'

// Define types for onboarding data
interface OnboardingData {
  plan: {
    type: string
    price: number
    billingCycle: string
    extraAgents: number
    extraContacts: number
  }
  user: {
    firstName: string
    lastName: string
    email: string
    phone: string
    bookingLink: string
  }
  company: {
    agencyName: string
    website: string
    phone: string
    primaryColor: string
    secondaryColor: string
    logo?: string
  }
  licensing: {
    stateLicenses: string[]
    carrierContracts: string[]
    stateCarrierSettings: StateCarrierSetting[]
  }
  agents: any[] // Using any for flexibility, could be more specific
}

interface StateCarrierSetting {
  state: string
  carrier: string
  active: boolean
  targetGI: boolean
}

// Helper function for generating random slugs
const generateRandomSlug = () => {
  const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
  const length = 12;
  let result = '';
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
};

export function createOnboardingRoutes() {
  const dbInstance = new Database()

  return new Elysia()
    .use(cookie())
    // Get onboarding settings using cookie
    .get('/api/onboarding/settings', async ({ cookie, set, headers }) => {
      try {
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        const sessionId = cookie.onboardingSession || headers['x-onboarding-session'];
        
        logger.info(`Fetching onboarding settings with cookies - orgSlug: ${orgSlug ? 'present' : 'missing'}, sessionId: ${sessionId ? 'present' : 'missing'}`);
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            error: 'No organization found in session',
            code: 'NO_ORG_SLUG' 
          };
        }
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found',
            code: 'NO_SESSION' 
          };
        }
        
        // Find organization and its admin user
        const orgInfo = await dbInstance.query<{ 
          id: number, 
          name: string,
          onboarding_step: number,
          subscription_tier: string,
          website: string,
          phone: string,
          primary_color: string,
          secondary_color: string
        }>(
          `SELECT id, name, onboarding_step, subscription_tier, website, phone, primary_color, secondary_color
           FROM organizations 
           WHERE slug = ? AND temp_session_id = ? AND onboarding_completed = FALSE
           LIMIT 1`,
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or onboarding already completed: ${orgSlug} (session: ${sessionId})`);
          
          // Try to find the organization without checking the session
          const orgWithoutSession = await dbInstance.query<{ id: number }>(
            `SELECT id FROM organizations WHERE slug = ? AND onboarding_completed = FALSE LIMIT 1`,
            [orgSlug]
          );
          
          if (orgWithoutSession && orgWithoutSession.length > 0) {
            logger.warn(`Organization exists but invalid session for: ${orgSlug}`);
            set.status = 401;
            return { 
              error: 'Invalid session for this organization',
              code: 'INVALID_SESSION' 
            };
          }
          
          set.status = 404;
          return { 
            error: 'Organization not found or onboarding already completed',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Get admin user details
        const userInfo = await dbInstance.query<{
          id: number,
          email: string,
          first_name: string,
          last_name: string,
          phone: string,
          booking_link: string
        }>(
          `SELECT id, email, first_name, last_name, phone, booking_link
           FROM users
           WHERE organization_id = ? AND is_admin = 1
           LIMIT 1`,
          [orgId]
        );
        
        // Get brand settings (for logo)
        const brandInfo = await dbInstance.query<{
          logo_data: string
        }>(
          `SELECT logo_data
           FROM brand_settings
           WHERE organization_id = ?
           LIMIT 1`,
          [orgId]
        );
        
        // Get licensing settings
        const licensingInfo = await dbInstance.query<{
          org_settings: string
        }>(
          `SELECT org_settings
           FROM organizations
           WHERE id = ?
           LIMIT 1`,
          [orgId]
        );
        
        // Parse carrier contracts and SmartSend settings from org_settings
        let carrierContracts = [];
        let useSmartSendForGI = false;
        try {
          if (licensingInfo.length > 0 && licensingInfo[0].org_settings) {
            const settings = JSON.parse(licensingInfo[0].org_settings);
            
            // Check if settings has a licensing property (new structure)
            if (settings.licensing && settings.licensing.carrierContracts) {
              carrierContracts = settings.licensing.carrierContracts;
            } else {
              // Fallback to old structure
              carrierContracts = settings.carrierContracts || [];
            }
            
            // Check for useSmartSendForGI in both places
            useSmartSendForGI = settings.useSmartSendForGI || 
                               (settings.licensing && settings.licensing.useSmartSendForGI) || 
                               false;
          }
        } catch (e) {
          logger.warn(`Error parsing org settings: ${e}`);
        }
        
        // Get agent list
        const agentList = await dbInstance.query<{
          id: number,
          email: string,
          first_name: string,
          last_name: string,
          phone: string,
          is_admin: number
        }>(
          `SELECT id, email, first_name, last_name, phone, is_admin
           FROM users
           WHERE organization_id = ? AND is_agent = 1 AND id NOT IN 
               (SELECT id FROM users WHERE organization_id = ? AND is_admin = 1 LIMIT 1)`,
          [orgId, orgId]
        );
        
        const agents = agentList.map(agent => ({
          id: agent.id,
          firstName: agent.first_name || '',
          lastName: agent.last_name || '',
          email: agent.email || '',
          phone: agent.phone || '',
          isAdmin: Boolean(agent.is_admin),
          isAgent: true
        }));
        
        // Build response structure
        const response = {
          onboardingStep: orgInfo[0].onboarding_step,
          planSelectionModel: {
            selectedPlan: orgInfo[0].subscription_tier || 'basic'
          },
          userDetailsModel: userInfo.length > 0 ? {
            firstName: userInfo[0].first_name || '',
            lastName: userInfo[0].last_name || '',
            email: userInfo[0].email || '',
            phone: userInfo[0].phone || '',
            bookingLink: userInfo[0].booking_link || ''
          } : null,
          companyDetailsModel: {
            agencyName: orgInfo[0].name || '',
            website: orgInfo[0].website || '',
            phone: orgInfo[0].phone || '',
            primaryColor: orgInfo[0].primary_color || '#0A0F4F',
            secondaryColor: orgInfo[0].secondary_color || '#7B61FF',
            logo: brandInfo.length > 0 ? brandInfo[0].logo_data : ''
          },
          licensingSettingsModel: {
            carrierContracts: carrierContracts,
            useSmartSendForGI: useSmartSendForGI
          },
          addAgentsModel: {
            agents: agents
          },
          paymentModel: {
            extraAgents: 0,
            extraContacts: 0
          },
          enterpriseFormModel: null
        };
        
        logger.info(`Retrieved onboarding settings for org ${orgSlug} (ID: ${orgId}), step: ${orgInfo[0].onboarding_step}`);
        
        return response;
        
      } catch (error) {
        logger.error(`Error fetching onboarding settings: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to fetch onboarding settings',
          code: 'SERVER_ERROR'
        };
      }
    })
    // New endpoint for initial account creation without email requirement
    .post('/api/onboarding/initialize', async ({ body, set, setCookie }) => {
      try {
        const { planType } = body as { planType: string };
        
        logger.info(`Initializing onboarding with plan: ${planType}`);
        
        // Generate a completely random slug (12 characters)
        const slug = generateRandomSlug();
        
        // Create temporary session token
        const tempSessionId = generateToken();
        
        // Set session cookie for 24 hours
        setCookie('onboardingSession', tempSessionId, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/',
          sameSite: 'lax'
        });
        
        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/',
          sameSite: 'lax'
        });
        
        // Create organization with minimal info
        const orgResult = await dbInstance.execute(`
          INSERT INTO organizations (
            name, 
            subscription_tier, 
            created_at, 
            onboarding_completed, 
            slug, 
            onboarding_step,
            temp_session_id
          ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
          ['New Organization', planType || 'basic', slug, 1, tempSessionId]
        );
        
        const orgId = Number(orgResult.lastInsertRowid);
        logger.info(`Created initial organization: ${orgId} with slug: ${slug}`);
        
        return {
          organizationId: orgId,
          slug: slug,
          sessionToken: tempSessionId,
          onboardingStep: 1
        };
        
      } catch (error) {
        logger.error(`Error initializing onboarding: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to initialize onboarding' 
        };
      }
    })
    
    // Alias endpoint for '/api/onboarding/initialize' to support frontend expectations
    .post('/api/onboarding/start', async ({ body, set, setCookie }) => {
      try {
        const { planType } = body as { planType: string };
        
        logger.info(`Starting onboarding with plan: ${planType}`);
        
        // Generate a completely random slug (12 characters)
        const slug = generateRandomSlug();
        
        // Create temporary session token
        const tempSessionId = generateToken();
        
        // Set session cookie for 24 hours
        setCookie('onboardingSession', tempSessionId, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/',
          sameSite: 'lax'
        });
        
        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/',
          sameSite: 'lax'
        });
        
        // Create organization with minimal info
        const orgResult = await dbInstance.execute(`
          INSERT INTO organizations (
            name, 
            subscription_tier, 
            created_at, 
            onboarding_completed, 
            slug, 
            onboarding_step,
            temp_session_id
          ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
          ['New Organization', planType || 'basic', slug, 1, tempSessionId]
        );
        
        const orgId = Number(orgResult.lastInsertRowid);
        logger.info(`Created initial organization: ${orgId} with slug: ${slug}`);
        
        // Return the response in the format expected by the frontend
        return {
          sessionId: tempSessionId,
          planType: planType || 'basic',
          step: 1
        };
        
      } catch (error) {
        logger.error(`Error starting onboarding: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to start onboarding' 
        };
      }
    })
    
    // Endpoint to check if an email is available during onboarding
    .post('/api/onboarding/check-email', async ({ body, set }) => {
      try {
        const { email } = body as { email: string, endpoint?: string };
        
        logger.info(`Checking email availability during onboarding: "${email}"`);
        
        if (!email || !email.trim()) {
          set.status = 400;
          return {
            available: false,
            message: 'Email is required'
          };
        }
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          logger.info(`Email validation failed for: "${email}"`);
          return {
            available: false,
            message: 'Invalid email format'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        const count = existingUser[0]?.count || 0;
        logger.info(`Email check query result count: ${count} for email: "${email}"`);
        
        if (count > 0) {
          return {
            available: false,
            message: 'This email address is already registered'
          };
        }
        
        // If we get here, the email is available
        return {
          available: true,
          message: 'Email is available'
        };
        
      } catch (error) {
        logger.error(`Error checking email availability: ${error}`);
        set.status = 500;
        return {
          available: false,
          message: 'Failed to check email availability'
        };
      }
    })
    
    // Endpoint to check if an agent email is available during onboarding
    .post('/api/onboarding/check-agent-email', async ({ body, set }) => {
      try {
        const { email, sessionId } = body as { email: string, sessionId: string };
        
        logger.info(`Checking agent email availability during onboarding: "${email}"`);
        
        if (!email || !email.trim()) {
          set.status = 400;
          return {
            available: false,
            message: 'Email is required'
          };
        }
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          logger.info(`Agent email validation failed for: "${email}"`);
          return {
            available: false,
            message: 'Invalid email format'
          };
        }
        
        // Find the organization based on the session ID
        const orgData = await dbInstance.query<{ id: number }>(
          'SELECT id FROM organizations WHERE temp_session_id = ?',
          [sessionId]
        );
        
        if (!orgData || orgData.length === 0) {
          logger.warn(`No organization found for session: ${sessionId}`);
          set.status = 401;
          return {
            available: false,
            message: 'Invalid session'
          };
        }
        
        const organizationId = orgData[0].id;
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        const count = existingUser[0]?.count || 0;
        logger.info(`Agent email check query result count: ${count} for email: "${email}"`);
        
        if (count > 0) {
          return {
            available: false,
            message: 'This email address is already registered'
          };
        }
        
        // If we get here, the email is available
        return {
          available: true,
          message: 'Email is available'
        };
        
      } catch (error) {
        logger.error(`Error checking agent email availability: ${error}`);
        set.status = 500;
        return {
          available: false,
          message: 'Failed to check email availability'
        };
      }
    })
    
    // New endpoint to resume onboarding by email
    .post('/api/onboarding/resume-onboarding', async ({ body, set, setCookie }) => {
      try {
        const { email } = body as { email: string };
        
        logger.info(`Attempting to resume onboarding for email: ${email}`);
        
        if (!email || !email.trim()) {
          logger.warn('Attempt to resume onboarding with empty email');
          set.status = 400;
          return { 
            error: 'Email is required' 
          };
        }
        
        // Find user and organization by email
        const userData = await dbInstance.query<{ 
          organization_id: number, 
          slug: string, 
          onboarding_step: number,
          temp_session_id: string,
          subscription_tier: string 
        }>(
          `SELECT u.organization_id, o.slug, o.onboarding_step, o.temp_session_id, o.subscription_tier
           FROM users u
           JOIN organizations o ON u.organization_id = o.id
           WHERE LOWER(u.email) = LOWER(?) AND o.onboarding_completed = FALSE`,
          [email]
        );
        
        if (!userData || userData.length === 0) {
          logger.warn(`No in-progress onboarding found for email: ${email}`);
          set.status = 404;
          return { 
            error: 'No onboarding in progress for this email' 
          };
        }
        
        const { organization_id, slug, onboarding_step, temp_session_id, subscription_tier } = userData[0];
        
        // Update session token if needed
        let sessionToken = temp_session_id;
        if (!sessionToken) {
          sessionToken = generateToken();
          await dbInstance.execute(
            'UPDATE organizations SET temp_session_id = ? WHERE id = ?',
            [sessionToken, organization_id]
          );
          logger.info(`Generated new session token for org ${organization_id}`);
        }
        
        // Set session cookie
        setCookie('onboardingSession', sessionToken, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/',
          sameSite: 'lax'
        });
        
        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/',
          sameSite: 'lax'
        });
        
        logger.info(`Resumed onboarding for organization: ${organization_id}, step: ${onboarding_step}, plan: ${subscription_tier}`);
        
        return {
          organizationId: organization_id,
          slug: slug,
          sessionToken: sessionToken,
          onboardingStep: onboarding_step,
          planType: subscription_tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error resuming onboarding: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to resume onboarding' 
        };
      }
    })
    
    // Endpoint to update user details
    .post('/api/onboarding/user-details', async ({ body, cookie, set, setCookie, request }) => {
      try {
        // Extract all fields from the request body
        const { firstName, lastName, email, phone, bookingLink, planType } = body as { 
          firstName: string, 
          lastName: string, 
          email: string,
          phone: string,
          bookingLink?: string,
          planType?: string // New optional parameter
        };
        
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        let orgId: number;
        
        // Handle case where no cookie exists but planType is provided - create a new organization
        if ((!orgSlug || !sessionId) && planType) {
          logger.info(`No existing organization found, creating new one with plan: ${planType}`);
          
          // Generate a new slug and session token
          const slug = generateRandomSlug();
          const tempSessionId = generateToken();
          
          // Set cookies
          setCookie('onboardingSession', tempSessionId, {
            httpOnly: true,
            maxAge: 60 * 60 * 24, // 24 hours
            path: '/',
            sameSite: 'lax'
          });
          
          setCookie('orgSlug', slug, {
            httpOnly: false,
            maxAge: 60 * 60 * 24 * 30, // 30 days
            path: '/',
            sameSite: 'lax'
          });
          
          // Create organization with minimal info
          const orgResult = await dbInstance.execute(`
            INSERT INTO organizations (
              name, 
              subscription_tier, 
              created_at, 
              onboarding_completed, 
              slug, 
              onboarding_step,
              temp_session_id
            ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
            ['New Organization', planType || 'basic', slug, 1, tempSessionId]
          );
          
          orgId = Number(orgResult.lastInsertRowid);
          logger.info(`Created initial organization: ${orgId} with slug: ${slug} for user ${email}`);
          
          // Create the user immediately
          await dbInstance.execute(
            `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone, 
              booking_link,
              is_admin, 
              is_agent, 
              organization_id, 
              created_at,
              is_active
            ) VALUES (?, ?, ?, ?, ?, 1, 1, ?, datetime('now'), 0)`,
            [email, firstName, lastName, phone, bookingLink || '', orgId]
          );
          
          // Update onboarding step
          await dbInstance.execute(
            'UPDATE organizations SET onboarding_step = 2 WHERE id = ?',
            [orgId]
          );
          
          logger.info(`Created user for new org ${slug} - Name: ${firstName} ${lastName}, Email: ${email}`);
          
          return {
            success: true,
            message: 'User details saved successfully',
            onboardingStep: 2,
            userEmail: email,
            slug: slug,
            sessionToken: tempSessionId
          };
        }
        
        // Handle the existing case where org slug exists
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            error: 'No organization found in session' 
          };
        }
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found' 
          };
        }
        
        logger.info(`Updating user details for organization ${orgSlug} with session ID ${sessionId}`);
        
        // Find organization from slug and session ID
        const orgInfo = await dbInstance.query<{ id: number, subscription_tier: string }>(
          'SELECT id, subscription_tier FROM organizations WHERE slug = ? AND temp_session_id = ? AND onboarding_completed = FALSE',
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or session invalid for slug: ${orgSlug}`);
          set.status = 404;
          return { 
            error: 'Organization not found or invalid session' 
          };
        }
        
        orgId = orgInfo[0].id;
        
        // Check if user already exists for this email but different org
        const existingUserCheck = await dbInstance.query<{ count: number, org_id: number | null }>(
          `SELECT COUNT(*) as count, organization_id as org_id
           FROM users 
           WHERE LOWER(email) = LOWER(?) AND organization_id != ?
           LIMIT 1`,
          [email, orgId]
        );
        
        if (existingUserCheck[0]?.count > 0) {
          logger.warn(`Email ${email} is already in use by another organization`);
          set.status = 400;
          return { 
            success: false, 
            message: 'This email address is already registered with another account' 
          };
        }
        
        // Check if user exists for this org
        const adminUserCheck = await dbInstance.query<{ id: number | null }>(
          `SELECT id FROM users WHERE organization_id = ? AND is_admin = 1 LIMIT 1`,
          [orgId]
        );
        
        if (adminUserCheck.length > 0 && adminUserCheck[0].id) {
          // Update existing user
          await dbInstance.execute(
            `UPDATE users 
             SET first_name = ?, last_name = ?, email = ?, phone = ?, booking_link = ?
             WHERE id = ?`,
            [firstName, lastName, email, phone, bookingLink || '', adminUserCheck[0].id]
          );
        } else {
          // Create new user
          await dbInstance.execute(
            `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone, 
              booking_link,
              is_admin, 
              is_agent, 
              organization_id, 
              created_at,
              is_active
            ) VALUES (?, ?, ?, ?, ?, 1, 1, ?, datetime('now'), 0)`,
            [email, firstName, lastName, phone, bookingLink || '', orgId]
          );
        }
        
        // Update subscription tier if planType is provided and different from current
        if (planType) {
          await dbInstance.execute(
            'UPDATE organizations SET subscription_tier = ? WHERE id = ?',
            [planType, orgId]
          );
        }
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_step = 2 WHERE id = ?',
          [orgId]
        );
        
        logger.info(`Updated user details for org ${orgSlug} - Name: ${firstName} ${lastName}, Email: ${email}`);
        
        return {
          success: true,
          message: 'User details updated successfully',
          onboardingStep: 2,
          userEmail: email,
          slug: orgSlug,
          sessionToken: sessionId,
          planType: orgInfo[0].subscription_tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error updating user details: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to update user details' 
        };
      }
    })
    
    // Endpoint to update company details
    .post('/api/onboarding/company-details', async ({ body, cookie, set, request }) => {
      try {
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            error: 'No organization found in session',
            success: false
          };
        }
        
        // Get session ID from cookie or header (prefer cookie)
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found',
            success: false
          };
        }
        
        logger.info(`Updating company details for organization ${orgSlug} with session ID ${sessionId}`);
        
        const { 
          agencyName, 
          website, 
          phone, 
          primaryColor, 
          secondaryColor,
          logo
        } = body as { 
          agencyName: string,
          website: string,
          phone: string,
          primaryColor: string,
          secondaryColor: string,
          logo?: string
        };
        
        // Find organization from slug and session ID
        const orgInfo = await dbInstance.query<{ id: number, subscription_tier: string }>(
          'SELECT id, subscription_tier FROM organizations WHERE slug = ? AND temp_session_id = ? AND onboarding_completed = FALSE',
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or session invalid for slug: ${orgSlug}`);
          set.status = 404;
          return { 
            error: 'Organization not found or invalid session',
            success: false
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Update organization info with default values if empty
        await dbInstance.execute(`
          UPDATE organizations 
          SET name = COALESCE(NULLIF(?, ''), name, 'New Organization'), 
              website = COALESCE(NULLIF(?, ''), website, ''), 
              phone = COALESCE(NULLIF(?, ''), phone, ''), 
              primary_color = COALESCE(NULLIF(?, ''), primary_color, '#6B46C1'), 
              secondary_color = COALESCE(NULLIF(?, ''), secondary_color, '#9F7AEA')
          WHERE id = ?`,
          [agencyName, website, phone, primaryColor, secondaryColor, orgId]
        );
        
        // Store logo if provided
        if (logo) {
          // Check if brand settings already exist
          const brandCheck = await dbInstance.query<{ count: number }>(
            'SELECT COUNT(*) as count FROM brand_settings WHERE organization_id = ?',
            [orgId]
          );
          
          if (brandCheck[0]?.count > 0) {
            // Update existing brand settings
            await dbInstance.execute(`
              UPDATE brand_settings 
              SET brand_name = COALESCE(NULLIF(?, ''), brand_name, 'New Organization'),
                  primary_color = COALESCE(NULLIF(?, ''), primary_color, '#6B46C1'),
                  secondary_color = COALESCE(NULLIF(?, ''), secondary_color, '#9F7AEA'),
                  logo_data = ?
              WHERE organization_id = ?`,
              [agencyName, primaryColor, secondaryColor, logo, orgId]
            );
          } else {
            // Create new brand settings
            await dbInstance.execute(`
              INSERT INTO brand_settings (
                organization_id, brand_name, primary_color, secondary_color, logo_data
              ) VALUES (?, ?, ?, ?, ?)`,
              [orgId, 
               agencyName || 'New Organization', 
               primaryColor || '#6B46C1', 
               secondaryColor || '#9F7AEA', 
               logo]
            );
          }
        }
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_step = 3 WHERE id = ?',
          [orgId]
        );
        
        logger.info(`Updated company details for org ${orgSlug} - Name: ${agencyName}`);
        
        return {
          success: true,
          message: 'Company details updated successfully',
          onboardingStep: 3,
          slug: orgSlug,
          sessionToken: sessionId,
          planType: orgInfo[0].subscription_tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error updating company details: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to update company details',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to update licensing settings
    .post('/api/onboarding/licensing-settings', async ({ body, cookie, set, request }) => {
      try {
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            error: 'No organization found in session',
            success: false,
            slug: ""
          };
        }
        
        // Get session ID from cookie or header (prefer cookie)
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found',
            success: false,
            slug: orgSlug
          };
        }
        
        logger.info(`Updating licensing settings for organization ${orgSlug} with session ID ${sessionId}`);
        
        const { 
          carrierContracts,
          useSmartSendForGI,
          stateLicenses = [],
          stateCarrierSettings = []
        } = body as { 
          carrierContracts: string[],
          useSmartSendForGI: boolean,
          stateLicenses?: string[],
          stateCarrierSettings?: StateCarrierSetting[]
        };
        
        // Find organization from slug and session ID
        const orgInfo = await dbInstance.query<{ id: number, tier: string, org_settings: string | null }>(
          'SELECT id, subscription_tier as tier, org_settings FROM organizations WHERE slug = ? AND temp_session_id = ? AND onboarding_completed = FALSE',
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or session invalid for slug: ${orgSlug}`);
          set.status = 404;
          return { 
            error: 'Organization not found or invalid session',
            success: false,
            slug: orgSlug
          };
        }
        
        const orgId = orgInfo[0].id;
        
        try {
          // Get existing org_settings if any
          let orgSettings = {};
          if (orgInfo[0].org_settings) {
            try {
              orgSettings = JSON.parse(orgInfo[0].org_settings);
            } catch (parseError) {
              logger.warn(`Error parsing existing org_settings: ${parseError}`);
              // Continue with empty object if parse fails
            }
          }
          
          // Update org_settings with new licensing data
          const updatedSettings = {
            ...orgSettings,
            useSmartSendForGI,
            licensing: {
              carrierContracts,
              stateLicenses,
              stateCarrierSettings
            }
          };
          
          // Store updated settings in org_settings column
          await dbInstance.execute(
            'UPDATE organizations SET org_settings = ? WHERE id = ?',
            [JSON.stringify(updatedSettings), orgId]
          );
          
          logger.info(`Saved licensing settings for org ${orgSlug} (ID: ${orgId}) - Carriers: ${carrierContracts.length}`);
        } catch (settingsError) {
          logger.error(`Error saving licensing settings: ${settingsError}`);
          // Continue execution even if this fails - non-critical
        }
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_step = 4 WHERE id = ?',
          [orgId]
        );
        
        const isBasicPlan = orgInfo[0]?.tier === 'basic';
        const nextStep = isBasicPlan ? 5 : 4; // Skip agents step if basic plan
        
        return {
          success: true,
          message: 'Licensing settings updated successfully',
          onboardingStep: 4,
          nextStep: nextStep,
          isBasicPlan: isBasicPlan,
          sessionToken: sessionId,
          slug: orgSlug,
          planType: orgInfo[0].tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error updating licensing settings: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to update licensing settings',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to add agents
    .post('/api/onboarding/agents', async ({ body, cookie, set, request }) => {
      try {
        // Get org slug and session ID from cookies
        const orgSlug = cookie.orgSlug;
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            success: false,
            message: 'No organization found in session',
            code: 'NO_ORG_SLUG'
          };
        }
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            success: false,
            message: 'Invalid session',
            code: 'NO_SESSION'
          };
        }
        
        logger.info(`Adding agents for organization ${orgSlug} with session ID ${sessionId}`);
        
        const { agents } = body as { 
          agents: Array<{
            firstName: string,
            lastName: string,
            email: string,
            phone: string,
            isAdmin: boolean,
            isAgent: boolean
          }>
        };
        
        // Find organization from slug and session token
        const orgInfo = await dbInstance.query<{ id: number, subscription_tier: string }>(
          'SELECT id, subscription_tier FROM organizations WHERE slug = ? AND temp_session_id = ?',
          [orgSlug, sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Invalid session or organization slug: ${orgSlug}`);
          set.status = 401;
          return { 
            success: false, 
            message: 'Unauthorized: Invalid session',
            code: 'INVALID_SESSION'
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Process agents in transaction to ensure all-or-nothing
        const addedAgents = await dbInstance.transaction(async (db) => {
          const addedEmails = [];
          
          for (const agent of agents) {
            // Check if email already exists
            const emailCheck = await db.query<{ count: number }>(
              'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
              [agent.email]
            );
            
            if (emailCheck[0]?.count > 0) {
              logger.warn(`Skip adding agent with email ${agent.email} - already exists`);
              continue; // Skip this agent, email already exists
            }
            
            // Insert new agent
            await db.execute(`
              INSERT INTO users (
                email,
                first_name,
                last_name,
                phone,
                is_admin,
                is_agent,
                organization_id,
                created_at,
                is_active
              ) VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), 1)`,
              [
                agent.email,
                agent.firstName,
                agent.lastName,
                agent.phone || '',
                agent.isAdmin ? 1 : 0,
                agent.isAgent ? 1 : 0,
                orgId
              ]
            );
            
            logger.info(`Added agent: ${agent.firstName} ${agent.lastName} (${agent.email})`);
            addedEmails.push(agent.email);
          }
          
          return addedEmails;
        });
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_step = 5 WHERE id = ?',
          [orgId]
        );
        
        return {
          success: true,
          message: `Added ${addedAgents.length} agents successfully`,
          addedAgents: addedAgents,
          onboardingStep: 5,
          sessionToken: sessionId,
          slug: orgSlug,
          planType: orgInfo[0].subscription_tier || 'basic'
        };
        
      } catch (error) {
        logger.error(`Error adding agents: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to add agents',
          code: 'SERVER_ERROR',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to process payment and complete subscription
    .post('/api/onboarding/payment', async ({ body, cookie, set }) => {
      try {
        // Get org slug and session ID from cookies
        const orgSlug = cookie.orgSlug;
        const tempSessionId = cookie.onboardingSession;
        
        if (!orgSlug || !tempSessionId) {
          logger.warn('No organization slug or session ID found in cookie');
          set.status = 401;
          return { 
            success: false,
            message: 'No organization found in session or invalid session',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        logger.info(`Processing payment for organization ${orgSlug} from cookie`);
        
        const { 
          tierId, 
          extraAgents, 
          extraContacts 
        } = body as {
          tierId: string,
          extraAgents: number,
          extraContacts: number
        };
        
        // Find organization from slug and session token
        const orgInfo = await dbInstance.query<{ id: number, email: string }>(
          `SELECT o.id, (SELECT email FROM users WHERE organization_id = o.id AND is_admin = 1 LIMIT 1) as email 
           FROM organizations o WHERE o.slug = ? AND o.temp_session_id = ?`,
          [orgSlug, tempSessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Invalid session or organization slug: ${orgSlug}`);
          set.status = 401;
          return { 
            success: false, 
            message: 'Unauthorized: Invalid session',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Import the Stripe service here
        const { createOrUpdateSubscription } = await import('../services/stripe');
        
        try {
          // Get admin user's email for Stripe customer
          const userEmail = orgInfo[0]?.email;
          if (!userEmail) {
            throw new Error('Admin user email not found');
          }
          
          // Create or update the Stripe subscription
          const stripeResult = await createOrUpdateSubscription({
            tierId: tierId as 'basic' | 'pro' | 'enterprise',
            organizationId: orgId,
            email: userEmail,
            extraAgents: extraAgents || 0,
            extraContacts: extraContacts || 0
          });
          
          // Update organization with Stripe IDs and subscription tier
          await dbInstance.execute(`
            UPDATE organizations 
            SET subscription_tier = ?,
                stripe_customer_id = ?,
                stripe_subscription_id = ?,
                onboarding_completed = TRUE,
                onboarding_step = 6,
                extra_agents = ?,
                extra_contacts = ?,
                temp_session_id = NULL
            WHERE id = ?`,
            [
              tierId, 
              stripeResult.customerId, 
              stripeResult.subscriptionId, 
              extraAgents || 0,
              extraContacts || 0,
              orgId
            ]
          );
          
          // Activate the admin user
          await dbInstance.execute(`
            UPDATE users
            SET is_active = 1
            WHERE organization_id = ? AND is_admin = 1`,
            [orgId]
          );
          
          // Set up the database for the organization
          const { TursoService } = await import('../services/turso');
          const turso = new TursoService();
          
          try {
            const { url, token } = await turso.createOrganizationDatabase(orgId.toString());
            
            // Update organization with Turso database credentials
            await dbInstance.execute(
              'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ? WHERE id = ?',
              [url, token, orgId]
            );
            
            logger.info(`Created Turso database for organization ${orgId}`);
          } catch (dbError) {
            logger.error(`Error creating database: ${dbError}`);
            // Continue execution even if this fails - can be set up later
          }
          
          logger.info(`Successfully completed payment for org ${orgSlug} (ID: ${orgId}) with plan ${tierId}`);
          
          // Return the client secret for frontend payment completion
          return {
            success: true,
            message: 'Subscription activated successfully',
            clientSecret: stripeResult.clientSecret,
            publishableKey: config.stripe.publishableKey,
            organizationId: orgId
          };
          
        } catch (stripeError) {
          logger.error(`Stripe subscription error: ${stripeError}`);
          set.status = 400;
          return {
            success: false,
            error: 'Failed to process subscription payment',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
      } catch (error) {
        logger.error(`Error processing payment: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to process payment',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to handle enterprise plan inquiries
    .post('/api/onboarding/enterprise', async ({ body, cookie, set }) => {
      try {
        // Get org slug from cookie
        const orgSlug = cookie.orgSlug;
        
        if (!orgSlug) {
          logger.warn('No organization slug found in cookie');
          set.status = 401;
          return { 
            success: false,
            message: 'No organization found in session',
            slug: ""  // Include an empty slug in error responses for decoder compatibility
          };
        }
        
        logger.info(`Processing enterprise inquiry for organization ${orgSlug}`);
        
        const { 
          companyName,
          contactName,
          email,
          phone,
          message
        } = body as { 
          companyName: string, 
          contactName: string, 
          email: string,
          phone: string,
          message?: string
        };
        
        // Find organization by slug
        const orgInfo = await dbInstance.query<{ id: number }>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found: ${orgSlug}`);
          set.status = 404;
          return { 
            success: false, 
            message: 'Organization not found',
            slug: orgSlug  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Update organization to enterprise tier
        await dbInstance.execute(
          'UPDATE organizations SET subscription_tier = ?, onboarding_step = 6 WHERE id = ?',
          ['enterprise', orgId]
        );
        
        // Import SendGrid to send enterprise request email
        const sgMail = await import('@sendgrid/mail');
        sgMail.default.setApiKey(process.env.SENDGRID_API_KEY || '');
        
        const emailContent = `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">New Enterprise Plan Inquiry (Onboarding)</h2>
            
            <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
              <p><strong>Company:</strong> ${companyName}</p>
              <p><strong>Contact Name:</strong> ${contactName}</p>
              <p><strong>Email:</strong> ${email}</p>
              <p><strong>Phone:</strong> ${phone}</p>
              <p><strong>Message:</strong></p>
              <p style="white-space: pre-line;">${message || 'No message provided'}</p>
            </div>
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
              <p><strong>Organization Info:</strong></p>
              <p>Organization ID: ${orgId}</p>
              <p>Organization Slug: ${orgSlug}</p>
            </div>
            
            <p style="color: #666; font-size: 14px;">
              This inquiry was submitted through the Enterprise Form during the onboarding process on MedicareMax.
            </p>
          </div>
        `;
        
        try {
          // Send email notification
          const emailMsg = {
            to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
            from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
            subject: `Enterprise Plan Inquiry from ${contactName} at ${companyName} (Onboarding)`,
            text: `New Enterprise Plan Inquiry (Onboarding):\n\nCompany: ${companyName}\nContact Name: ${contactName}\nEmail: ${email}\nPhone: ${phone}\n\nMessage: ${message || 'No message provided'}\n\nOrganization ID: ${orgId}\nOrganization Slug: ${orgSlug}\n\nThis inquiry was submitted through the Enterprise Form during onboarding on MedicareMax.`,
            html: emailContent
          };
          
          await sgMail.default.send(emailMsg);
          logger.info(`Enterprise inquiry email sent for organization ${orgSlug}`);
        } catch (emailError) {
          logger.error(`Error sending enterprise inquiry email: ${emailError}`);
          // Continue execution even if email fails
        }
        
        // Update onboarding step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_completed = TRUE, onboarding_step = 6 WHERE id = ?',
          [orgId]
        );
        
        // Activate the admin user
        await dbInstance.execute(
          'UPDATE users SET is_active = 1 WHERE organization_id = ? AND is_admin = 1',
          [orgId]
        );
        
        logger.info(`Successfully submitted enterprise inquiry for org ${orgSlug}`);
        
        return {
          success: true,
          message: 'Enterprise inquiry submitted successfully. Our sales team will contact you shortly.'
        };
        
      } catch (error) {
        logger.error(`Error processing enterprise inquiry: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to process enterprise inquiry',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })
    
    // Endpoint to complete the onboarding process
    .post('/api/onboarding/complete', async ({ cookie, set }) => {
      try {
        // Get org slug and session ID from cookies
        const orgSlug = cookie.orgSlug;
        const sessionToken = cookie.onboardingSession;
        
        if (!orgSlug || !sessionToken) {
          logger.warn('No organization slug or session ID found in cookie');
          set.status = 401;
          return { 
            success: false,
            message: 'No organization found in session or invalid session',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        logger.info(`Finalizing onboarding for organization ${orgSlug}`);
        
        // Find organization by slug and session token
        const orgInfo = await dbInstance.query<{ id: number }>(
          'SELECT id FROM organizations WHERE slug = ? AND temp_session_id = ?',
          [orgSlug, sessionToken]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Invalid session or organization slug: ${orgSlug}`);
          set.status = 401;
          return { 
            success: false, 
            message: 'Unauthorized: Invalid session',
            slug: orgSlug  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Mark onboarding as completed and clear temp session
        await dbInstance.execute(`
          UPDATE organizations 
          SET onboarding_completed = TRUE,
              onboarding_step = 6,
              temp_session_id = NULL
          WHERE id = ?`,
          [orgId]
        );
        
        // Activate the admin user
        await dbInstance.execute(`
          UPDATE users
          SET is_active = 1
          WHERE organization_id = ? AND is_admin = 1`,
          [orgId]
        );
        
        logger.info(`Successfully finalized onboarding for org ${orgSlug} (ID: ${orgId})`);
        
        return {
          success: true,
          message: 'Onboarding completed successfully'
        };
        
      } catch (error) {
        logger.error(`Error finalizing onboarding: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          message: 'Failed to finalize onboarding process',
          slug: cookie?.orgSlug || ""  // Include the slug in error responses for decoder compatibility
        };
      }
    })

    // New endpoint to get all onboarding settings for an organization
    .get('/api/organizations/:orgSlug/onboarding-settings', async ({ params, set, request }) => {
      try {
        const { orgSlug } = params;
        
        logger.info(`Fetching onboarding settings for organization ${orgSlug}`);
        
        // Find organization and its admin user
        const orgInfo = await dbInstance.query<{ 
          id: number, 
          name: string,
          onboarding_step: number,
          subscription_tier: string,
          website: string,
          phone: string,
          primary_color: string,
          secondary_color: string
        }>(
          `SELECT id, name, onboarding_step, subscription_tier, website, phone, primary_color, secondary_color
           FROM organizations 
           WHERE slug = ? AND onboarding_completed = FALSE
           LIMIT 1`,
          [orgSlug]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found or onboarding already completed: ${orgSlug}`);
          set.status = 404;
          return { 
            error: 'Organization not found or onboarding already completed',
            slug: orgSlug || ""  // Include the slug in error responses for decoder compatibility
          };
        }
        
        const orgId = orgInfo[0].id;
        
        // Get admin user details
        const userInfo = await dbInstance.query<{
          id: number,
          email: string,
          first_name: string,
          last_name: string,
          phone: string,
          booking_link: string
        }>(
          `SELECT id, email, first_name, last_name, phone, booking_link
           FROM users
           WHERE organization_id = ? AND is_admin = 1
           LIMIT 1`,
          [orgId]
        );
        
        // Get brand settings (for logo)
        const brandInfo = await dbInstance.query<{
          logo_data: string
        }>(
          `SELECT logo_data
           FROM brand_settings
           WHERE organization_id = ?
           LIMIT 1`,
          [orgId]
        );
        
        // Get licensing settings
        const licensingInfo = await dbInstance.query<{
          org_settings: string
        }>(
          `SELECT org_settings
           FROM organizations
           WHERE id = ?
           LIMIT 1`,
          [orgId]
        );
        
        // Parse carrier contracts and SmartSend settings from org_settings
        let carrierContracts = [];
        let useSmartSendForGI = false;
        try {
          if (licensingInfo.length > 0 && licensingInfo[0].org_settings) {
            const settings = JSON.parse(licensingInfo[0].org_settings);
            
            // Check if settings has a licensing property (new structure)
            if (settings.licensing && settings.licensing.carrierContracts) {
              carrierContracts = settings.licensing.carrierContracts;
            } else {
              // Fallback to old structure
              carrierContracts = settings.carrierContracts || [];
            }
            
            // Check for useSmartSendForGI in both places
            useSmartSendForGI = settings.useSmartSendForGI || 
                               (settings.licensing && settings.licensing.useSmartSendForGI) || 
                               false;
          }
        } catch (e) {
          logger.warn(`Error parsing org settings: ${e}`);
        }
        
        // Get agent list
        const agentList = await dbInstance.query<{
          id: number,
          email: string,
          first_name: string,
          last_name: string,
          phone: string,
          is_admin: number
        }>(
          `SELECT id, email, first_name, last_name, phone, is_admin
           FROM users
           WHERE organization_id = ? AND is_agent = 1 AND id NOT IN 
               (SELECT id FROM users WHERE organization_id = ? AND is_admin = 1 LIMIT 1)`,
          [orgId, orgId]
        );
        
        const agents = agentList.map(agent => ({
          id: agent.id,
          firstName: agent.first_name || '',
          lastName: agent.last_name || '',
          email: agent.email || '',
          phone: agent.phone || '',
          isAdmin: Boolean(agent.is_admin),
          isAgent: true
        }));
        
        // Build response structure
        const response = {
          onboardingStep: orgInfo[0].onboarding_step,
          planSelectionModel: {
            selectedPlan: orgInfo[0].subscription_tier || 'basic'
          },
          userDetailsModel: userInfo.length > 0 ? {
            firstName: userInfo[0].first_name || '',
            lastName: userInfo[0].last_name || '',
            email: userInfo[0].email || '',
            phone: userInfo[0].phone || '',
            bookingLink: userInfo[0].booking_link || ''
          } : null,
          companyDetailsModel: {
            agencyName: orgInfo[0].name || '',
            website: orgInfo[0].website || '',
            phone: orgInfo[0].phone || '',
            primaryColor: orgInfo[0].primary_color || '#0A0F4F',
            secondaryColor: orgInfo[0].secondary_color || '#7B61FF',
            logo: brandInfo.length > 0 ? brandInfo[0].logo_data : ''
          },
          licensingSettingsModel: {
            carrierContracts: carrierContracts,
            useSmartSendForGI: useSmartSendForGI
          },
          addAgentsModel: {
            agents: agents
          },
          paymentModel: {
            extraAgents: 0,
            extraContacts: 0
          },
          enterpriseFormModel: null
        };
        
        logger.info(`Retrieved onboarding settings for org ${orgSlug} (ID: ${orgId})`);
        
        return response;
        
      } catch (error) {
        logger.error(`Error fetching onboarding settings: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to fetch onboarding settings' 
        };
      }
    })

    // New endpoint to get user details for an organization
    .get('/api/onboarding/user-details', async ({ cookie, set, request }) => {
      try {
        // Get session ID from cookie or header (prefer cookie)
        const sessionId = cookie.onboardingSession || request.headers.get('x-onboarding-session');
        
        if (!sessionId) {
          logger.warn('No session ID found in cookie or header');
          set.status = 401;
          return { 
            error: 'No valid session found',
            success: false
          };
        }
        
        logger.info(`Fetching user details with session ID ${sessionId}`);
        
        // Find organization from session ID
        const orgInfo = await dbInstance.query<{ id: number, slug: string }>(
          'SELECT id, slug FROM organizations WHERE temp_session_id = ?',
          [sessionId]
        );
        
        if (!orgInfo || orgInfo.length === 0) {
          logger.warn(`Organization not found for session ID: ${sessionId}`);
          set.status = 404;
          return { 
            error: 'Organization not found or invalid session',
            success: false
          };
        }
        
        const orgId = orgInfo[0].id;
        const orgSlug = orgInfo[0].slug;
        
        // Get user details
        const userInfo = await dbInstance.query<{
          first_name: string,
          last_name: string,
          email: string,
          phone: string
        }>(
          `SELECT first_name, last_name, email, phone
           FROM users
           WHERE organization_id = ? AND is_admin = 1
           LIMIT 1`,
          [orgId]
        );
        
        if (!userInfo || userInfo.length === 0) {
          logger.warn(`No user found for organization ID: ${orgId}`);
          set.status = 404;
          return { 
            error: 'No user found for this organization',
            success: false
          };
        }
        
        // Return user details
        return {
          firstName: userInfo[0].first_name || '',
          lastName: userInfo[0].last_name || '',
          email: userInfo[0].email || '',
          phone: userInfo[0].phone || '',
          success: true,
          slug: orgSlug // Include slug for frontend reference
        };
        
      } catch (error) {
        logger.error(`Error fetching user details: ${error}`);
        set.status = 500;
        return { 
          error: 'Failed to fetch user details',
          success: false
        };
      }
    })
}

// Function to clean up old organizations that haven't completed onboarding
export async function cleanupOldOrganizations() {
  const dbInstance = new Database();
  
  try {
    logger.info('Running cleanup job for old organizations');
    
    // Find organizations older than 7 days
    const oldOrgs = await dbInstance.query<{ id: number }>(
      `SELECT id FROM organizations 
       WHERE created_at < datetime('now', '-7 days') 
       AND onboarding_completed = FALSE`
    );
    
    if (!oldOrgs || oldOrgs.length === 0) {
      logger.info('No old organizations to clean up');
      return;
    }
    
    logger.info(`Found ${oldOrgs.length} old organizations to check for cleanup`);
    
    for (const org of oldOrgs) {
      // Check if the organization has users
      const userCount = await dbInstance.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE organization_id = ?',
        [org.id]
      );
      
      // Check if the organization has a contact database
      const contactDbCount = await dbInstance.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM contact_databases WHERE organization_id = ?',
        [org.id]
      );
      
      // If no users and no contact database, delete the organization
      if (userCount[0]?.count === 0 && contactDbCount[0]?.count === 0) {
        logger.info(`Deleting old organization: ${org.id}`);
        await dbInstance.execute(
          'DELETE FROM organizations WHERE id = ?',
          [org.id]
        );
      }
    }
    
    logger.info('Completed cleanup job for old organizations');
  } catch (error) {
    logger.error(`Error in cleanup job: ${error}`);
  }
}

export default createOnboardingRoutes

================
File: src/routes/organizations.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { TursoService } from '../services/turso';
import { z } from 'zod';
import { sendMagicLink } from '../services/email';
import { generateToken, getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { AuthService } from '../services/auth';
import { config } from '../config';
import sgMail from '@sendgrid/mail';
import { cookie } from '@elysiajs/cookie';

// Update the validation schema to include slug rules
const signupSchema = z.object({
  organizationName: z.string()
    .min(1, "Organization name is required")
    .max(100, "Organization name must be less than 100 characters")
    .regex(/^[a-zA-Z0-9\s\-_.]+$/, "Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores"),
  adminFirstName: z.string().min(1, "First name is required"),
  adminLastName: z.string().min(1, "Last name is required"),
  adminEmail: z.string().email("Invalid email address"),
  phone: z.string().optional(),
  planType: z.string().optional(),
});

// Enhanced slug generation with uniqueness check
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

export const organizationRoutes = new Elysia({ prefix: '/api' })
  .post('/organizations/signup', async ({ body, set }) => {
    const db = new Database();
    const turso = new TursoService();
    const auth = new AuthService();

    try {
      logger.info(`Attempting to create organization with data: ${JSON.stringify(body)}`);
      const data = signupSchema.parse(body);
      
      // Generate unique slug
      const slug = await generateUniqueSlug(db, data.organizationName);
      logger.info(`Generated unique slug: ${slug}`);
      
      // Check if email is already registered in any organization
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
        [data.adminEmail]
      );

      logger.info(`Existing user check result: ${JSON.stringify(existingUser)}`);

      if (existingUser[0]?.count > 0) {
        logger.warn(`Email ${data.adminEmail} is already registered`);
        set.status = 400;
        return {
          success: false,
          message: 'This email address is already registered. Please use a different email or contact support.'
        };
      }

      // Check if organization name or slug is taken
      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [data.organizationName, slug]
      );

      logger.info(`Existing org check result: ${JSON.stringify(existingOrg)}`);

      if (existingOrg[0]?.count > 0) {
        logger.warn(`Organization name ${data.organizationName} or slug ${slug} is already taken`);
        set.status = 400;
        return {
          success: false,
          message: 'Organization name is already taken'
        };
      }

      // Wrap all database operations in a transaction
      const orgId = await db.transaction('write', async (transactionDb) => {
        // Create organization
        logger.info('Creating organization');
        const org = await transactionDb.execute(
          `INSERT INTO organizations (
            name,
            slug,
            subscription_tier,
            agent_limit,
            contact_limit
          ) VALUES (?, ?, 'basic', 5, 100) RETURNING id`,
          [data.organizationName, slug]
        );

        const orgId = org.rows?.[0]?.id;
        if (!orgId) {
          throw new Error('Failed to create organization');
        }

        logger.info(`Organization created with ID: ${orgId}`);

        // Create inactive admin user
        logger.info('Creating admin user');
        await transactionDb.execute(
          `INSERT INTO users (
            email,
            organization_id,
            is_admin,
            is_agent,
            is_active,
            first_name,
            last_name,
            created_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            data.adminEmail,
            orgId,
            1, // is_admin
            1, // is_agent - Set to 1 for basic tier since admin is also an agent
            1, // is_active
            data.adminFirstName,
            data.adminLastName,
            new Date().toISOString()
          ]
        );

        return orgId;
      });

      // Return success response without sending magic link
      set.status = 201;
      return { 
        success: true,
        message: 'Organization created successfully',
        slug: slug
      };

    } catch (error) {
      logger.error(`Organization creation error: ${error}`);
      set.status = 400;
      return {
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Failed to create organization. Please try again.'
      };
    }
  })
  .get('/organizations/check-name/:name', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedName = decodeURIComponent(params.name);
      const potentialSlug = decodedName
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');

      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [decodedName, potentialSlug]
      );

      const count = existingOrg[0]?.count || 0;

      if (count > 0) {
        return {
          available: false,
          message: 'Organization name is already taken'
        };
      }

      // Validate name format
      if (!/^[a-zA-Z0-9\s\-_.]+$/.test(decodedName)) {
        return {
          available: false,
          message: 'Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores'
        };
      }

      return {
        available: true,
        message: 'Organization name is available'
      };

    } catch (error) {
      logger.error(`Error checking organization name: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check organization name'
      };
    }
  })
  .get('/organizations/check-email/:email', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedEmail = decodeURIComponent(params.email);
      logger.info(`Checking email availability for: "${decodedEmail}"`);
      
      // Basic email format validation
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(decodedEmail)) {
        logger.info(`Email validation failed for: "${decodedEmail}"`);
        return {
          available: false,
          message: 'Invalid email format'
        };
      }

      // Use LOWER() for case-insensitive comparison to match unique constraint behavior
      logger.info(`Running SQL query: SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER('${decodedEmail}')`);
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
        [decodedEmail]
      );

      const count = existingUser[0]?.count || 0;
      logger.info(`Email check query result count: ${count} for email: "${decodedEmail}"`);

      if (count > 0) {
        logger.info(`Email "${decodedEmail}" is already registered`);
        return {
          available: false,
          message: 'This email address is already registered'
        };
      }

      logger.info(`Email "${decodedEmail}" is available`);
      return {
        available: true,
        message: 'Email is available'
      };

    } catch (error) {
      logger.error(`Error checking email: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check email availability'
      };
    }
  })
  .get('/organizations/subscription-tiers', async ({ set }) => {
    const db = new Database();
    try {
      const tiersResult = await db.query<{
        id: string,
        name: string,
        agent_limit: number,
        contact_limit: number,
        price_monthly: number,
        features: string
      }>('SELECT id, name, agent_limit, contact_limit, price_monthly, features FROM subscription_tiers');

      const tiers = tiersResult.map(tier => ({
        id: tier.id,
        name: tier.name,
        price: `$${(tier.price_monthly / 100).toFixed(0)}/mo`,
        agentLimit: tier.agent_limit,
        contactLimit: tier.contact_limit,
        features: JSON.parse(tier.features)
      }));

      return { success: true, tiers };
    } catch (error) {
      logger.error(`Error fetching subscription tiers: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to fetch subscription tiers' };
    }
  })
  .get('/organizations/:orgSlug/subscription', async ({ params, request, set }) => {
    try {
      const db = new Database();
      const orgSlug = params.orgSlug;
      
      logger.info(`GET /organizations/${orgSlug}/subscription - Request received`);
      
      // Get session cookie for debugging
      const sessionCookie = request.headers.get('cookie');
      logger.info(`Session cookie: ${sessionCookie ? 'Present' : 'Missing'}`);
      
      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('Subscription fetch failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Log request information for debugging
      logger.info(`Fetching subscription - orgSlug: ${orgSlug}, userId: ${currentUser.id}, orgId: ${currentUser.organization_id}`);
      
      // Get organization details
      const orgResult = await db.query<{ 
        id: number,
        subscription_tier: string,
        agent_limit: number,
        contact_limit: number
      }>(
        'SELECT id, subscription_tier, agent_limit, contact_limit FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`Subscription fetch failed: Organization not found - ${orgSlug}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Verify user has permission for this org
      if (organization.id !== currentUser.organization_id) {
        logger.error(`Subscription fetch failed: Permission denied - User from org ${currentUser.organization_id} attempted to access org ${organization.id}`);
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to view this organization'
        };
      }
      
      // Set up the response with subscription details
      const response = {
        success: true,
        tierId: organization.subscription_tier,
        agentLimit: organization.agent_limit,
        contactLimit: organization.contact_limit
      };

      logger.info(`Successfully fetched subscription for org ${organization.id}: tier=${organization.subscription_tier}, agents=${organization.agent_limit}, contacts=${organization.contact_limit}`);
      
      return response;
      
    } catch (error) {
      logger.error(`Error fetching organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to fetch subscription details'
      };
    }
  })
  .get('/organizations/my-subscription', async ({ request, set }) => {
    try {
      const db = new Database();
      
      logger.info('GET /organizations/my-subscription - Request received');
      
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('My subscription fetch failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Get organization details using user's organization_id
      const orgResult = await db.query<{ 
        id: number,
        name: string,
        slug: string,
        subscription_tier: string,
        agent_limit: number,
        contact_limit: number,
        stripe_subscription_id: string | null
      }>(
        'SELECT id, name, slug, subscription_tier, agent_limit, contact_limit, stripe_subscription_id FROM organizations WHERE id = ?',
        [currentUser.organization_id]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`My subscription fetch failed: Organization not found for user ${currentUser.id}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Get subscription tier details from subscription_tiers table
      const tierResult = await db.query<{
        name: string,
        agent_limit: number,
        contact_limit: number,
        features: string
      }>(
        'SELECT name, agent_limit, contact_limit, features FROM subscription_tiers WHERE id = ?',
        [organization.subscription_tier]
      );
      
      const tier = tierResult[0] || null;
      
      // Determine subscription status based on Stripe subscription
      const subscriptionStatus = organization.stripe_subscription_id ? 'active' : 'inactive';
      
      // Set up the response with complete subscription details
      const response = {
        success: true,
        organization: {
          id: organization.id,
          name: organization.name,
          slug: organization.slug
        },
        subscription: {
          tierId: organization.subscription_tier,
          tierName: tier?.name || organization.subscription_tier,
          status: subscriptionStatus,
          agentLimit: organization.agent_limit,
          contactLimit: organization.contact_limit,
          features: tier ? JSON.parse(tier.features) : []
        }
      };

      logger.info(`Successfully fetched my subscription for org ${organization.id}: tier=${organization.subscription_tier}, agents=${organization.agent_limit}, contacts=${organization.contact_limit}`);
      
      return response;
      
    } catch (error) {
      logger.error(`Error fetching my organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to fetch subscription details'
      };
    }
  })
  .post('/organizations/:orgSlug/subscription', async ({ params: { orgSlug }, body, request, set }) => {
    try {
      const db = new Database();

      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request)
      if (!currentUser) {
        set.status = 401
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        }
      }

      // Add more detailed logging
      logger.info(`Updating subscription - orgSlug: ${orgSlug}, userId: ${currentUser.organization_id}, body: ${JSON.stringify(body)}`);

      // First verify this user belongs to the organization they're trying to update
      const orgResult = await db.query<{ 
        id: number,
        stripe_customer_id: string | null,
        stripe_subscription_id: string | null,
        name: string
      }>(
        'SELECT id, stripe_customer_id, stripe_subscription_id, name FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404
        return {
          success: false,
          error: 'Organization not found'
        }
      }

      const organization = orgResult[0];

      // Verify user has permission for this org
      if (organization.id !== currentUser.organization_id) {
        logger.error(`User from org ${currentUser.organization_id} attempted to update org ${organization.id}`)
        set.status = 403
        return {
          success: false,
          error: 'You do not have permission to update this organization'
        }
      }

      // Parse the request body
      const { tierId, extraAgents = 0, extraContacts = 0 } = body as { 
        tierId: string, 
        extraAgents?: number, 
        extraContacts?: number 
      };
      
      // Import the Stripe service here to avoid circular dependencies
      const { createOrUpdateSubscription } = await import('../services/stripe');
      
      try {
        // Get user's email for Stripe customer
        const userResult = await db.query<{ email: string }>(
          'SELECT email FROM users WHERE id = ?',
          [currentUser.id]
        );
        
        if (!userResult || userResult.length === 0) {
          throw new Error('User not found');
        }
        
        // Create or update the Stripe subscription
        const stripeResult = await createOrUpdateSubscription({
          tierId: tierId as 'basic' | 'pro' | 'enterprise',
          organizationId: organization.id,
          email: userResult[0].email,
          extraAgents,
          extraContacts,
          stripeCustomerId: organization.stripe_customer_id || undefined
        });
        
        // Update organization with Stripe IDs and subscription tier
        await db.execute(
          `UPDATE organizations 
           SET subscription_tier = ?, 
               stripe_customer_id = ?, 
               stripe_subscription_id = ?
           WHERE id = ?`,
          [tierId, stripeResult.customerId, stripeResult.subscriptionId, organization.id]
        );
        
        // Set up the Turso database after subscription is saved
        const baseUrl = process.env.PUBLIC_URL || 'http://localhost:5173';
        const setupDbResponse = await fetch(`${baseUrl}/api/organizations/${orgSlug}/setup-database`, {
          method: 'POST',
          headers: {
            'Cookie': request.headers.get('cookie') || ''
          }
        });

        if (!setupDbResponse.ok) {
          logger.error(`Failed to set up database for org ${organization.id}`);
        } else {
          logger.info(`Successfully set up database for org ${organization.id}`);
        }

        logger.info(`Successfully updated subscription for org ${organization.id} to tier ${tierId}`);

        // Return the client secret for frontend payment completion
        return {
          success: true,
          message: 'Subscription updated successfully',
          clientSecret: stripeResult.clientSecret,
          publishableKey: config.stripe.publishableKey
        };
        
      } catch (stripeError) {
        logger.error(`Stripe subscription error: ${stripeError}`);
        set.status = 400;
        return {
          success: false,
          error: 'Failed to process subscription payment'
        };
      }

    } catch (e) {
      logger.error(`Error updating subscription: ${e}`)
      set.status = 500
      return {
        success: false,
        error: String(e)
      }
    }
  })
  // Add new endpoint to create Turso database after plan selection
  .post('/organizations/:orgSlug/setup-database', async ({ params, set }) => {
    const db = new Database();
    const turso = new TursoService();

    try {
      const orgSlug = params.orgSlug;

      // Get organization ID from slug
      const orgResult = await db.query<{ id: number, has_db: number }>(
        'SELECT id, CASE WHEN turso_db_url IS NOT NULL THEN 1 ELSE 0 END as has_db FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        return {
          success: false,
          message: 'Organization not found'
        };
      }

      const orgId = orgResult[0].id;

      if (orgResult[0].has_db === 1) {
        set.status = 400;
        return {
          success: false,
          message: 'Organization already has a database'
        };
      }

      // Create Turso database for the organization
      const { url, token } = await turso.createOrganizationDatabase(orgId.toString());

      // Update organization with Turso database credentials
      await db.execute(
        'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ? WHERE id = ?',
        [url, token, orgId]
      );

      logger.info(`Successfully created Turso database for organization ${orgId}`);

      return {
        success: true,
        message: 'Database created successfully'
      };

    } catch (error) {
      logger.error(`Error creating database for organization ${params.orgSlug}: ${error}`);
      set.status = 500;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return {
        success: false,
        message: `Failed to create database: ${errorMessage}`
      };
    }
  })
  // Get organization account status
  .get('/organizations/:orgSlug/account-status', async ({ params, set, request }) => {
    try {
      const db = new Database();
      
      // Authenticate the request
      const currentUser = await getUserFromSession(request);
      if (!currentUser) {
        set.status = 401;
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }
      
      // Get organization ID from slug
      const orgResult = await db.query<{ id: number }>(
        'SELECT id FROM organizations WHERE slug = ?',
        [params.orgSlug]
      );
      
      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        return {
          success: false,
          error: 'Organization not found'
        };
      }
      
      const organizationId = orgResult[0].id;
      
      // Verify user has permission to access this organization
      if (organizationId !== currentUser.organization_id) {
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to access this organization'
        };
      }
      
      // Import the subscription service
      const { checkAccountStatus } = await import('../services/subscription');
      
      // Check account status
      const statusDetails = await checkAccountStatus(organizationId);
      
      return {
        success: true,
        status: statusDetails
      };
      
    } catch (error) {
      logger.error(`Error checking account status: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  
  // Stripe webhook handler
  .post('/stripe-webhook', async ({ body, set, request }) => {
    try {
      const signature = request.headers.get('stripe-signature');
      
      if (!signature) {
        set.status = 400;
        return { success: false, error: 'Stripe signature missing' };
      }
      
      // Import Stripe to verify the webhook
      const Stripe = await import('stripe');
      const stripe = new Stripe.default(config.stripe.secretKey, {
        apiVersion: '2025-02-24.acacia',
      });
      
      const event = stripe.webhooks.constructEvent(
        JSON.stringify(body),
        signature,
        config.stripe.webhookSecret
      );
      
      // Import the Stripe service to handle the webhook
      const { handleStripeWebhook } = await import('../services/stripe');
      await handleStripeWebhook(event);
      
      logger.info(`Processed Stripe webhook: ${event.type}`);
      return { success: true };
      
    } catch (error) {
      logger.error(`Error processing Stripe webhook: ${error}`);
      set.status = 400;
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  // Add interface for enterprise contact form data
  .post('/enterprise-contact', async ({ body, set, request }: { 
    body: { name: string; email: string; phone: string; company: string; companySize?: string; message?: string }, 
    set: { status: number },
    request: Request 
  }) => {
    try {
      const { name, email, phone, company, companySize, message } = body;
      
      // Validate required fields
      if (!name || !email || !phone || !company) {
        set.status = 400;
        return { success: false, error: 'Missing required fields' };
      }
      
      // Try to get user/organization info from session if available
      let orgInfo = "";
      try {
        const user = await getUserFromSession(request);
        if (user) {
          orgInfo = `
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <p><strong>User is logged in with the following details:</strong></p>
            <p>Organization: ${user.organization_name} (ID: ${user.organization_id})</p>
            <p>User: ${user.first_name} ${user.last_name} (${user.email})</p>
          </div>`;
        }
      } catch (sessionError) {
        // Just log the error but continue - the session info is optional
        logger.warn(`Unable to get session info: ${sessionError}`);
      }
      
      // Format the email content
      const emailContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">New Enterprise Plan Inquiry</h2>
          
          <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
            <p><strong>Name:</strong> ${name}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Phone:</strong> ${phone}</p>
            <p><strong>Company:</strong> ${company}</p>
            <p><strong>Company Size:</strong> ${companySize || 'Not specified'}</p>
            <p><strong>Message:</strong></p>
            <p style="white-space: pre-line;">${message || 'No message provided'}</p>
          </div>
          ${orgInfo}
          <p style="color: #666; font-size: 14px;">
            This inquiry was submitted through the Enterprise Contact form on the MedicareMax portal.
          </p>
        </div>
      `;
      
      // Configure email
      const msg = {
        to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: `Enterprise Plan Inquiry from ${name} at ${company}`,
        text: `New Enterprise Plan Inquiry:\n\nName: ${name}\nEmail: ${email}\nPhone: ${phone}\nCompany: ${company}\nCompany Size: ${companySize || 'Not specified'}\n\nMessage: ${message || 'No message provided'}\n\n${orgInfo ? `User is logged in from organization: ${orgInfo}` : ''}\n\nThis inquiry was submitted through the Enterprise Contact form on the MedicareMax portal.`,
        html: emailContent
      };
      
      // Send the email
      await sgMail.send(msg);
      
      // Log successful submission
      logger.info(`Enterprise plan inquiry submitted by ${name} from ${company}`);
      
      // Return success response
      return { success: true };
    } catch (error) {
      logger.error(`Error processing enterprise contact submission: ${error}`);
      set.status = 500;
      return { 
        success: false, 
        error: 'Failed to process your request. Please try again later.' 
      };
    }
  })
  // Add endpoint for enterprise inquiry during onboarding
  .post('/enterprise-inquiry', async ({ body, set, request }: { 
    body: { companyName: string; contactName: string; email: string; phone: string; message?: string }, 
    set: { status: number },
    request: Request 
  }) => {
    try {
      const { companyName, contactName, email, phone, message } = body;
      
      // Validate required fields
      if (!companyName || !contactName || !email || !phone) {
        set.status = 400;
        return { success: false, error: 'Missing required fields' };
      }
      
      // Try to get user/organization info from session if available
      let orgInfo = "";
      try {
        const user = await getUserFromSession(request);
        if (user) {
          orgInfo = `
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <p><strong>User is logged in with the following details:</strong></p>
            <p>Organization: ${user.organization_name} (ID: ${user.organization_id})</p>
            <p>User: ${user.first_name} ${user.last_name} (${user.email})</p>
          </div>`;
        }
      } catch (sessionError) {
        // Just log the error but continue - the session info is optional
        logger.warn(`Unable to get session info: ${sessionError}`);
      }
      
      // Format the email content
      const emailContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">New Enterprise Plan Inquiry (Onboarding)</h2>
          
          <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
            <p><strong>Company:</strong> ${companyName}</p>
            <p><strong>Contact Name:</strong> ${contactName}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Phone:</strong> ${phone}</p>
            <p><strong>Message:</strong></p>
            <p style="white-space: pre-line;">${message || 'No message provided'}</p>
          </div>
          ${orgInfo}
          <p style="color: #666; font-size: 14px;">
            This inquiry was submitted through the Enterprise Form during the onboarding process on MedicareMax.
          </p>
        </div>
      `;
      
      // Configure email
      const msg = {
        to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: `Enterprise Plan Inquiry from ${contactName} at ${companyName} (Onboarding)`,
        text: `New Enterprise Plan Inquiry (Onboarding):\n\nCompany: ${companyName}\nContact Name: ${contactName}\nEmail: ${email}\nPhone: ${phone}\n\nMessage: ${message || 'No message provided'}\n\n${orgInfo ? `User is logged in from organization: ${orgInfo}` : ''}\n\nThis inquiry was submitted through the Enterprise Form during onboarding on MedicareMax.`,
        html: emailContent
      };
      
      // Send the email
      await sgMail.send(msg);
      
      // Log successful submission
      logger.info(`Enterprise plan inquiry (onboarding) submitted by ${contactName} from ${companyName}`);
      
      // Return success response
      return { success: true };
    } catch (error) {
      logger.error(`Error processing enterprise inquiry submission: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to process inquiry' };
    }
  });

export function createOrganizationRoutes() {
  const dbInstance = new Database();
  const authService = new AuthService();

  return new Elysia()
    .use(cookie())
    // Add a new endpoint for direct signup from UserDetails page
    .post('/api/organizations/signup', async ({ body, set, setCookie }) => {
      try {
        const { adminFirstName, adminLastName, adminEmail, phone, organizationName, planType } = body as {
          adminFirstName: string;
          adminLastName: string;
          adminEmail: string;
          phone?: string;
          organizationName: string;
          planType?: string;
        };

        // Validate input
        const validation = signupSchema.safeParse(body);
        if (!validation.success) {
          set.status = 400;
          return {
            success: false,
            message: validation.error.errors[0].message
          };
        }

        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [adminEmail]
        );

        if (existingUser[0]?.count > 0) {
          set.status = 400;
          return {
            success: false,
            message: 'This email address is already registered'
          };
        }

        // Generate a unique slug from the organization name
        const slug = await generateUniqueSlug(dbInstance, organizationName);

        // Create temporary session token
        const tempSessionId = generateToken();

        // Set session cookie for 24 hours
        setCookie('onboardingSession', tempSessionId, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/'
        });

        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/'
        });

        // Create organization
        const orgResult = await dbInstance.execute(`
          INSERT INTO organizations (
            name, 
            subscription_tier, 
            created_at, 
            onboarding_completed, 
            slug, 
            onboarding_step,
            temp_session_id
          ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
          [organizationName, planType || 'basic', slug, 2, tempSessionId]
        );

        const orgId = Number(orgResult.lastInsertRowid);
        logger.info(`Created organization: ${orgId} with slug: ${slug}`);

        // Create admin user
        await dbInstance.execute(
          `INSERT INTO users (
            email, 
            first_name, 
            last_name, 
            phone, 
            is_admin, 
            is_agent, 
            organization_id, 
            created_at,
            is_active
          ) VALUES (?, ?, ?, ?, 1, 1, ?, datetime('now'), 0)`,
          [adminEmail, adminFirstName, adminLastName, phone || '', orgId]
        );

        logger.info(`Created admin user for org ${slug} - Name: ${adminFirstName} ${adminLastName}, Email: ${adminEmail}`);

        // Generate a magic link for verification
        const magicLink = `${config.clientUrl}/auth/verify/${slug}/${tempSessionId}`;

        // Send welcome email
        try {
          await sendMagicLink({
            email: adminEmail,
            magicLink: magicLink,
            name: adminFirstName
          });
          logger.info(`Sent welcome email to ${adminEmail}`);
        } catch (emailError) {
          logger.error(`Failed to send welcome email: ${emailError}`);
          // Continue even if email fails
        }

        return {
          success: true,
          message: 'Organization and admin user created successfully',
          slug: slug
        };

      } catch (error) {
        logger.error(`Error creating organization: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to create organization'
        };
      }
    })
    
    // Add a new endpoint to check email availability
    .get('/api/organizations/check-email/:email', async ({ params, set }) => {
      try {
        const { email } = params;
        
        if (!email || !email.trim()) {
          set.status = 400;
          return {
            available: false,
            message: 'Email is required'
          };
        }
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          return {
            available: false,
            message: 'Invalid email format'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        const count = existingUser[0]?.count || 0;
        
        if (count > 0) {
          return {
            available: false,
            message: 'This email address is already registered'
          };
        }
        
        // If we get here, the email is available
        return {
          available: true,
          message: 'Email is available'
        };
        
      } catch (error) {
        logger.error(`Error checking email availability: ${error}`);
        set.status = 500;
        return {
          available: false,
          message: 'Error checking email availability'
        };
      }
    });
}

================
File: src/routes/quotes.ts
================
import { Elysia } from 'elysia';
import axios from 'axios';
import { config } from '../config';
import { logger } from '../logger';
import { Database } from '../database';
import { generateQuoteId, decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';
import { readFile } from 'fs/promises';
import { join } from 'path';
import { readFileSync } from 'fs';


interface ZipInfo {
  state: string;
  // Add other ZIP info properties as needed
}


// Update ZIP_DATA declaration
let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'))
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}


interface Quote {
    age: number;
    gender: string;
    plan: string;
    tobacco: number;
    rate: number;
    discount_rate: number;
    discount_category: string;
}

interface QuoteResponse {
    naic: string;
    group: number;
    company_name: string;
    quotes: Quote[];
}

interface QuoteRequestBody {
    zip_code: string;
    state: string;
    age: string | number;
    tobacco: string | boolean;
    gender: string;
    county?: string;
}

interface QuoteRequest {
    zip_code: string;
    state: string;
    age: number;
    tobacco: boolean;
    gender: string;
    plans: string[];
    carriers: string;
    county?: string;
}

interface ContactQuoteInfo {
    zip_code: string;
    birth_date: string;
    tobacco_user: number;
    gender: string;
    email: string;
    first_name: string;
    last_name: string;
    current_carrier: string;
    phone_number: string;
}

// Add new interface for org info response
interface OrgRedirectInfo {
    redirect_url: string | null;
    agent_name: string;
}

export const quotesRoutes = (app: Elysia) => {
    app
    .get('/api/quotes/generate/:contactId', async ({ params, request }) => {
        try {
            const user = await getUserFromSession(request);
            if (!user?.organization_id) {
                throw new Error('No organization ID found in session');
            }

            const contactId = parseInt(params.contactId);
            if (isNaN(contactId)) {
                throw new Error('Invalid contact ID');
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
            
            // Verify contact exists and belongs to this org
            const contact = await orgDb.fetchOne(
                'SELECT id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                throw new Error('Contact not found');
            }

            // Generate quote ID
            const quoteId = generateQuoteId(user.organization_id, contactId);

            return {
                success: true,
                quoteId,
                redirectUrl: `${process.env.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`
            };
        } catch (e) {
            logger.error(`Error generating quote ID: ${e}`);
            throw new Error(String(e));
        }
    })
    .get('/api/quotes/decode/:quoteId', async ({ params }) => {
        try {
            const decoded = decodeQuoteId(params.quoteId);
            if (!decoded) {
                throw new Error('Invalid quote ID');
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(decoded.orgId.toString());
            const mainDb = new Database();
            const result = await mainDb.fetchOne<{ slug: string, org_settings: string }>(
                'SELECT slug, org_settings FROM organizations WHERE id = ?',
                [decoded.orgId]
            );

            if (!result) {
                throw new Error('Organization not found');
            }

            const orgSlug = result.slug;
            const orgSettings = JSON.parse(result.org_settings);
            const carrierContracts = orgSettings?.carrierContracts || [];
            // Fetch contact details
            const contact = await orgDb.fetchOne<ContactQuoteInfo>(
                'SELECT zip_code, birth_date, tobacco_user, gender, email, first_name, last_name, current_carrier, phone_number FROM contacts WHERE id = ?',
                [decoded.contactId]
            );



            if (!contact) {
                throw new Error('Contact not found');
            }

            const zipInfo = ZIP_DATA[contact.zip_code];
            const contactState = zipInfo?.state;

            const output = {
                success: true,
                orgSlug: orgSlug || null,
                carrierContracts: carrierContracts || null,
                contact: {
                    zipCode: contact.zip_code,
                    state: contactState,
                    dateOfBirth: contact.birth_date,
                    tobacco: Boolean(contact.tobacco_user),
                    gender: contact.gender,
                    email: contact.email,
                    firstName: contact.first_name,
                    lastName: contact.last_name,
                    currentCarrier: contact.current_carrier,
                    phoneNumber: contact.phone_number
                }
            };

            logger.info(`Output: ${JSON.stringify(output, null, 2)}`);
            return output;
        } catch (e) {
            logger.error(`Error decoding quote ID: ${e}`);
            throw new Error(String(e));
        }
    })
    .post('/api/quotes', async ({ body }: { body: QuoteRequestBody }) => {
        try {
            // Format request body
            const requestBody: QuoteRequest = {
                zip_code: body.zip_code,
                state: body.state,
                age: Number(body.age),
                tobacco: body.tobacco === 'true' || body.tobacco === true,
                gender: body.gender,
                plans: ['G', 'N'],
                carriers: 'supported',
                county: body.county
            };

            // Log incoming request details
            logger.info(`Incoming quote request body: ${JSON.stringify(requestBody, null, 2)}`);
            
            // Construct request config
            const quoteEngineUrl = 'https://quote-engine.replit.app/quotes/';
            const requestConfig = {
                url: quoteEngineUrl,
                method: 'POST' as const,
                headers: {
                    'X-API-Key': config.quoteApiKey,
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                data: requestBody
            };

            // Make request to quote engine API
            const response = await axios(requestConfig);
            
            logger.info(`Quote engine response status: ${response.status}`);
            logger.info(`Quote engine response data: ${JSON.stringify(response.data, null, 2)}`);
            
            // Return quotes from response data
            return response.data;
        } catch (error) {
            logger.error(`Error fetching quotes: ${error}`);
            throw new Error(String(error));
        }
    })
    .get('/api/contact-request/org-info/:orgId', async ({ params }) => {
        try {
            const db = new Database();
            
            // Get organization info including redirect URL
            const orgResult = await db.fetchOne<{ redirect_url: string | null }>(
                'SELECT redirect_url FROM organizations WHERE id = ?',
                [params.orgId]
            );

            if (!orgResult) {
                throw new Error('Organization not found');
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(params.orgId);

            // Try to get default agent (first admin or agent)
            const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                `SELECT first_name, last_name 
                FROM users 
                WHERE (is_admin = 1 OR is_agent = 1) 
                AND is_active = 1 
                ORDER BY is_admin DESC, id ASC 
                LIMIT 1`
            );

            if (!defaultAgent) {
                throw new Error('No active agents or admins found');
            }

            return {
                success: true,
                redirect_url: orgResult.redirect_url,
                agent_name: `${defaultAgent.first_name} ${defaultAgent.last_name}`
            };
        } catch (e) {
            logger.error(`Error getting org redirect info: ${e}`);
            throw new Error(String(e));
        }
    })
    .post('/api/contact-request', async ({ body }) => {
        try {
            const { name, email, type, quoteId } = body as { 
                name: string;
                email: string;
                type: 'accept' | 'decline' | 'generic';
                quoteId?: string;
            };

            // Get contact info from quoteId if available
            let orgId: number | undefined;
            let contactId: number | undefined;
            let agentName: string | undefined;

            if (!quoteId) {
                throw new Error('Quote ID is required');
            }

            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                throw new Error('Invalid quote ID');
            }

            orgId = decoded.orgId;
            contactId = decoded.contactId;

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // If we have a contact ID, try to get the assigned agent's name
            if (contactId) {
                const contact = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT u.first_name, u.last_name 
                    FROM contacts c
                    JOIN users u ON c.agent_id = u.id
                    WHERE c.id = ? AND u.is_active = 1`,
                    [contactId]
                );
                if (contact) {
                    agentName = `${contact.first_name} ${contact.last_name}`;
                }
            }

            // If no agent assigned to contact, get default agent
            if (!agentName) {
                const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT first_name, last_name 
                    FROM users 
                    WHERE (is_admin = 1 OR is_agent = 1) 
                    AND is_active = 1 
                    ORDER BY is_admin DESC, id ASC 
                    LIMIT 1`
                );
                if (defaultAgent) {
                    agentName = `${defaultAgent.first_name} ${defaultAgent.last_name}`;
                }
            }

            // Store request in org-specific database
            await orgDb.execute(
                `INSERT INTO contact_requests (
                    name, email, request_type, contact_id, status, agent_name, created_at
                ) VALUES (?, ?, ?, ?, 'new', ?, CURRENT_TIMESTAMP)`,
                [name, email, type, contactId || null, agentName || null]
            );

            // Get org redirect URL from central database
            const db = new Database();
            const orgResult = await db.fetchOne<{ redirect_url: string | null }>(
                'SELECT redirect_url FROM organizations WHERE id = ?',
                [orgId]
            );

            return { 
                success: true,
                redirect: orgResult?.redirect_url ? { redirect_url: orgResult.redirect_url } : null
            };
        } catch (e) {
            logger.error(`Error saving contact request: ${e}`);
            throw new Error(String(e));
        }
    })
    // Add new endpoint for zip code information
    .get('/api/zipinfo/:zipCode', async ({ params }) => {
        try {
            const { zipCode } = params;
            
            // Read the zip data file from the ROOT directory, not the backend directory
            const zipDataPath = join(process.cwd(), '..', 'zipData.json');
            logger.info(`Looking for zip data at: ${zipDataPath}`);
            const zipDataContent = await readFile(zipDataPath, 'utf-8');
            const zipData = JSON.parse(zipDataContent);
            
            // Look up the zip code
            if (zipData[zipCode]) {
                return {
                    success: true,
                    data: zipData[zipCode]
                };
            } else {
                return {
                    success: false,
                    error: 'Zip code not found'
                };
            }
        } catch (error) {
            logger.error(`Error fetching zip code info: ${error}`);
            return {
                success: false,
                error: 'Failed to fetch zip code information'
            };
        }
    });

    return app;
};

================
File: src/routes/self-service.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import crypto from 'crypto';
import { config } from '../config';

// Import generateHash function - reimplementing it since it's not exported from email.ts
function generateHash(orgId: string, email: string): string {
  const SECRET = process.env.HASH_SECRET || 'default-hash-secret';
  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
}

export function createSelfServiceRoutes() {
  return new Elysia()
    .get('/api/self-service/init', async ({ query, set }) => {
      // Extract query parameters
      const { orgId, email, hash } = query as { 
        orgId?: string; 
        email?: string; 
        hash?: string;
      };

      // Validate required parameters
      if (!orgId) {
        set.status = 400;
        return { error: 'orgId is required' };
      }

      // Validate hash if email is provided
      if (email && hash) {
        const expectedHash = generateHash(orgId, email);
        if (hash !== expectedHash) {
          logger.warn(`Invalid hash for email ${email} and orgId ${orgId}`);
          set.status = 403;
          return { error: 'Invalid email or hash' };
        }
      }

      try {
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        
        // If email is provided, check for existing contact
        if (email) {
          const client = orgDb.getClient();
          const result = await client.execute({
            sql: `SELECT 
                  email, 
                  first_name AS firstName, 
                  last_name AS lastName, 
                  opt_in_quarterly_updates AS optInQuarterlyUpdates 
                FROM contacts 
                WHERE email = ?`,
            args: [email]
          });

          // If contact exists, return contact details
          if (result.rows.length > 0) {
            const contact = result.rows[0];
            logger.info(`Contact found for email ${email} in organization ${orgId}`);
            return { 
              contact, 
              email, 
              emailReadOnly: true 
            };
          }

          // If no contact exists but email is provided
          logger.info(`No contact found for email ${email} in organization ${orgId}`);
          return { 
            email, 
            emailReadOnly: true 
          };
        }

        // If no email is provided
        return { emailReadOnly: false };

      } catch (error) {
        logger.error(`Error in self-service init endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    .post('/api/self-service/signup', async ({ body, set }) => {
      const { orgId, email, firstName, lastName, optInQuarterlyUpdates } = body as {
        orgId: string;
        email: string;
        firstName: string;
        lastName: string;
        optInQuarterlyUpdates: boolean;
      };

      // Validate required parameters
      if (!orgId || !email || !firstName || !lastName) {
        set.status = 400;
        return { error: 'Missing required fields' };
      }

      try {
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        const client = orgDb.getClient();
        
        // Check if contact already exists
        const existingContact = await client.execute({
          sql: 'SELECT id FROM contacts WHERE email = ?',
          args: [email]
        });

        const timestamp = new Date().toISOString();

        if (existingContact.rows.length > 0) {
          // Update existing contact
          const contactId = existingContact.rows[0].id;
          await client.execute({
            sql: `UPDATE contacts SET 
                  first_name = ?, 
                  last_name = ?, 
                  opt_in_quarterly_updates = ?,
                  updated_at = ?
                  WHERE id = ?`,
            args: [firstName, lastName, optInQuarterlyUpdates ? 1 : 0, timestamp, contactId]
          });
          
          logger.info(`Updated contact ${contactId} for email ${email} in organization ${orgId}`);
        } else {
          // Create new contact
          const result = await client.execute({
            sql: `INSERT INTO contacts (
                  email, 
                  first_name, 
                  last_name, 
                  opt_in_quarterly_updates,
                  created_at,
                  updated_at
                ) VALUES (?, ?, ?, ?, ?, ?)`,
            args: [email, firstName, lastName, optInQuarterlyUpdates ? 1 : 0, timestamp, timestamp]
          });
          
          logger.info(`Created new contact for email ${email} in organization ${orgId}`);
        }

        return { success: true };
      } catch (error) {
        logger.error(`Error in self-service signup endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    .get('/api/self-service/:orgSlug', async ({ params, set, request }) => {
      const { orgSlug } = params;
      
      try {
        // For the 'latest' slug, get the current user's organization
        if (orgSlug === 'latest') {
          const userFromSession = await Database.getUserFromSession(request);
          if (!userFromSession) {
            set.status = 401;
            return { success: false, error: 'Unauthorized' };
          }
          
          const orgResult = await Database.getOrganizationById(userFromSession.organization_id);
          if (!orgResult) {
            set.status = 404;
            return { success: false, message: 'Organization not found' };
          }
          
          return {
            success: true,
            orgId: userFromSession.organization_id.toString(),
            orgSlug: orgResult.slug,
            selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgResult.slug}`
          };
        }
        
        // Regular slug lookup
        const db = new Database();
        const result = await db.query(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!result || result.length === 0) {
          set.status = 404;
          return { success: false, message: 'Organization not found' };
        }

        const orgId = result[0].id;
        
        // Return basic organization info for the frontend
        return {
          success: true,
          orgId: orgId.toString(),
          orgSlug,
          selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgSlug}`
        };
      } catch (error) {
        logger.error(`Error in self-service org slug endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    });
}

================
File: src/routes/settings.ts
================
import { Elysia } from 'elysia';
import { validateSession } from '../services/auth';
import { Database } from '../database';
import { type User } from '../types';
import { logger } from '../logger';
import { type Cookie } from '@elysiajs/cookie';
import { type BaseSettings } from '../types';

interface StateCarrierSetting {
  state: string;
  carrier: string;
  active: boolean;
  targetGI: boolean;
}

interface SettingsBody {
    settings?: BaseSettings;
    inheritOrgSettings?: boolean;
}

interface AgentSettingsResponse {
  orgSettings: BaseSettings;
  agentSettings: {
    inheritOrgSettings: boolean;
    settings: BaseSettings;
  } | null;
  canEditOrgSettings: boolean;
}

const defaultSettings: BaseSettings = {
  stateLicenses: [],
  carrierContracts: [],
  stateCarrierSettings: [],
  allowAgentSettings: true,
  emailSendBirthday: true,
  emailSendPolicyAnniversary: true,
  emailSendAep: true,
  smartSendEnabled: false
};

// Helper function to generate default state/carrier settings
function generateDefaultStateCarrierSettings(states: string[], carriers: string[]): StateCarrierSetting[] {
  return states.flatMap(state => 
    carriers.map(carrier => ({
      state,
      carrier,
      active: true,  // Default to active
      targetGI: false  // Default to no GI
    }))
  );
}

export const settingsRoutes = new Elysia()
  .get('/api/settings', async ({ cookie }) => {
    logger.info('GET /api/settings - Starting');
    
    const user = await validateSession(cookie.session);
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization settings
        const orgSettingsRow = await db.fetchOne<{ org_settings: string | null }>(
            'SELECT org_settings FROM organizations WHERE id = ?',
            [user.organization_id]
        );
        
        logger.info(`Retrieved org settings row`);

        // Parse the JSON string into an object
        let orgSettings: BaseSettings;
        try {
            orgSettings = orgSettingsRow?.org_settings 
                ? { ...defaultSettings, ...JSON.parse(orgSettingsRow.org_settings) }
                : { ...defaultSettings };

            // If we have states and carriers but no settings array, generate them
            if (orgSettings.stateLicenses.length > 0 && 
                orgSettings.carrierContracts.length > 0 && 
                !Array.isArray(orgSettings.stateCarrierSettings)) {
                
                logger.info('Generating default state/carrier settings');
                orgSettings.stateCarrierSettings = generateDefaultStateCarrierSettings(
                    orgSettings.stateLicenses,
                    orgSettings.carrierContracts
                );
            }
        } catch (parseError) {
            logger.error(`Error parsing org settings: ${parseError}`);
            orgSettings = { ...defaultSettings };
        }

        // Get agent settings if they exist
        const agentSettingsRow = await db.fetchOne<{ inherit_org_settings: boolean, settings: string | null }>(
            'SELECT inherit_org_settings, settings FROM agent_settings WHERE agent_id = ?',
            [user.id]
        );

        // Parse agent settings
        let agentSettings = null;
        if (agentSettingsRow) {
            try {
                const parsedSettings = agentSettingsRow.settings 
                    ? { ...defaultSettings, ...JSON.parse(agentSettingsRow.settings) }
                    : { ...defaultSettings };

                agentSettings = {
                    inheritOrgSettings: agentSettingsRow.inherit_org_settings,
                    settings: parsedSettings
                };
            } catch (parseError) {
                logger.error(`Error parsing agent settings: ${parseError}`);
            }
        }

        const canEditOrgSettings = user.is_admin;

        const response = {
            success: true,
            orgSettings,  // Now it's already an object, not a string
            agentSettings,
            canEditOrgSettings
        };

        logger.info(`Sending response`);
        return response;

    } catch (error) {
        logger.error(`Error fetching settings: ${error}`);
        return {
            success: false,
            error: 'Failed to load settings'
        };
    }
  })

  .put('/api/settings/:scope', async ({ cookie, body, params }) => {
    const { scope } = params;
    logger.info(`PUT /api/settings/${scope} - Starting`);
    
    const user = await validateSession(cookie?.session?.toString() || '');
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization's subscription tier
        const orgRow = await db.fetchOne<{ subscription_tier: string }>(
            'SELECT subscription_tier FROM organizations WHERE id = ?',
            [user.organization_id]
        );

        const isBasicTier = orgRow?.subscription_tier === 'basic';
        const typedBody = body as SettingsBody;

        if (scope === 'org') {
            logger.info('Updating organization settings');
            
            // Update organization settings
            await db.execute(
                'UPDATE organizations SET org_settings = ? WHERE id = ?',
                [JSON.stringify(typedBody), user.organization_id]
            );

            // For basic tier, also update the admin agent's settings
            if (isBasicTier) {
                logger.info('Basic tier detected - syncing settings to admin agent');
                
                // Get the admin agent's ID
                const adminAgentRow = await db.fetchOne<{ id: number }>(
                    'SELECT id FROM users WHERE organization_id = ? AND is_admin = 1 AND is_agent = 1 LIMIT 1',
                    [user.organization_id]
                );

                if (adminAgentRow) {
                    // Update agent settings with organization settings and set inherit_org_settings to true
                    await db.execute(
                        `INSERT INTO agent_settings (agent_id, inherit_org_settings, settings)
                         VALUES (?, true, ?)
                         ON CONFLICT (agent_id) DO UPDATE
                         SET inherit_org_settings = true, settings = ?`,
                        [adminAgentRow.id, JSON.stringify(typedBody), JSON.stringify(typedBody)]
                    );
                    logger.info('Successfully synced settings to admin agent');
                }
            }
        } else if (scope === 'agent') {
            // For basic tier, don't allow direct agent settings updates
            if (isBasicTier) {
                return {
                    success: false,
                    error: 'Agent settings cannot be modified directly in basic tier - update organization settings instead'
                };
            }

            logger.info('Updating agent settings');
            logger.info(`Agent settings body: ${JSON.stringify(typedBody, null, 2)}`);

            try {
                await db.execute(
                    `INSERT INTO agent_settings (agent_id, inherit_org_settings, settings)
                     VALUES (?, ?, ?)
                     ON CONFLICT (agent_id) DO UPDATE
                     SET inherit_org_settings = ?, settings = ?`,
                    [
                        user.id,
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings),
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings)
                    ]
                );
                logger.info('Agent settings updated successfully');
            } catch (dbError) {
                logger.error(`Database execute error details: ${JSON.stringify(dbError, null, 2)}`);
                throw dbError;
            }
        }

        return {
            success: true,
            settings: typedBody.settings || typedBody
        };
    } catch (error) {
        logger.error(`Error updating settings: ${error}`);
        logger.error(`Error stack: ${(error as Error).stack}`);
        return {
            success: false,
            error: 'Failed to update settings'
        };
    }
  })

  // Update the GI recommendations endpoint to use Elysia style
  .get('/api/settings/gi-recommendations', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const recommendations = await db.fetchAll<{ state: string; carrier: string }>(
        `SELECT state, carrier
         FROM guaranteed_issue_recommendations
         ORDER BY carrier, state`
      );

      // Transform the results to match the expected format
      const formattedRecommendations = recommendations.map(rec => ({
        state: rec.state,
        carrier: rec.carrier,
        active: true,
        targetGI: true
      }));

      return formattedRecommendations;

    } catch (error) {
      logger.error('Error fetching GI recommendations:', error);
      return { success: false, error: 'Failed to fetch GI recommendations' };
    }
  })

  // Update carriers endpoint to use Elysia style
  .get('/api/settings/carriers', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll<{ name: string }>(
        `SELECT name
         FROM carriers
         ORDER BY name`
      );

      return carriers;

    } catch (error) {
      logger.error('Error fetching carriers:', error);
      return { success: false, error: 'Failed to fetch carriers' };
    }
  })

  .get('/api/settings/carriers-with-aliases', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll<{ name: string, aliases: string | null }>(
        `SELECT name, aliases
         FROM carriers
         ORDER BY name`
      );

      return carriers.map(carrier => ({
        name: carrier.name,
        aliases: carrier.aliases ? JSON.parse(carrier.aliases) : []
      }));

    } catch (error) {
      logger.error('Error fetching carriers with aliases:', error);
      return { success: false, error: 'Failed to fetch carriers with aliases' };
    }
  });

================
File: src/routes/stripe.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { config } from '../config';
import { getUserFromSession } from '../services/auth';

// Mock Stripe if not available
let stripe: any;
try {
  if (config.stripeApiKey) {
    // @ts-ignore - Dynamic import for Stripe
    stripe = require('stripe')(config.stripeApiKey);
  } else {
    // Mock Stripe for development
    stripe = {
      checkout: {
        sessions: {
          create: async () => ({ id: `test_session_id_${Date.now()}` })
        }
      },
      webhooks: {
        constructEvent: () => ({ 
          type: 'test.event', 
          data: { object: {} } 
        })
      }
    };
    logger.info('Using mock Stripe implementation');
  }
} catch (error) {
  logger.error(`Error loading Stripe: ${error}`);
  // Create a mock implementation
  stripe = {
    checkout: {
      sessions: {
        create: async () => ({ id: `test_session_id_${Date.now()}` })
      }
    },
    webhooks: {
      constructEvent: () => ({ 
        type: 'test.event', 
        data: { object: {} } 
      })
    }
  };
  logger.info('Using mock Stripe implementation due to error');
}

export const createStripeRoutes = () => {
  return new Elysia({ prefix: '/api/stripe' })
    // Create a Stripe checkout session
    .post('/create-checkout-session', async ({ body, set, request }) => {
      const db = new Database();
      
      try {
        const user = await getUserFromSession(request);
        if (!user) {
          set.status = 401;
          return { error: 'Unauthorized' };
        }
        
        const { orgSlug, tierId, extraAgents, extraContacts } = body as {
          orgSlug: string;
          tierId: string;
          extraAgents: number;
          extraContacts: number;
        };
        
        // Get the organization
        const organization = await db.query(
          'SELECT id, name, stripe_customer_id FROM organizations WHERE slug = ?',
          [orgSlug]
        ).then(rows => rows[0]);
        
        if (!organization) {
          set.status = 404;
          return { error: 'Organization not found' };
        }
        
        // Get the subscription tier pricing
        const tier = await db.query(
          'SELECT id, name, price_monthly, agent_limit, contact_limit FROM subscription_tiers WHERE id = ?',
          [tierId]
        ).then(rows => rows[0]);
        
        if (!tier) {
          set.status = 404;
          return { error: 'Subscription tier not found' };
        }
        
        // Calculate the total price
        const basePriceInCents = Number(tier.price_monthly);
        const extraAgentPriceInCents = extraAgents * 2000; // $20 per agent
        const extraContactsPackages = Math.ceil(extraContacts / 5000);
        const extraContactsPriceInCents = extraContactsPackages * 5000; // $50 per 5000 contacts
        
        const totalPriceInCents = basePriceInCents + extraAgentPriceInCents + extraContactsPriceInCents;
        
        let sessionConfig: any = {
          payment_method_types: ['card'],
          line_items: [
            {
              price_data: {
                currency: 'usd',
                product_data: {
                  name: tier.name + ' Plan',
                  description: `Includes ${tier.agent_limit} agents and ${tier.contact_limit} contacts`
                },
                unit_amount: basePriceInCents
              },
              quantity: 1
            }
          ],
          mode: 'subscription',
          success_url: config.clientUrl + '/dashboard?payment_success=true',
          cancel_url: config.clientUrl + '/change-plan?payment_canceled=true',
        };
        
        // Add extra agents if any
        if (extraAgents > 0) {
          sessionConfig.line_items.push({
            price_data: {
              currency: 'usd',
              product_data: {
                name: 'Extra Agents',
                description: `${extraAgents} additional agents at $20/agent/month`
              },
              unit_amount: 2000,
            },
            quantity: extraAgents
          });
        }
        
        // Add extra contacts if any
        if (extraContacts > 0) {
          sessionConfig.line_items.push({
            price_data: {
              currency: 'usd',
              product_data: {
                name: 'Extra Contacts',
                description: `${extraContactsPackages} packages of 5,000 contacts at $50/package/month`
              },
              unit_amount: 5000,
            },
            quantity: extraContactsPackages
          });
        }
        
        // If organization already has a Stripe customer ID, use it
        if (organization.stripe_customer_id) {
          sessionConfig.customer = organization.stripe_customer_id;
        } else {
          sessionConfig.customer_email = user.email;
        }

        // Create the checkout session
        let session;
        if (config.stripeApiKey) {
          session = await stripe.checkout.sessions.create(sessionConfig);
        } else {
          // For development without Stripe API key
          logger.info('Creating test checkout session with config:', sessionConfig);
          session = { id: 'test_session_id_' + Date.now() };
        }
        
        // Store the checkout session ID in the database for later verification
        await db.execute(
          `UPDATE organizations 
           SET stripe_checkout_session = ? 
           WHERE id = ?`,
          [session.id, organization.id]
        );
        
        // Return the session ID to the client
        return { sessionId: session.id };
        
      } catch (error) {
        logger.error('Error creating checkout session:', error);
        set.status = 500;
        return { error: 'Failed to create checkout session' };
      }
    })
    
    // Redirect to Stripe checkout
    .get('/redirect-to-checkout', async ({ query, set }) => {
      const sessionId = query.session_id as string;
      
      if (!sessionId) {
        set.status = 400;
        return { error: 'Session ID is required' };
      }
      
      // In production, you would use Stripe's client-side SDK to redirect
      // For this demo, we'll simulate by redirecting to a success page
      if (config.stripeApiKey) {
        set.redirect = `https://checkout.stripe.com/pay/${sessionId}`;
      } else {
        // Simulate successful payment in development
        set.redirect = '/dashboard?payment_success=true&test_mode=true';
      }
      
      return {};
    })
    
    // Webhook for Stripe events (payment completion, etc.)
    .post('/webhook', async ({ body, request, set }) => {
      let event;
      const db = new Database();
      
      try {
        const signature = request.headers.get('stripe-signature');
        
        if (config.stripeWebhookSecret && config.stripeApiKey && signature) {
          event = stripe.webhooks.constructEvent(
            body, // Raw body needed here
            signature,
            config.stripeWebhookSecret
          );
        } else {
          // For development without Stripe
          event = { 
            type: 'checkout.session.completed',
            data: { object: body } 
          };
        }
        
        // Handle the event
        if (event.type === 'checkout.session.completed') {
          await handleCheckoutComplete(event.data.object, db);
        } else {
          logger.info(`Unhandled event type ${event.type}`);
        }
        
        set.status = 200;
        return { received: true };
      } catch (error) {
        logger.error('Error processing webhook:', error);
        set.status = 400;
        return { error: `Webhook Error: ${error instanceof Error ? error.message : 'Unknown error'}` };
      }
    });
};

async function handleCheckoutComplete(session: any, db: Database): Promise<void> {
  try {
    // Find the organization by checkout session ID
    const organization = await db.query(
      `SELECT id, slug FROM organizations WHERE stripe_checkout_session = ?`,
      [session.id]
    ).then(rows => rows[0]);
    
    if (!organization) {
      logger.error('Organization not found for checkout session:', session.id);
      return;
    }
    
    // Update the organization with the subscription info
    await db.execute(
      `UPDATE organizations 
       SET stripe_subscription_id = ?, 
           stripe_customer_id = ?,
           stripe_checkout_session = NULL,
           agent_limit = (SELECT agent_limit FROM subscription_tiers WHERE id = ?) + ?,
           contact_limit = (SELECT contact_limit FROM subscription_tiers WHERE id = ?) + ?,
           subscription_tier = ?
       WHERE id = ?`,
      [
        session.subscription, 
        session.customer, 
        session.metadata?.tierId || 'basic',
        Number(session.metadata?.extraAgents || 0),
        session.metadata?.tierId || 'basic',
        Number(session.metadata?.extraContacts || 0),
        session.metadata?.tierId || 'basic',
        organization.id
      ]
    );
    
    logger.info(`Subscription updated for organization: ${organization.slug}`);
  } catch (error) {
    logger.error('Error handling checkout completion:', error);
  }
}

================
File: src/services/agentSettings.ts
================
import { db } from '../database';
import { NotFoundError } from '../errors';
import { logger } from '../logger';

export interface StateCarrierSetting {
  active: boolean;
  targetGI: boolean;
}

export interface AgentSettings {
  id: number;
  agentId: number;
  stateLicenses: string[];
  carrierContracts: string[];
  stateCarrierSettings: {
    [state: string]: {
      [carrier: string]: StateCarrierSetting;
    };
  };
  emailSendBirthday: boolean;
  emailSendPolicyAnniversary: boolean;
  emailSendAep: boolean;
  smartSendEnabled: boolean;
}

export async function getAgentSettings(agentId: number): Promise<AgentSettings> {
  try {
    const result = await db.oneOrNone(
      'SELECT * FROM agent_settings WHERE agent_id = $1',
      [agentId]
    )

    if (!result) {
      // Return default settings instead of creating them
      return {
        id: 0,
        agentId: agentId,
        stateLicenses: [],
        carrierContracts: [],
        stateCarrierSettings: {},
        emailSendBirthday: false,
        emailSendPolicyAnniversary: false,
        emailSendAep: false,
        smartSendEnabled: false
      }
    }

    return {
      id: result.id,
      agentId: result.agent_id,
      stateLicenses: result.state_licenses || [],
      carrierContracts: result.carrier_contracts || [],
      stateCarrierSettings: result.state_carrier_settings || {},
      emailSendBirthday: result.email_send_birthday || false,
      emailSendPolicyAnniversary: result.email_send_policy_anniversary || false,
      emailSendAep: result.email_send_aep || false,
      smartSendEnabled: result.smart_send_enabled || false,
    }
  } catch (error) {
    logger.error(`Error fetching agent settings: ${error}`)
    // Return default settings on error
    return {
      id: 0,
      agentId: agentId,
      stateLicenses: [],
      carrierContracts: [],
      stateCarrierSettings: {},
      emailSendBirthday: false,
      emailSendPolicyAnniversary: false,
      emailSendAep: false,
      smartSendEnabled: false
    }
  }
}

async function createDefaultSettings(agentId: number): Promise<AgentSettings> {
  const result = await db.one(
    `INSERT INTO agent_settings 
     (agent_id, state_licenses, carrier_contracts, state_carrier_settings)
     VALUES ($1, $2, $3, $4)
     RETURNING *`,
    [agentId, [], [], {}]
  );

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

export async function updateAgentSettings(
  agentId: number,
  settings: Partial<AgentSettings>
): Promise<AgentSettings> {
  const result = await db.oneOrNone(
    `UPDATE agent_settings
     SET state_licenses = COALESCE($1, state_licenses),
         carrier_contracts = COALESCE($2, carrier_contracts),
         state_carrier_settings = COALESCE($3, state_carrier_settings),
         email_send_birthday = COALESCE($4, email_send_birthday),
         email_send_policy_anniversary = COALESCE($5, email_send_policy_anniversary),
         email_send_aep = COALESCE($6, email_send_aep),
         smart_send_enabled = COALESCE($7, smart_send_enabled)
     WHERE agent_id = $8
     RETURNING *`,
    [
      settings.stateLicenses,
      settings.carrierContracts,
      settings.stateCarrierSettings,
      settings.emailSendBirthday,
      settings.emailSendPolicyAnniversary,
      settings.emailSendAep,
      settings.smartSendEnabled,
      agentId,
    ]
  );

  if (!result) {
    throw new NotFoundError('Agent settings not found');
  }

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

================
File: src/services/auth.ts
================
import crypto from 'crypto';
import { logger } from '../logger';
import { db } from '../database';
import { Database } from '../database';
import type { User } from '../types';
import { config } from '../config';

const algorithm = "aes-256-gcm";
const IV_LENGTH = 12;
const UTF8 = "utf8";
const HEX = "hex";

// Initialize encryption key
let secret = process.env.MAGIC_LINK_SECRET;
if (!secret) {
  if (process.env.NODE_ENV === "production") {
    throw new Error("Must set MAGIC_LINK_SECRET in production");
  }
  secret = "dev-secret-key";
}

const ENCRYPTION_KEY = crypto.scryptSync(secret, "salt", 32);

interface MagicLinkPayload {
  email: string;
  organizationSlug: string;
  expiresAt: number;
  redirectUrl: string;
  orgId?: number;
  name?: string;
}

export class AuthService {
  constructor(private baseUrl?: string) {
    // If no baseUrl is provided, get it from config
    if (!baseUrl) {
      this.baseUrl = config.PUBLIC_URL;
    } else {
      // Ensure baseUrl doesn't end with a slash
      this.baseUrl = baseUrl.replace(/\/$/, '');
    }
    
    logger.info(`AuthService initialized with baseUrl: ${this.baseUrl}`);
  }

  async createMagicLink(
    email: string, 
    organizationSlug: string, 
    options?: { 
      redirectUrl?: string;
      orgId?: number;
      name?: string;
    }
  ): Promise<string> {
    const payload: MagicLinkPayload = {
      email,
      organizationSlug,
      expiresAt: Date.now() + (30 * 60 * 1000), // 30 minutes
      redirectUrl: options?.redirectUrl || '/dashboard',
      ...(options?.orgId && { orgId: options.orgId }),
      ...(options?.name && { name: options.name })
    };

    logger.info(`Creating magic link with payload: ${JSON.stringify(payload)}`);
    const token = this.encrypt(JSON.stringify(payload));
    // URL encode the entire token
    const encodedToken = encodeURIComponent(token);
    logger.info(`Generated magic link token: ${token}`);
    return `${this.baseUrl}/auth/verify/${organizationSlug}/${encodedToken}`;
  }

  async verifyMagicLink(token: string, organizationSlug: string): Promise<{
    valid: boolean;
    email?: string;
    redirectUrl?: string;
  }> {
    try {
      logger.info('Starting magic link verification');
      logger.info(`Organization slug: ${organizationSlug}`);

      const decodedToken = decodeURIComponent(token);
      const decrypted = this.decrypt(decodedToken);
      const payload: MagicLinkPayload = JSON.parse(decrypted);

      // Verify organization and expiration
      if (payload.organizationSlug !== organizationSlug) {
        logger.error(`Organization slug mismatch: ${payload.organizationSlug} !== ${organizationSlug}`);
        return { valid: false };
      }

      if (payload.expiresAt < Date.now()) {
        logger.error(`Token expired: ${new Date(payload.expiresAt)} < ${new Date()}`);
        return { valid: false };
      }

      // No need to check agent status here since we only send links to valid agents

      logger.info('Verification successful, returning payload');
      return {
        valid: true,
        email: payload.email,
        redirectUrl: payload.redirectUrl
      };

    } catch (error) {
      logger.error(`Magic link verification failed: ${error}`);
      return { valid: false };
    }
  }

  private encrypt(text: string): string {
    try {
      const iv = crypto.randomBytes(IV_LENGTH);
      const cipher = crypto.createCipheriv(algorithm, ENCRYPTION_KEY, iv);
      let encrypted = cipher.update(text, UTF8, HEX);
      encrypted += cipher.final(HEX);
      const authTag = cipher.getAuthTag();
      
      const token = `${iv.toString(HEX)}:${authTag.toString(HEX)}:${encrypted}`;
      return token;
    } catch (error) {
      logger.error(`Encryption failed: ${error}`);
      throw error;
    }
  }

  private decrypt(text: string): string {
    try {
      const [ivPart, authTagPart, encryptedText] = text.split(":");
      if (!ivPart || !authTagPart || !encryptedText) {
        throw new Error("Invalid token format - missing parts");
      }

      logger.info('Decrypting token parts:');
      logger.info(`IV length: ${ivPart.length}`);
      logger.info(`Auth tag length: ${authTagPart.length}`);
      logger.info(`Encrypted text length: ${encryptedText.length}`);

      const iv = Buffer.from(ivPart, HEX);
      const authTag = Buffer.from(authTagPart, HEX);
      const decipher = crypto.createDecipheriv(algorithm, ENCRYPTION_KEY, iv);
      decipher.setAuthTag(authTag);
      let decrypted = decipher.update(encryptedText, HEX, UTF8);
      decrypted += decipher.final(UTF8);
      return decrypted;
    } catch (error) {
      logger.error(`Decryption failed: ${error}`);
      throw error;
    }
  }
}

export async function validateSession(sessionId: string): Promise<User | null> {
  logger.info(`Validating session: ${sessionId}`);
  
  const db = new Database();

  // Get the session
  const session = await db.fetchOne<{
    id: string;
    user_id: number;
    expires_at: string;
  }>('SELECT * FROM sessions WHERE id = ?', [sessionId]);

  logger.info(`Session lookup result: ${session ? JSON.stringify(session) : 'not found'}`);

  if (!session) {
    logger.warn('No session found in database');
    return null;
  }

  // Check if session is expired
  const expiresAt = new Date(session.expires_at);
  const now = new Date();
  logger.info(`Session expires: ${expiresAt}, current time: ${now}`);

  if (expiresAt < now) {
    logger.warn('Session is expired');
    await db.execute('DELETE FROM sessions WHERE id = ?', [sessionId]);
    return null;
  }

  // Get the user associated with this session with updated columns
  const user = await db.fetchOne<User>(
    `SELECT 
      u.id,
      u.email,
      u.organization_id,
      u.is_admin,
      u.is_agent,
      u.first_name,
      u.last_name,
      u.is_active,
      u.phone,
      o.name as organization_name 
     FROM users u
     JOIN organizations o ON u.organization_id = o.id 
     WHERE u.id = ?`,
    [session.user_id]
  );

  logger.info(`User lookup result: ${user ? JSON.stringify(user) : 'not found'}`);

  return user;
}

export function generateToken(): string {
  return crypto.randomBytes(32).toString('hex');
}

export async function getUserFromSession(request: Request) {
  try {
    // Get session cookie
    const sessionId = request.headers.get('cookie')?.split('session=')[1]?.split(';')[0];
    
    if (!sessionId) {
      logger.warn('No session cookie found');
      return null;
    }

    // Initialize database
    const db = new Database();

    // Get session data
    const sessionResult = await db.fetchAll(
      'SELECT user_id FROM sessions WHERE id = ?',
      [sessionId]
    );

    if (!sessionResult || sessionResult.length === 0) {
      logger.warn(`No session found for ID: ${sessionId}`);
      return null;
    }

    const userId = sessionResult[0][0];

    // Updated query to use is_admin and is_agent
    const userResult = await db.fetchAll(
      `SELECT 
        u.id,
        u.email,
        u.organization_id,
        u.is_admin,
        u.is_agent,
        u.first_name,
        u.last_name,
        u.is_active,
        u.phone,
        o.name as organization_name
       FROM users u
       JOIN organizations o ON u.organization_id = o.id 
       WHERE u.id = ?`,
      [userId]
    );

    if (!userResult || userResult.length === 0) {
      logger.warn('No user found for session');
      return null;
    }

    const user = {
      id: userResult[0][0],
      email: userResult[0][1],
      organization_id: userResult[0][2],
      is_admin: Boolean(userResult[0][3]),
      is_agent: Boolean(userResult[0][4]),
      first_name: userResult[0][5],
      last_name: userResult[0][6],
      is_active: userResult[0][7],
      phone: userResult[0][8],
      organization_name: userResult[0][9]
    };

    return user;

  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

================
File: src/services/email.ts
================
import sgMail from '@sendgrid/mail';
import { logger } from '../logger';
import crypto from 'crypto';


interface MagicLinkEmailParams {
  email: string;
  token: string;
  orgId: number;
  name: string;
}

export class EmailService {
  constructor() {
    if (!process.env.SENDGRID_API_KEY) {
      throw new Error('Missing SENDGRID_API_KEY environment variable');
    }
    sgMail.setApiKey(process.env.SENDGRID_API_KEY);
  }

  async sendMagicLink(email: string, magicLink: string, organizationSlug: string) {
    try {
      const msg = {
        to: email,
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: 'Your Login Link',
        text: `Click this link to log in: ${magicLink}\n\nThis link will expire in 30 minutes.`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">Welcome to MedicareMax</h2>
            <p>Click the button below to log in to your account. This link will expire in 30 minutes.</p>
            <div style="margin: 30px 0;">
              <a href="${magicLink}" 
                 style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                        text-decoration: none; border-radius: 4px; display: inline-block;">
                Log In
              </a>
            </div>
            <p style="color: #666; font-size: 14px;">
              If the button doesn't work, copy and paste this link into your browser:
              <br>
              <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
            </p>
          </div>
        `
      };

      await sgMail.send(msg);
      logger.info(`Magic link email sent successfully to ${email}`);
    } catch (error) {
      logger.error(`Error sending magic link email: ${error}`);
      throw new Error('Failed to send magic link email');
    }
  }

  async sendQuoteEmail(params: {
    email: string;
    firstName: string;
    lastName: string;
    quoteUrl: string;
    planType: string;
  }) {
    try {
      const { email, firstName, lastName, quoteUrl, planType } = params;
      const fullName = `${firstName} ${lastName}`;
      
      const msg = {
        to: email,
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: 'Your Personalized Medicare Quote',
        text: `Hello ${fullName},\n\nThank you for your interest in Medicare coverage options. We've prepared a personalized quote for your ${planType} plan. You can view and compare your options by clicking the link below:\n\n${quoteUrl}\n\nIf you have any questions, please don't hesitate to reach out.\n\nThe MedicareMax Team`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">Your Medicare Quote is Ready</h2>
            <p>Hello ${firstName},</p>
            <p>Thank you for your interest in Medicare coverage options. We've prepared a personalized quote for your ${planType} plan.</p>
            <div style="margin: 30px 0;">
              <a href="${quoteUrl}" 
                 style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                        text-decoration: none; border-radius: 4px; display: inline-block;">
                View Your Quote
              </a>
            </div>
            <p>This quote has been tailored specifically for your needs based on the information you provided.</p>
            <p style="color: #666; font-size: 14px;">
              If the button doesn't work, copy and paste this link into your browser:
              <br>
              <a href="${quoteUrl}" style="color: #4F46E5;">${quoteUrl}</a>
            </p>
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
              <p style="color: #888; font-size: 14px;">
                If you have any questions, please don't hesitate to contact us.
                <br>
                The MedicareMax Team
              </p>
            </div>
          </div>
        `
      };

      await sgMail.send(msg);
      logger.info(`Quote email sent successfully to ${email}`);
      return { success: true };
    } catch (error) {
      logger.error(`Error sending quote email: ${error}`);
      throw new Error('Failed to send quote email');
    }
  }
}

// For the organization signup flow
export async function sendMagicLink({ email, magicLink, name }: {
  email: string;
  magicLink: string;
  name: string;
}) {
  try {
    const msg = {
      to: email,
      from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
      subject: 'Verify Your MedicareMax Account',
      text: `Hi ${name},\n\nClick this link to verify your account: ${magicLink}\n\nThis link will expire in 30 minutes.`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Welcome to MedicareMax</h2>
          <p>Hi ${name},</p>
          <p>Click the button below to verify your account and complete your organization setup. This link will expire in 30 minutes.</p>
          <div style="margin: 30px 0;">
            <a href="${magicLink}" 
               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 4px; display: inline-block;">
              Verify Account
            </a>
          </div>
          <p style="color: #666; font-size: 14px;">
            If the button doesn't work, copy and paste this link into your browser:
            <br>
            <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
          </p>
        </div>
      `
    };

    await sgMail.send(msg);
    logger.info('Magic link email sent successfully');
  } catch (error) {
    logger.error(`Failed to send magic link email: ${error}`);
    throw error;
  }
}

// Generate a hash for onboarding link validation
function generateHash(orgId: string, email: string): string {
  const SECRET = process.env.HASH_SECRET || 'default-hash-secret'; // Ensure this is set in your environment
  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
}

/**
 * Sends an onboarding link that includes organizationId, and optionally email and hash
 * @param orgId Organization ID to include in the link
 * @param email Optional email to include in the link and use as recipient
 */
export async function sendOnboardingLink(orgId: string, email?: string) {
  try {
    // Base onboarding URL with orgId
    const baseUrl = process.env.FRONTEND_URL || 'https://medicaremax.ai';
    let onboardingUrl = `${baseUrl}/onboard?orgId=${orgId}`;
    
    // If email is provided, add email and hash to the URL
    if (email) {
      const hash = generateHash(orgId, email);
      onboardingUrl += `&email=${encodeURIComponent(email)}&hash=${hash}`;
    }
    
    // Create email message
    const msg = {
      to: email || process.env.FALLBACK_EMAIL || 'information@medicaremax.ai', // Fallback if no email provided
      from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
      subject: 'Join MedicareMax',
      text: `Click this link to create or update your profile: ${onboardingUrl}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Welcome to MedicareMax</h2>
          <p>Click the button below to create or update your profile:</p>
          <div style="margin: 30px 0;">
            <a href="${onboardingUrl}" 
               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 4px; display: inline-block;">
              Get Started
            </a>
          </div>
          <p style="color: #666; font-size: 14px;">
            If the button doesn't work, copy and paste this link into your browser:
            <br>
            <a href="${onboardingUrl}" style="color: #4F46E5;">${onboardingUrl}</a>
          </p>
          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
            <p style="color: #888; font-size: 14px;">
              If you have any questions, please don't hesitate to contact us.
              <br>
              The MedicareMax Team
            </p>
          </div>
        </div>
      `
    };

    await sgMail.send(msg);
    logger.info(`Onboarding link email sent successfully${email ? ` to ${email}` : ''}`);
    return { success: true };
  } catch (error) {
    logger.error(`Error sending onboarding link email: ${error}`);
    throw new Error('Failed to send onboarding link email');
  }
}

================
File: src/services/stripe.ts
================
import Stripe from 'stripe';
import { config } from '../config';
import { logger } from '../logger';

// Initialize Stripe with the secret key from environment variables
const stripe = new Stripe(config.stripe.secretKey, {
  apiVersion: '2023-10-16',
});

export type PlanTier = 'basic' | 'pro' | 'enterprise';

// Map subscription tier IDs to Stripe price IDs
const PRICE_MAP: Record<PlanTier, string> = {
  basic: config.stripe.prices.basic,
  pro: config.stripe.prices.pro,
  enterprise: config.stripe.prices.enterprise,
};

// Extra resource price IDs
const EXTRA_AGENT_PRICE = config.stripe.prices.extraAgent;
const EXTRA_CONTACT_PRICE = config.stripe.prices.extraContact;

interface CreateSubscriptionOptions {
  tierId: PlanTier;
  organizationId: number;
  email: string;
  extraAgents: number;
  extraContacts: number;
  stripeCustomerId?: string;
}

export interface SubscriptionResult {
  customerId: string;
  subscriptionId: string;
  clientSecret?: string;
}

/**
 * Creates or updates a Stripe subscription for an organization
 */
export async function createOrUpdateSubscription({
  tierId,
  organizationId,
  email,
  extraAgents,
  extraContacts,
  stripeCustomerId,
}: CreateSubscriptionOptions): Promise<SubscriptionResult> {
  try {
    // Get or create a customer
    let customerId = stripeCustomerId;
    
    if (!customerId) {
      const customer = await stripe.customers.create({
        email,
        metadata: {
          organizationId: organizationId.toString(),
        },
      });
      customerId = customer.id;
      logger.info(`Created Stripe customer for organization ${organizationId}: ${customerId}`);
    }

    // Create subscription line items
    const items = [
      {
        price: PRICE_MAP[tierId],
        quantity: 1,
      },
    ];

    // Add extra agents if needed
    if (extraAgents > 0 && EXTRA_AGENT_PRICE) {
      items.push({
        price: EXTRA_AGENT_PRICE,
        quantity: extraAgents,
      });
    }

    // Add extra contacts (subscription is based on 100s of contacts)
    if (extraContacts > 0 && EXTRA_CONTACT_PRICE) {
      items.push({
        price: EXTRA_CONTACT_PRICE,
        // Calculate how many 100s of contacts
        quantity: Math.ceil(extraContacts / 100),
      });
    }

    // Create the subscription
    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items,
      payment_behavior: 'default_incomplete',
      payment_settings: {
        save_default_payment_method: 'on_subscription',
        payment_method_types: ['card'],
      },
      expand: ['latest_invoice.payment_intent'],
      metadata: {
        organizationId: organizationId.toString(),
        tierId,
        extraAgents: extraAgents.toString(),
        extraContacts: extraContacts.toString(),
      },
    });

    // Get the client secret from the subscription
    const invoice = subscription.latest_invoice as Stripe.Invoice;
    const paymentIntent = invoice.payment_intent as Stripe.PaymentIntent;
    const clientSecret = paymentIntent?.client_secret || undefined;

    logger.info(`Created Stripe subscription for organization ${organizationId}: ${subscription.id}`);

    return {
      customerId,
      subscriptionId: subscription.id,
      clientSecret,
    };
  } catch (error) {
    logger.error('Error creating Stripe subscription:', error);
    throw error;
  }
}

/**
 * Webhook handler for Stripe events
 */
export async function handleStripeWebhook(event: Stripe.Event): Promise<void> {
  logger.info(`Processing Stripe webhook: ${event.type}`);
  const db = new Database();

  try {
    switch (event.type) {
      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription;
        // Find organization with this subscription
        const orgResult = await db.query<{ id: number }>(
          'SELECT id FROM organizations WHERE stripe_subscription_id = ?',
          [subscription.id]
        );
        
        if (orgResult && orgResult.length > 0) {
          const organizationId = orgResult[0].id;
          
          // Map Stripe status to our status
          let subscriptionStatus = 'active';
          if (subscription.status === 'active' || subscription.status === 'trialing') {
            subscriptionStatus = 'active';
          } else if (subscription.status === 'past_due') {
            subscriptionStatus = 'past_due';
          } else {
            subscriptionStatus = 'inactive';
          }
          
          // Get extra agents and contacts
          const extraAgents = parseInt(subscription.metadata.extraAgents || '0', 10);
          const extraContacts = parseInt(subscription.metadata.extraContacts || '0', 10);
          
          // Update organization with subscription status
          await db.execute(
            `UPDATE organizations 
             SET subscription_status = ?,
                 billing_cycle_end = ?,
                 trial_end_date = ?,
                 extra_agents = ?,
                 extra_contacts = ?
             WHERE id = ?`,
            [
              subscriptionStatus,
              new Date(subscription.current_period_end * 1000).toISOString(),
              subscription.trial_end ? new Date(subscription.trial_end * 1000).toISOString() : null,
              extraAgents,
              extraContacts,
              organizationId
            ]
          );
          
          logger.info(`Updated organization ${organizationId} with subscription status: ${subscriptionStatus}`);
        } else {
          logger.warn(`No organization found for subscription: ${subscription.id}`);
        }
        break;
      }
      
      case 'invoice.payment_succeeded': {
        const invoice = event.data.object as Stripe.Invoice;
        if (invoice.subscription) {
          // Find organization with this subscription
          const orgResult = await db.query<{ id: number }>(
            'SELECT id FROM organizations WHERE stripe_subscription_id = ?',
            [invoice.subscription]
          );
          
          if (orgResult && orgResult.length > 0) {
            // Update last payment date and reset failure count
            await db.execute(
              `UPDATE organizations 
               SET last_payment_date = ?,
                   payment_failure_count = 0,
                   subscription_status = 'active'
               WHERE id = ?`,
              [new Date().toISOString(), orgResult[0].id]
            );
            
            logger.info(`Payment succeeded for organization ${orgResult[0].id}`);
          }
        }
        break;
      }
      
      case 'invoice.payment_failed': {
        const invoice = event.data.object as Stripe.Invoice;
        if (invoice.subscription) {
          // Find organization with this subscription
          const orgResult = await db.query<{ id: number, payment_failure_count: number }>(
            'SELECT id, payment_failure_count FROM organizations WHERE stripe_subscription_id = ?',
            [invoice.subscription]
          );
          
          if (orgResult && orgResult.length > 0) {
            const org = orgResult[0];
            const newFailureCount = org.payment_failure_count + 1;
            
            // Update payment failure count
            await db.execute(
              `UPDATE organizations 
               SET payment_failure_count = ?,
                   subscription_status = ?
               WHERE id = ?`,
              [
                newFailureCount,
                newFailureCount >= 3 ? 'past_due' : 'active', // Mark as past_due after 3 failures
                org.id
              ]
            );
            
            logger.warn(`Payment failed for organization ${org.id}. Failure count: ${newFailureCount}`);
          }
        }
        break;
      }
      
      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription;
        const orgResult = await db.query<{ id: number }>(
          'SELECT id FROM organizations WHERE stripe_subscription_id = ?',
          [subscription.id]
        );
        
        if (orgResult && orgResult.length > 0) {
          // Mark subscription as canceled
          await db.execute(
            `UPDATE organizations SET subscription_status = 'canceled' WHERE id = ?`,
            [orgResult[0].id]
          );
          
          logger.info(`Subscription canceled for organization ${orgResult[0].id}`);
        }
        break;
      }
    }
  } catch (error) {
    logger.error('Error handling Stripe webhook:', error);
    throw error;
  }
}

================
File: src/services/subscription.ts
================
import { Database } from '../database';
import { logger } from '../logger';
import Stripe from 'stripe';
import { config } from '../config';

// Define possible account statuses
export type AccountStatus = 
  | 'good_standing'           // Everything is fine
  | 'inactive'                // Subscription inactive (canceled, past_due, etc.)
  | 'agent_limit_exceeded'    // Too many agents for current plan
  | 'contact_limit_exceeded'; // Too many contacts for current plan

export interface AccountStatusDetails {
  status: AccountStatus;
  message: string;
  organizationId: number;
  organizationName: string;
  organizationSlug: string;
  subscriptionTier: string;
  subscriptionStatus: string;
  agentLimit: number;
  contactLimit: number;
  currentAgentCount: number;
  currentContactCount: number;
  billingCycleEnd?: Date;
  paymentFailureCount: number;
}

/**
 * Updates organization subscription status from Stripe
 */
export async function syncSubscriptionStatus(organizationId: number): Promise<void> {
  const db = new Database();
  
  try {
    // Get organization details
    const orgResult = await db.execute(
      'SELECT stripe_subscription_id, stripe_customer_id FROM organizations WHERE id = ?', 
      [organizationId]
    );
    
    if (!orgResult.rows || orgResult.rows.length === 0) {
      logger.error(`Organization not found: ${organizationId}`);
      return;
    }
    
    const org = orgResult.rows[0];
    
    // If no Stripe subscription ID, nothing to sync
    if (!org[0]) {
      logger.info(`No Stripe subscription for organization ${organizationId}`);
      return;
    }
    
    // Initialize Stripe client
    const stripe = new Stripe(config.stripe.secretKey, {
      apiVersion: '2025-02-24.acacia' as Stripe.LatestApiVersion,
    });
    
    // Fetch the subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(org[0]);
    
    // Map Stripe status to our status
    let subscriptionStatus = 'active';
    if (subscription.status === 'active' || subscription.status === 'trialing') {
      subscriptionStatus = 'active';
    } else if (subscription.status === 'past_due') {
      subscriptionStatus = 'past_due';
    } else {
      subscriptionStatus = 'inactive';
    }
    
    // Get the billing cycle end
    const billingCycleEnd = new Date(subscription.current_period_end * 1000);
    
    // Get trial end if applicable
    const trialEnd = subscription.trial_end 
      ? new Date(subscription.trial_end * 1000) 
      : null;
    
    // Get extra agents and contacts from subscription metadata
    const extraAgents = parseInt(subscription.metadata.extraAgents || '0', 10);
    const extraContacts = parseInt(subscription.metadata.extraContacts || '0', 10);
    
    // Update the organization with Stripe data
    await db.execute(`
      UPDATE organizations 
      SET 
        subscription_status = ?,
        billing_cycle_end = ?,
        trial_end_date = ?,
        extra_agents = ?,
        extra_contacts = ?
      WHERE id = ?
    `, [
      subscriptionStatus,
      billingCycleEnd.toISOString(),
      trialEnd?.toISOString() || null,
      extraAgents,
      extraContacts,
      organizationId
    ]);
    
    logger.info(`Updated subscription status for organization ${organizationId}: ${subscriptionStatus}`);
    
  } catch (error) {
    logger.error(`Error syncing subscription status for organization ${organizationId}:`, error);
    throw error;
  }
}

/**
 * Checks if an organization's account is in good standing
 */
export async function checkAccountStatus(organizationId: number): Promise<AccountStatusDetails> {
  const db = new Database();
  
  try {
    // Try to sync with Stripe first
    try {
      await syncSubscriptionStatus(organizationId);
    } catch (error) {
      logger.warn(`Could not sync with Stripe for organization ${organizationId}:`, error);
    }
    
    // Get basic organization info first (this should always work)
    const orgResult = await db.execute(
      'SELECT id, name, slug, subscription_tier, subscription_status, agent_limit, contact_limit, extra_agents, extra_contacts, billing_cycle_end, payment_failure_count FROM organizations WHERE id = ?', 
      [organizationId]
    );
    
    if (!orgResult.rows || orgResult.rows.length === 0) {
      throw new Error(`Organization not found: ${organizationId}`);
    }
    
    const org = orgResult.rows[0];
    
    try {
      // Try to query the organization_status view
      const statusResult = await db.execute(
        'SELECT * FROM organization_status WHERE id = ?', 
        [organizationId]
      );
      
      if (statusResult.rows && statusResult.rows.length > 0) {
        const status = statusResult.rows[0];
        const columns = statusResult.columns || [];
        
        // Create an object from the row array using column names
        const statusObj: any = {};
        columns.forEach((col, i) => {
          statusObj[col] = status[i];
        });
        
        // Prepare status details with appropriate message
        let message = '';
        switch (statusObj.account_status) {
          case 'inactive':
            message = `Your subscription is ${statusObj.subscription_status}. Please update your payment method.`;
            break;
            
          case 'agent_limit_exceeded':
            message = `Your account has ${statusObj.current_agent_count} agents, but your plan only allows for ${statusObj.agent_limit + statusObj.extra_agents}. Please remove some agents or upgrade your plan.`;
            break;
            
          case 'contact_limit_exceeded':
            message = `Your account has ${statusObj.current_contact_count} contacts, but your plan only allows for ${statusObj.contact_limit + statusObj.extra_contacts}. Please remove some contacts or upgrade your plan.`;
            break;
            
          case 'good_standing':
          default:
            message = 'Your account is in good standing.';
            break;
        }
        
        return {
          status: statusObj.account_status,
          message,
          organizationId: statusObj.id,
          organizationName: statusObj.name,
          organizationSlug: statusObj.slug,
          subscriptionTier: statusObj.subscription_tier,
          subscriptionStatus: statusObj.subscription_status,
          agentLimit: statusObj.agent_limit + statusObj.extra_agents,
          contactLimit: statusObj.contact_limit + statusObj.extra_contacts,
          currentAgentCount: statusObj.current_agent_count,
          currentContactCount: statusObj.current_contact_count,
          billingCycleEnd: statusObj.billing_cycle_end ? new Date(statusObj.billing_cycle_end) : undefined,
          paymentFailureCount: statusObj.payment_failure_count
        };
      }
    } catch (viewError) {
      // If there's an error querying the view (e.g., it doesn't exist),
      // we'll fall through to the default implementation below
      logger.warn(`Error querying organization_status view: ${viewError}`);
    }
    
    // If we get here, either the view doesn't exist or there was no result
    // Provide default values based on the organization record
    
    // Default to good standing
    const accountStatus: AccountStatus = 'good_standing';
    const message = 'Your account is in good standing.';
    
    // Extract values from the row array
    const columns = orgResult.columns || [];
    const orgObj: any = {};
    columns.forEach((col, i) => {
      orgObj[col] = org[i];
    });
    
    // Use defaults for missing values
    const subscriptionStatus = orgObj.subscription_status || 'active';
    const agentLimit = orgObj.agent_limit || 5;
    const contactLimit = orgObj.contact_limit || 100;
    const extraAgents = orgObj.extra_agents || 0;
    const extraContacts = orgObj.extra_contacts || 0;
    
    return {
      status: accountStatus,
      message,
      organizationId: orgObj.id,
      organizationName: orgObj.name,
      organizationSlug: orgObj.slug,
      subscriptionTier: orgObj.subscription_tier,
      subscriptionStatus,
      agentLimit: agentLimit + extraAgents,
      contactLimit: contactLimit + extraContacts,
      currentAgentCount: 0, // Default to 0 since we can't query agents table
      currentContactCount: 0, // Default to 0 since we can't query contacts table
      billingCycleEnd: orgObj.billing_cycle_end ? new Date(orgObj.billing_cycle_end) : undefined,
      paymentFailureCount: orgObj.payment_failure_count || 0
    };
    
  } catch (error) {
    logger.error(`Error checking account status for organization ${organizationId}:`, error);
    throw error;
  }
}

================
File: src/services/turso.ts
================
import { createClient } from '@libsql/client';
import { TURSO_CONFIG } from '../config/turso';

export class TursoService {
  private headers = {
    'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
    'Content-Type': 'application/json'
  };

  async createOrganizationDatabase(orgId: string): Promise<{url: string, token: string}> {
    const dbName = `org-${orgId}`;

    // Create database using Turso API
    const createDbResponse = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, 
      {
        method: 'POST',
        headers: this.headers,
        body: JSON.stringify({
          name: dbName,
          group: TURSO_CONFIG.GROUP_NAME
        })
      }
    );

    if (!createDbResponse.ok) {
      throw new Error(`Failed to create database: ${await createDbResponse.text()}`);
    }

    const dbData = await createDbResponse.json();
    
    // Generate auth token for the database
    const tokenResponse = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}/auth/tokens`,
      {
        method: 'POST',
        headers: this.headers
      }
    );

    if (!tokenResponse.ok) {
      throw new Error(`Failed to create auth token: ${await tokenResponse.text()}`);
    }

    const tokenData = await tokenResponse.json();

    // Initialize database client and create schema
    const client = createClient({
      url: `https://${dbData.database.Hostname}`,
      authToken: tokenData.jwt
    });

    // Execute SQL statements one at a time
    const statements = [
      `CREATE TABLE contacts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        first_name TEXT NOT NULL,
        last_name TEXT NOT NULL,
        email TEXT NOT NULL,
        current_carrier TEXT NOT NULL,
        plan_type TEXT NOT NULL,
        effective_date TEXT NOT NULL,
        birth_date TEXT NOT NULL,
        tobacco_user BOOLEAN NOT NULL,
        gender TEXT NOT NULL,
        state TEXT NOT NULL,
        zip_code TEXT NOT NULL,
        agent_id INTEGER,
        last_emailed TEXT,
        phone_number TEXT NOT NULL DEFAULT '',
        status TEXT NOT NULL DEFAULT '',
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
      )`,
      `CREATE TABLE leads (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'new',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        converted_contact_id INTEGER,
        FOREIGN KEY (converted_contact_id) REFERENCES contacts(id)
      )`,
      `CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email)`,
      `CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status)`,
      `CREATE TABLE contact_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        contact_id INTEGER,
        lead_id INTEGER,
        event_type TEXT NOT NULL,
        metadata TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (contact_id) REFERENCES contacts(id),
        FOREIGN KEY (lead_id) REFERENCES leads(id),
        CHECK ((contact_id IS NOT NULL AND lead_id IS NULL) OR (contact_id IS NULL AND lead_id IS NOT NULL))
      )`,
      `CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id)`,
      `CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id)`,
      `CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type)`,
      `CREATE TABLE contact_requests (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT NOT NULL,
        request_type TEXT NOT NULL CHECK(request_type IN ('accept', 'decline', 'generic')),
        contact_id INTEGER,
        status TEXT NOT NULL DEFAULT 'new',
        agent_name TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (contact_id) REFERENCES contacts(id)
      )`,
      `CREATE TABLE eligibility_answers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        contact_id INTEGER NOT NULL,
        quote_id TEXT NOT NULL,
        answers TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (contact_id) REFERENCES contacts(id)
      )`,
      `CREATE INDEX IF NOT EXISTS idx_eligibility_answers_contact_id ON eligibility_answers(contact_id)`
    ];

    // Execute each statement
    for (const statement of statements) {
      await client.execute(statement);
    }

    return {
      url: `https://${dbData.database.Hostname}`,
      token: tokenData.jwt
    };
  }

  async deleteOrganizationDatabase(dbName: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}`,
      {
        method: 'DELETE',
        headers: this.headers
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete database: ${await response.text()}`);
    }
  }
}

================
File: src/utils/quoteId.ts
================
import { createHash } from 'crypto';

// Function to generate a unique quote ID from org ID and contact ID
export function generateQuoteId(orgId: number, contactId: number): string {
  // Create a string combining org ID and contact ID
  const data = `${orgId}-${contactId}-${process.env.QUOTE_ID_SECRET || 'default-secret'}`;
  
  // Generate a hash of the data
  const hash = createHash('sha256').update(data).digest('base64');
  
  // Take first 12 characters and make URL safe
  const urlSafeHash = hash
    .slice(0, 12)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
  
  // Encode org ID and contact ID in base36 for shorter strings
  const encodedOrgId = orgId.toString(36);
  const encodedContactId = contactId.toString(36);
  
  // Combine everything with a separator
  return `${encodedOrgId}-${encodedContactId}-${urlSafeHash}`;
}

// Function to decode a quote ID back to org ID and contact ID
export function decodeQuoteId(quoteId: string): { orgId: number; contactId: number } | null {
  try {
    // Split the quote ID into its components
    const [encodedOrgId, encodedContactId] = quoteId.split('-');
    
    // Decode the IDs from base36 back to numbers
    const orgId = parseInt(encodedOrgId, 36);
    const contactId = parseInt(encodedContactId, 36);
    
    if (isNaN(orgId) || isNaN(contactId)) {
      return null;
    }
    
    return { orgId, contactId };
  } catch (e) {
    return null;
  }
}

================
File: src/config.ts
================
import { config as dotenvConfig } from 'dotenv'
import { resolve } from 'path'
import { logger } from './logger'
import { existsSync } from 'fs'

// Get absolute path to .env file
const envPath = resolve(__dirname, '../.env')

// Check if .env file exists - but don't exit if using Replit Secrets
const envFileExists = existsSync(envPath)
if (!envFileExists) {
  console.log(`⚠️ .env file not found at: ${envPath}, will attempt to use Replit Secrets instead`)
} else {
  // Load .env file with override option only if it exists
  const result = dotenvConfig({ 
    path: envPath,
    override: true // This tells dotenv to override existing env vars
  })

  if (result.error) {
    console.warn('⚠️ Error loading .env file:', result.error)
  } else {
    console.log('📁 Loading .env from:', envPath)
  }
}

// Log environment variables (safely)
console.log('📝 Environment variables available:', {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL ? '[PRESENT]' : '[MISSING]',
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN ? '[PRESENT]' : '[MISSING]',
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH ? '[PRESENT]' : '[MISSING]'
})

export const config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  quoteApiKey: process.env.QUOTE_API_KEY,
  PUBLIC_URL: process.env.PUBLIC_URL || (process.env.NODE_ENV === 'development' 
    ? 'http://localhost:5173'
    : 'http://localhost:3000'),
  stripe: {
    secretKey: process.env.STRIPE_SECRET_KEY || '',
    publishableKey: process.env.STRIPE_PUBLISHABLE_KEY || '',
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET || '',
    prices: {
      basic: process.env.STRIPE_PRICE_BASIC || '',
      pro: process.env.STRIPE_PRICE_PRO || '',
      enterprise: process.env.STRIPE_PRICE_ENTERPRISE || '',
      extraAgent: process.env.STRIPE_PRICE_EXTRA_AGENT || '',
      extraContact: process.env.STRIPE_PRICE_EXTRA_CONTACT || '',
    }
  },
  stripeApiKey: process.env.STRIPE_API_KEY,
  stripeWebhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
  clientUrl: process.env.CLIENT_URL || 'http://localhost:3000',
}

// Log loaded config (safely)
logger.info(`Config loaded ${envFileExists ? `from ${envPath}` : 'from environment'}`)

================
File: src/database.ts
================
import { createClient } from '@libsql/client'
import { config } from './config'
import { logger } from './logger'
import { TursoService } from './services/turso'

export class Database {
  private client: any
  private url: string

  constructor(dbUrl?: string, authToken?: string) {
    const url = dbUrl || config.TURSO_DATABASE_URL
    const token = authToken || config.TURSO_AUTH_TOKEN

    if (!url || !token) {
      logger.error('Missing database credentials')
      throw new Error('Missing database credentials')
    }

    this.url = url
    this.client = createClient({
      url: url,
      authToken: token,
    })
    
    logger.info(`Database connected to: ${this.url}`)
  }

  static async getOrgDb(orgId: string): Promise<Database> {
    try {
      // Use main DB to get org's Turso credentials
      const mainDb = new Database()
      const org = await mainDb.fetchOne<{turso_db_url: string, turso_auth_token: string}>(
        'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
        [orgId]
      )

      if (!org?.turso_db_url || !org?.turso_auth_token) {
        logger.error(`No Turso credentials found for org ${orgId}`)
        throw new Error('Organization database not configured')
      }

      logger.info(`Creating client for org ${orgId} database: ${org.turso_db_url}`)
      return new Database(org.turso_db_url, org.turso_auth_token)
    } catch (error) {
      logger.error(`Failed to get org database: ${error}`)
      throw error
    }
  }

  /**
   * Get organization's database or initialize it if it doesn't exist
   * This method is used as a fallback when the database needs to be created on the fly
   */
  static async getOrInitOrgDb(orgId: string): Promise<Database> {
    try {
      // First try to get the existing database
      const db = await Database.getOrgDb(orgId)
      
      // Ensure schema is up to date
      await Database.ensureDatabaseSchema(orgId)
      
      return db
    } catch (error) {
      // If the error is that the database doesn't exist, initialize it
      if (error instanceof Error && error.message === 'Organization database not configured') {
        logger.info(`No database found for org ${orgId}, initializing new database`)
        
        try {
          // Use main DB to check if the organization exists
          const mainDb = new Database()
          const orgExists = await mainDb.fetchOne<{id: number}>(
            'SELECT id FROM organizations WHERE id = ?',
            [orgId]
          )

          if (!orgExists) {
            logger.error(`Cannot initialize database: Organization ${orgId} does not exist`)
            throw new Error('Organization not found')
          }

          // Create the database using the TursoService
          const turso = new TursoService()
          const { url, token } = await turso.createOrganizationDatabase(orgId)

          // Update the organization record with the new database credentials
          await mainDb.execute(
            'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ? WHERE id = ?',
            [url, token, orgId]
          )

          logger.info(`Successfully initialized database for organization ${orgId}`)
          
          // Return a new database instance with the created credentials
          return new Database(url, token)
        } catch (initError) {
          logger.error(`Failed to initialize database for org ${orgId}: ${initError}`)
          throw initError
        }
      } else {
        // If it's some other error, rethrow it
        throw error
      }
    }
  }

  /**
   * Ensure that the organization database has all required tables
   * This can be used to add new tables to existing databases when the schema changes
   */
  static async ensureDatabaseSchema(orgId: string): Promise<void> {
    try {
      // Get the organization database
      const orgDb = await Database.getOrgDb(orgId)
      
      // Check for existence of each table and create if missing
      const tables = [
        {
          name: 'eligibility_answers',
          createStatement: `CREATE TABLE IF NOT EXISTS eligibility_answers (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            contact_id INTEGER NOT NULL,
            quote_id TEXT NOT NULL,
            answers TEXT NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (contact_id) REFERENCES contacts(id)
          )`,
          indexStatements: [
            `CREATE INDEX IF NOT EXISTS idx_eligibility_answers_contact_id ON eligibility_answers(contact_id)`
          ]
        }
        // Add more tables here as needed
      ]
      
      // Execute each table creation statement
      for (const table of tables) {
        try {
          // Check if table exists
          const tableExists = await orgDb.fetchOne<{cnt: number}>(
            `SELECT COUNT(*) as cnt FROM sqlite_master WHERE type='table' AND name=?`,
            [table.name]
          )
          
          if (!tableExists || (tableExists.cnt === 0)) {
            logger.info(`Creating missing table ${table.name} for org ${orgId}`)
            await orgDb.execute(table.createStatement)
            
            // Create indexes
            for (const indexStatement of table.indexStatements) {
              await orgDb.execute(indexStatement)
            }
          }
        } catch (e) {
          logger.error(`Error checking/creating table ${table.name}: ${e}`)
          // Continue to next table
        }
      }
    } catch (error) {
      logger.error(`Error ensuring database schema for org ${orgId}: ${error}`)
      throw error
    }
  }

  getClient() {
    return this.client
  }

  async execute(sql: string, args: any[] = []) {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result
    } catch (error) {
      logger.error(`Database execute error: ${error}`)
      throw error
    }
  }

  async fetchAll(sql: string, args: any[] = []) {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result.rows || []
    } catch (error) {
      logger.error(`Database fetchAll error: ${error}`)
      throw error
    }
  }

  async fetchOne<T>(sql: string, args: any[] = []): Promise<T | null> {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      if (!result.rows || result.rows.length === 0) {
        return null
      }
      // Convert array row to object using column names
      const row = result.rows[0]
      const columns = result.columns || []
      const obj: any = {}
      columns.forEach((col: string, i: number) => {
        obj[col] = row[i]
      })
      return obj as T
    } catch (error) {
      logger.error(`Database fetchOne error: ${error}`)
      throw error
    }
  }

  // Compatibility method for old query interface
  async query<T = any>(sql: string, args: any[] = []): Promise<T[]> {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result.rows || []
    } catch (error) {
      logger.error(`Database query error: ${error}`)
      throw error
    }
  }

  // Transaction support with function overloads
  async transaction<T>(callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(mode: 'read' | 'write', callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(
    callbackOrMode: ((tx: Database) => Promise<T>) | 'read' | 'write',
    callback?: (tx: Database) => Promise<T>
  ): Promise<T> {
    let mode: 'read' | 'write' = 'write'
    let fn: ((tx: Database) => Promise<T>) | null = null

    if (typeof callbackOrMode === 'string') {
      mode = callbackOrMode
      fn = callback || null
    } else {
      fn = callbackOrMode
    }
    
    if (!fn) {
      throw new Error('Transaction callback is required')
    }

    const tx = await this.client.transaction(mode)
    try {
      // Create a Database-like wrapper around the transaction
      const txWrapper = new Database()
      // Override the client with the transaction
      txWrapper.client = tx
      
      const result = await fn(txWrapper)
      await tx.commit()
      return result
    } catch (error) {
      await tx.rollback()
      throw error
    }
  }
}

export const db = new Database() 

/**
 * Get user from session cookie
 */
export async function getUserFromSession(request: Request): Promise<any> {
  try {
    const db = new Database();
    const sessionCookie = request.headers.get('cookie')?.split(';')
      .find(c => c.trim().startsWith('session='))
      ?.split('=')[1];

    if (!sessionCookie) {
      return null;
    }

    const user = await db.query(
      'SELECT * FROM users WHERE session_id = ? AND session_expires > datetime("now")',
      [sessionCookie]
    );

    if (!user || user.length === 0) {
      return null;
    }

    return user[0];
  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

/**
 * Get organization by ID
 */
export async function getOrganizationById(orgId: number): Promise<any> {
  try {
    const db = new Database();
    const org = await db.query(
      'SELECT * FROM organizations WHERE id = ?',
      [orgId]
    );

    if (!org || org.length === 0) {
      return null;
    }

    return org[0];
  } catch (error) {
    logger.error(`Error getting organization: ${error}`);
    return null;
  }
}

// Add these methods to the Database class
Database.getUserFromSession = getUserFromSession;
Database.getOrganizationById = getOrganizationById;

================
File: src/errors.ts
================
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'NotFoundError'
  }
}

export class UnauthorizedError extends Error {
  constructor(message: string = 'Unauthorized') {
    super(message)
    this.name = 'UnauthorizedError'
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'ValidationError'
  }
}

export class DatabaseError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'DatabaseError'
  }
}

================
File: src/index.ts
================
import { Elysia, t } from 'elysia'
import { cors } from '@elysiajs/cors'
import { Database } from './database'
import { logger } from './logger'
import type { ContactCreate, AgentCreate } from './types'
import { readFileSync } from 'fs'
import { staticPlugin } from '@elysiajs/static'
import { parse as csvParse } from 'csv-parse/sync'
import { Readable } from 'stream'
import { Buffer } from 'buffer'
import { createAuthRoutes } from './routes/auth'
import { settingsRoutes } from './routes/settings'
import { organizationRoutes } from './routes/organizations'
import { createBrandRoutes } from './routes/brand'
import { quotesRoutes } from './routes/quotes'
import { createStripeRoutes } from './routes/stripe'
import { createOnboardingRoutes, cleanupOldOrganizations } from './routes/onboarding'
import { errorHandler } from './middleware/error'
import { getUserFromSession } from './services/auth'
import { join } from 'path'
import { existsSync } from 'fs'
import { EmailService } from './services/email'
import * as cron from 'node-cron'
import { eligibilityRoutes } from './routes/eligibility'
import { generateQuoteId } from './utils/quoteId'
import { createSelfServiceRoutes } from './routes/self-service'

// At the top of the file, add interface for ZIP data
interface ZipInfo {
  state: string;
  // Add other ZIP info properties as needed
}

// Update ZIP_DATA declaration
let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'))
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}

// Add with the other type imports
type NewAgentRequest = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

type AgentUpdate = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

interface DbRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  phone: string | null;
  is_admin: number;
  is_agent: number;
  settings: string | null;
}

// Add at the top with other interfaces
interface ContactRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  current_carrier: string;
  plan_type: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: number;
  gender: string;
  state: string;
  zip_code: string;
  agent_id: number | null;
  last_emailed: string | null;
  phone_number: string;
}

interface CarrierRow {
  name: string;
  aliases: string | null;
}

// Add this helper function before startServer
function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
  const digits = phone.replace(/\D/g, '').slice(0, 10);
  return {
    isValid: digits.length === 10,
    standardized: digits
  };
}

// Add this helper function near the other validation functions
function validateEmail(email: string): boolean {
  // RFC 5322 compliant email regex
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  return emailRegex.test(email.trim());
}

// Add this helper function near the other validation functions
function validateISODate(dateStr: string): { isValid: boolean; isoDate: string | null } {
  try {
    const trimmed = dateStr.trim();
    
    // Try to parse the date - will throw if invalid
    const date = new Date(trimmed);
    
    // Check if date is invalid
    if (isNaN(date.getTime())) {
      return { isValid: false, isoDate: null };
    }
    
    // Convert to ISO format (YYYY-MM-DD)
    const isoDate = date.toISOString().split('T')[0];
    
    // Verify the date is not in the future
    if (date > new Date()) {
      return { isValid: false, isoDate: null };
    }
    
    return { isValid: true, isoDate };
  } catch (e) {
    return { isValid: false, isoDate: null };
  }
}

// Add this helper function near the other validation functions
async function validateCarrier(carrier: string, db: Database): Promise<{ isValid: boolean; standardizedName: string; wasConverted: boolean }> {
  try {
    // Trim and standardize input
    const trimmedCarrier = carrier.trim();
    logger.info(`Validating carrier: "${trimmedCarrier}"`);
    
    // Create a new instance of the central database
    const centralDb = new Database();
    
    // Get all carriers with their aliases from the central database
    const result = await centralDb.execute<CarrierRow>(
      'SELECT name, aliases FROM carriers'
    );
    
    logger.info(`Found ${result.rows.length} carriers in database`);
    
    // Check each carrier and its aliases
    for (const row of result.rows) {
      logger.info(`Checking against carrier: "${row.name}", aliases: ${row.aliases || '[]'}`);
      
      // Check exact name match (case insensitive)
      if (row.name.toLowerCase() === trimmedCarrier.toLowerCase()) {
        logger.info(`Found exact match with carrier: ${row.name}`);
        return { isValid: true, standardizedName: row.name, wasConverted: false };
      }
      
      // Check aliases if they exist
      if (row.aliases) {
        const aliases = JSON.parse(row.aliases);
        logger.info(`Checking aliases for ${row.name}: ${JSON.stringify(aliases)}`);
        if (Array.isArray(aliases) && aliases.some(alias => alias.toLowerCase() === trimmedCarrier.toLowerCase())) {
          logger.info(`Found match in aliases for carrier: ${row.name}`);
          return { isValid: true, standardizedName: row.name, wasConverted: false };
        }
      }
    }
    
    // If no match found, keep the original carrier name but mark as converted
    logger.info(`No matching carrier found for: "${trimmedCarrier}", keeping original name`);
    return { isValid: true, standardizedName: trimmedCarrier, wasConverted: true };
  } catch (e) {
    logger.error(`Error validating carrier: ${e}`);
    return { isValid: true, standardizedName: carrier.trim(), wasConverted: true };
  }
}

const startServer = async () => {
  try {
    // Log environment information at startup
    logger.info(`Environment: NODE_ENV = "${process.env.NODE_ENV}"`)
    logger.info(`Current working directory: ${process.cwd()}`)
    logger.info(`Is production mode: ${process.env.NODE_ENV === 'production'}`)
    
    // Log available environment variables (without values for security)
    logger.info(`Available environment variables: ${Object.keys(process.env).join(', ')}`)
    
    // Try loading directly from process.env
    if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
      logger.warn('Critical environment variables missing. Check Replit Secrets are properly set:')
      logger.warn('Required: TURSO_DATABASE_URL, TURSO_AUTH_TOKEN')
      logger.warn('Available env vars: ' + Object.keys(process.env).join(', '))
    } else {
      logger.info('Required environment variables found')
    }
    
    const db = new Database()
    logger.info('Database initialized successfully')

    const app = new Elysia()
      .use(cors({
        // In development, allow the Vite dev server origin
        origin: process.env.NODE_ENV === 'development' 
          ? 'http://localhost:5173'
          : false, // Disable CORS in production
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Cookie'],  // Add Cookie to allowed headers
        credentials: true,
        preflight: true
      }))
      // Add explicit OPTIONS handler for preflight
      .options('/api/contacts/:id', ({ set }) => {
        set.headers = {
          'Access-Control-Allow-Origin': 'http://localhost:5173',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Allow-Credentials': 'true'
        }
        return new Response(null, { status: 204 })
      })
      // Log all requests
      .onRequest(({ request: { method, url, headers } }) => {
        const path = new URL(url).pathname
        logger.info(`⮕ ${method} ${path}`)
      })
      // Log all responses
      .onResponse((context) => {
        const { request: { method }, path, set } = context
        logger.info(`⬅ ${method} ${path} ${set.status}`)
      })
      // Enhanced error handling
      .onError(({ code, error, request }: {
        code: string;
        error: Error;
        request: { url: string; method: string };
      }) => {
        const path = new URL(request.url).pathname
        const errorMessage = `❌ ${request.method} ${path} - ${error.message}`
        logger.error(errorMessage)

        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), { 
          status: code === 'NOT_FOUND' ? 404 : 500,
          headers: {
            'Content-Type': 'application/json'
          }
        })
      })
      // Add health check endpoint
      .get('/health', () => ({ status: 'OK' }))
      .get('/api/contacts', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts - Attempting to fetch contacts for org ${user.organization_id}`)
          
          // Get org-specific database, initializing it if needed
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // First get all unique carriers and states for filter options
          const [carrierResults, stateResults] = await Promise.all([
            orgDb.fetchAll('SELECT DISTINCT current_carrier FROM contacts WHERE current_carrier IS NOT NULL ORDER BY current_carrier'),
            orgDb.fetchAll('SELECT DISTINCT state FROM contacts WHERE state IS NOT NULL ORDER BY state')
          ])

          const allCarriers = carrierResults.map((row: any[]) => row[0])
          const allStates = stateResults.map((row: any[]) => row[0])
          
          // Get search query and filters from URL params
          const url = new URL(request.url)
          const searchQuery = url.searchParams.get('search') || ''
          const carriers = (url.searchParams.get('carriers') || '').split(',').filter(Boolean)
          const states = (url.searchParams.get('states') || '').split(',').filter(Boolean)
          const agents = (url.searchParams.get('agents') || '').split(',').filter(Boolean)
          
          // Build the SQL query with search and filter conditions
          let conditions = []
          let params = []

          // Add search condition if search query exists
          if (searchQuery) {
            conditions.push(`(
              LOWER(first_name) LIKE ? OR 
              LOWER(last_name) LIKE ? OR 
              LOWER(email) LIKE ? OR
              LOWER(current_carrier) LIKE ? OR
              LOWER(state) LIKE ?
            )`)
            const searchTerm = `%${searchQuery.toLowerCase()}%`
            params.push(searchTerm, searchTerm, searchTerm, searchTerm, searchTerm)
          }

          // Add carrier filter if carriers are specified
          if (carriers.length > 0) {
            conditions.push(`current_carrier IN (${carriers.map(() => '?').join(',')})`)
            params.push(...carriers)
          }

          // Add state filter if states are specified
          if (states.length > 0) {
            conditions.push(`state IN (${states.map(() => '?').join(',')})`)
            params.push(...states)
          }

          // Add agent filter if agents are specified
          if (agents.length > 0) {
            // Handle special case: if agent list includes '0', include NULL agent_id values too
            if (agents.includes('0')) {
              const nonZeroAgents = agents.filter(id => id !== '0')
              if (nonZeroAgents.length > 0) {
                conditions.push(`(agent_id IN (${nonZeroAgents.map(() => '?').join(',')}) OR agent_id IS NULL)`)
                params.push(...nonZeroAgents.map(Number))
              } else {
                conditions.push(`agent_id IS NULL`)
              }
            } else {
              conditions.push(`agent_id IN (${agents.map(() => '?').join(',')})`)
              params.push(...agents.map(Number))
            }
          }

          // Construct the final query
          const query = `
            SELECT * FROM contacts 
            ${conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : ''}
            ORDER BY id DESC
          `
          
          // Execute query with params
          const contacts = await orgDb.fetchAll(query, params)

          if (!contacts || !Array.isArray(contacts)) {
            logger.warn('GET /api/contacts - No contacts found or invalid response')
            return {
              contacts: [],
              filterOptions: {
                carriers: allCarriers,
                states: allStates
              }
            }
          }

          logger.info(`GET /api/contacts - Successfully fetched ${contacts.length} contacts from org database`)

          const mappedContacts = contacts.map(contact => ({
            id: contact[0],
            first_name: contact[1],
            last_name: contact[2],
            email: contact[3],
            current_carrier: contact[4],
            plan_type: contact[5],
            effective_date: contact[6],
            birth_date: contact[7],
            tobacco_user: Boolean(contact[8]),
            gender: contact[9],
            state: contact[10],
            zip_code: contact[11],
            agent_id: contact[12],
            last_emailed: contact[13],
            phone_number: contact[14] || ''
          }))

          logger.info(`GET /api/contacts - Returning ${mappedContacts.length} contacts with ${allCarriers.length} carriers and ${allStates.length} states`)
          return {
            contacts: mappedContacts,
            filterOptions: {
              carriers: allCarriers,
              states: allStates
            }
          }
        } catch (e) {
          logger.error(`Error in GET /api/contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/check-email/:email', async ({ params: { email }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          const result = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          return {
            exists: result !== null
          }
        } catch (e) {
          logger.error(`Error checking email existence: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/:id', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id} - Fetching contact for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Fetch the contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            throw new Error(`Contact ${id} not found`)
          }

          // Return the contact with mapped fields
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error fetching contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .post('/api/contacts', async ({ body, request }: { body: ContactCreate, request: Request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contact = body
          logger.info(`Attempting to create contact for org ${user.organization_id}: ${contact.first_name} ${contact.last_name}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Check for existing email
          const existingContact = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [contact.email]
          )

          if (existingContact) {
            throw new Error('A contact with this email already exists')
          }
          
          const query = `
            INSERT INTO contacts (
              first_name, last_name, email, current_carrier, plan_type,
              effective_date, birth_date, tobacco_user, gender,
              state, zip_code, agent_id, phone_number
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `
          
          const params = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            contact.state,
            contact.zip_code,
            contact.agent_id || null,
            contact.phone_number || ''
          ]

          logger.info(`Executing query with params: ${JSON.stringify(params)}`)
          await orgDb.execute(query, params)

          // Fetch the newly created contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE email = ? ORDER BY id DESC LIMIT 1',
            [contact.email]
          )

          if (!result) {
            throw new Error('Failed to fetch created contact')
          }

          // Match response format to schema
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error creating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .put('/api/contacts/:id', async ({ params: { id }, body, request }: { body: ContactCreate, request: Request }) => {
        try {
          // Get user and org info
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          const contact = body as ContactCreate
          logger.info(`PUT /api/contacts/${id} - Updating contact for org ${user.organization_id}`)

          // Get state from ZIP code
          const zipInfo = ZIP_DATA[contact.zip_code]
          if (!zipInfo) {
            throw new Error(`Invalid ZIP code: ${contact.zip_code}`)
          }

          // First update the contact
          const updateQuery = /* sql */ `
            UPDATE contacts SET 
              first_name = ?,
              last_name = ?,
              email = ?,
              current_carrier = ?,
              plan_type = ?,
              effective_date = ?,
              birth_date = ?,
              tobacco_user = ?,
              gender = ?,
              state = ?,
              zip_code = ?,
              phone_number = ?
            WHERE id = ?
          `

          const updateParams = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            zipInfo.state, // Use state from ZIP code
            contact.zip_code,
            contact.phone_number || '',
            id
          ]

          // Execute the update
          await orgDb.execute(updateQuery, updateParams)

          // Then fetch the updated contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            throw new Error(`Contact ${id} not found after update`)
          }

          logger.info(`Successfully updated contact ${id} in org ${user.organization_id}`)

          // Return the updated contact
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number
          }
        } catch (e) {
          logger.error(`Error updating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add DELETE endpoint for contacts
      .delete('/api/contacts', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Parse contact IDs from the request
          const url = new URL(request.url)
          const ids = url.searchParams.get('ids')
          if (!ids) {
            throw new Error('No contact IDs provided')
          }

          const contactIds = ids.split(',').map(id => parseInt(id.trim(), 10))
          
          logger.info(`DELETE /api/contacts - Attempting to delete ${contactIds.length} contacts for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contactIds.map(() => '?').join(',')
          
          const query = `
            DELETE FROM contacts 
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const result = await orgDb.execute(query, contactIds)
          const deletedIds = result.rows?.map(row => row.id) || []

          logger.info(`DELETE /api/contacts - Successfully deleted ${deletedIds.length} contacts from org ${user.organization_id}`)

          return {
            success: true,
            deleted_ids: deletedIds,
            message: `Successfully deleted ${deletedIds.length} contacts`
          }
        } catch (e) {
          logger.error(`Error deleting contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add endpoint for reassigning contacts to a different agent
      .put('/api/contacts/reassign', async ({ request, body }: { request: Request, body: { contact_ids: number[], agent_id: number | null } }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const { contact_ids, agent_id } = body
          if (!contact_ids || !Array.isArray(contact_ids) || contact_ids.length === 0) {
            throw new Error('Invalid or empty contact_ids array')
          }

          logger.info(`PUT /api/contacts/reassign - Reassigning ${contact_ids.length} contacts to agent ${agent_id} for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contact_ids.map(() => '?').join(',')
          
          const query = `
            UPDATE contacts 
            SET agent_id = ?
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const params = [agent_id, ...contact_ids]
          const result = await orgDb.execute(query, params)
          const updatedIds = result.rows?.map(row => row.id) || []

          logger.info(`PUT /api/contacts/reassign - Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`)

            return {
            success: true,
            updated_ids: updatedIds,
            message: `Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`
          }
        } catch (e) {
          logger.error(`Error reassigning contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add file upload endpoint
      .post('/api/contacts/upload', async ({ request, body }: { request: Request, body: { contacts: any[], file_type?: string, sheet_name?: string } }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Extract file and overwrite flag from form data
          const formData = body as { file: File, overwrite_duplicates: boolean | string, duplicateStrategy: string, agent_id?: string }
          const file = formData.file
          
          // Get agent_id from form data or use current user's ID if they're an agent
          const agentId = formData.agent_id ? parseInt(formData.agent_id, 10) : (user.is_agent ? user.id : null)
          logger.info(`Using agent_id: ${agentId} for contact upload (from form: ${formData.agent_id}, user is agent: ${user.is_agent}, user id: ${user.id})`)
          
          // Support both naming conventions - overwrite_duplicates (old) and duplicateStrategy (new)
          let overwriteDuplicates = false
          if (formData.overwrite_duplicates !== undefined) {
            // Convert string 'false'/'true' to boolean
            overwriteDuplicates = formData.overwrite_duplicates === 'true' || formData.overwrite_duplicates === true
          } else if (formData.duplicateStrategy !== undefined) {
            // Support the new 'duplicateStrategy' parameter
            overwriteDuplicates = formData.duplicateStrategy === 'overwrite'
          }

          logger.info(`Initial overwriteDuplicates value: ${overwriteDuplicates}, type: ${typeof overwriteDuplicates}, raw overwrite_duplicates: ${formData.overwrite_duplicates}, raw duplicateStrategy: ${formData.duplicateStrategy}`)

          logger.info(`POST /api/contacts/upload - Processing CSV upload with overwriteDuplicates=${overwriteDuplicates}`)

          // Read file contents
          const fileContents = await file.text()
          
          // Parse CSV
          const records = csvParse(fileContents, {
            columns: true,
            skip_empty_lines: true
          })

          // Required fields in desired order
          const requiredFields = [
            'First Name',
            'Last Name',
            'Email',
            'Current Carrier',
            'Plan Type',
            'Effective Date',
            'Birth Date',
            'Tobacco User',
            'Gender',
            'ZIP Code',
            'Phone Number'
          ]

          // Validate headers
          const headers = Object.keys(records[0] || {})
          const missingFields = requiredFields.filter(field => !headers.includes(field))

          // Add this: Get the email column index from headers
          const emailColumnIndex = headers.indexOf('Email')

          if (missingFields.length > 0) {
            return {
              success: false,
              message: `Missing required columns: ${missingFields.join(', ')}`,
              error_csv: null,
              converted_carriers_csv: null,
              total_rows: 0,
              error_rows: 0,
              valid_rows: 0,
              converted_carrier_rows: 0,
              supported_carriers: []
            }
          }

          const validRows: any[] = []
          const errorRows: any[] = []
          const paramsList: any[] = []
          const convertedCarrierRows: any[] = []

          // Get existing emails for duplicate checking
          let existingEmails = new Set<string>()
          const emailResults = await orgDb.fetchAll("SELECT email FROM contacts")
          existingEmails = new Set(emailResults.map((row: any) => row[0]?.trim().toLowerCase()))

          logger.info(`Found ${existingEmails.size} existing emails in database`)

          // Validate each row
          for (const [index, row] of records.entries()) {
            const rowNum = index + 2 // Account for header row and 0-based index
            
            // Check for missing values
            const missingValues = requiredFields.filter(field => !row[field]?.trim())
            if (missingValues.length > 0) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Missing values for: ${missingValues.join(', ')}`
              })
              continue
            }

            // Validate email format
            const email = row['Email'].trim().toLowerCase()
            if (!validateEmail(email)) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid email format: ${row['Email']}`
              })
              continue
            }

            // Validate phone number
            const phoneResult = standardizePhoneNumber(row['Phone Number']);
            if (!phoneResult.isValid) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid phone number: ${row['Phone Number']}. Must be exactly 10 digits.`
              })
              continue
            }

            // Validate ZIP code
            const zipCode = row['ZIP Code'].trim()
            const zipInfo = ZIP_DATA[zipCode]
            if (!zipInfo) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid ZIP code: ${zipCode}`
              })
              continue
            }

            // Validate gender
            const gender = row['Gender'].trim().toUpperCase()
            if (!['M', 'F'].includes(gender)) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid gender: ${gender}. Must be 'M' or 'F'`
              })
              continue
            }

            // Check for duplicate email
            logger.info(`Checking row ${rowNum} email: ${email}`)
            logger.info(`Overwrite duplicates is set to: ${overwriteDuplicates}`)
            if (existingEmails.has(email)) {
              logger.info(`Found duplicate email: ${email}`)
              const notOverwrite = !overwriteDuplicates
              logger.info(`Debug - overwriteDuplicates: ${overwriteDuplicates}, !overwriteDuplicates: ${notOverwrite}`)
              if (!overwriteDuplicates) {
                logger.info(`Adding duplicate email to error rows since overwrite is disabled`)
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Email already exists: ${row['Email']}`
                })
                logger.info('Skipping duplicate email')
                continue
              }
              logger.info(`Allowing duplicate email since overwrite is enabled`)
            }

            // Add carrier validation
            const carrierResult = await validateCarrier(row['Current Carrier'], orgDb);
            let carrierNote = null;
            if (carrierResult.wasConverted) {
              carrierNote = {
                Row: rowNum,
                ...row,
                OriginalCarrier: row['Current Carrier']
              };
            }

            try {
              // Validate dates with better error messages
              const effectiveDateResult = validateISODate(row['Effective Date']);
              if (!effectiveDateResult.isValid) {
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Invalid effective date format: ${row['Effective Date']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
                });
                continue;
              }

              const birthDateResult = validateISODate(row['Birth Date']);
              if (!birthDateResult.isValid) {
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Invalid birth date format: ${row['Birth Date']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
                });
                continue;
              }

              const tobaccoUser = ['yes', 'true', '1', 'y'].includes(row['Tobacco User'].trim().toLowerCase())

              paramsList.push([
                row['First Name'].trim(),
                row['Last Name'].trim(),
                email,
                carrierResult.standardizedName,
                row['Plan Type'].trim(),
                effectiveDateResult.isoDate,
                birthDateResult.isoDate,
                tobaccoUser,
                gender,
                zipInfo.state,
                zipCode,
                phoneResult.standardized,
                agentId  // Add agentId parameter
              ])
              validRows.push(row)
              
              // If this row had a carrier conversion, track it
              if (carrierNote) {
                convertedCarrierRows.push(carrierNote)
              }
            } catch (e) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: 'Unexpected error processing dates. Please ensure dates are in YYYY-MM-DD format.'
              })
            }
          }

          // Insert valid rows
          let insertedCount = 0
          if (paramsList.length > 0) {
            logger.info(`Processing ${paramsList.length} valid rows with overwriteDuplicates=${overwriteDuplicates}`)
            logger.info(`Debug - overwriteDuplicates value type: ${typeof overwriteDuplicates}`)
            if (overwriteDuplicates) {
              logger.info('Using update/insert logic for duplicates')
              // First update existing records
              const updateQuery = /* sql */ `
                UPDATE contacts SET 
                  first_name = ?,
                  last_name = ?,
                  current_carrier = ?,
                  plan_type = ?,
                  effective_date = ?,
                  birth_date = ?,
                  tobacco_user = ?,
                  gender = ?,
                  state = ?,
                  zip_code = ?,
                  phone_number = ?,
                  agent_id = ?
                WHERE LOWER(email) = ?
              `
              
              for (const params of paramsList) {
                const email = params[2].toLowerCase()
                logger.info(`Processing row with email: ${email}`)
                
                // Check if email exists
                const existingContact = await orgDb.fetchAll(
                  'SELECT 1 FROM contacts WHERE LOWER(email) = ?',
                  [email]
                )
                
                if (existingContact.length > 0) {
                  logger.info(`Updating existing contact with email: ${email}`)
                  // Update existing contact
                  const updateParams = [
                    params[0], // first_name
                    params[1], // last_name
                    params[3], // current_carrier
                    params[4], // plan_type
                    params[5], // effective_date
                    params[6], // birth_date
                    params[7], // tobacco_user
                    params[8], // gender
                    params[9], // state
                    params[10], // zip_code
                    params[11], // phone_number
                    params[12], // agent_id
                    email     // for WHERE clause
                  ]
                  logger.info(`Update params: ${JSON.stringify(updateParams)}`)
                  await orgDb.execute(updateQuery, updateParams)
                  logger.info(`Successfully updated contact with email: ${email}`)
                } else {
                  logger.info(`Inserting new contact with email: ${email}`)
                  // Insert new contact
                  await orgDb.execute(
                    `INSERT INTO contacts (
                      first_name, last_name, email, current_carrier, plan_type,
                      effective_date, birth_date, tobacco_user, gender,
                      state, zip_code, phone_number, agent_id
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    params
                  )
                  logger.info(`Successfully inserted new contact with email: ${email}`)
                }
              }
              insertedCount = paramsList.length
            } else {
              logger.info('Using insert-only logic for non-duplicates')
              // If not overwriting duplicates, only insert non-duplicate rows
              for (const params of paramsList) {
                const email = params[2].toLowerCase()
                // Check if email exists
                const existingContact = await orgDb.fetchAll(
                  'SELECT 1 FROM contacts WHERE LOWER(email) = ?',
                  [email]
                )

                if (existingContact.length === 0) {
                  // Only insert if email doesn't exist
                  await orgDb.execute(
                    `INSERT INTO contacts (
                      first_name, last_name, email, current_carrier, plan_type,
                      effective_date, birth_date, tobacco_user, gender,
                      state, zip_code, phone_number, agent_id
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    params
                  )
                  insertedCount++
                }
              }
            }
          }

          // Generate error CSV if needed
          let errorCsv = null
          if (errorRows.length > 0) {
            errorCsv = [
              ['Row', ...requiredFields, 'Error'].join(','),
              ...errorRows.map(row => {
                return [
                  row.Row,
                  ...requiredFields.map(field => `"${row[field] || ''}"`),
                  `"${row.Error}"`
                ].join(',')
              })
            ].join('\n')
          }

          // Generate converted carriers CSV if needed
          let convertedCarriersCsv = null;
          if (convertedCarrierRows.length > 0) {
            convertedCarriersCsv = [
              ['Row', ...requiredFields, 'Original Carrier'].join(','),
              ...convertedCarrierRows.map((row: { Row: number; [key: string]: any }) => {
                return [
                  row.Row,
                  ...requiredFields.map(field => `"${row[field] || ''}"`),
                  `"${row.OriginalCarrier}"`
                ].join(',')
              })
            ].join('\n');
          }

          // Get list of supported carriers and their aliases
          const centralDb = new Database();
          const carriersResult = await centralDb.execute(
            'SELECT name, aliases FROM carriers ORDER BY name'
          );
          
          const supportedCarriers = carriersResult.rows.map((row: any) => ({
            name: row.name,
            aliases: row.aliases ? JSON.parse(row.aliases) : []
          }));

          // Create carrier info message
          const carrierInfoMessage = `Supported carriers: ${supportedCarriers.map((c: { name: string; aliases: string[] }) => 
            `${c.name}${c.aliases.length > 0 ? ` (also accepts: ${c.aliases.join(', ')})` : ''}`
          ).join(', ')}`;

          // Create messages array for different types of feedback
          const messages = [];
          
          // Add error message if there are errors
          if (errorRows.length > 0) {
            messages.push(`Found ${errorRows.length} rows with errors. Successfully imported ${insertedCount} rows.`);
          } else {
            messages.push(`Successfully imported ${insertedCount} rows.`);
          }

          // Add carrier conversion message if there were conversions
          if (convertedCarrierRows.length > 0) {
            messages.push(
              `${convertedCarrierRows.length} rows had unrecognized carriers and were marked as "Other". ` +
              `This is normal if these are carriers we don't support. However, please review the carrier conversion CSV ` +
              `to ensure there are no typos or misspellings of supported carriers.`
            );
          }

          // Add supported carriers message
          messages.push(carrierInfoMessage);

          return {
            success: true,
            message: messages.join('\n\n'),
            error_csv: errorCsv,
            converted_carriers_csv: convertedCarriersCsv,
            total_rows: validRows.length + errorRows.length,
            error_rows: errorRows.length,
            valid_rows: insertedCount,
            converted_carrier_rows: convertedCarrierRows.length,
            supported_carriers: supportedCarriers
          }

        } catch (e) {
          logger.error(`Error processing CSV upload: ${e.stack || e}`)
          return {
            success: false,
            message: String(e),
            error_csv: null,
            converted_carriers_csv: null,
            total_rows: 0,
            error_rows: 0,
            valid_rows: 0,
            converted_carrier_rows: 0,
            supported_carriers: []
          }
        }
      })
      // Add error handler
      .use(errorHandler)
      // Add explicit debug log for auth routes
      .use(app => {
        logger.info('Registering auth routes...')
        return app.use(createAuthRoutes())
      })
      // Add settings routes
      .use(settingsRoutes)
      // Add organization routes
      .use(organizationRoutes)
      // Add brand routes
      .use(createBrandRoutes())
      // Add quotes routes
      .use(quotesRoutes)
      // Add Stripe routes
      .use(createStripeRoutes())
      // Add onboarding routes
      .use(createOnboardingRoutes())
      // Add eligibility routes
      .use(eligibilityRoutes)
      // Add self-service routes
      .use(createSelfServiceRoutes())
      // In production, serve the frontend static files
      .use(process.env.NODE_ENV === 'production' 
        ? async (app) => {
            logger.info(`[Static Files] Running in production mode: NODE_ENV = "${process.env.NODE_ENV}"`)
            const distPath = join(process.cwd(), '../dist');
            logger.info(`[Static Files] Serving from: ${distPath} (exists: ${existsSync(distPath)})`);
            
            // List directory contents for debugging
            try {
              const fs = require('fs');
              const distContents = fs.readdirSync(distPath);
              logger.info(`[Static Files] dist directory contents: ${JSON.stringify(distContents)}`);
              
              // Check if index.html exists
              const indexPath = join(distPath, 'index.html');
              logger.info(`[Static Files] index.html path: ${indexPath} (exists: ${existsSync(indexPath)})`);
              
              // If it exists, log its contents for debugging
              if (existsSync(indexPath)) {
                const indexContent = fs.readFileSync(indexPath, 'utf-8');
                logger.info(`[Static Files] index.html first 100 chars: ${indexContent.substring(0, 100)}...`);
              }
            } catch (error) {
              logger.error(`[Static Files] Error inspecting dist directory: ${error}`);
            }
            
            // Try different approach for static files
            app.get('/*', async ({ request }) => {
              const url = new URL(request.url);
              const path = url.pathname;
              
              logger.info(`[Static Route Handler] Handling request for: ${path}`);
              
              // Skip API routes
              if (path.startsWith('/api/')) {
                logger.info(`[Static Route Handler] Skipping API route: ${path}`);
                return;
              }
              
              // Try to serve the file directly from dist directory
              try {
                const filePath = join(distPath, path === '/' ? 'index.html' : path.slice(1));
                logger.info(`[Static Route Handler] Trying file path: ${filePath} (exists: ${existsSync(filePath)})`);
                
                if (existsSync(filePath)) {
                  logger.info(`[Static Route Handler] File exists, serving: ${filePath}`);
                  const ext = filePath.substring(filePath.lastIndexOf('.') + 1);
                  const mimeTypes: Record<string, string> = {
                    'html': 'text/html',
                    'js': 'application/javascript',
                    'css': 'text/css',
                    'json': 'application/json',
                    'png': 'image/png',
                    'jpg': 'image/jpeg',
                    'svg': 'image/svg+xml',
                    'ico': 'image/x-icon',
                    'csv': 'text/csv',
                  };
                  
                  return new Response(Bun.file(filePath), {
                    headers: { 'Content-Type': mimeTypes[ext] || 'application/octet-stream' }
                  });
                } else if (path !== '/' && !path.includes('.')) {
                  // This is likely a SPA route, serve index.html
                  logger.info(`[Static Route Handler] Likely SPA route, serving index.html for: ${path}`);
                  return new Response(Bun.file(join(distPath, 'index.html')), {
                    headers: { 'Content-Type': 'text/html' }
                  });
                } else if (path === '/') {
                  // Explicitly handle root path
                  logger.info(`[Static Route Handler] Handling root path, serving index.html`);
                  const indexPath = join(distPath, 'index.html');
                  
                  if (existsSync(indexPath)) {
                    logger.info(`[Static Route Handler] Root: index.html exists, serving it`);
                    return new Response(Bun.file(indexPath), {
                      headers: { 'Content-Type': 'text/html' }
                    });
                  } else {
                    logger.error(`[Static Route Handler] Root: index.html doesn't exist at ${indexPath}`);
                    return new Response('index.html not found', { status: 404 });
                  }
                }
                
                // If we get here, the file doesn't exist
                logger.warn(`[Static Route Handler] No matching file found for: ${path}`);
                return new Response('Not found', { status: 404 });
              } catch (error) {
                logger.error(`[Static Route Handler] Error serving file for ${path}: ${error}`);
                return new Response(`Server error: ${error}`, { status: 500 });
              }
            });

            return app;
          }
        : (app) => app
      )
      // Add this endpoint within the app definition
      .post('/api/agents', async ({ body, request, set }) => {
        try {
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent: ${newAgent.email} (org: ${currentUser.organization_id})`)

          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Check if the organization has reached its agent limit
          const orgLimitResult = await client.execute({
            sql: `
              SELECT 
                o.agent_limit, 
                COUNT(u.id) as current_agent_count
              FROM 
                organizations o
              LEFT JOIN 
                users u ON o.id = u.organization_id AND (u.is_agent = 1 OR u.is_admin = 1) AND u.is_active = 1
              WHERE 
                o.id = ?
              GROUP BY 
                o.id
            `,
            args: [currentUser.organization_id]
          })
          
          if (orgLimitResult.rows.length > 0) {
            const { agent_limit, current_agent_count } = orgLimitResult.rows[0]
            
            if (Number(current_agent_count) >= Number(agent_limit)) {
              logger.warn(`Organization ${currentUser.organization_id} has reached its agent limit (${agent_limit}). Cannot create new agent.`)
              set.status = 403
              return {
                success: false,
                error: `You have reached your plan's agent limit (${agent_limit}). Please upgrade your plan to add more agents.`
              }
            }
            
            logger.info(`Organization has ${current_agent_count}/${agent_limit} agents (before adding new agent)`)
          }
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add an alias endpoint for POST /api/agents/create to match frontend expectations
      .post('/api/agents/create', async ({ body, request, set }) => {
        try {
          // Log the request to the alias endpoint
          logger.info(`POST /api/agents/create - Using the same implementation as /api/agents`)
          
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent via /api/agents/create: ${newAgent.email} (org: ${currentUser.organization_id})`)
          
          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent via /api/agents/create: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add this GET endpoint within the app definition, near the POST /api/agents endpoint
      .get('/api/agents', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Remove admin check - allow any authenticated user to fetch agents for their organization
          // All users should be able to see the agent list for assignment purposes
          logger.info(`GET /api/agents - Fetching agents for org ${currentUser.organization_id}`)

          // Get the libSQL client
          const client = db.getClient()

          // Fetch all agents (users) from the organization along with their settings
          const result = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.first_name,
                u.last_name,
                u.email,
                u.phone,
                u.is_admin,
                u.is_agent,
                a.settings
              FROM users u
              LEFT JOIN agent_settings a ON u.id = a.agent_id
              WHERE u.organization_id = ?
              AND u.is_active = 1
              ORDER BY u.first_name, u.last_name
            `,
            args: [currentUser.organization_id]
          })

          logger.info(`GET /api/agents - Found ${result.rows.length} agents`)

          // Map the database results to the expected format with camelCase field names
          const agents = result.rows.map((row: any) => {
            const settings = row.settings ? JSON.parse(row.settings) : {
              stateLicenses: [],
              carrierContracts: [],
              stateCarrierSettings: []
            }

            return {
              id: String(row.id),
              firstName: row.first_name,
              lastName: row.last_name,
              email: row.email,
              phone: row.phone || '',
              isAdmin: Boolean(row.is_admin),
              isAgent: Boolean(row.is_agent),
              carriers: settings.carrierContracts || [],
              stateLicenses: settings.stateLicenses || []
            }
          })

          logger.info(`GET /api/agents - Returning ${agents.length} agents`)
          return agents

        } catch (e) {
          logger.error(`Error fetching agents: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Update PUT endpoint for updating agent details - moved here to be with other agent endpoints
      .put('/api/agents/:id', async ({ params, body, request, set }: {
        params: { id: string },
        body: AgentUpdate,
        request: Request,
        set: any
      }) => {
        console.log('DEBUG: PUT handler hit', { params, path: request.url })
        logger.info(`Starting update for agent ${params.id}`)
        logger.info(`Request body: ${JSON.stringify(body, null, 2)}`)
        
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            logger.error('Authentication failed: No user in session')
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Allow users to update their own details or admins to update any agent
          if (!currentUser.is_admin && currentUser.id.toString() !== params.id) {
            logger.error(`Authorization failed: User ${currentUser.id} is not an admin and trying to update another user`)
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can update other agents'
            }
          }
          
          // Security protection: NEVER allow ANY user to remove their own admin status,
          // even if they are an admin themselves
          if (currentUser.id.toString() === params.id) {
            // If this is a self-update and user is trying to change admin status
            if (body.is_admin !== Boolean(currentUser.is_admin)) {
              // If they're trying to REMOVE admin status
              if (Boolean(currentUser.is_admin) && !body.is_admin) {
                logger.warn(`Security protection: Admin user ${currentUser.id} attempted to remove their own admin status`)
                // Prevent admin from removing their own admin status - keep it as is
                body.is_admin = true;
              }
              // Note: We still allow non-admins to be promoted by an admin
            }
          }

          const agent = body
          logger.info(`Updating agent ${params.id} - Name: ${agent.firstName} ${agent.lastName}, Phone: ${agent.phone}`)

          // Get the libSQL client
          const client = db.getClient()

          // Determine if this is a self-update by a non-admin
          const isSelfUpdate = currentUser.id.toString() === params.id && !currentUser.is_admin
          
          // Create dynamic SQL that excludes is_admin for self-updates
          let sql, args
          if (isSelfUpdate) {
            // For self-updates, exclude is_admin from the update
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
            logger.info(`Self-update detected: excluding admin status from update for user ${params.id}`)
          } else {
            // For admin updates or other users, include all fields
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      is_admin = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.is_admin ? 1 : 0,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
          }

          // Execute the update with the appropriate SQL and args
          const userUpdateResult = await client.execute({
            sql,
            args
          })

          logger.info(`User update result: ${JSON.stringify(userUpdateResult.rows, null, 2)}`)

          if (!userUpdateResult.rows || userUpdateResult.rows.length === 0) {
            logger.error('User update failed: No rows affected')
            throw new Error('User update failed - no rows affected')
          }

          logger.info('User details updated successfully')

          // Update agent settings
          const settings = {
            stateLicenses: agent.stateLicenses,
            carrierContracts: agent.carriers,
            stateCarrierSettings: [],
            emailSendBirthday: false,
            emailSendPolicyAnniversary: false,
            emailSendAep: false,
            smartSendEnabled: false
          }

          logger.info(`Agent settings to update: ${JSON.stringify(settings, null, 2)}`)

          const settingsUpdateResult = await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)
            ON CONFLICT (agent_id) 
            DO UPDATE SET settings = EXCLUDED.settings
            RETURNING *`,
            args: [
              params.id,
              JSON.stringify(settings)
            ]
          })

          logger.info(`Settings update result: ${JSON.stringify(settingsUpdateResult.rows, null, 2)}`)

          if (!settingsUpdateResult.rows || settingsUpdateResult.rows.length === 0) {
            logger.error('Settings update failed: No rows affected')
            throw new Error('Settings update failed - no rows affected')
          }

          logger.info('Settings updated successfully')

          const updatedUser = userUpdateResult.rows[0]
          const updatedSettings = JSON.parse(settingsUpdateResult.rows[0].settings)

          return {
            success: true,
            message: 'Agent updated successfully',
            agent: {
              id: updatedUser.id.toString(),
              firstName: updatedUser.first_name,
              lastName: updatedUser.last_name,
              email: updatedUser.email,
              phone: updatedUser.phone || '',
              is_admin: Boolean(updatedUser.is_admin),
              is_agent: Boolean(updatedUser.is_agent),
              carriers: updatedSettings.carrierContracts,
              stateLicenses: updatedSettings.stateLicenses
            }
          }

        } catch (error: unknown) {
          const dbError = error as Error
          logger.error(`Database error: ${dbError.message}`)
          set.status = 500
          return {
            success: false,
            error: dbError.message
          }
        }
      })
      // Add DELETE endpoint for agent deletion with contact reassignment
      .delete('/api/agents/:id', async ({ params, request, set, query }: {
        params: { id: string },
        request: Request,
        set: any,
        query: { reassignTo?: string }
      }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Only admins can delete agents
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can delete agents'
            }
          }

          const agentId = params.id
          
          // Prevent users from deleting themselves
          if (String(currentUser.id) === agentId) {
            set.status = 403
            return {
              success: false,
              error: 'You cannot delete your own account'
            }
          }
          
          const reassignToAgentId = query.reassignTo

          // Get the main database client for user/agent operations
          const client = db.getClient()

          // Also get the organization-specific database for contact operations
          const orgDb = await Database.getOrgDb(currentUser.organization_id.toString())

          // First handle contact operations in org database
          try {
            // Using the transaction method instead of direct SQL commands
            await orgDb.transaction(async (orgTx) => {
            // If reassignToAgentId is provided, reassign contacts to the new agent
            if (reassignToAgentId && reassignToAgentId !== agentId) {
              logger.info(`Reassigning contacts from agent ${agentId} to agent ${reassignToAgentId}`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = ?
                   WHERE agent_id = ?`,
                  [reassignToAgentId, agentId]
                )
            } else {
              // Set agent_id to NULL for contacts associated with this agent
              logger.info(`Setting contacts from agent ${agentId} to have no assigned agent`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = NULL
                   WHERE agent_id = ?`,
                  [agentId]
                )
              }
            })
            
            logger.info(`Successfully updated contacts for agent ${agentId}`)
            
            // Now handle agent operations in the main database
            await db.transaction(async (tx) => {
              // First, check if the user has any other related records that need to be deleted

            // Delete agent's settings
              await tx.execute(
                `DELETE FROM agent_settings
                 WHERE agent_id = ?`,
                [agentId]
              )
              
              // Check for any related records in other tables that might reference this user
              // For example, delete from sessions table if it exists
              await tx.execute(
                `DELETE FROM sessions
                 WHERE user_id = ?`,
                [agentId]
              )
              
              // IMPORTANT: Add any other related tables that might have foreign keys to users
              
              // Finally, completely delete the user record instead of just marking as inactive
              await tx.execute(
                `DELETE FROM users
                 WHERE id = ?`,
                [agentId]
              )
            })
            
            logger.info(`Successfully deleted agent ${agentId}`)

            return {
              success: true,
              message: 'Agent deleted successfully'
            }
          } catch (error) {
            logger.error(`Error in agent deletion: ${error}`)
            throw error;
          }
        } catch (e) {
          logger.error(`Error deleting agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: 'An error occurred while deleting the agent'
          }
        }
      })
      // Add this endpoint within the app definition
      .get('/api/me', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          logger.info(`GET /api/me - Current user from session: ${JSON.stringify(currentUser)}`)
          
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          // Get user details including agent settings if they exist
          const client = db.getClient()
          const userDetails = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.email,
                u.first_name as firstName,
                u.last_name as lastName,
                u.is_admin,
                u.is_agent,
                u.phone,
                u.organization_id,
                o.slug as organization_slug,
                o.subscription_tier,
                a.settings as agentSettings
              FROM users u
              JOIN organizations o ON u.organization_id = o.id
              LEFT JOIN agent_settings a ON a.agent_id = u.id
              WHERE u.id = ?
            `,
            args: [currentUser.id]
          })

          logger.info(`GET /api/me - Raw user details from DB: (omitted)`)

          if (!userDetails.rows[0]) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          const user = userDetails.rows[0]
          const response = {
            success: true,
            user: {
              id: user.id,
              email: user.email,
              firstName: user.firstName,
              lastName: user.lastName,
              is_admin: Boolean(user.is_admin),
              is_agent: Boolean(user.is_agent),
              phone: user.phone || '',
              organization_id: user.organization_id,
              organization_slug: user.organization_slug,
              subscription_tier: user.subscription_tier,
              agentSettings: user.agentSettings ? JSON.parse(user.agentSettings) : null
            }
          }
          logger.info(`GET /api/me - Sending response`)
          return response

        } catch (e) {
          logger.error(`Error fetching current user: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/:redirect', async ({ params, set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for redirect to: ${params.redirect}`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`

          // Handle redirect
          const redirectPath = params.redirect === 'add-agent' ? 'agents/add' : params.redirect
          set.redirect = `/${redirectPath}`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/login', async ({ set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for login page`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add ZIP lookup endpoint
      .get('/api/zip-lookup/:zipCode', ({ params: { zipCode } }) => {
        try {
          const zipInfo = ZIP_DATA[zipCode]
          if (!zipInfo) {
            return {
              success: false,
              error: `Invalid ZIP code: ${zipCode}`
            }
          }
          return {
            success: true,
            ...zipInfo
          }
        } catch (e) {
          logger.error(`Error looking up ZIP code ${zipCode}: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      
      // Send quote email to contact
      .post('/api/contacts/:contactId/send-quote-email', async ({ params, request, body }) => {
        try {
          const user = await getUserFromSession(request);
          if (!user) {
            return {
              success: false,
              message: 'Authentication required'
            };
          }

          const contactId = Number(params.contactId);
          if (isNaN(contactId)) {
            return {
              success: false,
              message: 'Invalid contact ID'
            };
          }

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString());

          // Fetch contact details
          const contact = await orgDb.fetchOne<{id: number, first_name: string, last_name: string, email: string, plan_type: string}>(
            'SELECT id, first_name, last_name, email, plan_type FROM contacts WHERE id = ?',
            [contactId]
          );

          if (!contact) {
            return {
              success: false,
              message: 'Contact not found'
            };
          }

          // Use the proper generateQuoteId function
          const quoteId = generateQuoteId(user.organization_id, contactId);
          
          // Calculate base URL
          const baseUrl = process.env.PUBLIC_URL || 'http://localhost:5173';
          let quoteUrl = `${baseUrl}/quote?id=${quoteId}&planType=${contact.plan_type}`;

          // Add organization ID to URL
          quoteUrl += `&orgId=${user.organization_id}`;

          // Send the email via SendGrid
          const emailService = new EmailService();
          await emailService.sendQuoteEmail({
            email: contact.email,
            firstName: contact.first_name,
            lastName: contact.last_name,
            quoteUrl,
            planType: contact.plan_type
          });

          // Update last_emailed timestamp
          await orgDb.execute(
            'UPDATE contacts SET last_emailed = CURRENT_TIMESTAMP WHERE id = ?',
            [contactId]
          );

          return {
            success: true,
            message: 'Quote email sent successfully'
          };
        } catch (error) {
          logger.error(`Error sending quote email: ${error}`);
          return {
            success: false,
            message: 'Failed to send quote email',
            error: String(error)
          };
        }
      })
      
      .post('/api/contact-request', async ({ body }: { body: { name: string; email: string; type: string; quoteId?: string } }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contactRequest = body as { name: string, email: string, type: string, quoteId: string }
          const { name, email, type, quoteId } = contactRequest
          logger.info(`Processing contact request for ${email} (type: ${type})`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Check for existing contact
          const existingContact = await orgDb.fetchOne<{ id: number }>(
            'SELECT id FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          let eventTargetId: number
          let isLead = false

          if (existingContact) {
            // Use existing contact
            logger.info(`Found existing contact with ID ${existingContact.id}`)
            eventTargetId = existingContact.id
          } else {
            // Create new lead
            logger.info(`No existing contact found, creating lead for ${email}`)
            const leadResult = await orgDb.execute(
              `INSERT INTO leads (name, email) VALUES (?, ?) RETURNING id`,
              [name, email]
            )
            
            if (!leadResult.rows?.[0]?.id) {
              throw new Error('Failed to create lead')
            }
            
            eventTargetId = leadResult.rows[0].id
            isLead = true
          }

          // Record the event
          const metadata = {
            quoteId,
            requestType: type
          }

          const eventQuery = isLead
            ? `INSERT INTO contact_events (lead_id, event_type, metadata) VALUES (?, 'followup_request', ?)`
            : `INSERT INTO contact_events (contact_id, event_type, metadata) VALUES (?, 'followup_request', ?)`

          await orgDb.execute(eventQuery, [eventTargetId, JSON.stringify(metadata)])
          logger.info(`Recorded followup request event for ${isLead ? 'lead' : 'contact'} ${eventTargetId}`)

          // Return success response
          return {
            success: true,
            message: 'Contact request recorded successfully'
          }

        } catch (e) {
          logger.error(`Error processing contact request: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/:id/eligibility', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/eligibility - Fetching eligibility results`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get most recent eligibility answers for this contact
          const result = await orgDb.fetchOne(
            `SELECT answers 
             FROM eligibility_answers 
             WHERE contact_id = ? 
             ORDER BY created_at DESC 
             LIMIT 1`,
            [id]
          ) as { answers: string } | null

          if (!result) {
            return {
              status: "incomplete",
              answers: null
            }
          }

          // Parse answers JSON and determine status
          const answers = JSON.parse(result.answers)
          const allTrue = Object.values(answers).every(value => value === true)

          return {
            status: allTrue ? "pass" : "flagged",
            answers: result.answers  // Return the raw JSON string instead of the parsed object
          }

        } catch (e) {
          logger.error(`Error fetching eligibility results: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add new endpoint to get follow-up requests
      .get('/api/contacts/:id/follow-ups', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/follow-ups - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get follow-up requests from contact_events table
          const result = await orgDb.execute(
            `SELECT 
              event_type,
              metadata,
              created_at
             FROM contact_events 
             WHERE contact_id = ? 
               AND event_type = 'followup_request'
             ORDER BY created_at DESC`,
            [id]
          )

          // Map results to a more friendly format
          const followUps = result.rows?.map((row: { metadata: string, created_at: string }) => {
            const metadata = JSON.parse(row.metadata)
            return {
              type: metadata.requestType,
              quoteId: metadata.quoteId,
              createdAt: row.created_at
            }
          }) || []

          return followUps

        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      // Add profile update endpoint
      .put('/api/profile', async ({ request, body, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          const { firstName, lastName, phone } = body as { 
            firstName: string;
            lastName: string;
            phone: string;
          }

          // Get the libSQL client
          const client = db.getClient()

          // Update only allowed profile fields
          const result = await client.execute({
            sql: `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      phone = ?
                  WHERE id = ?
                  RETURNING *`,
            args: [firstName, lastName, phone, currentUser.id]
          })

          if (!result.rows || result.rows.length === 0) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          return {
            success: true,
            message: 'Profile updated successfully'
          }

        } catch (error) {
          logger.error(`Error updating profile: ${error}`)
          set.status = 500
          return {
            success: false,
            error: String(error)
          }
        }
      })
      .get('/api/agents/:id/contacts', async ({ params, request }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser?.organization_id) {
            throw new Error('No organization ID found in session')
          }
          
          logger.info(`GET /api/agents/${params.id}/contacts - Fetching contacts for agent ${params.id}`)
          
          // Get organization-specific database
          const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())
          
          // Fetch all contacts for the agent
          const result = await orgDb.fetchAll('SELECT * FROM contacts WHERE agent_id = ?', [params.id])
          
          logger.info(`GET /api/agents/${params.id}/contacts - Found ${result.length} contacts`)
          
          // Map the database results to the expected format with camelCase field names
          const contacts = result.map(contact => ({
            id: contact.id,
            first_name: contact.first_name,
            last_name: contact.last_name,
            email: contact.email,
            current_carrier: contact.current_carrier,
            plan_type: contact.plan_type,
            effective_date: contact.effective_date,
            birth_date: contact.birth_date,
            tobacco_user: Boolean(contact.tobacco_user),
            gender: contact.gender,
            state: contact.state,
            zip_code: contact.zip_code,
            agent_id: contact.agent_id,
            last_emailed: contact.last_emailed,
            phone_number: contact.phone_number || ''
          }))
          
          return {
            success: true,
            contacts: contacts
          }
        } catch (e) {
          logger.error(`Error fetching contacts for agent ${params.id}: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .get('/api/contact-requests', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contact-requests - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Fetch all follow-up requests
          const result = await orgDb.fetchAll('SELECT * FROM contact_events WHERE event_type = ?', ['followup_request'])
          
          logger.info(`GET /api/contact-requests - Found ${result.length} follow-up requests`)
          
          // Map the database results to the expected format with camelCase field names
          const followUps = result.map(followUp => ({
            id: followUp.id,
            event_type: followUp.event_type,
            metadata: JSON.parse(followUp.metadata),
            created_at: followUp.created_at
          }))
          
          return {
            success: true,
            followUps: followUps
          }
        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .get('/api/contacts/:id/follow-ups', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/follow-ups - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get follow-up requests from contact_events table
          const result = await orgDb.execute(
            `SELECT 
              event_type,
              metadata,
              created_at
             FROM contact_events 
             WHERE contact_id = ? 
               AND event_type = 'followup_request'
             ORDER BY created_at DESC`,
            [id]
          )

          // Map results to a more friendly format
          const followUps = result.rows?.map((row: { metadata: string, created_at: string }) => {
            const metadata = JSON.parse(row.metadata)
            return {
              type: metadata.requestType,
              quoteId: metadata.quoteId,
              createdAt: row.created_at
            }
          }) || []

          return followUps

        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      .listen(8000)

    logger.info('Server started on port 8000')

    // Schedule the cleanup job to run daily at midnight
    cron.schedule('0 0 * * *', () => {
      logger.info('Running scheduled cleanup job for old organizations');
      cleanupOldOrganizations().catch(error => {
        logger.error(`Error in scheduled cleanup job: ${error}`);
      });
    });
    
    logger.info('Scheduled daily cleanup job for old organizations');

    return app
  } catch (error) {
    logger.error(`Error starting server: ${error}`)
    throw error
  }
}

startServer()

================
File: src/logger.ts
================
export const logger = {
  info: (message: string) => {
    const timestamp = new Date().toISOString()
    console.log(`[${timestamp}] [INFO] ${message}`)
  },
  error: (message: string) => {
    const timestamp = new Date().toISOString()
    console.error(`[${timestamp}] [ERROR] ${message}`)
  },
  warn: (message: string) => {
    const timestamp = new Date().toISOString()
    console.warn(`[${timestamp}] [WARN] ${message}`)
  }
}

================
File: src/types.ts
================
export interface ContactCreate {
  first_name: string
  last_name: string
  email: string
  current_carrier: string
  plan_type: string
  effective_date: string
  birth_date: string
  tobacco_user: boolean
  gender: string
  state: string
  zip_code: string
  agent_id?: number | null
  phone_number: string
}

export interface AgentCreate {
  first_name: string
  last_name: string
  email: string
  phone: string
}

export interface User {
  id: number;
  email: string;
  organization_id: number;
  is_admin: boolean;
  is_agent: boolean;
  is_active: boolean;
  first_name: string;
  last_name: string;
  phone: string;
  organization_name?: string;
}



================================================================
End of Codebase
================================================================

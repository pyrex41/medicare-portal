This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.ts
- Files matching these patterns are excluded: node_modules/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
scripts/
  add-agent.ts
  apply-contact-migration.ts
  generate-test-data.ts
  generateQuoteId.ts
  generateQuoteUrl.ts
  manage-recommendations.ts
  manage-turso.ts
  test-bulk-import.ts
src/
  config/
    index.ts
    turso.ts
  middleware/
    account-status.ts
    auth.copy.ts
    error.ts
  routes/
    admin-portal.ts
    admin.ts
    auth.ts
    brand.ts
    contacts.ts
    contactTracking.ts
    eligibility.ts
    onboarding.ts
    organizations.ts
    quotes.ts
    schedule.ts
    self-service.ts
    settings.ts
    signup.ts
    stripe.ts
    waitlist.ts
  scripts/
    apply_org_migrations.ts
  services/
    agentSettings.ts
    auth.ts
    contactCount.ts
    contactTracking.ts
    email.ts
    stripe.ts
    subscription.ts
    turso.ts
  utils/
    quoteId.ts
  config.ts
  database.ts
  errors.ts
  index.ts
  logger.ts
  types.ts

================================================================
Files
================================================================

================
File: scripts/add-agent.ts
================
async function main() {
  const db = new Database();

================
File: scripts/apply-contact-migration.ts
================
async function main() {
    const mainDb = new Database()
        const orgDb = new Database(dbUrl, authToken)

================
File: scripts/generate-test-data.ts
================
function getRandomItem<T>(array: T[]): T {
function getRandomDate(start: Date, end: Date): string {
  const date = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
function getRandomPhone(): string {
function getRandomZip(): string {
async function main() {
        effective_date: getRandomDate(new Date('2022-01-01'), new Date('2023-12-31')),
        birth_date: getRandomDate(new Date('1940-01-01'), new Date('1965-12-31')),

================
File: scripts/generateQuoteId.ts
================


================
File: scripts/generateQuoteUrl.ts
================
const generateQuoteUrl = async () => {

================
File: scripts/manage-recommendations.ts
================
async function main() {
  const db = new Database();
async function listRecommendations(db: Database) {
async function addRecommendation(db: Database) {
async function removeRecommendation(db: Database) {

================
File: scripts/manage-turso.ts
================
interface Organization {
class TursoManager {
  async listLocations(): Promise<string[]> {
      throw new Error(`Failed to fetch locations: ${await response.text()}`);
  async listDatabases(): Promise<Array<{name: string, hostname: string}>> {
      throw new Error(`Failed to fetch databases: ${await response.text()}`);
  async updateGroup(name: string, location: string): Promise<void> {
      throw new Error(`Failed to update group: ${await response.text()}`);
  async deleteDatabase(name: string): Promise<void> {
      throw new Error(`Failed to delete database: ${await response.text()}`);
async function main() {
  const db = new Database();
  const turso = new TursoManager();
async function listDatabasesAndOrgs(db: Database, turso: TursoManager) {
async function updateGroupConfig(turso: TursoManager) {
async function deleteCustomerDatabase(db: Database, turso: TursoManager) {

================
File: scripts/test-bulk-import.ts
================
async function main() {
    await new Promise(resolve => setTimeout(resolve, 5000));

================
File: src/config/index.ts
================
interface Config {
export const config: Config = {

================
File: src/config/turso.ts
================


================
File: src/middleware/account-status.ts
================
export const accountStatusMiddleware = new Elysia()
      const db = new Database();

================
File: src/middleware/auth.copy.ts
================
interface AuthenticatedRequest extends Request {
export async function authMiddleware(
  req: AuthenticatedRequest, 
  res: Response, 
  next: NextFunction
    const db = new Database();

================
File: src/middleware/error.ts
================
export const errorHandler = new Elysia()

================
File: src/routes/admin-portal.ts
================
export const createAdminPortalRoutes = () => {
  const adminPortal = new Elysia({ prefix: '/api/admin' })

================
File: src/routes/admin.ts
================
const tursoService = new TursoService()
export const adminRoutes = new Elysia()
    open(ws) {
    message(ws, message) {

================
File: src/routes/auth.ts
================
const dbInstance = new Database();
export function createAuthRoutes() {
  const auth = new AuthService();
  const emailService = new EmailService();
  return new Elysia()
        const expiresAt = new Date();

================
File: src/routes/brand.ts
================
const db = new Database();
interface Organization {
interface BrandSettings {
export function createBrandRoutes() {
  return new Elysia()

================
File: src/routes/contacts.ts
================
type User = {
interface ContactImport {
type BulkImportRequest = {
interface Contact {
type Context = {
  request: Request;
  user: User;
export const contactsRoutes = new Elysia({ prefix: '/api/contacts' })
  .get('/', async ({ request, user, set }: Context) => {
      const url = new URL(request.url);
          const tursoService = new TursoService();
          const mainDb = new Database();
  .post('/bulk-import', async ({ body, user, set }: { body: BulkImportRequest; user: User; set: { status: number } }) => {

================
File: src/routes/contactTracking.ts
================
export const createContactTrackingRoutes = () => {
  return new Elysia({ prefix: '/api/contact-tracking' })

================
File: src/routes/eligibility.ts
================
interface EligibilityAnswers {
export const eligibilityRoutes = (app: Elysia) => {
                const mainDb = new Database();
                throw new Error('Failed to get organization details');
                throw new Error('Failed to get eligibility answers');
                    throw new Error('Failed to create temporary contact');
                throw new Error('Failed to save eligibility answers');

================
File: src/routes/onboarding.ts
================
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || 'sk_test_51Qyh7RCBUPXAZKNGFySALjap1pDAtEwPtuY5TAzEuKKDq7cfAmHhmQIn8W1UMf2CuOvQ1umjiUrlpPauOc159fpM00nfohCZH3')
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
function ensureEmailDecoded(email: string): string {
export function createOnboardingRoutes() {
  const dbInstance = new Database()
  const resumeHandler = async ({ query, set, request }: { query: any, set: any, request: any }) => {
  const app = new Elysia()
            throw new Error('Failed to create organization');
          throw new Error('Failed to create user');

================
File: src/routes/organizations.ts
================
function ensureEmailDecoded(email: string): string {
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
function mapLegacyTierToContactTier(tierId: string): number {
function getAgentLimitForContactTier(contactTier: number): number {
export const organizationRoutes = new Elysia({ prefix: '/api' })
    const db = new Database();
    const turso = new TursoService();
    const auth = new AuthService();
          throw new Error('Failed to create organization');
            new Date().toISOString()
    request: Request 
export function createOrganizationRoutes() {
  const dbInstance = new Database();
  const authService = new AuthService();
  return new Elysia()

================
File: src/routes/quotes.ts
================
interface ZipInfo {
interface Quote {
interface QuoteResponse {
interface QuoteRequestBody {
interface QuoteRequest {
interface ContactQuoteInfo {
interface OrgRedirectInfo {
function calculateAgeOnFirstOfNextMonth(birthDate: string, currentDate: string): number {
    const birth = new Date(birthDate);
    const current = new Date(currentDate);
    const nextMonth = new Date(current.getFullYear(), current.getMonth() + 1, 1);
export const quotesRoutes = (app: Elysia) => {
                throw new Error('No organization ID found in session');
                throw new Error('Invalid contact ID');
                throw new Error('Contact not found');
            throw new Error(String(e));
            const mainDb = new Database();
                    age: calculateAgeOnFirstOfNextMonth(contact.birth_date, new Date().toISOString()),
    .post('/api/quotes', async ({ body, set }: { body: QuoteRequestBody, set: any }) => {
            const requestBody: QuoteRequest = {
            throw new Error(String(error));
            const db = new Database();
                throw new Error('Organization not found');
                throw new Error('No active agents or admins found');
                throw new Error('Quote ID is required');
                throw new Error('Invalid quote ID');

================
File: src/routes/schedule.ts
================
export const scheduleRoutes = (app: Elysia) => {
            const mainDb = new Database();

================
File: src/routes/self-service.ts
================
interface ZipInfo {
type Contact = {
function generateHash(orgId: string, email: string): string {
export function createSelfServiceRoutes() {
  return new Elysia()
                new Date().toISOString().split('T')[0]
        const db = new Database();

================
File: src/routes/settings.ts
================
interface StateCarrierSetting {
interface SettingsBody {
    settings?: BaseSettings;
interface AgentSettingsResponse {
  orgSettings: BaseSettings;
    settings: BaseSettings;
const defaultSettings: BaseSettings = {
function generateDefaultStateCarrierSettings(states: string[], carriers: string[]): StateCarrierSetting[] {
export const settingsRoutes = new Elysia()
    const db = new Database();
        let orgSettings: BaseSettings;

================
File: src/routes/signup.ts
================
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
export async function checkEmailHandler({ params, set }: { params: { email: string }, set: { status: number } }) {
    const dbInstance = new Database();
const validateSignupToken = (token: string): boolean => {
export function createSignupRoutes() {
  const emailService = new EmailService();
  const authService = new AuthService();
  return new Elysia()

================
File: src/routes/stripe.ts
================
export const createStripeRoutes = () => {
  return new Elysia({ prefix: '/api/stripe' })
      const db = new Database();
async function handleCheckoutComplete(session: any, db: Database): Promise<void> {

================
File: src/routes/waitlist.ts
================
interface WaitlistEntry {
function validateEmail(email: string): boolean {
function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
export const createWaitlistRoutes = () => {
    const app = new Elysia({ prefix: '/api/waitlist' })
    const db = new Database(); // Create a new instance of the main database
        throw new Error('Missing SENDGRID_API_KEY environment variable');
    app.post('/', async ({ body, set }: { body: WaitlistEntry, set: any }) => {

================
File: src/scripts/apply_org_migrations.ts
================
async function main() {
    const mainDb = new Database();
        const orgDb = new Database(dbUrl, authToken);

================
File: src/services/agentSettings.ts
================
export interface StateCarrierSetting {
export interface AgentSettings {
      [carrier: string]: StateCarrierSetting;
export async function getAgentSettings(agentId: number): Promise<AgentSettings> {
async function createDefaultSettings(agentId: number): Promise<AgentSettings> {
export async function updateAgentSettings(
    throw new NotFoundError('Agent settings not found');

================
File: src/services/auth.ts
================
    throw new Error("Must set MAGIC_LINK_SECRET in production");
interface MagicLinkPayload {
interface SignupLinkPayload {
export class AuthService {
  constructor(private baseUrl?: string) {
  async createSignupLink(
    const payload: SignupLinkPayload = {
  async verifySignupLink(token: string): Promise<{
      const payload: SignupLinkPayload = JSON.parse(decrypted);
  async createMagicLink(
    const payload: MagicLinkPayload = {
  async verifyMagicLink(token: string, organizationSlug: string): Promise<{
      const payload: MagicLinkPayload = JSON.parse(decrypted);
        logger.error(`Token expired: ${new Date(payload.expiresAt)} < ${new Date()}`);
  private encrypt(text: string): string {
  private decrypt(text: string): string {
        throw new Error("Invalid token format - missing parts");
export async function validateSession(sessionId: string): Promise<User | null> {
  const db = new Database();
  const expiresAt = new Date(session.expires_at);
  const now = new Date();
export function generateToken(): string {
export async function getUserFromSession(request: Request) {
    const url = new URL(request.url);

================
File: src/services/contactCount.ts
================
export async function updateContactCount(userId: string, totalContacts: number): Promise<{
  const db = new Database();
export async function upsertContactCount(userId: string, count: number): Promise<void> {
export async function getContactCount(userId: string): Promise<number> {
export async function getContactLimit(userId: string): Promise<number> {
export async function updateAutoUpgradeLimit(userId: string, limit: number): Promise<boolean> {
export async function checkContactAddition(userId: string, additionalContacts: number): Promise<{

================
File: src/services/contactTracking.ts
================
function generateId(): string {
export async function getCurrentBillingCycle(organizationId: string): Promise<string> {
  const db = new Database();
      throw new Error(`Organization not found: ${organizationId}`);
    const now = new Date();
    const startDate = new Date(year, month, parseInt(billingDay, 10));
    const endDate = new Date(year, month + 1, parseInt(billingDay, 10));
export async function trackContact(
      throw new Error('Missing required parameters for contact tracking');
export async function trackContactBatch(
async function incrementUniqueContactCount(organizationId: string): Promise<number> {
export async function getUniqueContactCount(organizationId: string): Promise<number> {
async function updateStripeUsage(organizationId: string, contactCount: number): Promise<void> {
export async function getContactUsageStats(organizationId: string): Promise<{
      throw new Error(`Billing cycle not found for organization ${organizationId}`);
export async function resetContactCount(
async function recalculateContactCount(organizationId: string): Promise<number> {

================
File: src/services/email.ts
================
interface MagicLinkEmailParams {
interface EmailTrackingRecord {
export class EmailService {
  constructor() {
      throw new Error('Missing SENDGRID_API_KEY environment variable');
  async recordEmailSend(orgDb: Database, tracking: EmailTrackingRecord): Promise<any> {
      const now = new Date().toISOString();
      throw new Error(`Failed to record email send: ${error}`);
  async sendMagicLink(email: string, magicLink: string, organizationSlug: string) {
      throw new Error('Failed to send magic link email');
  async sendQuoteEmail(params: {
      throw new Error('Failed to send quote email');
export async function sendMagicLink({ email, magicLink, name }: {
function generateHash(orgId: string, email: string): string {
export async function sendOnboardingLink(orgId: string, email?: string) {
    throw new Error('Failed to send onboarding link email');

================
File: src/services/stripe.ts
================
class MockStripe {
    stripeClient = new Stripe(config.stripe.secretKey, {
    stripeClient = new MockStripe();
export type PlanTier = 'basic' | 'pro' | 'enterprise' | string;
interface CreateSubscriptionOptions {
interface SubscriptionResult {
function generateId(prefix: string): string {
export async function createContactSubscription(options: CreateSubscriptionOptions): Promise<SubscriptionResult> {
      throw new Error('userId is required');
    const db = new Database();
      new Date().toISOString(),
      new Date().toISOString()
export async function reportContactUsage(subscriptionItemId: string, blocks: number): Promise<void> {
      throw new Error('subscriptionItemId is required');
export async function updateContactCount(userId: string, newContactCount: number): Promise<void> {
export function getPricingTableId(): string {
export async function getSubscriptionInfo(userId: string): Promise<{
export async function checkSubscriptionTier(userId: string, contactCount: number): Promise<{
  currentTier: PlanTier;
  requiredTier: PlanTier;
    let currentTier: PlanTier = 'basic';
    const requiredTier: PlanTier = 'basic';
export async function updateSubscriptionTier(userId: string, targetTier: PlanTier): Promise<{
      throw new Error(`No active subscription found for user ${userId}`);
export async function createCheckoutSession(options: {

================
File: src/services/subscription.ts
================
export type AccountStatus = 
export interface AccountStatusDetails {
  status: AccountStatus;
  billingCycleEnd?: Date;
export async function syncSubscriptionStatus(organizationId: number): Promise<void> {
  const db = new Database();
    const stripe = new Stripe(config.stripe.secretKey, {
    const billingCycleEnd = new Date(subscription.current_period_end * 1000);
      ? new Date(subscription.trial_end * 1000) 
export async function checkAccountStatus(organizationId: number): Promise<AccountStatusDetails> {
      throw new Error(`Organization not found: ${organizationId}`);
          billingCycleEnd: statusObj.billing_cycle_end ? new Date(statusObj.billing_cycle_end) : undefined,
    const accountStatus: AccountStatus = 'good_standing';
      billingCycleEnd: orgObj.billing_cycle_end ? new Date(orgObj.billing_cycle_end) : undefined,

================
File: src/services/turso.ts
================
  throw new Error('TURSO_DATABASE_URL is not set');
  throw new Error('TURSO_AUTH_TOKEN is not set');
export async function getTursoClient() {
export async function checkTursoHealth(): Promise<boolean> {
interface TursoResponse {
export class TursoService {
  constructor() {
      throw new Error('TURSO_API_TOKEN is not set');
  async createDatabaseForImport(orgId: string): Promise<{dbName: string, url: string, token: string}> {
            await new Promise(resolve => setTimeout(resolve, 1000));
  async uploadDatabase(dbName: string, authToken: string, filePath: string): Promise<any> {
        const error = new Error(`File not found at path: ${normalizedPath}`);
        throw new Error(`Failed to upload database: ${errorText}`);
  async createOrganizationDatabase(orgId: string): Promise<{url: string, token: string}> {
        throw new Error(`Failed to create database: ${errorText}`)
        throw new Error('Failed to get database hostname')
        throw new Error(`Failed to create token: ${errorText}`)
        throw new Error('Failed to get database access token')
  async deleteOrganizationDatabase(dbName: string): Promise<void> {
        throw new Error(`Failed to delete database: ${errorText}`)
  private normalizeDbUrl(url: string): { hostname: string, apiUrl: string, dbUrl: string } {
  async downloadDatabaseDump(dbUrl: string, authToken: string): Promise<string> {
        throw new Error(`Failed to download dump: ${errorText}`);
  async createDatabaseFromDump(orgId: string, suffix: string, dumpContent: string): Promise<{url: string, token: string}> {
        throw new Error(`Failed to create database: ${errorText}`);
        throw new Error(`Failed to create auth token: ${errorText}`);
  private handleError(error: unknown): never {
    throw error instanceof Error ? error : new Error(String(error));
  private validateResponse(data: unknown): TursoResponse {
      throw new Error('Invalid response from Turso API');

================
File: src/utils/quoteId.ts
================
export function generateQuoteId(orgId: number, contactId: number): string {
export function decodeQuoteId(quoteId: string): { orgId: number; contactId: number } | null {

================
File: src/config.ts
================


================
File: src/database.ts
================
interface ConnectionInfo {
class ConnectionPool {
  private static instance: ConnectionPool;
  private connections: Map<string, ConnectionInfo> = new Map();
  private constructor() {
  public static getInstance(): ConnectionPool {
      ConnectionPool.instance = new ConnectionPool();
  public getConnection(url: string, authToken: string): any {
              await new Promise(resolve => setTimeout(resolve, delay));
        throw new Error('Max retries reached for Turso API call');
  private cleanupIdleConnections() {
  public shutdown() {
type ColumnMapping = {
type CarrierMapping = {
interface FetchOptions extends RequestInit {
export class Database {
  public static normalizeDbUrl(url: string): { hostname: string, apiUrl: string, dbUrl: string, dbName: string } {
  constructor(dbUrl?: string, authToken?: string) {
      throw new Error('Missing database URL')
      this.bunDb = new BunDatabase(dbPath)
        throw new Error('Missing database token')
  static async getOrgDb(orgId: string): Promise<Database> {
    const mainDb = new Database();
        throw new Error('Organization database not configured');
      const db = new Database(org.turso_db_url, org.turso_auth_token);
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Database validation timed out after 5 seconds')), 5000);
        throw new Error(`Failed to establish database connection: ${errorMessage}`);
  static async getOrInitOrgDb(orgId: string): Promise<Database> {
        const mainDb = new Database()
        if (!orgExists) throw new Error('Organization not found')
        const turso = new TursoService()
          const testDb = new Database(url, token)
          throw new Error('Failed to verify connection with new database credentials')
          throw new Error('Failed to update organization credentials')
          throw new Error('Organization credentials mismatch after update')
        const newDb = new Database(url, token)
  static async ensureDatabaseSchema(orgId: string): Promise<void> {
    const tableSet = new Set(existingTables.map((row: any) => row.name || row[0]));
  getClient() {
  async execute(sql: string, args: any[] = []) {
  async batch(statements: { sql: string, args: any[] }[], mode: 'read' | 'write' = 'write') {
  async fetchAll(sql: string, args: any[] = []) {
  async fetchOne<T>(sql: string, args: any[] = []): Promise<T | null> {
  async query<T = any>(sql: string, args: any[] = []): Promise<T[]> {
  async transaction<T>(callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(mode: 'read' | 'write', callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(
    callbackOrMode: ((tx: Database) => Promise<T>) | 'read' | 'write',
    callback?: (tx: Database) => Promise<T>
    let fn: ((tx: Database) => Promise<T>) | null = null
      throw new Error('Transaction callback is required')
        const txWrapper = new Database()
  static async bulkImportContacts(
    columnMapping?: ColumnMapping,
    carrierMapping?: CarrierMapping,
        throw new Error(`Organization ${orgId} not found`);
        throw new Error(`Could not get database configuration for organization ${orgId}`);
      const localDb = new BunDatabase(`file:${tempDbSuffix}`);
      const rows = await new Promise<any[]>((resolve, reject) => {
        throw new Error(`Email column "${emailColumn}" not found in CSV`);
      const processRow = (row: any) => {
        mappedRow.created_at = new Date().toISOString();
        mappedRow.updated_at = new Date().toISOString();
          const tursoService = new TursoService();
  static async ensureOrgSchema(orgDb: Database): Promise<void> {
  close() {
  private async fetch(fetchUrl: RequestInfo, options: RequestInit | undefined = undefined): Promise<Response> {
      throw new Error(`HTTP error! status: ${response.status}`);
  private async fetchWithRetry(fetchUrl: RequestInfo, options: RequestInit | undefined = undefined): Promise<Response> {
    throw lastError || new Error('Max retries reached');
export const db = new Database() 
export async function getUserFromSession(request: any): Promise<any> {
    const db = new Database();
    const expiresAt = new Date(session.expires_at);
    const now = new Date();
export async function getOrganizationById(orgId: number): Promise<any> {

================
File: src/errors.ts
================
export class NotFoundError extends Error {
  constructor(message: string) {
export class UnauthorizedError extends Error {
  constructor(message: string = 'Unauthorized') {
export class ValidationError extends Error {
export class DatabaseError extends Error {

================
File: src/index.ts
================
export interface ZipInfo {
type NewAgentRequest = {
type AgentUpdate = {
interface DbRow {
interface ContactRow {
interface CarrierRow {
function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
function validateEmail(email: string): boolean {
function validateISODate(dateStr: string, allowFuture: boolean = false): { isValid: boolean; isoDate: string | null } {
    const date = new Date(trimmed);
    if (!allowFuture && date > new Date()) {
async function validateCarrier(carrier: string, db: Database): Promise<{ isValid: boolean; standardizedName: string; wasConverted: boolean }> {
    const centralDb = new Database();
interface ValidationResult {
const validateRow = async (row: any, rowNum: number, carrierMap: Map<string, string>): Promise<ValidationResult> => {
    const missingFieldGroups = new Set<string>()
const startServer = async () => {
    const db = new Database()
    const app = new Elysia()
        return new Response(null, { status: 204 })
        const path = new URL(url).pathname
        error: Error;
        const path = new URL(request.url).pathname
        return new Response(JSON.stringify({
            throw new Error('No organization ID found in session')
          throw new Error(String(e))
            return new Response('Contact not found', { status: 404 })
      .post('/api/contacts', async ({ body, request }: { body: ContactCreate, request: Request }) => {
            throw new Error('A contact with this email already exists')
            throw new Error('Failed to fetch created contact')
      .put('/api/contacts/:id', async ({ params: { id }, body, request }: { body: ContactCreate, request: Request }) => {
            throw new Error(`Invalid ZIP code: ${contact.zip_code}`)
            throw new Error(`Contact ${id} not found after update`)
          const url = new URL(request.url)
            throw new Error('No contact IDs provided')
      .put('/api/contacts/reassign', async ({ request, body }: { request: Request, body: { contact_ids: number[], agent_id: number | null } }) => {
            throw new Error('Invalid or empty contact_ids array')
      .post('/api/contacts/upload', async ({ request, body, set }: { request: Request, body: { file: File, overwrite_duplicates?: boolean | string, duplicateStrategy?: string, agent_id?: string }, set: any }) => {
            .catch((error: Error) => {
              const url = new URL(request.url);
                  return new Response(Bun.file(filePath), {
                  return new Response(Bun.file(join(distPath, 'index.html')), {
                    return new Response(Bun.file(indexPath), {
                    return new Response('index.html not found', { status: 404 });
                return new Response('Not found', { status: 404 });
                return new Response(`Server error: ${error}`, { status: 500 });
        body: AgentUpdate,
        request: Request,
            throw new Error('User update failed - no rows affected')
            throw new Error('Settings update failed - no rows affected')
          const emailService = new EmailService();
          const now = new Date().toISOString();
      .post('/api/contact-request', async ({ body, request }: { body: { name: string; email: string; type: string; quoteId?: string }, request: Request }) => {
              throw new Error('Failed to create lead')
          throw new Error(e instanceof Error ? e.message : String(e))

================
File: src/logger.ts
================
    const timestamp = new Date().toISOString()

================
File: src/types.ts
================
export interface ContactCreate {
export interface AgentCreate {
export interface User {



================================================================
End of Codebase
================================================================

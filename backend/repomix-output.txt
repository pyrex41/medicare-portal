This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.ts, **/*.elm
- Files matching these patterns are excluded: node_modules/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
scripts/
  add-agent.ts
  generateQuoteId.ts
  generateQuoteUrl.ts
  manage-recommendations.ts
  manage-turso.ts
src/
  config/
    turso.ts
  middleware/
    account-status.ts
    auth.ts
    error.ts
  routes/
    admin-portal.ts
    admin.ts
    auth.ts
    brand.ts
    contacts.ts
    eligibility.ts
    onboarding.ts
    organizations.ts
    quotes.ts
    self-service.ts
    settings.ts
    stripe.ts
  services/
    agentSettings.ts
    auth.ts
    email.ts
    stripe.ts
    subscription.ts
    turso.ts
  utils/
    quoteId.ts
  config.ts
  database.ts
  errors.ts
  index.ts
  logger.ts
  types.ts

================================================================
Files
================================================================

================
File: scripts/add-agent.ts
================
async function main() {
  const db = new Database();

================
File: scripts/generateQuoteId.ts
================


================
File: scripts/generateQuoteUrl.ts
================
const generateQuoteUrl = async () => {

================
File: scripts/manage-recommendations.ts
================
async function main() {
  const db = new Database();
async function listRecommendations(db: Database) {
async function addRecommendation(db: Database) {
async function removeRecommendation(db: Database) {

================
File: scripts/manage-turso.ts
================
interface Organization {
class TursoManager {
  async listLocations(): Promise<string[]> {
      throw new Error(`Failed to fetch locations: ${await response.text()}`);
  async listDatabases(): Promise<Array<{name: string, hostname: string}>> {
      throw new Error(`Failed to fetch databases: ${await response.text()}`);
  async updateGroup(name: string, location: string): Promise<void> {
      throw new Error(`Failed to update group: ${await response.text()}`);
  async deleteDatabase(name: string): Promise<void> {
      throw new Error(`Failed to delete database: ${await response.text()}`);
async function main() {
  const db = new Database();
  const turso = new TursoManager();
async function listDatabasesAndOrgs(db: Database, turso: TursoManager) {
async function updateGroupConfig(turso: TursoManager) {
async function deleteCustomerDatabase(db: Database, turso: TursoManager) {

================
File: src/config/turso.ts
================


================
File: src/middleware/account-status.ts
================
export const accountStatusMiddleware = new Elysia()
      const db = new Database();

================
File: src/middleware/auth.ts
================
interface AuthenticatedRequest extends Request {
export async function authMiddleware(
  req: AuthenticatedRequest, 
  res: Response, 
  next: NextFunction
    const db = new Database();

================
File: src/middleware/error.ts
================
export const errorHandler = new Elysia()

================
File: src/routes/admin-portal.ts
================
export const createAdminPortalRoutes = () => {
  const adminPortal = new Elysia({ prefix: '/api/admin' })

================
File: src/routes/admin.ts
================
const tursoService = new TursoService()
export const adminRoutes = new Elysia()
    open(ws) {
    message(ws, message) {

================
File: src/routes/auth.ts
================
const dbInstance = new Database();
export function createAuthRoutes() {
  const auth = new AuthService();
  const emailService = new EmailService();
  return new Elysia()
        const expiresAt = new Date();

================
File: src/routes/brand.ts
================
const db = new Database();
interface Organization {
interface BrandSettings {
export function createBrandRoutes() {
  return new Elysia()

================
File: src/routes/contacts.ts
================
async function getOrgTursoClient(orgId: string) {

================
File: src/routes/eligibility.ts
================
interface EligibilityAnswers {
export const eligibilityRoutes = (app: Elysia) => {
                    throw new Error('Failed to create temporary contact');
                throw new Error('Failed to save eligibility answers');

================
File: src/routes/onboarding.ts
================
interface OnboardingData {
interface StateCarrierSetting {
const generateRandomSlug = () => {
export function createOnboardingRoutes() {
  const dbInstance = new Database()
  return new Elysia()
            throw new Error('Admin user email not found');
          const turso = new TursoService();
export async function cleanupOldOrganizations() {
  const dbInstance = new Database();

================
File: src/routes/organizations.ts
================
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
export const organizationRoutes = new Elysia({ prefix: '/api' })
    const db = new Database();
    const turso = new TursoService();
    const auth = new AuthService();
          throw new Error('Failed to create organization');
            new Date().toISOString()
          throw new Error('User not found');
    request: Request 
export function createOrganizationRoutes() {
  const dbInstance = new Database();
  const authService = new AuthService();
  return new Elysia()

================
File: src/routes/quotes.ts
================
interface Quote {
interface QuoteResponse {
interface QuoteRequestBody {
interface QuoteRequest {
interface ContactQuoteInfo {
interface OrgRedirectInfo {
export const quotesRoutes = (app: Elysia) => {
                throw new Error('No organization ID found in session');
                throw new Error('Invalid contact ID');
                throw new Error('Contact not found');
            throw new Error(String(e));
                throw new Error('Invalid quote ID');
    .post('/api/quotes', async ({ body }: { body: QuoteRequestBody }) => {
            const requestBody: QuoteRequest = {
            throw new Error(String(error));
            const db = new Database();
                throw new Error('Organization not found');
                throw new Error('No active agents or admins found');
                throw new Error('Quote ID is required');

================
File: src/routes/self-service.ts
================
function generateHash(orgId: string, email: string): string {
export function createSelfServiceRoutes() {
  return new Elysia()

================
File: src/routes/settings.ts
================
interface StateCarrierSetting {
interface SettingsBody {
    settings?: BaseSettings;
interface AgentSettingsResponse {
  orgSettings: BaseSettings;
    settings: BaseSettings;
const defaultSettings: BaseSettings = {
function generateDefaultStateCarrierSettings(states: string[], carriers: string[]): StateCarrierSetting[] {
export const settingsRoutes = new Elysia()
    const db = new Database();
        let orgSettings: BaseSettings;

================
File: src/routes/stripe.ts
================
export const createStripeRoutes = () => {
  return new Elysia({ prefix: '/api/stripe' })
      const db = new Database();
async function handleCheckoutComplete(session: any, db: Database): Promise<void> {

================
File: src/services/agentSettings.ts
================
export interface StateCarrierSetting {
export interface AgentSettings {
      [carrier: string]: StateCarrierSetting;
export async function getAgentSettings(agentId: number): Promise<AgentSettings> {
async function createDefaultSettings(agentId: number): Promise<AgentSettings> {
export async function updateAgentSettings(
    throw new NotFoundError('Agent settings not found');

================
File: src/services/auth.ts
================
    throw new Error("Must set MAGIC_LINK_SECRET in production");
interface MagicLinkPayload {
export class AuthService {
  constructor(private baseUrl?: string) {
  async createMagicLink(
    const payload: MagicLinkPayload = {
  async verifyMagicLink(token: string, organizationSlug: string): Promise<{
      const payload: MagicLinkPayload = JSON.parse(decrypted);
        logger.error(`Token expired: ${new Date(payload.expiresAt)} < ${new Date()}`);
  private encrypt(text: string): string {
  private decrypt(text: string): string {
        throw new Error("Invalid token format - missing parts");
export async function validateSession(sessionId: string): Promise<User | null> {
  const db = new Database();
  const expiresAt = new Date(session.expires_at);
  const now = new Date();
export function generateToken(): string {
export async function getUserFromSession(request: Request) {

================
File: src/services/email.ts
================
interface MagicLinkEmailParams {
export class EmailService {
  constructor() {
      throw new Error('Missing SENDGRID_API_KEY environment variable');
  async sendMagicLink(email: string, magicLink: string, organizationSlug: string) {
      throw new Error('Failed to send magic link email');
  async sendQuoteEmail(params: {
      throw new Error('Failed to send quote email');
export async function sendMagicLink({ email, magicLink, name }: {
function generateHash(orgId: string, email: string): string {
export async function sendOnboardingLink(orgId: string, email?: string) {
    throw new Error('Failed to send onboarding link email');

================
File: src/services/stripe.ts
================
const stripe = new Stripe(config.stripe.secretKey, {
export type PlanTier = 'basic' | 'pro' | 'enterprise';
interface CreateSubscriptionOptions {
  tierId: PlanTier;
export interface SubscriptionResult {
export async function createOrUpdateSubscription({
}: CreateSubscriptionOptions): Promise<SubscriptionResult> {
export async function handleStripeWebhook(event: Stripe.Event): Promise<void> {
  const db = new Database();
              new Date(subscription.current_period_end * 1000).toISOString(),
              subscription.trial_end ? new Date(subscription.trial_end * 1000).toISOString() : null,
              [new Date().toISOString(), orgResult[0].id]

================
File: src/services/subscription.ts
================
export type AccountStatus = 
export interface AccountStatusDetails {
  status: AccountStatus;
  billingCycleEnd?: Date;
export async function syncSubscriptionStatus(organizationId: number): Promise<void> {
  const db = new Database();
    const stripe = new Stripe(config.stripe.secretKey, {
    const billingCycleEnd = new Date(subscription.current_period_end * 1000);
      ? new Date(subscription.trial_end * 1000) 
export async function checkAccountStatus(organizationId: number): Promise<AccountStatusDetails> {
      throw new Error(`Organization not found: ${organizationId}`);
          billingCycleEnd: statusObj.billing_cycle_end ? new Date(statusObj.billing_cycle_end) : undefined,
    const accountStatus: AccountStatus = 'good_standing';
      billingCycleEnd: orgObj.billing_cycle_end ? new Date(orgObj.billing_cycle_end) : undefined,

================
File: src/services/turso.ts
================
export class TursoService {
  async createOrganizationDatabase(orgId: string): Promise<{url: string, token: string}> {
      throw new Error(`Failed to create database: ${await createDbResponse.text()}`);
      throw new Error(`Failed to create auth token: ${await tokenResponse.text()}`);
  async deleteOrganizationDatabase(dbName: string): Promise<void> {
      throw new Error(`Failed to delete database: ${await response.text()}`);

================
File: src/utils/quoteId.ts
================
export function generateQuoteId(orgId: number, contactId: number): string {
export function decodeQuoteId(quoteId: string): { orgId: number; contactId: number } | null {

================
File: src/config.ts
================


================
File: src/database.ts
================
export class Database {
  constructor(dbUrl?: string, authToken?: string) {
      throw new Error('Missing database credentials')
  static async getOrgDb(orgId: string): Promise<Database> {
      const mainDb = new Database()
        throw new Error('Organization database not configured')
      return new Database(org.turso_db_url, org.turso_auth_token)
  static async getOrInitOrgDb(orgId: string): Promise<Database> {
            throw new Error('Organization not found')
          const turso = new TursoService()
          return new Database(url, token)
  static async ensureDatabaseSchema(orgId: string): Promise<void> {
  getClient() {
  async execute(sql: string, args: any[] = []) {
  async fetchAll(sql: string, args: any[] = []) {
  async fetchOne<T>(sql: string, args: any[] = []): Promise<T | null> {
  async query<T = any>(sql: string, args: any[] = []): Promise<T[]> {
  async transaction<T>(callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(mode: 'read' | 'write', callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(
    callbackOrMode: ((tx: Database) => Promise<T>) | 'read' | 'write',
    callback?: (tx: Database) => Promise<T>
    let fn: ((tx: Database) => Promise<T>) | null = null
      throw new Error('Transaction callback is required')
      const txWrapper = new Database()
export const db = new Database()

================
File: src/errors.ts
================
export class NotFoundError extends Error {
  constructor(message: string) {
export class UnauthorizedError extends Error {
  constructor(message: string = 'Unauthorized') {
export class ValidationError extends Error {
export class DatabaseError extends Error {

================
File: src/index.ts
================
interface ZipInfo {
type NewAgentRequest = {
type AgentUpdate = {
interface DbRow {
interface ContactRow {
interface CarrierRow {
function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
function validateEmail(email: string): boolean {
function validateISODate(dateStr: string): { isValid: boolean; isoDate: string | null } {
    const date = new Date(trimmed);
    if (date > new Date()) {
async function validateCarrier(carrier: string, db: Database): Promise<{ isValid: boolean; standardizedName: string; wasConverted: boolean }> {
    const centralDb = new Database();
const startServer = async () => {
    const db = new Database()
    const app = new Elysia()
        return new Response(null, { status: 204 })
        const path = new URL(url).pathname
        error: Error;
        const path = new URL(request.url).pathname
        return new Response(JSON.stringify({
            throw new Error('No organization ID found in session')
          const url = new URL(request.url)
          throw new Error(String(e))
            throw new Error(`Contact ${id} not found`)
      .post('/api/contacts', async ({ body, request }: { body: ContactCreate, request: Request }) => {
            throw new Error('A contact with this email already exists')
            throw new Error('Failed to fetch created contact')
      .put('/api/contacts/:id', async ({ params: { id }, body, request }: { body: ContactCreate, request: Request }) => {
            throw new Error(`Invalid ZIP code: ${contact.zip_code}`)
            throw new Error(`Contact ${id} not found after update`)
            throw new Error('No contact IDs provided')
      .put('/api/contacts/reassign', async ({ request, body }: { request: Request, body: { contact_ids: number[], agent_id: number | null } }) => {
            throw new Error('Invalid or empty contact_ids array')
      .post('/api/contacts/upload', async ({ request, body }: { request: Request, body: { contacts: any[], file_type?: string, sheet_name?: string } }) => {
          const formData = body as { file: File, overwrite_duplicates: boolean | string, duplicateStrategy: string, agent_id?: string }
          let existingEmails = new Set<string>()
          existingEmails = new Set(emailResults.map((row: any) => row[0]?.trim().toLowerCase()))
              const url = new URL(request.url);
                  return new Response(Bun.file(filePath), {
                  return new Response(Bun.file(join(distPath, 'index.html')), {
                    return new Response(Bun.file(indexPath), {
                    return new Response('index.html not found', { status: 404 });
                return new Response('Not found', { status: 404 });
                return new Response(`Server error: ${error}`, { status: 500 });
        body: AgentUpdate,
        request: Request,
            throw new Error('User update failed - no rows affected')
            throw new Error('Settings update failed - no rows affected')
          const emailService = new EmailService();
              throw new Error('Failed to create lead')
          throw new Error(e instanceof Error ? e.message : String(e))

================
File: src/logger.ts
================
    const timestamp = new Date().toISOString()

================
File: src/types.ts
================
export interface ContactCreate {
export interface AgentCreate {
export interface User {



================================================================
End of Codebase
================================================================

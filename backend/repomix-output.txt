This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/, **/zipData.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
data/
  migrations/
    003_add_tracking_clicks.sql
    004_fix_tracking_clicks.sql
  public/
    hhd.csv
migrations/
  007-pending-signups-table.sql
  20240324_create_contacts_table.sql
  20240324_optimize_contacts.sql
  20240325_fix_missing_updated_at.sql
  20240326_create_waitlist_table.sql
  20240326_deduplicate_contacts.sql
  20240326_fix_contact_email_unique.sql
  20240326_fix_duplicate_contacts.sql
  20240402_allow_null_current_carrier.sql
  20240406_add_contact_history_tracking.sql
  20250425_create_schema_no_contacts.sql
  20250425_fix_schema_with_contacts.sql
  20250425_make_optional_fields_nullable.sql
  add_aep_request_columns.sql
  add_deleted_contacts_table.sql
  add_email_tracking.sql
  add_onboarding_columns.sql
  add_send_time_col.sql
  add_updated_at_col.sql
  create_subscription_tables.sql
  fix_email_tracking.sql
  remove_eligibility_answers_fk.sql
public/
  hhd.csv
  test-bulk-import.html
scripts/
  add-agent.ts
  apply-contact-migration.ts
  generate-test-data.ts
  generateQuoteId.ts
  generateQuoteUrl.ts
  manage-recommendations.ts
  manage-turso.ts
  migrate-tracking-clicks.js
  sample-contacts.csv
  setup-contact-tracking.sh
  test-bulk-import.ts
sql/
  add_demo_mode_column.sql
  create_tables.sql
  update_org_limits.sql
  update_org_schema.sql
src/
  config/
    index.ts
    turso.ts
  middleware/
    account-status.ts
    auth.copy.ts
    auth.ts
    error.ts
  routes/
    admin-portal.ts
    admin.ts
    auth.ts
    billing.ts
    brand.ts
    contacts.ts
    contactTracking.ts
    dashboard.ts
    eligibility.ts
    onboarding.ts
    organizations.ts
    quotes.ts
    schedule.ts
    self-service.ts
    settings.ts
    signup.ts
    stripe.ts
    waitlist.ts
  scripts/
    apply_nullable_fields_migration.ts
    apply_org_migrations.ts
    migrate-add-aep-columns.ts
  services/
    agentSettings.ts
    auth.ts
    contactCount.ts
    contactTracking.ts
    email.ts
    stripe.ts
    subscription.ts
    turso.ts
  utils/
    quoteId.ts
    tracking.ts
  config.ts
  database.ts
  errors.ts
  index.ts
  logger.ts
  types.ts
.env.example
.gitignore
BULK-IMPORT-IMPLEMENTATION.md
out.txt
package.json
README-bulk-import.md
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: data/migrations/003_add_tracking_clicks.sql
================
-- Migration: 003_add_tracking_clicks.sql
-- Description: Adds tracking_clicks table for link click tracking
-- Date: 2023-08-30

-- Create the tracking_clicks table if it doesn't exist
CREATE TABLE IF NOT EXISTS tracking_clicks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  tracking_id TEXT NOT NULL,
  path TEXT NOT NULL,
  query TEXT,
  contact_id INTEGER,
  ip_address TEXT,
  user_agent TEXT, 
  referrer TEXT,
  clicked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Create indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_tracking_clicks_tracking_id ON tracking_clicks(tracking_id);
CREATE INDEX IF NOT EXISTS idx_tracking_clicks_contact_id ON tracking_clicks(contact_id);
CREATE INDEX IF NOT EXISTS idx_tracking_clicks_clicked_at ON tracking_clicks(clicked_at);

-- Add versioning information to track that this migration has been applied

================
File: data/migrations/004_fix_tracking_clicks.sql
================
-- Add quote_id column if it doesn't exist
ALTER TABLE tracking_clicks ADD COLUMN quote_id TEXT;

-- Create a new table with the desired structure
CREATE TABLE tracking_clicks_new (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  tracking_id TEXT NOT NULL,
  contact_id INTEGER,
  quote_id TEXT,
  clicked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Copy data from the old table to the new table
INSERT INTO tracking_clicks_new (id, tracking_id, contact_id, quote_id, clicked_at)
SELECT id, tracking_id, contact_id, quote_id, clicked_at FROM tracking_clicks;

-- Drop the old table
DROP TABLE tracking_clicks;

-- Rename the new table to the original name
ALTER TABLE tracking_clicks_new RENAME TO tracking_clicks;

-- Recreate the indexes
CREATE INDEX idx_tracking_clicks_tracking_id ON tracking_clicks(tracking_id);
CREATE INDEX idx_tracking_clicks_contact_id ON tracking_clicks(contact_id);
CREATE INDEX idx_tracking_clicks_clicked_at ON tracking_clicks(clicked_at);

================
File: data/public/hhd.csv
================
,ACE/Chubb,AETNA,AFLAC,Allstate,Anthem,CIGNA,Mutual of Omaha,Humana (MIPPA),Humana (Achieve),UHIC
AL,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
AK,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,NA,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment.",NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,NA,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
AZ,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",Both you and your spouse/partner must have a supplemental plan with Anthem.,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
AR,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan.,NA,You need to live with a spouse or someone who is at least 50 years old.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
CA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",Both you and your spouse/partner must have a supplemental plan with Anthem.,Price includes 6% off for living with someone 50+. Additional discount of 5% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,NA,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #. Additional $25 discount for first 12 months for new to Medicare on Plan G.
CO,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",Both you and your spouse/partner must have a supplemental plan with Anthem.,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
CT,NA,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with Anthem.,Both you and your spouse/partner must have a supplemental plan with CIGNA.,NA,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
DE,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
DC,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,NA,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,NA,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,NA
FL,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,NA,Both you and your spouse/partner must have a supplemental plan with AFLAC.,Live with someone 50+,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,NA,NA,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
GA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",You need to live with a spouse or someone who is at least 60 years old.,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
HI,NA,NA,NA,NA,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,NA
ID,NA,NA,NA,NA,NA,NA,NA,*Value Plan - NA,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
IL,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+,NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
IN,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 10% for annual payment, 5% for wearable fitness device use.",Both you and your spouse/partner must have a supplemental plan with Anthem.,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,NA,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
IA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
KS,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
KY,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",Both you and your spouse/partner must have a supplemental plan with Anthem.,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
LA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
ME,You need to live with a spouse or someone who is at least 50 years old.,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with Anthem.,Both you and your spouse/partner must have a supplemental plan with CIGNA.,Both you and your spouse/partner must have a supplemental plan with Mutual of Omaha.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MD,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MA,NA,NA,NA,NA,NA,NA,NA,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MI,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MN,NA,NA,NA,Price includes 7% off for living with someone 50+. Save extra: 10% for annual payment.,NA,NA,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MS,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MO,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with someone who is at least 50 years old.,You need to live with a spouse or domestic partner.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MT,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 18 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
NE,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
NV,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan.,Both you and your spouse/partner must have a supplemental plan with Anthem.,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
NH,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,NA,NA,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,NA
NJ,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,Live with someone 50+,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
NM,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,NA
NY,NA,NA,NA,NA,Not accepting new Supps,NA,NA,NA,NA,NA
NC,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
ND,NA,NA,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,NA
OH,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,Live with someone 50+,Both you and your spouse/partner must have a supplemental plan with Anthem.,Both you and your spouse/partner must have a supplemental plan with CIGNA.,"You need to live with your spouse, partner, or a roomate for the last 12 months.",Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
OK,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,"You need to live with your spouse, partner, or a roomate for the last 12 months.",Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
OR,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
PA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+,NA,You need to live with a spouse or partner. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or domestic partner.,"You need to live with spouse, civil or domestic partner.",You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
RI,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,NA,NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,NA,NA,NA
SC,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
SD,You need to live with a spouse or someone who is at least 50 years old.,NA,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
TN,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
TX,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",Both you and your spouse/partner must have a supplemental plan with Anthem.,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
UT,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
VT,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA
VA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner must have a supplemental plan with AFLAC.,Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan.,Both you and your spouse/partner must have a supplemental plan with Anthem.,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
WA,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,NA,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,Both you and your spouse/partner must have a supplemental plan with Mutual of Omaha.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
WV,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
WI,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",Both you and your spouse/partner must have a supplemental plan with Anthem.,Price includes 6% off for living with someone 18+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
WY,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,"Price includes 7% off for living with someone 50+. Save extra: 3% for spouse enrolling into the same plan, 10% for annual payment, 5% for wearable fitness device use.",NA,Price includes 6% off for living with someone 50+. Additional discount of 14% is available if you and your spouse/partner enroll into the same plan. ,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.

================
File: migrations/007-pending-signups-table.sql
================
-- Create pending_signups table to store user information temporarily during signup
CREATE TABLE IF NOT EXISTS pending_signups (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  organization_id INTEGER NOT NULL,
  first_name TEXT NOT NULL,
  last_name TEXT,
  email TEXT NOT NULL,
  created_at TEXT NOT NULL,
  FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE
);

-- Add index for faster lookups
CREATE INDEX IF NOT EXISTS idx_pending_signups_org_id ON pending_signups(organization_id);
CREATE INDEX IF NOT EXISTS idx_pending_signups_email ON pending_signups(email);

================
File: migrations/20240324_create_contacts_table.sql
================
-- Create contacts table if it doesn't exist
CREATE TABLE IF NOT EXISTS contacts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT NOT NULL,
  current_carrier TEXT NOT NULL,
  plan_type TEXT NOT NULL,
  effective_date TEXT NOT NULL,
  birth_date TEXT NOT NULL,
  tobacco_user INTEGER NOT NULL,
  gender TEXT NOT NULL,
  state TEXT NOT NULL,
  zip_code TEXT NOT NULL,
  agent_id INTEGER,
  last_emailed DATETIME,
  phone_number TEXT NOT NULL DEFAULT '',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Add indexes for common queries
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_current_carrier ON contacts(current_carrier);
CREATE INDEX IF NOT EXISTS idx_contacts_effective_date ON contacts(effective_date);

-- Add unique constraint on email
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

================
File: migrations/20240324_optimize_contacts.sql
================
-- Optimize contacts table performance

-- Add missing columns if they don't exist
SELECT CASE 
    WHEN NOT EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'created_at') 
    THEN 'ALTER TABLE contacts ADD COLUMN created_at DATETIME DEFAULT CURRENT_TIMESTAMP;'
    ELSE 'SELECT 1;'
END AS sql_to_run;

SELECT CASE 
    WHEN NOT EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'updated_at') 
    THEN 'ALTER TABLE contacts ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP;'
    ELSE 'SELECT 1;'
END AS sql_to_run;

SELECT CASE 
    WHEN NOT EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'last_emailed') 
    THEN 'ALTER TABLE contacts ADD COLUMN last_emailed DATETIME;'
    ELSE 'SELECT 1;'
END AS sql_to_run;

-- Add core indexes that should work on all databases
-- Email is guaranteed to exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts (email COLLATE NOCASE);

-- Agent ID is guaranteed to exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts (agent_id);

-- Add carrier index which should exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_agent_carrier ON contacts (agent_id, current_carrier COLLATE NOCASE);

-- Add state index which should exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts (state COLLATE NOCASE);

-- Add plan type index which should exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_plan_type ON contacts (plan_type COLLATE NOCASE);

-- Add tobacco user index which should exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_tobacco_user ON contacts (tobacco_user);

-- Add timestamp indexes only if columns exist
SELECT CASE 
    WHEN EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'created_at') 
    THEN 'CREATE INDEX IF NOT EXISTS idx_contacts_created_at ON contacts (created_at);'
    ELSE 'SELECT 1;'
END AS sql_to_run;

SELECT CASE 
    WHEN EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'updated_at') 
    THEN 'CREATE INDEX IF NOT EXISTS idx_contacts_updated_at ON contacts (updated_at);'
    ELSE 'SELECT 1;'
END AS sql_to_run;

SELECT CASE 
    WHEN EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'last_emailed') 
    THEN 'CREATE INDEX IF NOT EXISTS idx_contacts_last_emailed ON contacts (last_emailed);'
    ELSE 'SELECT 1;'
END AS sql_to_run;

-- Add date field indexes which should exist as they're core fields
CREATE INDEX IF NOT EXISTS idx_contacts_birth_date ON contacts (birth_date);
CREATE INDEX IF NOT EXISTS idx_contacts_effective_date ON contacts (effective_date);

-- Create a view for contact statistics that works with core fields only
CREATE VIEW IF NOT EXISTS v_contact_stats AS
WITH contact_metrics AS (
    SELECT 
        agent_id,
        current_carrier,
        state,
        COUNT(*) as total_contacts,
        SUM(CASE WHEN tobacco_user = 1 THEN 1 ELSE 0 END) as tobacco_users,
        SUM(CASE WHEN plan_type IS NOT NULL THEN 1 ELSE 0 END) as with_plan_type
    FROM contacts
    GROUP BY agent_id, current_carrier, state
)
SELECT 
    cm.*,
    (SELECT COUNT(DISTINCT current_carrier) FROM contacts WHERE agent_id = cm.agent_id) as unique_carriers,
    (SELECT COUNT(DISTINCT state) FROM contacts WHERE agent_id = cm.agent_id) as unique_states
FROM contact_metrics cm;

================
File: migrations/20240325_fix_missing_updated_at.sql
================
-- Check if updated_at column exists, if not add it
PRAGMA foreign_keys=off;

BEGIN TRANSACTION;

-- Create a temporary table with the same structure plus the updated_at column
CREATE TABLE IF NOT EXISTS contacts_new (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT NOT NULL,
  current_carrier TEXT NOT NULL,
  plan_type TEXT NOT NULL,
  effective_date TEXT NOT NULL,
  birth_date TEXT NOT NULL,
  tobacco_user INTEGER NOT NULL,
  gender TEXT NOT NULL,
  state TEXT NOT NULL,
  zip_code TEXT NOT NULL,
  agent_id INTEGER,
  last_emailed DATETIME,
  phone_number TEXT NOT NULL DEFAULT '',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Copy data from the old table to the new table
INSERT INTO contacts_new 
SELECT 
  id, 
  first_name, 
  last_name, 
  email, 
  current_carrier, 
  plan_type, 
  effective_date, 
  birth_date, 
  tobacco_user, 
  gender, 
  state, 
  zip_code, 
  agent_id, 
  last_emailed, 
  phone_number, 
  COALESCE(created_at, CURRENT_TIMESTAMP),
  CURRENT_TIMESTAMP
FROM contacts;

-- Drop the old table
DROP TABLE contacts;

-- Rename the new table to the original name
ALTER TABLE contacts_new RENAME TO contacts;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_current_carrier ON contacts(current_carrier);
CREATE INDEX IF NOT EXISTS idx_contacts_effective_date ON contacts(effective_date);
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

COMMIT;

PRAGMA foreign_keys=on;

================
File: migrations/20240326_create_waitlist_table.sql
================
-- Create waitlist table
CREATE TABLE IF NOT EXISTS waitlist (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    phone TEXT NOT NULL,
    num_agents INTEGER NOT NULL,
    book_size INTEGER NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Create index on email for faster lookups
CREATE INDEX IF NOT EXISTS idx_waitlist_email ON waitlist(email);

-- Create trigger to update updated_at timestamp
CREATE TRIGGER IF NOT EXISTS tg_waitlist_updated_at 
    AFTER UPDATE ON waitlist
    FOR EACH ROW
BEGIN
    UPDATE waitlist 
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = NEW.id;
END;

================
File: migrations/20240326_deduplicate_contacts.sql
================
-- Migration to deduplicate contacts and ensure unique email constraint works properly
-- This script will:
-- 1. Check for duplicate emails
-- 2. Back up the existing contacts table
-- 3. Deduplicate contacts by keeping the most recently updated record for each email
-- 4. Create the unique index to prevent future duplicates

-- Print counts before
SELECT COUNT(*) as total_contacts_before FROM contacts;
SELECT COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as duplicate_emails FROM contacts;

-- Check if we already have a unique index on email
SELECT COUNT(*) as has_unique_index FROM sqlite_master 
WHERE type='index' AND name='idx_contacts_email_unique';

-- Create a backup of the original table for safety
DROP TABLE IF EXISTS contacts_backup;
CREATE TABLE contacts_backup AS SELECT * FROM contacts;

-- Only proceed with deduplication if there are duplicates
CREATE TABLE contacts_temp AS
SELECT * FROM (
  SELECT id, first_name, last_name, email, current_carrier, plan_type, effective_date,
         birth_date, tobacco_user, gender, state, zip_code, agent_id, last_emailed,
         phone_number, created_at, updated_at,
         ROW_NUMBER() OVER (PARTITION BY LOWER(TRIM(email)) ORDER BY updated_at DESC) as rn
  FROM contacts
) WHERE rn = 1;

-- Drop any existing unique index on email before we drop the table
DROP INDEX IF EXISTS idx_contacts_email_unique;
DROP INDEX IF EXISTS idx_contacts_email;

-- Drop original table
DROP TABLE contacts;

-- Rename the deduped table to contacts
ALTER TABLE contacts_temp RENAME TO contacts;

-- Recreate the primary key
CREATE UNIQUE INDEX sqlite_autoindex_contacts_1 ON contacts(id);

-- Add unique index on email with case and whitespace insensitivity
CREATE UNIQUE INDEX idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

-- Add other helpful indexes
CREATE INDEX idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);

-- Print counts after
SELECT COUNT(*) as total_contacts_after FROM contacts;

-- Verify indexes
SELECT name FROM sqlite_master WHERE type='index' AND tbl_name='contacts';

================
File: migrations/20240326_fix_contact_email_unique.sql
================
-- Migration to deduplicate contacts and ensure unique email constraint works properly

-- Print counts before
SELECT COUNT(*) as total_contacts_before FROM contacts;
SELECT COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as duplicate_emails FROM contacts;

-- Check if we already have a unique index on email
SELECT COUNT(*) as has_unique_index FROM sqlite_master 
WHERE type='index' AND name='idx_contacts_email_unique';

-- Only proceed with deduplication if there are duplicates
CREATE TABLE IF NOT EXISTS contacts_temp AS
SELECT * FROM (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY LOWER(TRIM(email)) ORDER BY updated_at DESC) as rn
  FROM contacts
) WHERE rn = 1;

-- Drop any existing unique index on email before we drop the table
DROP INDEX IF EXISTS idx_contacts_email_unique;

-- Create a backup of the original table for safety
CREATE TABLE contacts_backup AS SELECT * FROM contacts;

-- Drop original table
DROP TABLE contacts;

-- Rename the deduped table to contacts
ALTER TABLE contacts_temp RENAME TO contacts;

-- Recreate the primary key
CREATE UNIQUE INDEX sqlite_autoindex_contacts_1 ON contacts(id);

-- Add unique index on email with case and whitespace insensitivity
CREATE UNIQUE INDEX idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

-- Add other helpful indexes
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);

-- Print counts after
SELECT COUNT(*) as total_contacts_after FROM contacts;

================
File: migrations/20240326_fix_duplicate_contacts.sql
================
-- Migration to ensure unique index on email in contacts table
-- Run this script on all organization databases to prevent duplicate contacts

-- First check if we have duplicates
SELECT COUNT(*) as total_contacts FROM contacts;
SELECT COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as duplicate_emails FROM contacts;

-- Check if we already have the unique index on email
SELECT COUNT(*) as has_unique_index FROM sqlite_master 
WHERE type='index' AND name='idx_contacts_email_unique';

-- Create unique index if it doesn't exist 
-- (This will fail if there are duplicate emails, so run the deduplication process first)
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

-- Create or update the standard index
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);

-- Force indexes to be used by SQLite
ANALYZE;

-- Verify index creation
SELECT name FROM sqlite_master WHERE type='index' AND tbl_name='contacts';

================
File: migrations/20240402_allow_null_current_carrier.sql
================
-- Migration to allow NULL values in current_carrier, plan_type and add current_premium column
-- This migration needs to be applied to all organization databases

-- Create a temporary table with the desired schema
CREATE TABLE contacts_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    current_carrier TEXT, -- Changed to allow NULL
    current_premium TEXT, -- New column, allows NULL
    plan_type TEXT, -- Changed to allow NULL
    effective_date TEXT NOT NULL,
    birth_date TEXT NOT NULL,
    tobacco_user INTEGER NOT NULL,
    gender TEXT NOT NULL,
    state TEXT NOT NULL,
    zip_code TEXT NOT NULL,
    agent_id INTEGER,
    last_emailed DATETIME,
    phone_number TEXT NOT NULL DEFAULT '',
    status TEXT NOT NULL DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Copy data from the old table to the new table
INSERT INTO contacts_new 
SELECT 
    id,
    first_name,
    last_name,
    email,
    current_carrier,
    NULL as current_premium, -- Set existing rows to NULL for new column
    plan_type,
    effective_date,
    birth_date,
    tobacco_user,
    gender,
    state,
    zip_code,
    agent_id,
    last_emailed,
    phone_number,
    status,
    created_at,
    updated_at
FROM contacts;

-- Drop the old table
DROP TABLE contacts;

-- Rename the new table to contacts
ALTER TABLE contacts_new RENAME TO contacts;

-- Recreate any indexes that existed on the original table
CREATE UNIQUE INDEX idx_contacts_email ON contacts(email);
CREATE INDEX idx_contacts_zip_code ON contacts(zip_code);
CREATE INDEX idx_contacts_state ON contacts(state);
CREATE INDEX idx_contacts_created_at ON contacts(created_at);
CREATE INDEX idx_contacts_updated_at ON contacts(updated_at);

================
File: migrations/20240406_add_contact_history_tracking.sql
================
-- Migration: 20240406_add_contact_history_tracking.sql
-- Description: Adds contact history tracking table for usage-based billing

-- Create table to track unique contacts by email for billing purposes
CREATE TABLE IF NOT EXISTS contact_history (
  id TEXT PRIMARY KEY,
  organization_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  email TEXT NOT NULL,
  first_name TEXT,
  last_name TEXT,
  first_uploaded TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_uploaded TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  status TEXT DEFAULT 'active', -- active, deleted, blocked
  billing_cycle_key TEXT, -- To identify which billing cycle this contact belongs to
  UNIQUE(organization_id, email)
);

-- Add indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_contact_history_org_email ON contact_history(organization_id, email);
CREATE INDEX IF NOT EXISTS idx_contact_history_org_user ON contact_history(organization_id, user_id);
CREATE INDEX IF NOT EXISTS idx_contact_history_first_uploaded ON contact_history(first_uploaded);
CREATE INDEX IF NOT EXISTS idx_contact_history_billing_cycle ON contact_history(organization_id, billing_cycle_key);

-- Add tracking fields to organizations table if they don't exist
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS contact_count_billing_date TEXT; -- Date when billing cycle starts (e.g., '01' for 1st of month)
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS current_billing_cycle_key TEXT; -- Current billing cycle identifier
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS current_unique_contacts INTEGER DEFAULT 0; -- Count of unique contacts in current cycle

-- Create table to track billing cycle history
CREATE TABLE IF NOT EXISTS billing_cycle_history (
  id TEXT PRIMARY KEY,
  organization_id TEXT NOT NULL,
  cycle_key TEXT NOT NULL, -- Format: YYYY-MM for monthly cycles
  start_date TIMESTAMP NOT NULL,
  end_date TIMESTAMP NOT NULL,
  contact_count INTEGER DEFAULT 0,
  usage_reported BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(organization_id, cycle_key)
);

-- Create a trigger to update last_uploaded timestamp when existing contacts are re-uploaded
CREATE TRIGGER IF NOT EXISTS update_contact_last_uploaded
AFTER UPDATE ON contact_history
BEGIN
  UPDATE contact_history
  SET last_uploaded = CURRENT_TIMESTAMP
  WHERE id = NEW.id AND OLD.email = NEW.email;
END;

-- Create a function to generate a new billing cycle key
CREATE FUNCTION IF NOT EXISTS generate_billing_cycle_key(date_string TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN to_char(date_string::date, 'YYYY-MM');
END;
$$ LANGUAGE plpgsql;

================
File: migrations/20250425_create_schema_no_contacts.sql
================
-- Migration for databases WITHOUT an existing contacts table
-- This script creates the contacts table with nullable fields

-- Drop any temporary tables that might exist
DROP TABLE IF EXISTS contacts_new;

-- Create contacts table with the correct schema
CREATE TABLE IF NOT EXISTS contacts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    current_carrier TEXT, 
    current_premium TEXT, 
    plan_type TEXT, 
    effective_date TEXT, 
    birth_date TEXT, 
    tobacco_user INTEGER NOT NULL DEFAULT 0,
    gender TEXT, 
    state TEXT, 
    zip_code TEXT, 
    agent_id INTEGER,
    last_emailed DATETIME,
    phone_number TEXT, 
    status TEXT NOT NULL DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Check if contacts_backup exists before trying to access it
CREATE TEMP TABLE IF NOT EXISTS table_check AS
SELECT EXISTS(SELECT 1 FROM sqlite_master WHERE type='table' AND name='contacts_backup') as has_contacts_backup;

-- If contacts_backup exists, check its columns
CREATE TEMP TABLE IF NOT EXISTS column_check AS
SELECT 
    CASE WHEN (SELECT has_contacts_backup FROM table_check) = 1 THEN
        EXISTS(SELECT 1 FROM pragma_table_info('contacts_backup') WHERE name='current_premium')
    ELSE 0 END as has_current_premium,
    CASE WHEN (SELECT has_contacts_backup FROM table_check) = 1 THEN
        EXISTS(SELECT 1 FROM pragma_table_info('contacts_backup') WHERE name='plan_type')
    ELSE 0 END as has_plan_type;

-- Copy data from contacts_backup if it exists
INSERT OR IGNORE INTO contacts(
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, tobacco_user, gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    status, created_at, updated_at
)
SELECT 
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, COALESCE(tobacco_user, 0), gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    COALESCE(status, ''), COALESCE(created_at, CURRENT_TIMESTAMP), 
    COALESCE(updated_at, CURRENT_TIMESTAMP)
FROM contacts_backup WHERE EXISTS(SELECT 1 FROM sqlite_master WHERE type='table' AND name='contacts_backup');

-- Clean up temp tables
DROP TABLE IF EXISTS table_check;
DROP TABLE IF EXISTS column_check;

-- Create indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_zip_code ON contacts(zip_code);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_created_at ON contacts(created_at);
CREATE INDEX IF NOT EXISTS idx_contacts_updated_at ON contacts(updated_at);
CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp AFTER UPDATE ON contacts 
BEGIN 
  UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; 
END;

================
File: migrations/20250425_fix_schema_with_contacts.sql
================
-- Migration for databases WITH existing contacts table
-- This script makes optional fields nullable

-- Clean up any temporary tables from previous failed migrations
DROP TABLE IF EXISTS contacts_new;

-- Create new contacts table with the desired schema
CREATE TABLE contacts_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    current_carrier TEXT, 
    current_premium TEXT, 
    plan_type TEXT, 
    effective_date TEXT, 
    birth_date TEXT, 
    tobacco_user INTEGER NOT NULL DEFAULT 0,
    gender TEXT, 
    state TEXT, 
    zip_code TEXT, 
    agent_id INTEGER,
    last_emailed DATETIME,
    phone_number TEXT, 
    status TEXT NOT NULL DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Get schema information to determine available columns
CREATE TEMP TABLE IF NOT EXISTS pragma_table_info AS 
SELECT * FROM pragma_table_info('contacts');

-- Set variables for optional column existence
CREATE TEMP TABLE IF NOT EXISTS column_check AS
SELECT 
    EXISTS(SELECT 1 FROM pragma_table_info WHERE name='current_premium') as has_current_premium,
    EXISTS(SELECT 1 FROM pragma_table_info WHERE name='plan_type') as has_plan_type;

-- Copy data from the existing contacts table with safe column access
INSERT INTO contacts_new(
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, tobacco_user, gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    status, created_at, updated_at
)
SELECT 
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, COALESCE(tobacco_user, 0), gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    COALESCE(status, ''), COALESCE(created_at, CURRENT_TIMESTAMP), 
    COALESCE(updated_at, CURRENT_TIMESTAMP)
FROM contacts;

-- Handle current_premium separately based on column check
UPDATE contacts_new 
SET current_premium = (
    SELECT NULL
    FROM contacts 
    WHERE contacts.id = contacts_new.id
);

-- Rename tables
ALTER TABLE contacts RENAME TO contacts_backup;
ALTER TABLE contacts_new RENAME TO contacts;

-- Clean up temp tables
DROP TABLE IF EXISTS pragma_table_info;
DROP TABLE IF EXISTS column_check;

-- Recreate indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_zip_code ON contacts(zip_code);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_created_at ON contacts(created_at);
CREATE INDEX IF NOT EXISTS idx_contacts_updated_at ON contacts(updated_at);
CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp AFTER UPDATE ON contacts 
BEGIN 
  UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; 
END;

================
File: migrations/20250425_make_optional_fields_nullable.sql
================
-- Migration to make optional fields nullable
-- This migration allows all non-critical fields to be NULL based on frontend changes
-- This migration needs to be applied to all organization databases
-- This version includes recovery from partial migration failures

-- Method: Split the migration into small, independent steps that can be run
-- even if a previous migration attempt was interrupted

-- STEP 1: Clean up any temporary tables from previous failed migrations
DROP TABLE IF EXISTS contacts_new;

-- STEP 2: Create new contacts table with the desired schema
CREATE TABLE IF NOT EXISTS contacts_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    current_carrier TEXT, 
    current_premium TEXT, 
    plan_type TEXT, 
    effective_date TEXT, 
    birth_date TEXT, 
    tobacco_user INTEGER NOT NULL DEFAULT 0,
    gender TEXT, 
    state TEXT, 
    zip_code TEXT, 
    agent_id INTEGER,
    last_emailed DATETIME,
    phone_number TEXT, 
    status TEXT NOT NULL DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- STEP 3: Import data from contacts table if it exists
-- This will fail gracefully if the table doesn't exist
INSERT OR IGNORE INTO contacts_new(
    id, first_name, last_name, email, current_carrier, current_premium, 
    plan_type, effective_date, birth_date, tobacco_user, gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    status, created_at, updated_at
)
SELECT 
    id, first_name, last_name, email, current_carrier, current_premium, 
    plan_type, effective_date, birth_date, COALESCE(tobacco_user, 0), gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    COALESCE(status, ''), COALESCE(created_at, CURRENT_TIMESTAMP), 
    COALESCE(updated_at, CURRENT_TIMESTAMP)
FROM contacts WHERE 1=1;

-- STEP 4: Import data from contacts_backup table if it exists and contacts doesn't
-- This handles cases where migration was interrupted
INSERT OR IGNORE INTO contacts_new(
    id, first_name, last_name, email, current_carrier, current_premium, 
    plan_type, effective_date, birth_date, tobacco_user, gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    status, created_at, updated_at
)
SELECT 
    id, first_name, last_name, email, current_carrier, current_premium, 
    plan_type, effective_date, birth_date, COALESCE(tobacco_user, 0), gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    COALESCE(status, ''), COALESCE(created_at, CURRENT_TIMESTAMP), 
    COALESCE(updated_at, CURRENT_TIMESTAMP)
FROM contacts_backup WHERE 1=1;

-- STEP 5: Drop old tables and rename new table
DROP TABLE IF EXISTS contacts;

-- Rename the new table to contacts
ALTER TABLE contacts_new RENAME TO contacts;

-- STEP 6: Recreate indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_zip_code ON contacts(zip_code);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_created_at ON contacts(created_at);
CREATE INDEX IF NOT EXISTS idx_contacts_updated_at ON contacts(updated_at);
CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp AFTER UPDATE ON contacts 
BEGIN 
  UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; 
END;

================
File: migrations/add_aep_request_columns.sql
================
-- Migration script to add AEP request columns to contacts table

-- Add aep_request column (boolean field defaulting to false)
ALTER TABLE contacts ADD COLUMN aep_request BOOLEAN DEFAULT FALSE;

-- Add aep_request_date column (timestamp for when the request was made)
ALTER TABLE contacts ADD COLUMN aep_request_date DATETIME;

-- Create index for faster queries on aep_request status
CREATE INDEX IF NOT EXISTS idx_contacts_aep_request ON contacts(aep_request);

-- Sample query to check if migration worked:
-- SELECT name FROM pragma_table_info('contacts') WHERE name IN ('aep_request', 'aep_request_date');

================
File: migrations/add_deleted_contacts_table.sql
================
CREATE TABLE IF NOT EXISTS deleted_contacts (
    original_contact_id INTEGER NOT NULL, -- The ID from the original 'contacts' table
    first_name TEXT, -- Made nullable as they might be empty in original
    last_name TEXT,  -- Made nullable
    email TEXT NOT NULL, -- Crucial for billable count
    current_carrier TEXT,
    plan_type TEXT,
    effective_date TEXT,
    birth_date TEXT,
    tobacco_user INTEGER,
    gender TEXT,
    state TEXT,
    zip_code TEXT,
    agent_id INTEGER,
    phone_number TEXT,
    -- Include any other fields from 'contacts' you want to preserve historically
    deleted_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL
    -- No primary key on original_contact_id + email to allow multiple deletions if a user is re-added and deleted again
    -- though the billing logic will only count the most recent deletion within 12 months.
    -- A new unique ID for this table might be useful if needed:
    -- id TEXT PRIMARY KEY DEFAULT (hex(randomblob(16)))
);

CREATE INDEX IF NOT EXISTS idx_deleted_contacts_email ON deleted_contacts (LOWER(TRIM(email)));
CREATE INDEX IF NOT EXISTS idx_deleted_contacts_deleted_at ON deleted_contacts (deleted_at);
CREATE INDEX IF NOT EXISTS idx_deleted_contacts_original_id ON deleted_contacts (original_contact_id);

================
File: migrations/add_email_tracking.sql
================
-- Migration script to add email_send_tracking table and indexes to organization databases
-- This script can be applied to any organization database

-- Create the email_send_tracking table if it doesn't exist
CREATE TABLE IF NOT EXISTS email_send_tracking (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    org_id INTEGER NOT NULL,
    contact_id TEXT NOT NULL,
    email_type TEXT NOT NULL,
    scheduled_date TEXT NOT NULL,
    send_status TEXT NOT NULL CHECK(send_status IN ('pending', 'processing', 'accepted', 'delivered', 'sent', 'deferred', 'bounced', 'dropped', 'failed', 'skipped')) DEFAULT 'pending',
    send_mode TEXT NOT NULL CHECK(send_mode IN ('test', 'production')) DEFAULT 'test',
    test_email TEXT,
    send_attempt_count INTEGER NOT NULL DEFAULT 0,
    last_attempt_date TEXT,
    last_error TEXT,
    batch_id TEXT NOT NULL,
    message_id TEXT,
    delivery_status TEXT,
    status_checked_at TEXT,
    status_details TEXT,
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for the email_send_tracking table if they don't exist
-- We need to check if indexes exist before creating them to avoid errors

-- Index on batch_id for batch operations and lookups
CREATE INDEX IF NOT EXISTS idx_email_tracking_batch_id ON email_send_tracking(batch_id);

-- Index on send_status for filtering emails by status (pending/sent/failed/skipped)
CREATE INDEX IF NOT EXISTS idx_email_tracking_send_status ON email_send_tracking(send_status);

-- Index on send_mode for filtering by mode (test/production)
CREATE INDEX IF NOT EXISTS idx_email_tracking_send_mode ON email_send_tracking(send_mode);

-- Index on contact_id for looking up emails by contact
CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_id ON email_send_tracking(contact_id);

-- Composite index on contact_id and email_type for retrieving specific email types for a contact
CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_type ON email_send_tracking(contact_id, email_type);

-- Composite index on send_status and scheduled_date for retrieving emails by status within a date range
CREATE INDEX IF NOT EXISTS idx_email_tracking_status_date ON email_send_tracking(send_status, scheduled_date);

-- Index on message_id for looking up emails by SendGrid message ID
CREATE INDEX IF NOT EXISTS idx_email_tracking_message_id ON email_send_tracking(message_id);

-- Index on delivery_status for filtering by delivery status
CREATE INDEX IF NOT EXISTS idx_email_tracking_delivery_status ON email_send_tracking(delivery_status);

-- Create a trigger to update the updated_at timestamp when a record is modified
CREATE TRIGGER IF NOT EXISTS update_email_tracking_timestamp 
AFTER UPDATE ON email_send_tracking 
BEGIN
    UPDATE email_send_tracking SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; 
END;

================
File: migrations/add_onboarding_columns.sql
================
-- Add columns for storing onboarding state

-- Add onboarding_step column (INT with default 0)
ALTER TABLE organizations ADD COLUMN onboarding_step INTEGER DEFAULT 0;

-- Add temp_session_id column (TEXT, nullable)
ALTER TABLE organizations ADD COLUMN temp_session_id TEXT;

================
File: migrations/add_send_time_col.sql
================
-- Migration to add scheduled_send_time column to email_schedules table
-- This allows for separating the scheduling time from the actual send time

-- Check if email_schedules table exists
CREATE TABLE IF NOT EXISTS email_schedules (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER NOT NULL,
    email_type TEXT NOT NULL,
    scheduled_send_date TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pre-scheduled',
    skip_reason TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    tracking_id TEXT,
    FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Add scheduled_send_time column if it doesn't exist
PRAGMA foreign_keys=off;
BEGIN TRANSACTION;

-- Create a temporary table with the new schema
CREATE TABLE email_schedules_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER NOT NULL,
    email_type TEXT NOT NULL,
    scheduled_send_date TEXT NOT NULL,
    scheduled_send_time TEXT NOT NULL DEFAULT '08:30:00',
    status TEXT NOT NULL DEFAULT 'scheduled',
    skip_reason TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    batch_id TEXT,
    FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Copy data from the old table to the new table
INSERT INTO email_schedules_new 
    (id, contact_id, email_type, scheduled_send_date, status, skip_reason, created_at, updated_at, batch_id)
SELECT 
    id, contact_id, email_type, scheduled_send_date, status, skip_reason, created_at, updated_at, batch_id 
FROM email_schedules;

-- Drop the old table
DROP TABLE email_schedules;

-- Rename the new table to the original name
ALTER TABLE email_schedules_new RENAME TO email_schedules;

-- Add an index to improve query performance for scheduled email lookups
CREATE INDEX IF NOT EXISTS idx_email_schedules_date_time_status ON email_schedules 
    (scheduled_send_date, scheduled_send_time, status);

-- Create a unique index on contact_id, email_type, and scheduled_send_date
-- This prevents duplicate scheduling for the same contact, email type, and date
CREATE UNIQUE INDEX IF NOT EXISTS idx_email_schedules_unique ON email_schedules 
    (contact_id, email_type, scheduled_send_date);

COMMIT;
PRAGMA foreign_keys=on;

================
File: migrations/add_updated_at_col.sql
================
ALTER TABLE contacts
ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP;

CREATE TRIGGER update_contacts_updated_at
AFTER UPDATE ON contacts
FOR EACH ROW
BEGIN
  UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;

================
File: migrations/create_subscription_tables.sql
================
-- Create subscriptions table for tracking Stripe subscriptions
CREATE TABLE IF NOT EXISTS subscriptions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  stripe_subscription_id TEXT NOT NULL,
  stripe_customer_id TEXT NOT NULL,
  stripe_usage_item_id TEXT,  -- For usage-based billing
  status TEXT NOT NULL,
  current_contact_count INTEGER DEFAULT 0,  -- Current number of contacts for this user
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,
  cancel_at_period_end BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Track contact count changes for billing and auditing
CREATE TABLE IF NOT EXISTS contact_count_history (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  count INTEGER NOT NULL,
  previous_count INTEGER,
  change_type TEXT NOT NULL, -- 'add', 'remove', 'initial', etc.
  logged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Track contact counts for each user
CREATE TABLE IF NOT EXISTS contact_counts (
  user_id TEXT PRIMARY KEY,
  count INTEGER NOT NULL DEFAULT 0,
  last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Add auto_upgrade_limit column to users table
ALTER TABLE users ADD COLUMN IF NOT EXISTS auto_upgrade_limit INTEGER DEFAULT 0;

-- Create index on user_id for subscriptions
CREATE INDEX IF NOT EXISTS idx_subscriptions_user_id ON subscriptions(user_id);

-- Create index on status for quick filtering of active subscriptions
CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);

================
File: migrations/fix_email_tracking.sql
================
PRAGMA foreign_keys=off;

-- Rename the old table
ALTER TABLE email_send_tracking RENAME TO email_send_tracking_old;

-- Recreate the table with the correct foreign key
CREATE TABLE email_send_tracking (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  org_id INTEGER NOT NULL,
  contact_id INTEGER NOT NULL,
  email_type TEXT NOT NULL,
  scheduled_date TEXT NOT NULL,
  send_status TEXT NOT NULL CHECK(send_status IN ('pending', 'processing', 'accepted', 'delivered', 'sent', 'deferred', 'bounced', 'dropped', 'failed', 'skipped')) DEFAULT 'pending',
  send_mode TEXT NOT NULL CHECK(send_mode IN ('test', 'production')) DEFAULT 'test',
  test_email TEXT,
  send_attempt_count INTEGER NOT NULL DEFAULT 0,
  last_attempt_date TEXT,
  last_error TEXT,
  batch_id TEXT NOT NULL,
  message_id TEXT,
  delivery_status TEXT,
  status_checked_at TEXT,
  status_details TEXT,
  created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Copy data from old table (if needed)
INSERT INTO email_send_tracking (
  id, org_id, contact_id, email_type, scheduled_date, send_status, send_mode, test_email, send_attempt_count, last_attempt_date, last_error, batch_id, message_id, delivery_status, status_checked_at, status_details, created_at, updated_at
)
SELECT
  id, org_id, contact_id, email_type, scheduled_date, send_status, send_mode, test_email, send_attempt_count, last_attempt_date, last_error, batch_id, message_id, delivery_status, status_checked_at, status_details, created_at, updated_at
FROM email_send_tracking_old;

DROP TABLE email_send_tracking_old;

PRAGMA foreign_keys=on;

================
File: migrations/remove_eligibility_answers_fk.sql
================
-- Migration script to update foreign key constraints to reference contacts instead of contacts_backup

-- Part 1: Fix eligibility_answers table
-- Step 1: Create a new table with the correct foreign key constraint
CREATE TABLE eligibility_answers_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER NOT NULL,
    quote_id TEXT NOT NULL,
    answers TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Step 2: Copy data from the old table to the new table
INSERT INTO eligibility_answers_new (id, contact_id, quote_id, answers, created_at)
SELECT id, contact_id, quote_id, answers, created_at
FROM eligibility_answers;

-- Step 3: Drop the old table
DROP TABLE eligibility_answers;

-- Step 4: Rename the new table to the original name
ALTER TABLE eligibility_answers_new RENAME TO eligibility_answers;

-- Part 2: Fix contact_events table
-- Step 1: Create a new table with the correct foreign key constraints
CREATE TABLE contact_events_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER,
    lead_id INTEGER,
    event_type TEXT NOT NULL,
    metadata TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE,
    FOREIGN KEY (lead_id) REFERENCES leads(id) ON DELETE CASCADE
);

-- Step 2: Copy data from the old table to the new table
INSERT INTO contact_events_new (id, contact_id, lead_id, event_type, metadata, created_at)
SELECT id, contact_id, lead_id, event_type, metadata, created_at
FROM contact_events;

-- Step 3: Drop the old table
DROP TABLE contact_events;

-- Step 4: Rename the new table to the original name
ALTER TABLE contact_events_new RENAME TO contact_events;

-- Create required indexes
CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id);
CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id);
CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type);

-- Optional: Add a comment or log to confirm the migration
-- Note: Foreign key constraints on contact_id now reference contacts(id) instead of contacts_backup

================
File: public/hhd.csv
================
,ACE/Chubb,AETNA,AFLAC,Allstate,Anthem,CIGNA,Mutual of Omaha,Humana (MIPPA),Humana (Achieve),UHIC
AL,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
AK,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,NA,Live with someone 50+. Additional discounts available,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,NA,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
AZ,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
AR,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 50 years old.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
CA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,NA,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #. Additional $25 discount for first 12 months for new to Medicare on Plan G.
CO,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
CT,NA,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with Anthem.,Both you and your spouse/partner must have a supplemental plan with CIGNA.,NA,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
DE,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
DC,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,NA,Live with someone 50+. Additional discounts available,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,NA,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,NA
FL,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,NA,Both you and your spouse/partner must have a supplemental plan with AFLAC.,Live with someone 50+,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,NA,NA,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
GA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
HI,NA,NA,NA,NA,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,NA
ID,NA,NA,NA,NA,NA,NA,NA,*Value Plan - NA,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
IL,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
IN,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,NA,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
IA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
KS,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
KY,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
LA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
ME,You need to live with a spouse or someone who is at least 50 years old.,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with Anthem.,Both you and your spouse/partner must have a supplemental plan with CIGNA.,Both you and your spouse/partner must have a supplemental plan with Mutual of Omaha.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MD,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MA,NA,NA,NA,NA,NA,NA,NA,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MI,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MN,NA,NA,NA,Live with someone 50+. Additional discounts available,NA,NA,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MS,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MO,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with someone who is at least 50 years old.,You need to live with a spouse or domestic partner.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
MT,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 18 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
NE,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
NV,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
NH,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,NA,NA,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,NA
NJ,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,Live with someone 50+,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
NM,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,NA
NY,NA,NA,NA,NA,Not accepting new Supps,NA,NA,NA,NA,NA
NC,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
ND,NA,NA,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,NA
OH,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,Live with someone 50+,Both you and your spouse/partner must have a supplemental plan with Anthem.,Both you and your spouse/partner must have a supplemental plan with CIGNA.,"You need to live with your spouse, partner, or a roomate for the last 12 months.",Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with Humana.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
OK,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,Live with someone 50+. Additional discounts available,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,"You need to live with your spouse, partner, or a roomate for the last 12 months.",Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
OR,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
PA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+,NA,You need to live with a spouse or partner. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or domestic partner.,"You need to live with spouse, civil or domestic partner.",You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
RI,NA,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,NA,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,NA,NA,NA
SC,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
SD,You need to live with a spouse or someone who is at least 50 years old.,NA,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
TN,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
TX,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
UT,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
VT,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA
VA,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,Both you and your spouse/partner must have a supplemental plan with AFLAC.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,You need to live with a spouse or someone who is at least 18 years old.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
WA,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,NA,NA,NA,NA,Both you and your spouse/partner must have a supplemental plan with CIGNA.,Both you and your spouse/partner must have a supplemental plan with Mutual of Omaha.,Both you and your spouse/partner must have a supplemental plan with Humana.,NA,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
WV,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
WI,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,Both you and your spouse/partner must have a supplemental plan with Anthem.,You need to live with a spouse or someone who is at least 18 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
WY,You need to live with a spouse or someone who is at least 50 years old.,Both you and your spouse/partner must have a supplemental plan with AETNA.,You need to live with a spouse or someone who is at least 50 years old.,Live with someone 50+. Additional discounts available,NA,You need to live with a spouse or someone who is at least 50 years old. Additional dual-enrollment CIGNA discount available.,You need to live with a spouse or someone who is at least 60 years old.,Both you and your spouse/partner must have a supplemental plan with Humana.,You need to live with a spouse or someone who is at least 18 years old.,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.

================
File: public/test-bulk-import.html
================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bulk Contact Import Test</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
    }
    h1 {
      color: #2c3e50;
      margin-bottom: 20px;
    }
    form {
      background-color: #f9f9f9;
      padding: 20px;
      border-radius: 8px;
      border: 1px solid #ddd;
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
    }
    input[type="file"] {
      display: block;
      margin-bottom: 15px;
    }
    .checkbox-group {
      margin-bottom: 15px;
    }
    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover {
      background-color: #2980b9;
    }
    .result {
      background-color: #f0f7ff;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #d0e3ff;
      margin-top: 20px;
      white-space: pre-wrap;
      overflow-x: auto;
    }
    .info {
      background-color: #e8f4f8;
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid #3498db;
      margin-bottom: 20px;
    }
    .info h2 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #2c3e50;
    }
  </style>
</head>
<body>
  <h1>Bulk Contact Import Test</h1>
  
  <div class="info">
    <h2>About This Tool</h2>
    <p>This is a test page for the bulk contact import feature. Use this to test importing CSV files with contact data.</p>
    <p>Make sure you're logged in as an admin user before testing, as the endpoint requires admin privileges.</p>
  </div>

  <form id="uploadForm">
    <label for="csvFile">Select CSV File:</label>
    <input type="file" id="csvFile" name="file" accept=".csv" required>
    
    <div class="checkbox-group">
      <label>
        <input type="checkbox" id="overwriteExisting"> Overwrite existing contacts
      </label>
    </div>
    
    <div class="form-row">
      <button type="submit">Import Contacts</button>
    </div>
  </form>
  
  <div id="result" class="result" style="display: none;"></div>
  
  <div style="margin-top: 30px;">
    <h2>Check Import Status</h2>
    <form id="statusForm">
      <div class="form-row">
        <label for="orgId">Organization ID:</label>
        <input type="text" id="orgId" name="orgId" required>
      </div>
      <button type="submit">Check Status</button>
    </form>
    
    <div id="statusResult" class="result" style="display: none;"></div>
  </div>

  <script>
    document.getElementById('uploadForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      
      const resultDiv = document.getElementById('result');
      resultDiv.textContent = 'Processing...';
      resultDiv.style.display = 'block';
      
      try {
        const formData = new FormData();
        const csvFile = document.getElementById('csvFile').files[0];
        const overwriteExisting = document.getElementById('overwriteExisting').checked;
        
        formData.append('file', csvFile);
        formData.append('overwriteExisting', overwriteExisting);
        
        // Send request to the API
        const response = await fetch('/api/contacts/bulk-import', {
          method: 'POST',
          body: formData,
          credentials: 'include' // Important for the session cookie
        });
        
        const data = await response.json();
        
        // Display the result
        resultDiv.textContent = JSON.stringify(data, null, 2);
        
        // Update the org ID field with the organization ID from the response
        if (data.success && data.organizationId) {
          document.getElementById('orgId').value = data.organizationId;
        }
      } catch (error) {
        resultDiv.textContent = `Error: ${error.message}`;
      }
    });
    
    document.getElementById('statusForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      
      const statusResultDiv = document.getElementById('statusResult');
      statusResultDiv.textContent = 'Checking status...';
      statusResultDiv.style.display = 'block';
      
      try {
        const orgId = document.getElementById('orgId').value.trim();
        
        if (!orgId) {
          statusResultDiv.textContent = 'Please enter an organization ID';
          return;
        }
        
        // Send request to check the import status
        const response = await fetch(`/api/contacts/import-status/${orgId}`, {
          method: 'GET',
          credentials: 'include' // Important for the session cookie
        });
        
        const data = await response.json();
        
        // Display the status result
        statusResultDiv.textContent = JSON.stringify(data, null, 2);
        
        // If the import is still in progress, poll the status every 10 seconds
        if (data.status === 'in progress') {
          let pollCount = 0;
          const maxPolls = 30; // Maximum 5 minutes of polling
          
          const pollInterval = setInterval(async () => {
            pollCount++;
            
            if (pollCount > maxPolls) {
              clearInterval(pollInterval);
              statusResultDiv.textContent += '\n\nPolling stopped after 5 minutes.';
              return;
            }
            
            try {
              const pollResponse = await fetch(`/api/contacts/import-status/${orgId}`, {
                method: 'GET',
                credentials: 'include'
              });
              
              const pollData = await pollResponse.json();
              statusResultDiv.textContent = JSON.stringify(pollData, null, 2);
              
              if (pollData.status !== 'in progress') {
                clearInterval(pollInterval);
                statusResultDiv.textContent += '\n\nImport completed!';
              }
            } catch (pollError) {
              statusResultDiv.textContent += `\n\nError polling status: ${pollError.message}`;
              clearInterval(pollInterval);
            }
          }, 10000); // Poll every 10 seconds
        }
      } catch (error) {
        statusResultDiv.textContent = `Error: ${error.message}`;
      }
    });
  </script>
</body>
</html>

================
File: scripts/add-agent.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for agent data
const AgentSchema = z.object({
  first_name: z.string().min(1),
  last_name: z.string().min(1),
  email: z.string().email(),
  phone: z.string().min(1),
  organization_id: z.number(),
});

async function main() {
  p.intro(chalk.green(' Interactive Agent Creation Tool '));

  const db = new Database();

  // Get all organizations
  const orgs = await db.fetchAll<{ id: number; name: string }>('SELECT id, name FROM organizations');
  
  if (orgs.length === 0) {
    p.outro(chalk.red('No organizations found. Please create an organization first.'));
    exit(1);
  }

  // Gather information
  const firstName = await p.text({
    message: 'Enter agent first name:',
    validate: (value) => {
      if (value.length === 0) return 'First name cannot be empty';
    },
  });

  const lastName = await p.text({
    message: 'Enter agent last name:',
    validate: (value) => {
      if (value.length === 0) return 'Last name cannot be empty';
    },
  });

  const email = await p.text({
    message: 'Enter agent email:',
    validate: (value) => {
      if (!value.includes('@')) return 'Invalid email address';
    },
  });

  const phone = await p.text({
    message: 'Enter agent phone:',
    validate: (value) => {
      if (value.length === 0) return 'Phone cannot be empty';
    },
  });

  const organization = await p.select({
    message: 'Select organization:',
    options: orgs.map(org => ({
      value: org.id,
      label: org.name,
    })),
  });

  if (p.isCancel(firstName) || p.isCancel(lastName) || p.isCancel(email) || p.isCancel(phone) || p.isCancel(organization)) {
    p.outro(chalk.yellow('Operation cancelled'));
    exit(0);
  }

  try {
    // Validate data
    const agentData = AgentSchema.parse({
      first_name: firstName,
      last_name: lastName,
      email,
      phone,
      organization_id: organization,
    });

    // Start a transaction
    await db.execute('BEGIN TRANSACTION');

    try {
      // Insert into agents table
      await db.execute(
        `INSERT INTO agents (first_name, last_name, email, phone, organization_id)
         VALUES (?, ?, ?, ?, ?)`,
        [
          agentData.first_name,
          agentData.last_name,
          agentData.email,
          agentData.phone,
          agentData.organization_id
        ]
      );

      // Insert into users table
      await db.execute(
        `INSERT INTO users (email, organization_id, is_admin, is_agent, is_active)
         VALUES (?, ?, ?, ?, true)`,
        [agentData.email, agentData.organization_id, false, true]
      );

      // Commit the transaction
      await db.execute('COMMIT');

      p.outro(chalk.green('Agent created successfully! '));

    } catch (error) {
      // Rollback on error
      await db.execute('ROLLBACK');
      throw error;
    }

  } catch (error) {
    if (error instanceof z.ZodError) {
      p.outro(chalk.red(`Validation error: ${error.errors.map(e => e.message).join(', ')}`));
    } else {
      p.outro(chalk.red(`Error creating agent: ${error}`));
    }
    exit(1);
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/apply-contact-migration.ts
================
#!/usr/bin/env bun
/**
 * Script to apply contact deduplication and index creation to all organization databases
 * Usage: bun run apply-contact-migration.ts
 */

import { Database } from '../src/database'
import { logger } from '../src/logger'
import fs from 'fs/promises'
import path from 'path'

async function main() {
  try {
    logger.info('Starting contact migration script')
    
    // Connect to main database
    const mainDb = new Database()
    
    // Get all organizations
    const organizations = await mainDb.fetchAll('SELECT id, name, turso_db_url, turso_auth_token FROM organizations WHERE turso_db_url IS NOT NULL')
    logger.info(`Found ${organizations.length} organizations to process`)
    
    // Read the migration SQL file
    const migrationPath = path.join(process.cwd(), 'migrations', '20240326_deduplicate_contacts.sql')
    
    try {
      await fs.access(migrationPath)
    } catch (error) {
      logger.error(`Migration file not found: ${migrationPath}`)
      process.exit(1)
    }
    
    const migrationSql = await fs.readFile(migrationPath, 'utf-8')
    logger.info(`Loaded migration from: ${migrationPath}`)
    
    // Process each organization
    for (let i = 0; i < organizations.length; i++) {
      const org = organizations[i]
      const orgId = org.id
      const orgName = org.name
      const dbUrl = org.turso_db_url
      const authToken = org.turso_auth_token
      
      logger.info(`Processing organization ${i+1}/${organizations.length}: ${orgName} (ID: ${orgId})`)
      
      try {
        // Connect to the organization's database
        const orgDb = new Database(dbUrl, authToken)
        
        // Check if the contacts table exists
        const tableExists = await orgDb.fetchOne('SELECT name FROM sqlite_master WHERE type="table" AND name="contacts"')
        
        if (!tableExists) {
          logger.info(`Organization ${orgId} does not have a contacts table, skipping`)
          continue
        }
        
        // Get contact count before migration
        const beforeCount = await orgDb.fetchOne<{ count: number }>('SELECT COUNT(*) as count FROM contacts')
        logger.info(`Organization ${orgId} has ${beforeCount?.count || 0} contacts before migration`)
        
        // Check for duplicates
        const dupeCheck = await orgDb.fetchOne<{ dupes: number }>('SELECT COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as dupes FROM contacts')
        logger.info(`Organization ${orgId} has ${dupeCheck?.dupes || 0} duplicate email addresses`)
        
        // Check if unique index exists
        const indexExists = await orgDb.fetchOne('SELECT name FROM sqlite_master WHERE type="index" AND name="idx_contacts_email_unique"')
        
        if ((dupeCheck?.dupes || 0) === 0 && indexExists) {
          logger.info(`No duplicates found and unique index exists for organization ${orgId}, skipping`)
          continue
        }
        
        if ((dupeCheck?.dupes || 0) === 0) {
          // No duplicates, just create the index
          logger.info(`No duplicates found, creating unique email index for organization ${orgId}`)
          await orgDb.execute('CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))')
          logger.info(`Created unique email index for organization ${orgId}`)
          continue
        }
        
        // Execute the migration SQL for this organization
        logger.info(`Found ${dupeCheck?.dupes || 0} duplicates, applying full migration to organization ${orgId}`)
        
        // Split the SQL into statements
        const statements = migrationSql
          .split(';')
          .map(stmt => stmt.trim())
          .filter(stmt => stmt.length > 0 && !stmt.startsWith('--'))
        
        for (const statement of statements) {
          try {
            await orgDb.execute(statement)
          } catch (error) {
            // Log the error but continue with next statement
            logger.error(`Error executing statement for org ${orgId}: ${error}`)
            logger.error(`Statement: ${statement}`)
          }
        }
        
        // Get contact count after migration
        const afterCount = await orgDb.fetchOne<{ count: number }>('SELECT COUNT(*) as count FROM contacts')
        logger.info(`Organization ${orgId} has ${afterCount?.count || 0} contacts after migration`)
        
        // Calculate removed duplicates
        const removedCount = (beforeCount?.count || 0) - (afterCount?.count || 0)
        logger.info(`Removed ${removedCount} duplicate contacts from organization ${orgId}`)
        
      } catch (error) {
        // Log the error but continue with next organization
        logger.error(`Error processing organization ${orgId}: ${error}`)
      }
    }
    
    logger.info(`Migration completed for all organizations`)
    
  } catch (error) {
    logger.error(`Error in migration script: ${error}`)
    process.exit(1)
  }
}

main()

================
File: scripts/generate-test-data.ts
================
import fs from 'fs/promises';
import { stringify } from 'csv-stringify/sync';
import path from 'path';

/**
 * Script to generate a large dataset of test contacts for performance testing
 * 
 * Usage:
 *   bun run scripts/generate-test-data.ts <count> [output-file]
 * 
 * Where:
 *   <count> is the number of contacts to generate
 *   [output-file] is the optional output file path (defaults to ./scripts/test-contacts-{count}.csv)
 */

// Sample data for random generation
const firstNames = ['John', 'Jane', 'Robert', 'Mary', 'Michael', 'Jennifer', 'William', 'Patricia', 'Richard', 'Linda', 
  'David', 'Elizabeth', 'Joseph', 'Barbara', 'Thomas', 'Susan', 'Charles', 'Jessica', 'Daniel', 'Sarah', 'Matthew', 'Karen', 
  'Anthony', 'Nancy', 'Mark', 'Lisa', 'Donald', 'Betty', 'Steven', 'Dorothy'];

const lastNames = ['Smith', 'Johnson', 'Williams', 'Jones', 'Brown', 'Davis', 'Miller', 'Wilson', 'Moore', 'Taylor', 
  'Anderson', 'Thomas', 'Jackson', 'White', 'Harris', 'Martin', 'Thompson', 'Garcia', 'Martinez', 'Robinson', 'Clark', 
  'Rodriguez', 'Lewis', 'Lee', 'Walker', 'Hall', 'Allen', 'Young', 'Hernandez', 'King'];

const carriers = ['Aetna', 'Humana', 'UnitedHealthcare', 'Cigna', 'Blue Cross Blue Shield', 'Kaiser Permanente', 
  'Anthem', 'Wellcare', 'Centene', 'Molina Healthcare'];

const planTypes = ['A', 'B', 'C', 'D', 'F', 'G', 'K', 'L', 'M', 'N'];

const states = ['AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 
  'LA', 'ME', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 
  'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'];

// Helper functions for random data generation
function getRandomItem<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)];
}

function getRandomDate(start: Date, end: Date): string {
  const date = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
  return date.toISOString().split('T')[0];
}

function getRandomPhone(): string {
  return `${Math.floor(Math.random() * 900) + 100}-${Math.floor(Math.random() * 900) + 100}-${Math.floor(Math.random() * 9000) + 1000}`;
}

function getRandomZip(): string {
  return `${Math.floor(Math.random() * 90000) + 10000}`;
}

// Main function
async function main() {
  try {
    const args = process.argv.slice(2);
    
    if (args.length < 1) {
      console.error('Usage: bun run scripts/generate-test-data.ts <count> [output-file]');
      process.exit(1);
    }
    
    const count = parseInt(args[0], 10);
    
    if (isNaN(count) || count <= 0) {
      console.error('Count must be a positive number');
      process.exit(1);
    }
    
    const outputFile = args[1] || path.join(process.cwd(), 'scripts', `test-contacts-${count}.csv`);
    
    console.log(`Generating ${count} test contacts...`);
    
    // Generate the contacts
    const contacts = [];
    
    for (let i = 0; i < count; i++) {
      const firstName = getRandomItem(firstNames);
      const lastName = getRandomItem(lastNames);
      const email = `${firstName.toLowerCase()}.${lastName.toLowerCase()}${Math.floor(Math.random() * 10000)}@example.com`;
      
      contacts.push({
        first_name: firstName,
        last_name: lastName,
        email: email,
        current_carrier: getRandomItem(carriers),
        plan_type: getRandomItem(planTypes),
        effective_date: getRandomDate(new Date('2022-01-01'), new Date('2023-12-31')),
        birth_date: getRandomDate(new Date('1940-01-01'), new Date('1965-12-31')),
        tobacco_user: Math.random() > 0.8 ? 1 : 0, // 20% are tobacco users
        gender: Math.random() > 0.5 ? 'Male' : 'Female',
        state: getRandomItem(states),
        zip_code: getRandomZip(),
        phone_number: getRandomPhone()
      });
      
      // Log progress for large datasets
      if (i > 0 && i % 10000 === 0) {
        console.log(`Generated ${i} contacts...`);
      }
    }
    
    // Convert to CSV
    console.log('Converting to CSV...');
    const csv = stringify(contacts, { header: true });
    
    // Write to file
    console.log(`Writing to ${outputFile}...`);
    await fs.writeFile(outputFile, csv);
    
    console.log(`Successfully generated ${count} contacts in ${outputFile}`);
    
  } catch (error) {
    console.error(`Error generating test data: ${error}`);
    process.exit(1);
  }
}

main();

================
File: scripts/generateQuoteId.ts
================
import { generateQuoteId } from '../src/utils/quoteId';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteId.ts <orgId> <contactId>');
  process.exit(1);
}

// Generate quote ID
const quoteId = generateQuoteId(orgId, contactId);

// Output results
console.log('Generated Quote ID:', quoteId);
console.log('Quote URL:', `http://localhost:5173/quote?id=${quoteId}`);

================
File: scripts/generateQuoteUrl.ts
================
import axios, { AxiosError } from 'axios';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteUrl.ts <orgId> <contactId>');
  process.exit(1);
}

// Call the API to generate a quote ID
const generateQuoteUrl = async () => {
  try {
    // Use the debug endpoint to generate a quote ID without authentication
    const response = await axios.get(`http://localhost:8000/api/quotes/debug-generate/${orgId}/${contactId}`);

    if (response.data.success) {
      console.log('Quote ID:', response.data.quoteId);
      console.log('Quote URL:', response.data.redirectUrl);
    } else {
      console.error('Failed to generate quote ID:', response.data.error);
      
      if (response.data.availableContacts) {
        console.log('\nAvailable contacts for organization', orgId, ':');
        response.data.availableContacts.forEach((contact: any) => {
          console.log(`- ID: ${contact.id}, Name: ${contact.first_name} ${contact.last_name || ''}, Email: ${contact.email || 'N/A'}`);
        });
      }
    }
  } catch (error) {
    if (error instanceof AxiosError) {
      console.error('Error:', error.response?.data || error.message);
    } else {
      console.error('Error:', error);
    }
  }
};

generateQuoteUrl();

================
File: scripts/manage-recommendations.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for GI recommendation data
const RecommendationSchema = z.object({
  state: z.string().length(2),
  carrier: z.string().min(1),
});

async function main() {
  p.intro(chalk.green(' Guaranteed Issue Recommendations Manager '));

  const db = new Database();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all GI recommendations' },
        { value: 'add', label: 'Add new GI recommendation' },
        { value: 'remove', label: 'Remove GI recommendation' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listRecommendations(db);
          break;
        case 'add':
          await addRecommendation(db);
          break;
        case 'remove':
          await removeRecommendation(db);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listRecommendations(db: Database) {
  const results = await db.fetchAll<{ state: string; carrier: string; created_at: string }>(
    `SELECT state, carrier, created_at 
     FROM guaranteed_issue_recommendations 
     ORDER BY carrier, state`
  );

  if (results.length === 0) {
    p.note('No GI recommendations found', 'Empty');
    return;
  }

  const groupedByCarrier = results.reduce((acc, curr) => {
    if (!acc[curr.carrier]) {
      acc[curr.carrier] = [];
    }
    acc[curr.carrier].push(curr.state);
    return acc;
  }, {} as Record<string, string[]>);

  p.note(
    Object.entries(groupedByCarrier)
      .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
      .join('\n\n'),
    'Current GI Recommendations'
  );
}

async function addRecommendation(db: Database) {
  // Get available carriers first
  const carriers = await db.fetchAll<{ name: string }>(
    'SELECT name FROM carriers ORDER BY name'
  );

  if (carriers.length === 0) {
    p.note(chalk.red('No carriers found in database'));
    return;
  }

  const carrier = await p.select({
    message: 'Select carrier:',
    options: carriers.map(c => ({
      value: c.name,
      label: c.name,
    })),
  });

  if (p.isCancel(carrier)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const states = await p.text({
    message: 'Enter state codes (comma/space separated, e.g., TX CA FL):',
    validate: (value) => {
      const stateList = value.toUpperCase().split(/[\s,]+/).filter(Boolean);
      if (stateList.length === 0) return 'At least one state code is required';
      const invalidStates = stateList.filter(s => s.length !== 2);
      if (invalidStates.length > 0) {
        return `Invalid state codes: ${invalidStates.join(', ')}`;
      }
    },
  });

  if (p.isCancel(states)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const stateList = states.toUpperCase().split(/[\s,]+/).filter(Boolean);
  const results: { state: string; success: boolean; message: string }[] = [];

  for (const state of stateList) {
    try {
      const data = RecommendationSchema.parse({
        state,
        carrier,
      });

      // Check if recommendation already exists
      const existing = await db.fetchOne(
        'SELECT 1 FROM guaranteed_issue_recommendations WHERE state = ? AND carrier = ?',
        [data.state, data.carrier]
      );

      if (existing) {
        results.push({
          state: data.state,
          success: false,
          message: 'Already exists'
        });
        continue;
      }

      await db.execute(
        'INSERT INTO guaranteed_issue_recommendations (state, carrier) VALUES (?, ?)',
        [data.state, data.carrier]
      );

      results.push({
        state: data.state,
        success: true,
        message: 'Added successfully'
      });

    } catch (error) {
      results.push({
        state,
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Unknown error'
      });
    }
  }

  // Display results summary
  const successful = results.filter(r => r.success);
  const failed = results.filter(r => !r.success);

  if (successful.length > 0) {
    p.note(
      chalk.green(
        `Successfully added GI recommendations for ${carrier}:\n` +
        successful.map(r => `  ${r.state}`).join('\n')
      ),
      'Success'
    );
  }

  if (failed.length > 0) {
    p.note(
      chalk.yellow(
        `Failed to add some recommendations for ${carrier}:\n` +
        failed.map(r => `  ${r.state}: ${r.message}`).join('\n')
      ),
      'Warnings'
    );
  }
}

async function removeRecommendation(db: Database) {
  const recommendations = await db.fetchAll<{ id: number; state: string; carrier: string }>(
    'SELECT id, state, carrier FROM guaranteed_issue_recommendations ORDER BY carrier, state'
  );

  if (recommendations.length === 0) {
    p.note(chalk.yellow('No recommendations to remove'));
    return;
  }

  const selections = await p.multiselect({
    message: 'Select recommendations to remove (space to select/deselect):',
    options: recommendations
      .sort((a, b) => a.carrier.localeCompare(b.carrier) || a.state.localeCompare(b.state))
      .map(rec => ({
        value: rec.id.toString(),
        label: `${rec.carrier} - ${rec.state}`,
      })),
    required: true,
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const idsToRemove = (selections as string[]).map(Number);

  if (idsToRemove.length === 0) {
    p.note(chalk.yellow('No recommendations selected for removal'));
    return;
  }

  await db.execute(
    `DELETE FROM guaranteed_issue_recommendations WHERE id IN (${idsToRemove.join(',')})`,
  );

  const removedItems = recommendations
    .filter(r => idsToRemove.includes(r.id))
    .reduce((acc, curr) => {
      if (!acc[curr.carrier]) {
        acc[curr.carrier] = [];
      }
      acc[curr.carrier].push(curr.state);
      return acc;
    }, {} as Record<string, string[]>);

  p.note(
    chalk.green(
      'Successfully removed recommendations:\n\n' +
      Object.entries(removedItems)
        .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
        .join('\n\n')
    ),
    'Success'
  );
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/manage-turso.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';
import { TURSO_CONFIG } from '../src/config/turso';
import fetch from 'node-fetch';

interface Organization {
  id: number;
  name: string;
  turso_db_url: string | null;
}

class TursoManager {
  private headers = {
    'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
    'Content-Type': 'application/json'
  };

  async listLocations(): Promise<string[]> {
    const response = await fetch(`${TURSO_CONFIG.API_URL}/locations`, {
      headers: this.headers
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch locations: ${await response.text()}`);
    }

    const data = await response.json() as { locations: Array<{ name: string }> };
    return data.locations.map(l => l.name);
  }

  async listDatabases(): Promise<Array<{name: string, hostname: string}>> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`,
      { headers: this.headers }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch databases: ${await response.text()}`);
    }

    const data = await response.json() as { databases: Array<{Name: string, Hostname: string}> };
    return data.databases.map(db => ({
      name: db.Name,
      hostname: db.Hostname
    }));
  }

  async updateGroup(name: string, location: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/groups/${TURSO_CONFIG.GROUP_NAME}`,
      {
        method: 'PATCH',
        headers: this.headers,
        body: JSON.stringify({ name, location })
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to update group: ${await response.text()}`);
    }
  }

  async deleteDatabase(name: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${name}`,
      {
        method: 'DELETE',
        headers: this.headers
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete database: ${await response.text()}`);
    }
  }
}

async function main() {
  p.intro(chalk.green(' Turso Database Manager '));

  const db = new Database();
  const turso = new TursoManager();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all databases and organizations' },
        { value: 'update-group', label: 'Update group configuration' },
        { value: 'delete-db', label: 'Delete a customer database' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listDatabasesAndOrgs(db, turso);
          break;
        case 'update-group':
          await updateGroupConfig(turso);
          break;
        case 'delete-db':
          await deleteCustomerDatabase(db, turso);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listDatabasesAndOrgs(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  const mappedDatabases = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      name: database.name,
      hostname: database.hostname,
      organization: org ? org[1] : 'Not associated with any organization'
    };
  });

  if (mappedDatabases.length === 0) {
    p.note('No databases found', 'Empty');
    return;
  }

  p.note(
    mappedDatabases
      .map(db => `${db.name}:\n  URL: ${db.hostname}\n  Organization: ${db.organization}`)
      .join('\n\n'),
    'Current Databases'
  );
}

async function updateGroupConfig(turso: TursoManager) {
  // Get available locations
  const locations = await turso.listLocations();

  p.note(
    `Current Configuration:\n` +
    `  Group Name: ${TURSO_CONFIG.GROUP_NAME}\n` +
    `  Location: ${TURSO_CONFIG.LOCATION}`,
    'Current Settings'
  );

  const newGroupName = await p.text({
    message: 'Enter new group name (or press enter to keep current):',
    initial: TURSO_CONFIG.GROUP_NAME,
  });

  if (p.isCancel(newGroupName)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const newLocation = await p.select({
    message: 'Select new location:',
    options: locations.map(loc => ({
      value: loc,
      label: loc,
    })),
    initialValue: TURSO_CONFIG.LOCATION,
  });

  if (p.isCancel(newLocation)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const confirm = await p.confirm({
    message: `Update group "${TURSO_CONFIG.GROUP_NAME}" to:\n` +
             `  Name: ${newGroupName}\n` +
             `  Location: ${newLocation}\n` +
             `Are you sure?`,
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  await turso.updateGroup(newGroupName, newLocation as string);
  
  p.note(
    chalk.green(
      `Successfully updated group configuration.\n` +
      `Remember to update TURSO_CONFIG in your code!`
    ),
    'Success'
  );
}

async function deleteCustomerDatabase(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  if (databases.length === 0) {
    p.note('No databases found to delete', 'Empty');
    return;
  }

  const options = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      value: database.name,
      label: `${database.name} (${org ? org[1] : 'Unassociated'})`,
    };
  });

  const selections = await p.multiselect({
    message: 'Select databases to delete (space to select, enter to confirm):',
    options,
    required: true
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const selectedDbs = selections as string[];
  if (selectedDbs.length === 0) {
    p.note(chalk.yellow('No databases selected'));
    return;
  }

  const confirm = await p.confirm({
    message: chalk.red(
      `Are you sure you want to delete the following databases?\n` +
      selectedDbs.map(db => `  - ${db}`).join('\n') +
      `\nThis action cannot be undone!`
    ),
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  for (const dbName of selectedDbs) {
    try {
      await turso.deleteDatabase(dbName);

      // Update organization record
      const org = orgs.find((o: any) => 
        o[2] && 
        o[2].toString().includes(
          databases.find(d => d.name === dbName)?.hostname || ''
        )
      );

      if (org) {
        await db.execute(
          'UPDATE organizations SET turso_db_url = NULL, turso_auth_token = NULL WHERE id = ?',
          [org[0]]
        );
      }

      p.note(
        chalk.green(`Successfully deleted database "${dbName}"`),
        'Success'
      );
    } catch (error) {
      p.note(
        chalk.red(`Failed to delete database "${dbName}": ${error}`),
        'Error'
      );
    }
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/migrate-tracking-clicks.js
================
#!/usr/bin/env node

/**
 * Migration script to add tracking_clicks table to all organization databases
 * Usage: node migrate-tracking-clicks.js
 */

const fs = require('fs');
const path = require('path');
const { Database } = require('../dist/database');
const { logger } = require('../dist/logger');

// Path to the SQL migration
const MIGRATION_FILE = path.join(__dirname, '../data/migrations/003_add_tracking_clicks.sql');

async function main() {
  try {
    // Read the migration SQL
    const migrationSql = fs.readFileSync(MIGRATION_FILE, 'utf-8');
    logger.info(`Loaded migration SQL from ${MIGRATION_FILE}`);
    
    // Initialize the main database
    const db = new Database();
    logger.info('Connected to main database');

    // Get all organization IDs and their database URLs
    const orgs = await db.fetchAll(
      'SELECT id, name, slug, turso_db_url, turso_auth_token FROM organizations WHERE turso_db_url IS NOT NULL AND turso_auth_token IS NOT NULL'
    );
    
    logger.info(`Found ${orgs.length} organizations with database configurations`);

    // Process each organization
    for (const org of orgs) {
      const { id, name, slug, turso_db_url, turso_auth_token } = org;
      
      try {
        logger.info(`Migrating organization: ${name} (${id})`);
        
        // Connect to the organization's database
        const orgDb = new Database(turso_db_url, turso_auth_token);
        
        // Execute the migration SQL
        await orgDb.execute(migrationSql);
        
        // Verify the table was created
        const tableExists = await orgDb.fetchOne(
          "SELECT name FROM sqlite_master WHERE type='table' AND name='tracking_clicks'"
        );
        
        if (tableExists) {
          logger.info(`Successfully migrated organization ${name} (${id})`);
        } else {
          logger.error(`Migration failed for organization ${name} (${id}): table not created`);
        }
      } catch (error) {
        logger.error(`Error migrating organization ${name} (${id}): ${error.message}`);
      }
    }
    
    logger.info('Migration complete!');
    process.exit(0);
  } catch (error) {
    logger.error(`Migration failed: ${error.message}`);
    logger.error(error.stack);
    process.exit(1);
  }
}

// Start the migration
main();

================
File: scripts/sample-contacts.csv
================
first_name,last_name,email,current_carrier,plan_type,effective_date,birth_date,tobacco_user,gender,state,zip_code,phone_number
John,Doe,john.doe@example.com,Aetna,F,2023-01-01,1955-08-21,0,Male,FL,33101,123-456-7890
Jane,Smith,jane.smith@example.com,Humana,G,2023-02-15,1953-04-12,0,Female,TX,75001,214-555-1234
Robert,Johnson,robert.j@example.com,UnitedHealthcare,N,2022-12-01,1949-11-30,1,Male,CA,90210,310-555-9876
Susan,Williams,susan.w@example.com,Cigna,G,2023-03-20,1960-02-28,0,Female,NY,10001,212-555-4321
Michael,Brown,michael.b@example.com,Aetna,F,2023-01-15,1952-07-14,0,Male,IL,60601,312-555-7890
Patricia,Davis,patricia.d@example.com,Humana,G,2022-11-10,1958-09-17,0,Female,GA,30301,404-555-3456
James,Miller,james.m@example.com,UnitedHealthcare,N,2023-02-01,1950-12-05,1,Male,AZ,85001,480-555-6789
Linda,Wilson,linda.w@example.com,Cigna,F,2023-03-01,1956-05-22,0,Female,PA,19101,215-555-2345
William,Moore,william.m@example.com,Aetna,G,2022-10-15,1947-03-08,1,Male,OH,44101,216-555-7890
Jennifer,Taylor,jennifer.t@example.com,Humana,F,2023-01-20,1962-08-11,0,Female,MI,48201,313-555-4567

================
File: scripts/setup-contact-tracking.sh
================
#!/bin/bash

# Setup script for contact tracking system
# This script installs dependencies and sets up the database tables

# Exit on any error
set -e

echo "Setting up contact tracking system..."

# Install UUID package
echo "Installing dependencies..."
npm install uuid
npm install --save-dev @types/uuid

# Create necessary database tables
echo "Setting up database tables..."
DB_PATH="./database.db"

# Run the SQL migration
echo "Applying database migration..."
MIGRATION_PATH="./migrations/20240406_add_contact_history_tracking.sql"

# Use the migrate script if available
if [ -f "./scripts/migrate.sh" ]; then
  ./scripts/migrate.sh $MIGRATION_PATH
else
  # Fallback if migrate script doesn't exist
  echo "Migration script not found, attempting direct application..."
  
  # For SQLite
  if [ -f "$DB_PATH" ]; then
    sqlite3 $DB_PATH < $MIGRATION_PATH
  else
    echo "Database file not found at $DB_PATH"
    echo "Please run this script from the backend directory or update the DB_PATH variable."
    exit 1
  fi
fi

# Set file as executable
chmod +x ./scripts/setup-contact-tracking.sh

echo "Contact tracking system setup complete!"
echo ""
echo "Usage:"
echo "  - New contacts are automatically tracked when added to the system"
echo "  - Billing is based on unique contacts per billing cycle"
echo "  - Contact statistics are available at /api/contact-tracking/usage-stats"
echo ""

================
File: scripts/test-bulk-import.ts
================
import { Database } from '../src/database';
import { ContactCreate } from '../src/types';
import { logger } from '../src/logger';
import fs from 'fs/promises';
import { parse } from 'csv-parse/sync';

/**
 * Test utility for the bulk contact import feature
 * 
 * Usage:
 *   bun run scripts/test-bulk-import.ts <org_id> <csv_file> [--overwrite]
 * 
 * Where:
 *   <org_id> is the organization ID to import contacts for
 *   <csv_file> is the path to a CSV file containing contacts
 *   --overwrite is an optional flag to overwrite existing contacts
 * 
 * The CSV file should have headers that match the ContactCreate interface properties
 * Columns can be in either camelCase (firstName) or snake_case (first_name) format
 */

async function main() {
  try {
    // Parse command line arguments
    const args = process.argv.slice(2);
    
    if (args.length < 2) {
      console.error('Usage: bun run scripts/test-bulk-import.ts <org_id> <csv_file> [--overwrite]');
      process.exit(1);
    }
    
    const orgId = args[0];
    const csvPath = args[1];
    const overwriteExisting = args.includes('--overwrite');
    
    // Read and parse the CSV file
    logger.info(`Reading contacts from ${csvPath}`);
    const csvContent = await fs.readFile(csvPath, 'utf-8');
    
    // Parse CSV with header row
    const records = parse(csvContent, {
      columns: true,
      skip_empty_lines: true,
      trim: true
    });
    
    logger.info(`Parsed ${records.length} records from CSV`);
    
    // Convert records to ContactCreate objects
    const contacts: ContactCreate[] = records.map((record: any) => {
      return {
        first_name: record.first_name || record.firstName || '',
        last_name: record.last_name || record.lastName || '',
        email: record.email || '',
        current_carrier: record.current_carrier || record.currentCarrier || '',
        plan_type: record.plan_type || record.planType || '',
        effective_date: record.effective_date || record.effectiveDate || '',
        birth_date: record.birth_date || record.birthDate || '',
        tobacco_user: record.tobacco_user === '1' || record.tobacco_user === 'true' || record.tobaccoUser === true || record.tobaccoUser === '1' || record.tobaccoUser === 'true',
        gender: record.gender || '',
        state: record.state || '',
        zip_code: record.zip_code || record.zipCode || '',
        phone_number: record.phone_number || record.phoneNumber || '',
        agent_id: record.agent_id || record.agentId || null
      };
    });
    
    // Log a sample contact
    logger.info(`Sample contact: ${JSON.stringify(contacts[0])}`);
    
    // Validate contacts
    const validContacts = contacts.filter(contact => {
      return contact.first_name && contact.last_name && contact.email;
    });
    
    logger.info(`Found ${validContacts.length} valid contacts out of ${contacts.length}`);
    
    // Confirm with user
    console.log(`Ready to import ${validContacts.length} contacts for organization ${orgId}.`);
    console.log(`Overwrite existing: ${overwriteExisting}`);
    
    // Add a delay to allow cancellation
    console.log('Starting import in 5 seconds... Press Ctrl+C to cancel');
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Execute bulk import
    const startTime = Date.now();
    logger.info('Starting bulk import...');
    
    await Database.bulkImportContacts(orgId, validContacts, overwriteExisting);
    
    const totalTime = (Date.now() - startTime) / 1000;
    logger.info(`Bulk import completed in ${totalTime.toFixed(2)} seconds`);
    
  } catch (error) {
    logger.error(`Error in test-bulk-import: ${error}`);
    process.exit(1);
  }
}

main();

================
File: sql/add_demo_mode_column.sql
================


================
File: sql/create_tables.sql
================
-- Create organizations table
CREATE TABLE IF NOT EXISTS organizations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  subscription_tier TEXT DEFAULT 'basic',
  agent_limit INTEGER DEFAULT 1,
  contact_limit INTEGER DEFAULT 1000,
  stripe_customer_id TEXT,
  stripe_subscription_id TEXT,
  stripe_checkout_session TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create subscription_tiers table
CREATE TABLE IF NOT EXISTS subscription_tiers (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  agent_limit INTEGER NOT NULL,
  contact_limit INTEGER NOT NULL,
  price_monthly INTEGER NOT NULL,
  price_yearly INTEGER NOT NULL,
  features TEXT NOT NULL
);

-- Insert default subscription tiers
INSERT INTO subscription_tiers 
(id, name, agent_limit, contact_limit, price_monthly, price_yearly, features)
VALUES 
('basic', 'Basic', 1, 1000, 2900, 29900, '["Email Support", "Basic Analytics", "1 Agent"]'),
('pro', 'Professional', 5, 10000, 9900, 99900, '["Email & Phone Support", "Advanced Analytics", "Team Collaboration", "API Access", "5 Agents"]'),
('enterprise', 'Enterprise', 10, 20000, 19900, 199900, '["24/7 Priority Support", "Custom Reporting", "Dedicated Account Manager", "White-labeling", "SSO Integration", "10 Agents"]');

================
File: sql/update_org_limits.sql
================
-- Update organization tier limits
-- Basic tier: 1 agent, 1,000 contacts
UPDATE organizations 
SET agent_limit = 1, contact_limit = 1000 
WHERE subscription_tier = 'basic';

-- Pro tier: 5 agents, 10,000 contacts
UPDATE organizations 
SET agent_limit = 5, contact_limit = 10000 
WHERE subscription_tier = 'pro';

-- Enterprise tier: 10 agents, 20,000 contacts  
UPDATE organizations 
SET agent_limit = 10, contact_limit = 20000 
WHERE subscription_tier = 'enterprise';

-- Make sure subscription_tiers table is updated with correct limits
INSERT OR REPLACE INTO subscription_tiers 
(id, name, agent_limit, contact_limit, price_monthly, price_yearly, features)
VALUES 
('basic', 'Basic', 1, 1000, 2900, 29900, '["Email Support", "Basic Analytics", "1 Agent"]'),
('pro', 'Professional', 5, 10000, 9900, 99900, '["Email & Phone Support", "Advanced Analytics", "Team Collaboration", "API Access", "5 Agents"]'),
('enterprise', 'Enterprise', 10, 20000, 19900, 199900, '["24/7 Priority Support", "Custom Reporting", "Dedicated Account Manager", "White-labeling", "SSO Integration", "10 Agents"]');

================
File: sql/update_org_schema.sql
================
-- Add stripe_checkout_session column to organizations table
ALTER TABLE organizations ADD COLUMN stripe_checkout_session TEXT;

================
File: src/config/index.ts
================
interface Config {
  TURSO_DATABASE_URL?: string;
  TURSO_AUTH_TOKEN?: string;
  TURSO_DATABASE_PATH?: string;
  TURSO_API_TOKEN?: string;
  TURSO_ORG_GROUP: string;
  TURSO_ORG_SLUG: string;
  STRIPE_SECRET_KEY?: string;
  STRIPE_WEBHOOK_SECRET?: string;
  SENDGRID_API_KEY?: string;
  SENDGRID_FROM_EMAIL?: string;
  SENDGRID_TEMPLATES: Record<string, string>;
  USE_LOCAL_SQLITE: boolean;
  LOCAL_DB_PATH: string;
  clientUrl: string;
}

export const config: Config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  TURSO_API_TOKEN: process.env.TURSO_API_TOKEN,
  TURSO_ORG_GROUP: process.env.TURSO_ORG_GROUP || 'default',
  TURSO_ORG_SLUG: process.env.TURSO_ORG_SLUG || 'default',
  STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
  STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
  SENDGRID_API_KEY: process.env.SENDGRID_API_KEY,
  SENDGRID_FROM_EMAIL: process.env.SENDGRID_FROM_EMAIL,
  SENDGRID_TEMPLATES: {
    QUOTE_EMAIL: 'd-f43dasd8f9a8sd7f98asd7f',
    WELCOME_EMAIL: 'd-a9s8d7f98as7df89as7df9'
  },
  USE_LOCAL_SQLITE: process.env.USE_LOCAL_SQLITE !== 'false',
  LOCAL_DB_PATH: process.env.LOCAL_DB_PATH || 'data/organizations',
  clientUrl: process.env.NODE_ENV === 'production' 
    ? 'https://app.example.com'
    : 'http://localhost:5173'
}

================
File: src/config/turso.ts
================
export const TURSO_CONFIG = {
  API_URL: 'https://api.turso.tech/v1',
  API_TOKEN: process.env.TURSO_API_TOKEN, // Add this to your .env
  ORG_SLUG: 'pyrex41',
  GROUP_NAME: 'maxretain',
  LOCATION: 'aws-us-east-1' // We can update this to your preferred location
}

================
File: src/middleware/account-status.ts
================
import { Elysia } from 'elysia';
import { getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { Database } from '../database';

/**
 * Middleware to check if an organization's account is in good standing
 * This can be used on routes that should be blocked if the account has issues
 */
export const accountStatusMiddleware = new Elysia()
  .derive(async ({ request, set }) => {
    try {
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      if (!currentUser) {
        // If no user, let the auth middleware handle it
        return { accountStatus: null };
      }
      
      const db = new Database();
      
      // Query organization status from the view
      const statusResult = await db.query<{
        account_status: string;
        subscription_status: string;
      }>('SELECT account_status, subscription_status FROM organization_status WHERE id = ?', 
         [currentUser.organization_id]);
      
      if (!statusResult || statusResult.length === 0) {
        logger.error(`Could not find organization status for org ID: ${currentUser.organization_id}`);
        return { accountStatus: null };
      }
      
      const status = statusResult[0];
      
      // If account is not in good standing, block access to certain operations
      if (status.account_status !== 'good_standing') {
        logger.warn(`Blocked access due to account status: ${status.account_status} for org ${currentUser.organization_id}`);
        return { accountStatus: status.account_status, subscription_status: status.subscription_status };
      }
      
      // Account is in good standing
      return { accountStatus: 'good_standing' };
      
    } catch (error) {
      logger.error(`Error in account status middleware:`, error);
      return { accountStatus: null };
    }
  });

================
File: src/middleware/auth.copy.ts
================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { Database } from '../database';

interface AuthenticatedRequest extends Request {
  user?: {
    id: number;
    email: string;
    organization_id: number;
    role: string;
    turso_db_url?: string;
    turso_auth_token?: string;
  };
}

export async function authMiddleware(
  req: AuthenticatedRequest, 
  res: Response, 
  next: NextFunction
) {
  try {
    // Verify JWT token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      res.status(401).json({ error: 'No token provided' });
      return;
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
      userId: number;
    };

    const db = new Database();

    // Get user with organization info from central DB
    const user = await db.execute(
      `SELECT u.*, o.turso_db_url, o.turso_auth_token
       FROM users u
       JOIN organizations o ON u.organization_id = o.id
       WHERE u.id = ?`,
      [decoded.userId]
    );

    if (!user) {
      res.status(401).json({ error: 'User not found' });
      return;
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Unauthorized' });
  }
}

================
File: src/middleware/auth.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'
import { getUserFromSession } from '../services/auth'

// Auth middleware for protected routes
export const requireAuth = new Elysia()
  .derive(async ({ request, set }) => {
    try {
      // Check for auth bypass header - bypass if present
      const bypassAuth = request.headers.get('X-Bypass-Auth')
      if (bypassAuth) {
        logger.info(`Auth middleware: bypassing auth due to X-Bypass-Auth header`)
        return
      }

      // Check if this is a public endpoint that should bypass auth
      const url = new URL(request.url)
      const pathname = url.pathname
      
      // Bypass auth for SPA routes - belt and suspenders approach
      if ((!pathname.startsWith('/api/') && !pathname.includes('.')) || 
          pathname.startsWith('/compare/') ||
          pathname.startsWith('/quote/') ||
          pathname.startsWith('/eligibility') ||
          pathname.startsWith('/schedule')) {
        logger.info(`Auth middleware: bypassing auth for SPA route: ${pathname}`)
        return
      }
      
      // Get user from session
      const user = await getUserFromSession(request)
      logger.info(`Auth middleware: user: ${JSON.stringify(user)}`)
      
      // If no user or skip_auth not set, return 401
      if (!user ) {
        logger.warn(`not user: ${JSON.stringify(!user)}`)
        logger.warn(`Auth middleware: unauthorized access to ${pathname}`)
        set.status = 401
        return { success: false, error: 'Authentication required' }
      }
      
      // Return user object for routes to use
      return { user }
    } catch (error) {
      logger.error(`Auth middleware error: ${error}`)
      set.status = 500
      return { success: false, error: 'Internal server error' }
    }
  })

// Admin middleware - requires auth first
export const requireAdmin = new Elysia()
  .derive(async ({ request, set }) => {
    try {
      // Check for auth bypass header - bypass if present
      const bypassAuth = request.headers.get('X-Bypass-Auth')
      if (bypassAuth) {
        logger.info(`Admin middleware: bypassing auth due to X-Bypass-Auth header`)
        return
      }
      
      // Get user from session
      const user = await getUserFromSession(request)
      
      // If no user or not admin, return 403
      if (!user || !user.is_admin) {
        logger.warn(`Admin middleware: forbidden access to ${new URL(request.url).pathname}`)
        set.status = 403
        return { success: false, error: 'Admin access required' }
      }
      
      // Return user object for routes to use
      return { user }
    } catch (error) {
      logger.error(`Admin middleware error: ${error}`)
      set.status = 500
      return { success: false, error: 'Internal server error' }
    }
  })

================
File: src/middleware/error.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'

export const errorHandler = new Elysia()
  .onError(({ code, error, set }) => {
    logger.error(` Error: ${code} - ${error.message}`);
    logger.error(`Stack trace: ${error.stack}`);
    
    switch (code) {
      case 'NOT_FOUND':
        set.status = 404;
        return {
          success: false,
          message: 'Resource not found'
        };
      
      case 'VALIDATION':
        set.status = 400;
        return {
          success: false,
          message: error.message
        };
      
      default:
        set.status = 500;
        return {
          success: false,
          message: 'Internal server error'
        };
    }
  });

================
File: src/routes/admin-portal.ts
================
import { Elysia } from 'elysia'
import { spawn } from 'child_process'
import path from 'path'
import { logger } from '../logger'
import { requireAuth, requireAdmin } from '../middleware/auth'

// Create admin portal routes
export const createAdminPortalRoutes = () => {
  const adminPortal = new Elysia({ prefix: '/api/admin' })
    .use(requireAuth)
    .use(requireAdmin)

    // Get available admin scripts
    .get('/scripts', () => {
      const availableScripts = [
        {
          id: 'add-agent',
          name: 'Add Agent',
          description: 'Interactive tool to add new agents',
          script: 'add-agent.ts'
        },
        {
          id: 'manage-recommendations',
          name: 'Manage GI Recommendations', 
          description: 'Manage guaranteed issue recommendations',
          script: 'manage-recommendations.ts'
        }
      ]
      
      return { scripts: availableScripts }
    })

    // Execute script endpoint
    .post('/execute/:scriptId', ({ params, set, server }) => {
      const { scriptId } = params
      const scriptPath = path.join(__dirname, '../../scripts', `${scriptId}.ts`)

      logger.info(`Executing admin script: ${scriptId}`)

      // Spawn script process
      const process = spawn('bun', ['run', scriptPath], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      // Get WebSocket server instance
      const wss = server.webSocket

      // Handle new WebSocket connections
      wss.on('connection', (ws) => {
        logger.info('Admin terminal WebSocket connected')

        // Handle input from client
        ws.on('message', (data: string) => {
          const parsed = JSON.parse(data)
          if (parsed.type === 'input') {
            process.stdin.write(parsed.data)
          }
        })

        // Send output to client
        process.stdout.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'output', 
            data: data.toString() 
          }))
        })

        process.stderr.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'error', 
            data: data.toString() 
          }))
        })

        // Handle process exit
        process.on('exit', (code) => {
          ws.send(JSON.stringify({ type: 'exit', code }))
          logger.info(`Admin script ${scriptId} exited with code ${code}`)
        })

        // Handle WebSocket close
        ws.on('close', () => {
          logger.info('Admin terminal WebSocket disconnected')
          process.kill()
        })
      })

      set.status = 200
      return { 
        success: true, 
        message: 'Script execution started' 
      }
    })

  return adminPortal
}

================
File: src/routes/admin.ts
================
import { Elysia } from 'elysia'
import { staticPlugin } from '@elysiajs/static'
import { spawn } from 'child_process'
import path from 'path'
import { TursoService } from '../services/turso'

const tursoService = new TursoService()

export const adminRoutes = new Elysia()
  // Protect admin routes
  .guard({
    beforeHandle: ({ request, set }) => {
      // Add your admin authentication logic here
      const isAdmin = true // Replace with actual admin check
      if (!isAdmin) {
        set.status = 401
        return 'Unauthorized'
      }
    }
  })
  // Serve admin portal static files
  .use(staticPlugin({
    assets: '../admin-portal/dist',
    prefix: '/admin'
  }))
  // Terminal WebSocket endpoint
  .ws('/admin/terminal', {
    open(ws) {
      ws.send('Connected to admin terminal')
    },
    message(ws, message) {
      const { command, args } = JSON.parse(message as string)
      
      const scripts = {
        'add-agent': '../scripts/add-agent.ts',
        'manage-recommendations': '../scripts/manage-recommendations.ts'
      }

      if (!scripts[command]) {
        ws.send(JSON.stringify({ error: 'Invalid command' }))
        return
      }

      const script = spawn('bun', [path.resolve(__dirname, scripts[command]), ...args], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      script.stdout.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'output', data: data.toString() }))
      })

      script.stderr.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'error', data: data.toString() }))
      })

      script.on('close', (code) => {
        ws.send(JSON.stringify({ type: 'exit', code }))
      })
    }
  })

// In your create organization endpoint:
app.post('/api/organizations', async (req, res) => {
  const { name, /* other org fields */ } = req.body
  
  try {
    // Create org in central DB
    const org = await db.one(`
      INSERT INTO organizations (name) 
      VALUES ($1) 
      RETURNING id`, 
      [name]
    )

    // Create Turso DB for org
    const { url, token } = await tursoService.createOrganizationDatabase(org.id)

    // Update org with Turso credentials
    await db.none(`
      UPDATE organizations 
      SET turso_db_url = $1, turso_auth_token = $2
      WHERE id = $3`,
      [url, token, org.id]
    )

    res.json({ success: true, organization: org })
  } catch (err) {
    res.status(500).json({ success: false, error: err.message })
  }
})

================
File: src/routes/auth.ts
================
import { Elysia } from 'elysia';
import { cookie } from '@elysiajs/cookie';
import { AuthService } from '../services/auth';
import { EmailService } from '../services/email';
import { logger } from '../logger';
import { randomBytes } from 'crypto';
import { config } from '../config';
import crypto from 'crypto';
import { db } from '../database';
import { Database } from '../database';
import { getUserFromSession } from '../services/auth';
import type { User } from '../types';

const dbInstance = new Database();

export function createAuthRoutes() {
  const auth = new AuthService();
  const emailService = new EmailService();

  return new Elysia()
    .use(cookie())
    .post('/api/auth/set-session', async ({ body, set, setCookie }) => {
      const { email } = body as { email: string };
        logger.info(`Login request for email: ${email}`);

        // Check if user exists
        const client = dbInstance.getClient();
        const userResult = await client.execute({
          sql: 'SELECT id, email FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        if (userResult.rows.length === 0) {
          // Don't reveal if user exists or not
          logger.info(`No active user found for email: ${email}`);
          set.status = 404;
          return { success: false, error: 'User not found' };
        }
      const sessionId = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

      await db.execute(
        'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
        [sessionId, userResult.rows[0].id, expiresAt.toISOString()]
      );

      setCookie('session', sessionId, {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 24 * 1 // 1 day -- shorter to force them to login again soon after onboarding
      });

      set.status = 200;

      set.status = 200;
      return { success: true };
    })
    .post('/api/auth/login', async ({ body, set }) => {
      try {
        const { email } = body as { email: string };
        logger.info(`Login request for email: ${email}`);

        // Check if user exists
        const client = dbInstance.getClient();
        const userResult = await client.execute({
          sql: 'SELECT id, email FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        if (userResult.rows.length === 0) {
          // Don't reveal if user exists or not
          logger.info(`No active user found for email: ${email}`);
          return { success: true };
        }

        // Generate and send magic link
        const magicLink = await auth.createMagicLink(
          email,
          'default', // Default organization for now
          { redirectUrl: '/dashboard' }
        );

        // Always send the email, but also log in development
        if (process.env.NODE_ENV === 'development') {
          logger.info(`Development mode - Magic link: ${magicLink}`);
        }
        
        // Send the email
        await emailService.sendMagicLink(email, magicLink, 'default');

        set.status = 200;
        return { success: true };

      } catch (e) {
        logger.error(`Login error: ${e}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Internal server error'
        };
      }
    })

    .get('/api/signup/verify/:token', async ({ params, cookie, setCookie }) => {
      const { token } = params;
      logger.info(`Starting verification for token: ${token}`);

      try {
        const result = await auth.verifySignupLink(token);
        logger.info(`Signup verification result: ${JSON.stringify(result)}`);

        if (!result.valid) {
          logger.error('Signup verification failed');
          return {
            success: false, 
            redirectUrl: "/signup",
            session: "",
            email: ""
          };
        }

        logger.info(`Signup verification successful`);

        return {
          success: true,
          redirectUrl: result.redirectUrl || '/onboarding',
          session: "",
          email: result.email
        };
      } catch (error) {
        logger.error(`Signup verification error: ${error}`);
        return {
          success: false,
          redirectUrl: "/signup",
          session: "",  
          email: ""
        };
      }
    })

    .post('/api/auth/onboarding-login', async ({ body, set, setCookie }) => {
      const { emailRaw } = body as { emailRaw: string };
      logger.info(`Onboarding login request for email: ${emailRaw}`);

      // Decode the email if it's URL encoded and trim whitespace
      const email = decodeURIComponent(emailRaw).trim();
      
      const user = await db.fetchOne<User>(
        `SELECT u.*, o.slug as organization_slug 
        FROM users u 
        JOIN organizations o ON u.organization_id = o.id 
        WHERE LOWER(u.email) = LOWER(?) AND u.is_active = 1`,
        [email]
      );
      
      if (!user) {
        logger.error(`No active user found for email: ${email}`);
        return {
          success: false,
          redirectUrl: "/signup",
          email: ""
        };
      }
      
      logger.info(`Found user: ${JSON.stringify(user)}`);
      
      const sessionId = crypto.randomBytes(32).toString('hex');
      logger.info(`Created session ID: ${sessionId}`);
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 1); // 1 day from now

      await db.execute(
        'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
        [sessionId, user.id, expiresAt.toISOString()]
      );

      logger.info(`Created session in database for user ${user.id}`);

      setCookie('session', sessionId, {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 24 * 1 // 1 day -- shorter to force them to login again soon after onboarding
      });

      set.status = 200;
      return {
        success: true,  
        redirectUrl: "/contacts",
        email: user.email
      };
    })

    .get('/api/auth/verify/:organizationSlug/:token', async ({ params, cookie, setCookie }) => {
      const { token, organizationSlug } = params;
      
      logger.info(`Starting verification for org ${organizationSlug}`);

      try {
        logger.info('Verifying magic link');
        const result = await auth.verifyMagicLink(token, organizationSlug);
        logger.info(`Magic link verification result: ${JSON.stringify(result)}`);
        
        if (!result.valid) {
          logger.error('Magic link validation failed');
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        // Create session ID
        const sessionId = crypto.randomBytes(32).toString('hex');
        logger.info(`Created session ID: ${sessionId}`);

        // First find user by email
        const user = await db.fetchOne<User>(
          `SELECT u.*, o.slug as organization_slug 
           FROM users u 
           JOIN organizations o ON u.organization_id = o.id 
           WHERE LOWER(u.email) = LOWER(?) AND u.is_active = 1`,
          [result.email]
        );

        if (!user) {
          logger.error(`No active user found for email: ${result.email}`);
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        logger.info(`Found user: ${JSON.stringify(user)}`);

        // Create session in database
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

        await db.execute(
          'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
          [sessionId, user.id, expiresAt.toISOString()]
        );

        logger.info(`Created session in database for user ${user.id}`);

        // Set session cookie
        setCookie('session', sessionId, {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7 // 7 days
        });

        const verificationResult = {
          success: true,
          redirectUrl: result.redirectUrl || '/walkthrough',  // Use the redirectUrl from magic link payload
          session: sessionId,
          email: result.email,
          orgSlug: user.organization_id.toString()  // Use organization_id since organization_slug may not exist
        };
        logger.info(`Sending verification response: ${JSON.stringify(verificationResult)}`);
        return verificationResult;

      } catch (error) {
        logger.error(`Verification error: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return {
          success: false,
          redirectUrl: "/login",
          session: "",
          email: ""
        };
      }
    })

    .get('/api/auth/session', async ({ cookie, set }) => {
      const sessionId = cookie.session;
      logger.info(`Session check - Cookie session ID: ${sessionId}`);
      
      if (!sessionId) {
        logger.info('No session cookie found');
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: "",
          demo_mode: true,
          orgCreateDate: ""
        };
      }

      try {
        // Get user and organization info from session
        logger.info(`Looking up session in database: ${sessionId}`);
        const sessionUser = await db.fetchOne<{
          id: number;
          email: string;
          first_name: string;
          last_name: string;
          is_admin: boolean;
          organization_slug: string;
          demo_mode: boolean;
          orgCreateDate: string;
        }>(
          `SELECT u.id, u.email, u.first_name, u.last_name, u.is_admin, o.slug as organization_slug, o.demo_mode, o.created_at as orgCreateDate
           FROM sessions s
           JOIN users u ON s.user_id = u.id
           JOIN organizations o ON u.organization_id = o.id
           WHERE s.id = ?`,
          [sessionId]
        );

        if (!sessionUser) {
          logger.info(`No session found in database for ID: ${sessionId}`);
          return { 
            valid: false,
            session: "",
            email: "",
            organizationSlug: "",
            first_name: "",
            last_name: "",
            is_admin: false,
            id: "",
            demo_mode: true,
            orgCreateDate: ""
          };
        }

        logger.info(`Found valid session for user: ${sessionUser.email}`);
        logger.info(`Session details: ${JSON.stringify(sessionUser, null, 2)}`);

        set.status = 200;
        return { 
          valid: true,
          session: sessionId,
          email: sessionUser.email,
          organizationSlug: sessionUser.organization_slug,
          first_name: sessionUser.first_name,
          last_name: sessionUser.last_name,
          is_admin: sessionUser.is_admin,
          id: sessionUser.id,
          demo_mode: sessionUser.demo_mode,
          orgCreateDate: sessionUser.orgCreateDate.split(/[ T]/)[0]
        };
      } catch (error) {
        logger.error(`Error getting session info: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          is_admin: false,
          id: "",
          demo_mode: true,
          orgCreateDate: ""
        };
      }
    })

    .post('/api/auth/logout', async ({ set }) => {
      set.headers['Set-Cookie'] = 'session=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT';
      return { success: true };
    });
}

================
File: src/routes/billing.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { config } from '../config';
import { requireAuth } from '../middleware/auth';
import Stripe from 'stripe';

const stripe = new Stripe(config.stripeSecretKey || '', {
  apiVersion: '2025-02-24.acacia'
});

interface PlanInfo {
  name: string;
  contactCount: number;
  totalClients: number;
  priceDescription?: string;
  basePrice?: number;
  contactsIncluded?: number;
  pricePerAdditionalContact?: number;
}

interface PaymentMethod {
  id: string;
  type: string;
  last4: string;
  brand: string;
  expiryMonth: number;
  expiryYear: number;
  email: string;
}

interface Invoice {
  id: string;
  number: string;
  date: string;
  status: 'pending' | 'paid' | 'failed';
  amount: number;
  currency: string;
  plan: string;
  pdfUrl?: string;
}

export const createBillingRoutes = (app: Elysia) => {
  app.use(requireAuth)
    
    // Get current plan information
    .get('/api/billing/plan', async ({ user, set }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        logger.info(`Fetching plan for organization_id: ${user.organization_id}`);
        
        const mainDb = new Database(); // For main 'organizations' table
        
        // Get organization details (excluding contact_count) from main DB
        const orgDetailsFromMain = await mainDb.fetchOne<{
          id: number; 
          name: string;
          stripe_customer_id: string | null;
          stripe_subscription_id: string | null;
          subscription_tier: string | null;
        }>(
          `SELECT 
              id,
              name,
              stripe_customer_id,
              stripe_subscription_id,
              subscription_tier 
            FROM organizations
            WHERE id = ?`,
          [user.organization_id]
        );
        
        logger.info(`Organization details from DB for org ${user.organization_id}: ${JSON.stringify(orgDetailsFromMain)}`);

        if (!orgDetailsFromMain) {
          set.status = 404;
          logger.error(`Organization not found in main DB for id: ${user.organization_id}`);
          return { success: false, error: 'Organization not found' };
        }

        let contactCount = 0;
        try {
          // Get contact_count from org-specific DB
          // Ensure user.organization_id is passed as a string to getOrgDb
          const orgDb = await Database.getOrgDb(user.organization_id.toString());
          const contactCountResult = await orgDb.fetchOne<{ count: number }>(
            // Count all contacts in the table, as all are considered active
            "SELECT COUNT(id) as count FROM contacts"
          );
          if (contactCountResult) {
            contactCount = contactCountResult.count;
          }
          logger.info(`Fetched contact_count: ${contactCount} for org ${user.organization_id} from orgDB.`);
        } catch (orgDbError) {
          logger.error(`Error fetching contact count from orgDB for org ${user.organization_id}: ${orgDbError}`);
          // Continue with contactCount = 0 and rely on defaults.
        }
        
        // Combine org details with contact count
        const org = {
          ...orgDetailsFromMain,
          contact_count: contactCount // Add the count here
        };
        
        // Default plan info
        let planInfo: PlanInfo = {
          name: 'Monthly Plan',
          contactCount: Number(org.contact_count) || 0,
          totalClients: 500, // Default limit
          priceDescription: 'Plan details not available', // Default description
        };
        
        // If they have a Stripe subscription, get details from Stripe
        if (org.stripe_subscription_id) {
          try {
            let subscriptionIdToUse = org.stripe_subscription_id as string;
            logger.info(`Initial stripe_subscription_id from DB for org ${user.organization_id}: ${org.stripe_subscription_id}`);
            try {
              // Attempt to parse as JSON and get the id field
              const parsedSubscription = JSON.parse(org.stripe_subscription_id as string);
              if (parsedSubscription && typeof parsedSubscription.id === 'string') {
                subscriptionIdToUse = parsedSubscription.id;
              } else {
                // Log a warning if parsing succeeded but 'id' field is missing or not a string
                logger.warn(`Parsed stripe_subscription_id but 'id' field is missing or not a string for org ${user.organization_id}`);
              }
            } catch (parseError) {
              // If parsing fails, assume it's already a plain string ID. Log this for awareness.
              logger.info(`stripe_subscription_id for org ${user.organization_id} is not valid JSON, using as plain string: ${parseError}`);
            }

            logger.info(`Using subscriptionIdToUse: ${subscriptionIdToUse} for org ${user.organization_id}`);

            const subscription = await stripe.subscriptions.retrieve(
              subscriptionIdToUse
            );
            logger.info(`Full retrieved subscription object for org ${user.organization_id}: ${JSON.stringify(subscription, null, 2)}`);

            if (subscription.items.data.length > 0 && subscription.items.data[0].price) {
              // The full price object is part of the full subscription object logged above, so this specific log can be removed if desired.
            }
            
            // Get the price details
            if (subscription.items.data.length > 0) {
              const item = subscription.items.data[0];
              const price = item.price; // This is a Stripe.Price object
              
              // Update plan name from Stripe product
              if (price.product) {
                try {
                  const productObjectOrId = price.product;
                  const productId = typeof productObjectOrId === 'string' ? productObjectOrId : productObjectOrId.id;
                  
                  const stripeProduct = await stripe.products.retrieve(productId);
                  
                  logger.info(`Full retrieved product object for org ${user.organization_id} (product ID ${productId}): ${JSON.stringify(stripeProduct, null, 2)}`);

                  if (stripeProduct && stripeProduct.name) {
                    planInfo.name = stripeProduct.name;
                  }

                  // Initialize price fields before attempting to parse or use defaults
                  planInfo.basePrice = undefined;
                  planInfo.contactsIncluded = undefined;
                  planInfo.pricePerAdditionalContact = undefined;

                  if (price.unit_amount) {
                    planInfo.basePrice = price.unit_amount / 100;
                  } else if (price.billing_scheme === 'tiered' || price.billing_scheme === 'per_unit') {
                    planInfo.basePrice = 0; // Indicates usage-based or tiers, to be refined by description
                    logger.warn(`Price object for org ${user.organization_id} has null unit_amount (billing_scheme: ${price.billing_scheme}). Base price set to 0 initially.`);
                  }

                  // Try to parse detailed pricing from the product description.
                  if (stripeProduct && stripeProduct.description) {
                    planInfo.priceDescription = stripeProduct.description; // Store the raw description first
                    
                    const priceRegex = /\$(\d+(?:\.\d{1,2})?)[^\d]*?(\d+)\s+contacts\D*\$(\d+(?:\.\d{1,2})?)\s*\/\s*contact/i;
                    const matches = stripeProduct.description.match(priceRegex);

                    if (matches && matches.length >= 4) {
                      planInfo.basePrice = parseFloat(matches[1]); // Override if parsed
                      planInfo.contactsIncluded = parseInt(matches[2], 10);
                      planInfo.pricePerAdditionalContact = parseFloat(matches[3]);
                      planInfo.priceDescription = `\$${planInfo.basePrice}/month for first ${planInfo.contactsIncluded} contacts, then \$${planInfo.pricePerAdditionalContact}/contact.`;
                      logger.info(`Parsed detailed pricing for org ${user.organization_id}: Base: ${planInfo.basePrice}, Included: ${planInfo.contactsIncluded}, Additional: ${planInfo.pricePerAdditionalContact}`);
                    } else {
                      logger.warn(`Could not parse detailed pricing structure from product description for org ${user.organization_id}: ${stripeProduct.description}. Using full description.`);
                      // Fallback for basePrice if not parsed from complex structure but a simple price exists in description
                      if (planInfo.basePrice === 0 || planInfo.basePrice === undefined) { // Only if not set by unit_amount or complex parse
                        const singlePriceMatch = stripeProduct.description.match(/\$(\d+(?:\.\d{1,2})?)/);
                        if (singlePriceMatch && singlePriceMatch[1]) {
                          planInfo.basePrice = parseFloat(singlePriceMatch[1]);
                          logger.info(`Fallback: Parsed base price $${planInfo.basePrice} from product description for org ${user.organization_id}`);
                        }
                      }
                    }
                  } else {
                    planInfo.priceDescription = 'Pricing details not available in product description.';
                  }

                } catch (productError) {
                  logger.error(`Error fetching product details from Stripe: ${productError} for product ID: ${price.product}`);
                  // Continue with default plan name or previously set name
                }
              }

              if (price.unit_amount) {
                // planInfo.pricePerMonth = price.unit_amount / 100; // Convert from cents
              } else if (price.billing_scheme === 'tiered' || price.billing_scheme === 'per_unit') {
                // For tiered or metered plans without a simple unit_amount, actual price is usage-dependent.
                // Set to 0 or a specific indicator. For now, 0 and log.
                // planInfo.pricePerMonth = 0;
                logger.warn(`Price object for org ${user.organization_id} has null unit_amount (billing_scheme: ${price.billing_scheme}). Display price set to 0. Full pricing is usage-dependent or tiered.`);
              }
              // If unit_amount is null and it's not explicitly tiered/per_unit, it will keep the default 60, 
              // which might indicate an issue or a different pricing model not yet handled.
            }
            
            // You can customize the total clients based on the plan
            if (org.subscription_tier === 'premium') {
              planInfo.totalClients = 1000;
            } else if (org.subscription_tier === 'enterprise') {
              planInfo.totalClients = 5000;
            }
          } catch (stripeError) {
            logger.error(`Error fetching subscription from Stripe: ${stripeError}`);
            // Continue with default values
          }
        }
        
        logger.info(`Final planInfo for org ${user.organization_id}: ${JSON.stringify(planInfo)}`);
        return {
          success: true,
          data: planInfo
        };
      } catch (error) {
        logger.error(`Error in plan info route: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to fetch plan information'
        };
      }
    })
    
    // Get payment method information
    .get('/api/billing/payment-method', async ({ user, set }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const db = new Database();
        const client = db.getClient();
        
        const orgResult = await client.execute({
          sql: 'SELECT stripe_customer_id FROM organizations WHERE id = ?',
          args: [user.organization_id]
        });
        
        if (orgResult.rows.length === 0 || !orgResult.rows[0].stripe_customer_id) {
          return {
            success: true,
            data: null // No Stripe customer ID, so no payment method
          };
        }
        
        const stripeCustomerId = orgResult.rows[0].stripe_customer_id as string;

        // Retrieve the customer, expanding the default payment method
        const customer = await stripe.customers.retrieve(stripeCustomerId, {
          expand: ['invoice_settings.default_payment_method']
        });

        if (!customer || customer.deleted) {
          logger.warn(`Stripe customer not found or deleted for customer ID: ${stripeCustomerId}`);
          return {
            success: true,
            data: null
          };
        }
        
        const defaultPaymentMethod = customer.invoice_settings?.default_payment_method;

        if (defaultPaymentMethod && typeof defaultPaymentMethod !== 'string' && defaultPaymentMethod.type === 'card' && defaultPaymentMethod.card) {
          const paymentMethodDetails: PaymentMethod = {
            id: defaultPaymentMethod.id,
            type: defaultPaymentMethod.type,
            last4: defaultPaymentMethod.card.last4 || '',
            brand: defaultPaymentMethod.card.brand || '',
            expiryMonth: defaultPaymentMethod.card.exp_month || 0,
            expiryYear: defaultPaymentMethod.card.exp_year || 0,
            email: (customer as Stripe.Customer).email || ''
          };
          return {
            success: true,
            data: paymentMethodDetails
          };
        } else {
          // No default payment method, or it's not a card, or card details are missing
          logger.info(`No default card payment method found or details incomplete for customer ${stripeCustomerId}`);
          return {
            success: true,
            data: null // No suitable payment method found
          };
        }
      } catch (error) {
        logger.error(`Error in payment method route: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to fetch payment method information' 
        };
      }
    })
    
    // Get invoices list
    .get('/api/billing/invoices', async ({ user, set, query }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const db = new Database();
        const client = db.getClient();
        
        // Get organization's Stripe customer ID
        const orgResult = await client.execute({
          sql: 'SELECT stripe_customer_id FROM organizations WHERE id = ?',
          args: [user.organization_id]
        });
        
        if (orgResult.rows.length === 0 || !orgResult.rows[0].stripe_customer_id) {
          return {
            success: true,
            data: [] // No invoices
          };
        }
        
        const stripeCustomerId = orgResult.rows[0].stripe_customer_id as string;
        
        // Get invoices from Stripe
        const limit = query?.limit ? parseInt(query.limit as string) : 10;
        const stripeInvoices = await stripe.invoices.list({
          customer: stripeCustomerId,
          limit: limit
        });
        
        const invoices: Invoice[] = stripeInvoices.data.map(inv => ({
          id: inv.id,
          number: inv.number || `#${inv.id.slice(-4).toUpperCase()}`,
          date: new Date(inv.created * 1000).toISOString(),
          status: inv.status === 'paid' ? 'paid' : 
                  inv.status === 'open' ? 'pending' : 'failed',
          amount: (inv.amount_paid || inv.amount_due) / 100, // Convert from cents
          currency: inv.currency.toUpperCase(),
          plan: 'Monthly', // You can customize this based on subscription
          pdfUrl: inv.invoice_pdf || undefined
        }));
        
        return {
          success: true,
          data: invoices
        };
      } catch (error) {
        logger.error(`Error in invoices route: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to fetch invoices'
        };
      }
    })
    
    // Update payment method
    .post('/api/billing/update-payment-method', async ({ user, body, set }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const { paymentMethodId } = body as { paymentMethodId: string };
        
        if (!paymentMethodId) {
          set.status = 400;
          return {
            success: false,
            error: 'Payment method ID is required'
          };
        }
        
        const db = new Database();
        const client = db.getClient();
        
        // Get organization's Stripe customer ID
        const orgResult = await client.execute({
          sql: 'SELECT stripe_customer_id, stripe_subscription_id FROM organizations WHERE id = ?',
          args: [user.organization_id]
        });
        
        if (orgResult.rows.length === 0 || !orgResult.rows[0].stripe_customer_id) {
          set.status = 400;
          return {
            success: false,
            error: 'No Stripe customer found for organization'
          };
        }
        
        const stripeCustomerId = orgResult.rows[0].stripe_customer_id as string;
        const stripeSubscriptionId = orgResult.rows[0].stripe_subscription_id as string;
        
        // Attach the payment method to the customer
        await stripe.paymentMethods.attach(paymentMethodId, {
          customer: stripeCustomerId
        });
        
        // Set as default payment method for the customer
        await stripe.customers.update(stripeCustomerId, {
          invoice_settings: {
            default_payment_method: paymentMethodId
          }
        });
        
        // If there's a subscription, update its default payment method too
        if (stripeSubscriptionId) {
          await stripe.subscriptions.update(stripeSubscriptionId, {
            default_payment_method: paymentMethodId
          });
        }
        
        return {
          success: true,
          message: 'Payment method updated successfully'
        };
      } catch (error) {
        logger.error(`Error updating payment method: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to update payment method'
        };
      }
    })
    
    // Download invoice
    .get('/api/billing/invoices/:invoiceId/download', async ({ user, params, set }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const { invoiceId } = params;
        
        // Retrieve the invoice from Stripe
        const invoice = await stripe.invoices.retrieve(invoiceId);
        
        // Verify the invoice belongs to the user's organization
        const db = new Database();
        const client = db.getClient();
        
        const orgResult = await client.execute({
          sql: 'SELECT stripe_customer_id FROM organizations WHERE id = ?',
          args: [user.organization_id]
        });
        
        if (orgResult.rows.length === 0 || 
            orgResult.rows[0].stripe_customer_id !== invoice.customer) {
          set.status = 403;
          return {
            success: false,
            error: 'Unauthorized to access this invoice'
          };
        }
        
        if (!invoice.invoice_pdf) {
          set.status = 404;
          return {
            success: false,
            error: 'Invoice PDF not available'
          };
        }
        
        // Return the PDF URL for the client to download
        return {
          success: true,
          data: {
            url: invoice.invoice_pdf
          }
        };
      } catch (error) {
        logger.error(`Error downloading invoice: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to download invoice'
        };
      }
    });

  return app;
};

================
File: src/routes/brand.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';

const db = new Database();

interface Organization {
  id: number;
}

interface BrandSettings {
  brand_name: string;
  primary_color: string;
  secondary_color: string;
  logo_data: string | null;
}

export function createBrandRoutes() {
  return new Elysia()
    .get('/api/organizations/:orgSlug/brand', async ({ params }) => {
      try {
        const { orgSlug } = params;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Get brand settings
        const settings = await db.fetchOne<BrandSettings>(
          'SELECT brand_name, primary_color, secondary_color, logo_data FROM brand_settings WHERE organization_id = ?',
          [org.id]
        );

        if (!settings) {
          // Return defaults if no settings exist
          return {
            brand_name: '',
            primary_color: '#6B46C1',
            secondary_color: '#9F7AEA',
            logo: null
          };
        }

        return {
          brand_name: settings.brand_name,
          primary_color: settings.primary_color,
          secondary_color: settings.secondary_color,
          logo: settings.logo_data
        };
      } catch (error) {
        logger.error('Error fetching brand settings', error);
        return {
          success: false,
          error: 'Failed to fetch brand settings'
        };
      }
    })
    .put('/api/organizations/:orgSlug/brand', async ({ params, body }) => {
      try {
        const { orgSlug } = params;
        const { brand_name, primary_color, secondary_color, logo } = body as any;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Upsert brand settings
        await db.execute(`
          INSERT INTO brand_settings 
            (organization_id, brand_name, primary_color, secondary_color, logo_data)
          VALUES (?, ?, ?, ?, ?)
          ON CONFLICT(organization_id) DO UPDATE SET
            brand_name = excluded.brand_name,
            primary_color = excluded.primary_color,
            secondary_color = excluded.secondary_color,
            logo_data = excluded.logo_data
        `, [org.id, brand_name, primary_color, secondary_color, logo]);

        return {
          success: true
        };
      } catch (error) {
        logger.error('Error saving brand settings', error);
        return {
          success: false,
          error: 'Failed to save brand settings'
        };
      }
    });
}

================
File: src/routes/contacts.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { validateSession, getUserFromSession } from '../services/auth';
import fs from 'fs';
import path from 'path';
import { stringify } from 'csv-stringify/sync';
import { nanoid } from 'nanoid';
import { ZIP_DATA } from '../index';
import { TursoService } from '../services/turso';
import { TURSO_CONFIG } from '../config/turso';
import fetch from 'node-fetch';
import { 
  trackContact, 
  trackContactBatch, 
  getContactUsageStats, 
  getUniqueContactCount,
  resetContactCount
} from '../services/contactTracking';

type User = {
  id: number;
  organization_id: number;
  is_admin: boolean;
};

interface ContactImport {
  first_name: string;
  last_name: string;
  email: string;
  phone_number: string;
  state?: string;
  current_carrier: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: boolean;
  gender: string;
  zip_code: string;
  plan_type: string;
}

type BulkImportRequest = {
  contacts: ContactImport[];
  overwriteExisting: boolean;
  agentId?: number | null;
};

interface Contact {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  phone_number?: string;
  state: string;
  current_carrier?: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: number;
  gender: string;
  zip_code: string;
  plan_type?: string;
  agent_id?: number;
  last_emailed?: string;
  created_at: string;
  updated_at: string;
  status?: string;
}

type Context = {
  request: Request;
  user: User;
  set: { status: number };
};

function normalizeEmail(email: string): string {
    return email.trim().toLowerCase();
}

/**
 * Contacts API endpoints
 */
export const contactsRoutes = new Elysia({ prefix: '/api/contacts' })
  .use(app => app
    .derive(async ({ request, set }) => {
      const sessionCookie = request.headers.get('cookie')?.split(';')
        .find(c => c.trim().startsWith('session='))
        ?.split('=')[1];

      if (!sessionCookie) {
        set.status = 401;
        return { error: 'Not authorized' };
      }

      const user = await validateSession(sessionCookie);
      if (!user) {
        set.status = 401;
        return { error: 'Not authorized' };
      }

      return { user };
    })
  )
  .get('/', async ({ request, user, set }: Context) => {
    if (!user || !user.organization_id) {
      set.status = 401;
      return { error: 'Not authorized' };
    }

    try {
      // Parse query parameters
      const url = new URL(request.url);
      const page = parseInt(url.searchParams.get('page') || '1');
      const limit = parseInt(url.searchParams.get('limit') || '100');
      const search = url.searchParams.get('search') || '';
      const states = url.searchParams.get('states')?.split(',').filter(Boolean) || [];
      const carriers = url.searchParams.get('carriers')?.split(',').filter(Boolean) || [];
      const agents = url.searchParams.get('agents')?.split(',').map(Number).filter(Boolean) || [];

      logger.info(`Fetching contacts for org ${user.organization_id} - page: ${page}, limit: ${limit}, search: ${search || 'none'}, states: ${states.length ? states.join(',') : 'none'}, carriers: ${carriers.length ? carriers.join(',') : 'none'}, agents: ${agents.length ? agents.join(',') : 'none'}`);

      // Build base query parts
      let whereConditions = ['1=1'];
      let params: any[] = [];

      // Add search condition if present
      if (search) {
        const searchTerms = search.trim().split(/\s+/);
        
        if (searchTerms.length === 1) {
          // Single word search - check each column individually
          whereConditions.push('(first_name LIKE ? OR last_name LIKE ? OR email LIKE ? OR phone_number LIKE ?)');
          params.push(`%${search}%`, `%${search}%`, `%${search}%`, `%${search}%`);
        } else {
          // Multi-word search - treat first word as first name and remaining words as last name
          const firstName = searchTerms[0];
          const lastName = searchTerms.slice(1).join(' ');
          
          whereConditions.push('((first_name LIKE ? AND last_name LIKE ?) OR first_name LIKE ? OR last_name LIKE ? OR email LIKE ? OR phone_number LIKE ?)');
          params.push(
            `%${firstName}%`, `%${lastName}%`, // Combined name search
            `%${search}%`, `%${search}%`, // Full search term in either name field
            `%${search}%`, `%${search}%` // Email and phone
          );
        }
      }

      // Add state filter
      if (states.length > 0) {
        const zipCodesForStates = Object.entries(ZIP_DATA)
          .filter(([_, info]) => states.includes(info.state))
          .map(([zipCode]) => zipCode);
        whereConditions.push(`zip_code IN (${zipCodesForStates.map(() => '?').join(',')})`);
        params.push(...zipCodesForStates);
      }

      // Add carrier filter
      if (carriers.length > 0) {
        whereConditions.push(`(${carriers.map(() => 'current_carrier LIKE ?').join(' OR ')})`);
        params.push(...carriers.map(c => `%${c}%`));
      }

      // Add agent filter
      if (agents.length > 0) {
        whereConditions.push(`agent_id IN (${agents.map(() => '?').join(',')})`);
        params.push(...agents);
      }

      // Combine conditions
      const whereClause = whereConditions.join(' AND ');

      // Get organization database with retry logic
      let orgDb;
      try {
        orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
      } catch (error) {
        // If database not found, check if it exists in the list
        if (error instanceof Error && error.message.includes('database not configured')) {
          logger.info(`Database not found for org ${user.organization_id}, checking database list...`);
          
          const tursoService = new TursoService();
          const mainDb = new Database();
          
          // Get the org's database URL
          const orgData = await mainDb.fetchOne<{ turso_db_url: string }>(
            'SELECT turso_db_url FROM organizations WHERE id = ?',
            [user.organization_id]
          );

          if (!orgData?.turso_db_url) {
            logger.error(`No database URL found for org ${user.organization_id}`);
            set.status = 500;
            return { error: 'Organization database not configured' };
          }

          // Extract database name from URL
          const dbName = orgData.turso_db_url.split('/').pop()?.split('.')[0]?.replace(/-[^-]*$/, '');
          if (!dbName) {
            logger.error(`Could not extract database name from URL: ${orgData.turso_db_url}`);
            set.status = 500;
            return { error: 'Invalid database configuration' };
          }

          // Check if database exists in Turso
          const response = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
            }
          });

          if (!response.ok) {
            logger.error(`Failed to list databases, status: ${response.status}`);
            set.status = 500;
            return { error: 'Failed to verify database status' };
          }

          const data = await response.json();
          const dbExists = data.databases.some((db: any) => db.Name === dbName);

          if (dbExists) {
            logger.info(`Database ${dbName} found in list, retrying connection...`);
            // Retry getting the database
            try {
              orgDb = await Database.getOrgDb(user.organization_id.toString());
            } catch (retryError) {
              logger.error(`Failed to connect to database after verification: ${retryError}`);
              set.status = 500;
              return { error: 'Database exists but connection failed' };
            }
          } else {
            logger.error(`Database ${dbName} not found in Turso organization`);
            set.status = 500;
            return { error: 'Database not found in organization' };
          }
        } else {
          // For other errors, throw them
          throw error;
        }
      }

      logger.info(`Connected to org database for ${user.organization_id}`);

      // First get total count with a simpler query
      const countQuery = `SELECT COUNT(*) as total FROM contacts WHERE ${whereClause}`;
      logger.info(`Executing count query: ${countQuery} with params: ${JSON.stringify(params)}`);
      
      const countResult = await orgDb.fetchOne<{ total: number }>(countQuery, params);
      let total = countResult?.total || 0;
      logger.info(`Found total of ${total} contacts matching criteria`);

      // If no contacts found, verify database is properly synced
      if (total === 0) {
        logger.info(`No contacts found for org ${user.organization_id}, verifying database sync status...`);
        
        const mainDb = new Database();
        
        // Get the org's database URL
        const orgData = await mainDb.fetchOne<{ turso_db_url: string }>(
          'SELECT turso_db_url FROM organizations WHERE id = ?',
          [user.organization_id]
        );

        if (!orgData?.turso_db_url) {
          logger.error(`No database URL found for org ${user.organization_id}`);
          set.status = 500;
          return { error: 'Organization database not configured' };
        }

        // Extract database name from URL
        const dbName = orgData.turso_db_url.split('/').pop()?.split('.')[0]?.replace(/-[^-]*$/, '');
        if (!dbName) {
          logger.error(`Could not extract database name from URL: ${orgData.turso_db_url}`);
          set.status = 500;
          return { error: 'Invalid database configuration' };
        }

        // Check if database exists in Turso
        const response = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
          }
        });

        if (!response.ok) {
          logger.error(`Failed to list databases, status: ${response.status}`);
          set.status = 500;
          return { error: 'Failed to verify database status' };
        }

        const data = await response.json();
        const dbExists = data.databases.some((db: any) => db.Name === dbName);

        if (dbExists) {
          logger.info(`Database ${dbName} found in list, retrying connection and count...`);
          // Retry getting the database and count
          try {
            orgDb = await Database.getOrgDb(user.organization_id.toString());
            const retryCountResult = await orgDb.fetchOne<{ total: number }>(countQuery, params);
            const retryTotal = retryCountResult?.total || 0;
            logger.info(`Retry count found ${retryTotal} contacts`);
            if (retryTotal > 0) {
              total = retryTotal; // Update total if we found contacts on retry
            }
          } catch (retryError) {
            logger.error(`Failed to reconnect to database after verification: ${retryError}`);
            set.status = 500;
            return { error: 'Database exists but connection failed' };
          }
        } else {
          logger.error(`Database ${dbName} not found in Turso organization`);
          set.status = 500;
          return { error: 'Database not found in organization' };
        }
      }

      // Then get paginated results
      const offset = (page - 1) * limit;
      const selectQuery = `
        SELECT 
          COALESCE(id, rowid) as id,
          first_name, last_name, email, phone_number, state,
          current_carrier, effective_date, birth_date, tobacco_user,
          gender, zip_code, plan_type, agent_id, last_emailed,
          created_at, updated_at, status
        FROM contacts 
        WHERE ${whereClause}
        ORDER BY created_at DESC 
        LIMIT ? OFFSET ?`;
      
      logger.info(`Executing select query: ${selectQuery} with params: ${JSON.stringify([...params, limit, offset])}`);
      
      const contacts = await orgDb.query<Contact>(selectQuery, [...params, limit, offset]);
      logger.info(`Retrieved ${contacts.length} contacts for current page`);

      // Log first contact for debugging
      if (contacts.length > 0) {
        logger.info(`First contact: ${JSON.stringify(contacts[0])}`);
      }

      // Get filter options using separate queries for unique values
      const carrierQuery = `SELECT DISTINCT current_carrier FROM contacts WHERE ${whereClause} AND current_carrier IS NOT NULL ORDER BY current_carrier`;
      const zipQuery = `SELECT DISTINCT zip_code FROM contacts WHERE ${whereClause} AND zip_code IS NOT NULL ORDER BY zip_code`;
      
      const [carrierRows, zipRows] = await Promise.all([
        orgDb.query<{current_carrier: string}>(carrierQuery, params),
        orgDb.query<{zip_code: string}>(zipQuery, params)
      ]);

      // Get unique states from zip codes using ZIP_DATA
      const uniqueStates = zipRows
        .map(row => {
          const zipInfo = ZIP_DATA[row.zip_code];
          return zipInfo?.state;
        })
        .filter((state): state is string => state !== undefined)
        .filter((value, index, self) => self.indexOf(value) === index)
        .sort();
      
      const filterOptions = {
        carriers: carrierRows.map(row => row.current_carrier).filter(Boolean),
        states: uniqueStates
      };
      
      logger.info(`Filter options - carriers: ${filterOptions.carriers.join(',')}, states: ${filterOptions.states.join(',')}`);

      // Map contacts to expected format using snake_case
      const mappedContacts = contacts.map(contact => {
        // Get state from ZIP code
        const zipInfo = ZIP_DATA[contact.zip_code];
        const state = zipInfo?.state || contact.state; // Fallback to stored state if ZIP lookup fails

        // Ensure we have a valid ID
        if (!contact.id) {
          logger.error(`Contact missing ID: ${JSON.stringify(contact)}`);
        }

        return {
          id: contact.id || 0, // Fallback to 0 if null (shouldn't happen with COALESCE)
          first_name: contact.first_name,
          last_name: contact.last_name,
          email: contact.email,
          phone_number: contact.phone_number || '',
          state: state,
          current_carrier: contact.current_carrier,
          effective_date: contact.effective_date,
          birth_date: contact.birth_date,
          tobacco_user: Boolean(contact.tobacco_user),
          gender: contact.gender,
          zip_code: contact.zip_code,
          plan_type: contact.plan_type,
          agent_id: contact.agent_id,
          last_emailed: contact.last_emailed,
          status: contact.status || 'New'
        };
      });

      const response = {
        contacts: mappedContacts,
        filterOptions,
        total,
        page,
        limit
      };

      logger.info(`Returning response with ${mappedContacts.length} contacts, total: ${total}`);
      return response;

    } catch (error) {
      logger.error(`Error fetching contacts: ${error}`);
      set.status = 500;
      return { error: 'Failed to fetch contacts' };
    }
  })
  .post('/bulk-import', async ({ body, user, set }: { body: BulkImportRequest; user: User; set: { status: number } }) => {
    if (!user || !user.organization_id || !user.is_admin) {
      set.status = 401;
      return { success: false, message: 'Not authorized for bulk import', totalRows: 0 };
    }

    try {
      // For non-admin agents, force overwriteExisting to false
      const overwriteExisting = user.is_admin ? body.overwriteExisting : false;

      // Validate contacts array
      if (!Array.isArray(body.contacts) || body.contacts.length === 0) {
        set.status = 400;
        return { success: false, message: 'No contacts provided', totalRows: 0 };
      }

      // Create temp directory if it doesn't exist
      const tempDir = path.join(process.cwd(), 'tmp');
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }

      // Generate temp file name with random ID to avoid conflicts
      const tempFile = path.join(tempDir, `contacts-${nanoid()}.csv`);
      
      try {
        // Convert contacts array to CSV string
        const csvData = stringify(body.contacts, {
          header: true,
          
          columns: [
            'first_name', 'last_name', 'email', 'phone_number',
            'current_carrier', 'effective_date', 'birth_date', 'tobacco_user',
            'gender', 'zip_code', 'plan_type'
          ]
        });
        
        // Write CSV data to temp file
        fs.writeFileSync(tempFile, csvData);
        logger.info(`Created temporary CSV file: ${tempFile} with ${body.contacts.length} contacts`);
        
        // Use the bulk import function with the temp CSV file
        const result = await Database.bulkImportContacts(
          user.organization_id.toString(),
          tempFile,
          overwriteExisting,
          undefined, // columnMapping
          undefined, // carrierMapping
          body.agentId // Pass the agentId
        );
        
        logger.info(`Bulk import completed: ${result}`);

        // After bulk import, handle re-activation from deleted_contacts
        // This assumes the new org DB is now live and accessible via getOrInitOrgDb
        if (body.contacts && body.contacts.length > 0) {
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString()); // Connects to the NEW live DB
          const importedEmails = body.contacts.map(contact => normalizeEmail(contact.email)).filter(Boolean);

          if (importedEmails.length > 0) {
            const placeholders = importedEmails.map(() => '?').join(',');
            await orgDb.execute(
              `DELETE FROM deleted_contacts WHERE LOWER(TRIM(email)) IN (${placeholders})`,
              importedEmails
            );
            logger.info(`Cleared ${importedEmails.length} reactivated emails from deleted_contacts for org ${user.organization_id} post-bulk-import.`);
          }
        }
        
        return {
          success: true,
          message: 'Contacts imported successfully',
          totalRows: body.contacts.length
        };
      } finally {
        // Clean up temp file
        if (fs.existsSync(tempFile)) {
          fs.unlinkSync(tempFile);
          logger.info(`Removed temporary CSV file: ${tempFile}`);
        }
      }
    } catch (error) {
      logger.error(`Error in bulk import: ${error}`);
      set.status = 500;
      return { 
        success: false,
        message: error instanceof Error ? error.message : 'Failed to process import',
        totalRows: 0
      };
    }
  })
  .post('/track', 
    async ({ request, body, set }) => {
      try {
        const user = await getUserFromSession(request);
        
        // Check if request includes required fields
        if (!user || !body || 'skip_auth' in user) {
          set.status = 400;
          return { 
            success: false, 
            error: 'Invalid request' 
          };
        }
        
        const { email, firstName, lastName } = body as {
          email: string;
          firstName?: string;
          lastName?: string;
        };
        
        if (!email) {
          set.status = 400;
          return { 
            success: false, 
            error: 'Email is required' 
          };
        }
        
        // Track the contact
        const result = await trackContact(
          user.organization_id.toString(),
          user.id.toString(),
          email,
          firstName,
          lastName
        );
        
        // Get updated usage stats
        const stats = await getContactUsageStats(user.organization_id.toString());
        
        return {
          success: true,
          isNew: result.isNew,
          contactId: result.contactId,
          stats
        };
      } catch (error) {
        logger.error(`Error tracking contact: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Failed to track contact' 
        };
      }
    },
    {
      body: t.Object({
        email: t.String(),
        firstName: t.Optional(t.String()),
        lastName: t.Optional(t.String())
      })
    }
  )
  
  // Track a batch of contacts
  .post('/batch', 
    async ({ request, body, set }) => {
      try {
        const user = await getUserFromSession(request);
        
        // Check if request includes required fields
        if (!user || !body || !body.contacts || !Array.isArray(body.contacts) || 'skip_auth' in user) {
          set.status = 400;
          return { 
            success: false, 
            error: 'Invalid request' 
          };
        }
        
        const { contacts } = body as {
          contacts: Array<{
            email: string;
            firstName?: string;
            lastName?: string;
          }>
        };
        
        // Track the contacts in batch
        const result = await trackContactBatch(
          user.organization_id.toString(),
          user.id.toString(),
          contacts
        );
        
        // Get updated usage stats
        const stats = await getContactUsageStats(user.organization_id.toString());
        
        return {
          success: true,
          newCount: result.newCount,
          totalProcessed: result.totalProcessed,
          stats
        };
      } catch (error) {
        logger.error(`Error tracking contact batch: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Failed to track contacts' 
        };
      }
    },
    {
      body: t.Object({
        contacts: t.Array(
          t.Object({
            email: t.String(),
            firstName: t.Optional(t.String()),
            lastName: t.Optional(t.String())
          })
        )
      })
    }
  )
  
  // Get contact usage stats
  .get('/usage-stats', async ({ request, set }) => {
    try {
      const user = await getUserFromSession(request);
      
      if (!user || 'skip_auth' in user) {
        set.status = 401;
        return { 
          success: false, 
          error: 'Unauthorized' 
        };
      }
      
      const stats = await getContactUsageStats(user.organization_id.toString());
      
      return {
        success: true,
        stats
      };
    } catch (error) {
      logger.error(`Error getting contact usage stats: ${error}`);
      set.status = 500;
      return { 
        success: false, 
        error: 'Failed to get contact usage stats' 
      };
    }
  })
  
  // Reset contact count (admin/support only)
  .post('/reset', 
    async ({ request, body, set }) => {
      try {
        const user = await getUserFromSession(request);
        
        // Check if user is admin
        if (!user || 'skip_auth' in user || !user.is_admin) {
          set.status = 403;
          return { 
            success: false, 
            error: 'You do not have permission to perform this action' 
          };
        }
        
        const { email, reason } = body as {
          email: string;
          reason: string;
        };
        
        if (!email || !reason) {
          set.status = 400;
          return { 
            success: false, 
            error: 'Email and reason are required' 
          };
        }
        
        // Reset the contact
        const success = await resetContactCount(
          user.organization_id.toString(),
          email,
          reason
        );
        
        if (!success) {
          set.status = 404;
          return { 
            success: false, 
            error: 'Contact not found' 
          };
        }
        
        // Get updated stats
        const stats = await getContactUsageStats(user.organization_id.toString());
        
        return {
          success: true,
          stats
        };
      } catch (error) {
        logger.error(`Error resetting contact: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Failed to reset contact' 
        };
      }
    },
    {
      body: t.Object({
        email: t.String(),
        reason: t.String()
      })
    }
  )
  
  // Check if an email exists
  .get('/check-email/:email', async ({ params, request, set }) => {
    try {
      const user = await getUserFromSession(request);
      
      if (!user || 'skip_auth' in user) {
        set.status = 401;
        return { 
          success: false, 
          error: 'Unauthorized' 
        };
      }
      
      const { email } = params;
      
      if (!email) {
        set.status = 400;
        return { 
          success: false, 
          error: 'Email is required' 
        };
      }
      
      try {
        // Get the organization database
        const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
        
        // Check if the email exists
        const contact = await orgDb.fetchOne(
          'SELECT id FROM contacts WHERE email = ?',
          [email]
        );
        
        logger.info(`Email check for "${email}" - exists: ${!!contact}`);
        
        return {
          exists: !!contact
        };
      } catch (dbError) {
        logger.error(`Database error checking email ${email}: ${dbError}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Database error checking email',
          message: dbError instanceof Error ? dbError.message : 'Unknown database error'
        };
      }
    } catch (error) {
      logger.error(`Error checking email: ${error}`);
      set.status = 500;
      return { 
        success: false, 
        error: 'Failed to check email',
        message: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  
  // Add new POST endpoint for single contact creation/update
  .post('', 
    async ({ body, user, set }: { body: any; user: User; set: { status: number } }) => {
      if (!user || !user.organization_id) {
        set.status = 401;
        return { success: false, message: 'Not authorized' };
      }

      // TODO: Define a proper schema for single contact body using t.Object
      const contactData = body as ContactImport; // Assuming ContactImport for now, adjust as needed

      if (!contactData || !contactData.email) {
        set.status = 400;
        return { success: false, message: 'Invalid contact data: email is required' };
      }

      try {
        const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
        const normalizedEmail = normalizeEmail(contactData.email);

        // Handle re-activation: Remove from deleted_contacts if exists
        await orgDb.execute(
          'DELETE FROM deleted_contacts WHERE LOWER(TRIM(email)) = ?',
          [normalizedEmail]
        );
        logger.info(`Cleared ${normalizedEmail} from deleted_contacts (if existed) for org ${user.organization_id} during contact creation/update.`);

        // Logic to INSERT or UPDATE the contact in the 'contacts' table
        // This assumes an UPSERT-like behavior based on email.
        // Column names in 'contacts' table might differ slightly from ContactImport, adjust as needed.
        const { 
          first_name, last_name, email, phone_number, state, 
          current_carrier, effective_date, birth_date, tobacco_user, 
          gender, zip_code, plan_type 
        } = contactData;

        // Ensure zip_code and inferred_state are handled correctly
        let inferredState = state; // Use provided state by default
        if (zip_code && ZIP_DATA[zip_code]) {
          inferredState = ZIP_DATA[zip_code].state;
        }
        if (!inferredState && state) { // Fallback if zip lookup failed but state was provided
            inferredState = state;
        } else if (!inferredState) {
            inferredState = ''; // Default to empty string if no state can be determined
            logger.warn(`No state could be determined for contact ${email}`);
        }


        const result = await orgDb.execute(`
          INSERT INTO contacts (
            first_name, last_name, email, phone_number, state, 
            current_carrier, effective_date, birth_date, tobacco_user, 
            gender, zip_code, plan_type, agent_id, created_at, updated_at, status
          )
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 'New')
          ON CONFLICT(LOWER(TRIM(email))) DO UPDATE SET
            first_name = excluded.first_name,
            last_name = excluded.last_name,
            phone_number = excluded.phone_number,
            state = excluded.state,
            current_carrier = excluded.current_carrier,
            effective_date = excluded.effective_date,
            birth_date = excluded.birth_date,
            tobacco_user = excluded.tobacco_user,
            gender = excluded.gender,
            zip_code = excluded.zip_code,
            plan_type = excluded.plan_type,
            agent_id = excluded.agent_id, -- This might need to be handled differently if agent_id comes from user or elsewhere
            updated_at = CURRENT_TIMESTAMP,
            status = CASE WHEN contacts.status = 'Deleted' THEN 'Reactivated' ELSE contacts.status END -- Example status update
          RETURNING id;
        `, [
          first_name, last_name, normalizedEmail, phone_number, inferredState,
          current_carrier, effective_date, birth_date, tobacco_user ? 1 : 0,
          gender, zip_code, plan_type, user.id // Assuming agent_id is the creating user's ID for new contacts
        ]);
        
        const contactId = result.rows?.[0]?.id;

        logger.info(`Successfully created/updated contact ${normalizedEmail} with ID ${contactId} for org ${user.organization_id}.`);
        return { success: true, message: 'Contact created/updated successfully', contactId };

      } catch (error) {
        logger.error(`Error creating/updating contact: ${error}`);
        set.status = 500;
        return { success: false, message: 'Failed to create/update contact' };
      }
    },
    {
      // Define a proper schema for the request body using Elysia's 't' object
      // This is a placeholder and should be refined based on actual Contact model fields for creation/update
      body: t.Object({
        first_name: t.String(),
        last_name: t.String(),
        email: t.String({ format: 'email' }), // Elysia can validate email format
        phone_number: t.Optional(t.String()),
        state: t.Optional(t.String()),
        current_carrier: t.Optional(t.String()),
        effective_date: t.Optional(t.String()), // Consider t.Date() or string format validation
        birth_date: t.Optional(t.String()),     // Consider t.Date() or string format validation
        tobacco_user: t.Optional(t.Boolean()),
        gender: t.Optional(t.String()),
        zip_code: t.Optional(t.String()),
        plan_type: t.Optional(t.String())
        // agent_id might be derived from the user session or explicitly passed
      })
    }
  )
  // Add DELETE endpoint for contacts
  .delete('/', 
    async ({ body, set, request }) => {
      try {
        const user = await getUserFromSession(request);
        if (!user || 'skip_auth' in user || !user.organization_id) {
          set.status = 401;
          return { error: 'Not authorized' };
        }

        const contactIdsToDelete = body as number[]; // Assuming body is an array of numbers (contact IDs)
        if (!Array.isArray(contactIdsToDelete) || contactIdsToDelete.length === 0) {
          set.status = 400;
          return { error: 'No contact IDs provided' };
        }
        
        logger.info(`DELETE /api/contacts - Attempting to move ${contactIdsToDelete.length} contacts to deleted_contacts for org ${user.organization_id}`);
        
        const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());

        const successfullyMovedIds: number[] = [];
        const failedToMoveIds: any[] = [];

        for (const contactId of contactIdsToDelete) {
          if (typeof contactId !== 'number') {
            logger.warn(`Invalid contactId type: ${contactId}, skipping.`);
            failedToMoveIds.push({ id: contactId, error: 'Invalid ID type' });
            continue;
          }

          try {
            await orgDb.transaction(async (tx) => {
              // 1. Select the contact from the 'contacts' table
              const contact = await tx.fetchOne<Contact>(
                'SELECT * FROM contacts WHERE id = ?',
                [contactId]
              );

              if (!contact) {
                logger.warn(`Contact with ID ${contactId} not found in contacts table for org ${user.organization_id}.`);
                failedToMoveIds.push({ id: contactId, error: 'Not found' });
                return; // Exit transaction for this contactId
              }

              const normalizedEmail = normalizeEmail(contact.email);

              // 2. Insert into 'deleted_contacts' table
              // Ensure all fields match the deleted_contacts schema
              await tx.execute(`
                INSERT INTO deleted_contacts (
                  original_contact_id, first_name, last_name, email, phone_number, 
                  current_carrier, plan_type, effective_date, birth_date, 
                  tobacco_user, gender, state, zip_code, agent_id, status, deleted_at
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
              `, [
                contact.id, contact.first_name, contact.last_name, normalizedEmail, contact.phone_number,
                contact.current_carrier, contact.plan_type, contact.effective_date, contact.birth_date,
                contact.tobacco_user, contact.gender, contact.state, contact.zip_code, 
                contact.agent_id, contact.status
              ]);

              // 3. Delete from related tables (e.g., email_send_tracking, eligibility_answers, contact_events etc.)
              // It's important to delete from child tables before deleting from the parent (contacts) if ON DELETE CASCADE is not set up for all relations
              // or if you want to log/handle these deletions specifically.
              // Assuming ON DELETE CASCADE is set for email_send_tracking, eligibility_answers on contacts.id
              // If not, add explicit deletes here:
              // await tx.execute('DELETE FROM email_send_tracking WHERE contact_id = ?', [contactId]);
              // await tx.execute('DELETE FROM eligibility_answers WHERE contact_id = ?', [contactId]);
              // await tx.execute('DELETE FROM contact_events WHERE contact_id = ?', [contactId]);
              // etc.

              // 4. Delete from 'contacts' table
              await tx.execute(
                'DELETE FROM contacts WHERE id = ?',
                [contactId]
              );
              
              successfullyMovedIds.push(contactId);
              logger.info(`Successfully moved contact ID ${contactId} to deleted_contacts for org ${user.organization_id}`);
            });
          } catch (e) {
            logger.error(`Error moving contact ID ${contactId} to deleted_contacts: ${e}`);
            failedToMoveIds.push({ id: contactId, error: e instanceof Error ? e.message : String(e) });
            // Transaction will be rolled back automatically by the Database class if an error is thrown from the callback
          }
        }

        const responseMessage = `Moved ${successfullyMovedIds.length} contacts. Failed to move ${failedToMoveIds.length} contacts.`;
        logger.info(`DELETE /api/contacts - Result for org ${user.organization_id}: ${responseMessage}`);

        if (failedToMoveIds.length > 0) {
          // Partial success, or complete failure if successfullyMovedIds is empty
          set.status = successfullyMovedIds.length > 0 ? 207 : 500; // 207 Multi-Status or 500 Internal Server Error
          return {
            success: successfullyMovedIds.length > 0,
            message: responseMessage,
            deleted_ids: successfullyMovedIds,
            failed_to_move_ids: failedToMoveIds
          };
        }

        return {
          success: true,
          message: responseMessage,
          deleted_ids: successfullyMovedIds
        };

      } catch (e) {
        logger.error(`Error processing delete contacts request: ${e}`);
        // Ensure set.status is managed by Elysia's error handling or set manually
        const currentStatus = typeof set.status === 'number' ? set.status : 0;
        if (currentStatus < 400) { // If not already an error status, set to 500
            set.status = 500;
        }
        return { error: e instanceof Error ? e.message : 'Failed to delete contacts' };
      }
    },
    {
      body: t.Array(t.Number())
    }
  );

================
File: src/routes/contactTracking.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { getUserFromSession } from '../services/auth';
import { 
  trackContact, 
  trackContactBatch, 
  getContactUsageStats, 
  getUniqueContactCount,
  resetContactCount
} from '../services/contactTracking';

export const createContactTrackingRoutes = () => {
  return new Elysia({ prefix: '/api/contact-tracking' })

    // Track a single contact
    .post('/track', 
      async ({ request, body, set }) => {
        try {
          const user = await getUserFromSession(request);
          
          // Check if request includes required fields
          if (!user || !body) {
            set.status = 400;
            return { 
              success: false, 
              error: 'Invalid request' 
            };
          }
          
          const { email, firstName, lastName } = body as {
            email: string;
            firstName?: string;
            lastName?: string;
          };
          
          if (!email) {
            set.status = 400;
            return { 
              success: false, 
              error: 'Email is required' 
            };
          }
          
          // Track the contact
          const result = await trackContact(
            user.organization_id.toString(),
            user.id.toString(),
            email,
            firstName,
            lastName
          );
          
          // Get updated usage stats
          const stats = await getContactUsageStats(user.organization_id.toString());
          
          return {
            success: true,
            isNew: result.isNew,
            contactId: result.contactId,
            stats
          };
        } catch (error) {
          logger.error(`Error tracking contact: ${error}`);
          set.status = 500;
          return { 
            success: false, 
            error: 'Failed to track contact' 
          };
        }
      },
      {
        body: t.Object({
          email: t.String(),
          firstName: t.Optional(t.String()),
          lastName: t.Optional(t.String())
        })
      }
    )
    
    // Track a batch of contacts
    .post('/batch', 
      async ({ request, body, set }) => {
        try {
          const user = await getUserFromSession(request);
          
          // Check if request includes required fields
          if (!user || !body || !body.contacts || !Array.isArray(body.contacts)) {
            set.status = 400;
            return { 
              success: false, 
              error: 'Invalid request' 
            };
          }
          
          const { contacts } = body as {
            contacts: Array<{
              email: string;
              firstName?: string;
              lastName?: string;
            }>
          };
          
          // Track the contacts in batch
          const result = await trackContactBatch(
            user.organization_id.toString(),
            user.id.toString(),
            contacts
          );
          
          // Get updated usage stats
          const stats = await getContactUsageStats(user.organization_id.toString());
          
          return {
            success: true,
            newCount: result.newCount,
            totalProcessed: result.totalProcessed,
            stats
          };
        } catch (error) {
          logger.error(`Error tracking contact batch: ${error}`);
          set.status = 500;
          return { 
            success: false, 
            error: 'Failed to track contacts' 
          };
        }
      },
      {
        body: t.Object({
          contacts: t.Array(
            t.Object({
              email: t.String(),
              firstName: t.Optional(t.String()),
              lastName: t.Optional(t.String())
            })
          )
        })
      }
    )
    
    // Get contact usage stats
    .get('/usage-stats', async ({ request, set }) => {
      try {
        const user = await getUserFromSession(request);
        
        if (!user) {
          set.status = 401;
          return { 
            success: false, 
            error: 'Unauthorized' 
          };
        }
        
        const stats = await getContactUsageStats(user.organization_id.toString());
        
        return {
          success: true,
          stats
        };
      } catch (error) {
        logger.error(`Error getting contact usage stats: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Failed to get contact usage stats' 
        };
      }
    })
    
    // Reset contact count (admin/support only)
    .post('/reset', 
      async ({ request, body, set }) => {
        try {
          const user = await getUserFromSession(request);
          
          // Check if user is admin
          if (!user || !user.is_admin) {
            set.status = 403;
            return { 
              success: false, 
              error: 'You do not have permission to perform this action' 
            };
          }
          
          const { email, reason } = body as {
            email: string;
            reason: string;
          };
          
          if (!email || !reason) {
            set.status = 400;
            return { 
              success: false, 
              error: 'Email and reason are required' 
            };
          }
          
          // Reset the contact
          const success = await resetContactCount(
            user.organization_id.toString(),
            email,
            reason
          );
          
          if (!success) {
            set.status = 404;
            return { 
              success: false, 
              error: 'Contact not found' 
            };
          }
          
          // Get updated stats
          const stats = await getContactUsageStats(user.organization_id.toString());
          
          return {
            success: true,
            stats
          };
        } catch (error) {
          logger.error(`Error resetting contact: ${error}`);
          set.status = 500;
          return { 
            success: false, 
            error: 'Failed to reset contact' 
          };
        }
      },
      {
        body: t.Object({
          email: t.String(),
          reason: t.String()
        })
      }
    );
};

================
File: src/routes/dashboard.ts
================
import { Elysia } from 'elysia'
import { Database } from '../database'
import { logger } from '../logger'
import { getUserFromSession } from '../services/auth'

// Helper function to get date range for SQL queries
function getDateRange(period?: string): { startDateStr: string, endDateStr: string } {
    const today = new Date();
    let startDate = new Date(today);
    let endDate = new Date(today);

    startDate.setHours(0, 0, 0, 0);
    endDate.setHours(23, 59, 59, 999); // End of today for endDate default

    // Default to '30days' if period is undefined or invalid
    const effectivePeriod = ['today', 'yesterday', '7days', '30days', '90days', 'ytd'].includes(period || '') ? period : '30days';

    switch (effectivePeriod) {
        case 'today':
            // startDate is already beginning of today
            // endDate is already end of today
            break;
        case 'yesterday':
            startDate.setDate(today.getDate() - 1);
            endDate.setDate(today.getDate() - 1);
            // endDate still needs to be end of that day
            endDate.setHours(23, 59, 59, 999);
            break;
        case '7days':
            startDate.setDate(today.getDate() - 6); // today is the 7th day
            break;
        case '90days':
            startDate.setDate(today.getDate() - 89); // today is the 90th day
            break;
        case 'ytd':
            startDate = new Date(today.getFullYear(), 0, 1); // First day of current year
            startDate.setHours(0, 0, 0, 0);
            break;
        case '30days':
        default:
            startDate.setDate(today.getDate() - 29); // today is the 30th day
            break;
    }
    const formatDate = (d: Date) => d.toISOString().slice(0, 10); // YYYY-MM-DD
    return {
        startDateStr: formatDate(startDate),
        endDateStr: formatDate(endDate), // endDate is always today's date
    };
}

/**
 * Creates and configures dashboard-related routes
 */
export function createDashboardRoutes() {
  return new Elysia({ prefix: '/api/dashboard' })
    // Dashboard statistics endpoint
    .get('/stats', async ({ request, set, query }) => {
      try {
        // Get current user from session
        const currentUser = await getUserFromSession(request)
        if (!currentUser || !currentUser.organization_id) {
          set.status = 401
          return {
            success: false,
            error: 'Authentication required'
          }
        }

        // Get organization-specific database
        const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())

        const period = query?.period as string | undefined;
        let startDateStr: string, endDateStr: string;

        if (period === 'custom' && query?.startDate && query?.endDate) {
            startDateStr = query.startDate as string;
            endDateStr = query.endDate as string;
            // Basic validation for custom dates can be added here if needed
            // For now, assume they are valid YYYY-MM-DD strings
            logger.info(`Using custom date range: ${startDateStr} to ${endDateStr}`);
        } else {
            const range = getDateRange(period);
            startDateStr = range.startDateStr;
            endDateStr = range.endDateStr;
        }
          

        logger.info(`Fetching dashboard stats for org ${currentUser.organization_id} for period: ${period || '30days'} (range: ${startDateStr} to ${endDateStr})`);

        // For accurate counts, we need to be precise about what we're counting
        // Log all tables to help diagnose
        logger.info(`Checking available tables in org DB for ${currentUser.organization_id}`)
        const tablesResult = await orgDb.fetchAll(
          "SELECT name FROM sqlite_master WHERE type='table'"
        )
        logger.info(`Available tables: ${JSON.stringify(tablesResult.map((r: any) => r.name || r[0]))}`)
        
        // Better debug query to understand tracking_clicks structure
        const sampleClicks = await orgDb.fetchAll(
          "SELECT * FROM tracking_clicks LIMIT 5"
        )
        logger.info(`Sample tracking_clicks: ${JSON.stringify(sampleClicks)}`)
        
        // 1. "Quotes Sent" - count emails that have been sent (status = 'scheduled') - EXCLUDE follow-ups
        const quotesSentSql = `
          SELECT COUNT(*) as count 
          FROM email_schedules 
          WHERE status IN ('scheduled', 'send', 'sent', 'delivered')
            AND scheduled_send_date BETWEEN ? AND ?
            AND (email_type IS NULL OR email_type NOT LIKE 'followup%')
        `
        const quotesSentResult = await orgDb.fetchOne<{ count: number }>(quotesSentSql, [startDateStr, endDateStr])
        const quotesSent = quotesSentResult?.count || 0
        logger.info(`Quotes Sent count: ${quotesSent}`)

        // 1b. "Manual Quotes Sent" - count manual quote emails from email_send_tracking
        const manualQuotesSql = `
          SELECT COUNT(*) as count
          FROM email_send_tracking
          WHERE email_type = 'quote_email' AND send_status IN ('sent', 'delivered', 'scheduled')
            AND DATE(created_at) BETWEEN ? AND ?
        `
        const manualQuotesResult = await orgDb.fetchOne<{ count: number }>(manualQuotesSql, [startDateStr, endDateStr])
        const manualQuotesSent = manualQuotesResult?.count || 0
        logger.info(`Manual Quotes Sent count: ${manualQuotesSent}`)

        // 2. "Quotes Viewed" - count unique contacts who clicked links during the period
        const quotesViewedSql = `
          SELECT COUNT(DISTINCT contact_id) as count
          FROM tracking_clicks
          WHERE contact_id IS NOT NULL
            AND DATE(clicked_at) BETWEEN ? AND ?
        `
        const quotesViewedResult = await orgDb.fetchOne<{ count: number }>(quotesViewedSql, [startDateStr, endDateStr])
        const quotesViewed = quotesViewedResult?.count || 0
        logger.info(`Quotes Viewed count: ${quotesViewed}`)

        // 3. Get "Follow Ups Requested" count from email_schedules (Performance context)
        // These are follow-ups scheduled to be sent in the period.
        const followUpsSql = `
          SELECT COUNT(*) as count
          FROM email_schedules
          WHERE status IN ('scheduled', 'send', 'delivered') -- Assuming 'scheduled' means sent for past dates
            AND email_type LIKE 'followup%' 
            AND scheduled_send_date BETWEEN ? AND ?
        `
        const followUpsResult = await orgDb.fetchOne<{ count: number }>(followUpsSql, [startDateStr, endDateStr])
        const followUpsRequested = followUpsResult?.count || 0
        logger.info(`Follow Ups Requested count: ${followUpsRequested}`)

        // 4. "Health Questions Completed" - unique contacts who completed health questions during the period
        const healthQuestionsCompletedSql = `
          SELECT COUNT(DISTINCT contact_id) as count
          FROM eligibility_answers
          WHERE contact_id IS NOT NULL
            AND DATE(created_at) BETWEEN ? AND ?
        `
        const healthQuestionsResult = await orgDb.fetchOne<{ count: number }>(healthQuestionsCompletedSql, [startDateStr, endDateStr])
        const healthQuestionsCompleted = healthQuestionsResult?.count || 0
        logger.info(`Health Questions Completed count: ${healthQuestionsCompleted}`)

        // Show data for all 12 months, with real data for current month and zeros for others
        const currentMonth = new Date().getMonth(); // 0-11

        // Create array of chart data for all months
        const chartData = [];
        const monthsToShow = 12;

        // Create entries for all 12 months, but only put real data in current month
        for (let i = 0; i < monthsToShow; i++) {
          // Only the current month has actual data, rest are zeros
          const isCurrentMonth = i === currentMonth;

          let sentValue = 0;
          let viewedValue = 0;
          let followUpValue = 0;
          let healthCompletedValue = 0;

          if (isCurrentMonth) {
            // Use real data for current month
            sentValue = quotesSent;
            viewedValue = quotesViewed;
            followUpValue = followUpsRequested;
            healthCompletedValue = healthQuestionsCompleted;
          }

          chartData.push({
            x: i, // 0-11 for months (Jan-Dec)
            sends: sentValue,
            views: viewedValue,
            followUps: followUpValue,
            healthCompleted: healthCompletedValue
          });
        }

        // No need to transform the chart data anymore

        logger.info(`Dashboard stats for org ${currentUser.organization_id} (period ${period}): Quotes Sent: ${quotesSent}, Manual Quotes Sent: ${manualQuotesSent}, Quotes Viewed: ${quotesViewed}, FollowUps: ${followUpsRequested}, HealthCompleted: ${healthQuestionsCompleted}`)

        // UPCOMING EMAILS LOGIC
        // Only include emails scheduled in the next 30 days and status = 'pre-scheduled'
        const now = new Date();
        const in30Days = new Date(now);
        in30Days.setDate(now.getDate() + 30);
        const upcomingStartDate = now.toISOString().slice(0, 10);
        const upcomingEndDate = in30Days.toISOString().slice(0, 10);

        // Total count - EXCLUDE follow-ups
        const upcomingTotalResult = await orgDb.fetchOne<{ total: number } | null>(
          `SELECT COUNT(*) as total FROM email_schedules
           WHERE status = 'pre-scheduled'
             AND scheduled_send_date >= ?
             AND scheduled_send_date <= ?
             AND (email_type IS NULL OR email_type NOT LIKE 'followup%')`,
          [upcomingStartDate, upcomingEndDate]
        );
        const upcomingEmailsTotal = upcomingTotalResult?.total ?? 0;

        // First page (up to 20) - EXCLUDE follow-ups
        const upcomingEmailsPage = await orgDb.fetchAll(
          `SELECT es.id, es.contact_id, es.email_type, es.scheduled_send_date, es.status,
                  c.first_name, c.last_name
           FROM email_schedules es
           LEFT JOIN contacts c ON es.contact_id = c.id
           WHERE es.status = 'pre-scheduled'
             AND es.scheduled_send_date >= ?
             AND es.scheduled_send_date <= ?
             AND (es.email_type IS NULL OR es.email_type NOT LIKE 'followup%')
           ORDER BY es.scheduled_send_date ASC
           LIMIT 30 OFFSET 0`,
          [upcomingStartDate, upcomingEndDate]
        );

        return {
          success: true,
          stats: {
            quotesSent,
            manualQuotesSent,
            quotesViewed,
            followUpsRequested,
            healthQuestionsCompleted,
            chartData,
            upcomingEmailsTotal,
            upcomingEmailsPage
          }
        }
      } catch (error) {
        logger.error(`Error fetching dashboard stats: ${error instanceof Error ? error.message : String(error)}`)
        set.status = 500
        return {
          success: false,
          error: 'Failed to load dashboard stats'
        }
      }
    })
    // Send ranking endpoint
    .get('/send-ranking', async ({ request, set, query }) => {
      try {
        logger.info('=== SEND RANKING ENDPOINT HIT ===')
        
        const currentUser = await getUserFromSession(request)
        if (!currentUser || !currentUser.organization_id) {
          logger.error('Send ranking: No authenticated user or organization_id')
          set.status = 401
          return {
            success: false,
            error: 'Authentication required'
          }
        }

        logger.info(`Send ranking: User ${currentUser.id} from org ${currentUser.organization_id}`)

        const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())
        logger.info(`Send ranking: Got org database for ${currentUser.organization_id}`)

        // Always show last 30 days for send ranking, regardless of dropdown
        const today = new Date();
        const thirtyDaysAgo = new Date(today);
        thirtyDaysAgo.setDate(today.getDate() - 29); // Last 30 days including today
        
        const startDateStr = thirtyDaysAgo.toISOString().slice(0, 10);
        const endDateStr = today.toISOString().slice(0, 10);

        logger.info(`Send ranking: Fetching for org ${currentUser.organization_id} for last 30 days (range: ${startDateStr} to ${endDateStr})`);

        // Get daily breakdown of email performance - track emails sent on each date and their outcomes - EXCLUDE follow-ups
        const sendRankingSql = `
          WITH emails_sent_by_date AS (
            SELECT 
              DATE(scheduled_send_date) as scheduled_send_date,
              COUNT(*) as quotes_sent,
              contact_id
            FROM email_schedules
            WHERE status IN ('scheduled', 'send', 'sent', 'delivered')
              AND scheduled_send_date BETWEEN ? AND ?
              AND (email_type IS NULL OR email_type NOT LIKE 'followup%')
            GROUP BY DATE(scheduled_send_date), contact_id
          ),
          quotes_sent_summary AS (
            SELECT 
              scheduled_send_date,
              COUNT(*) as quotes_sent
            FROM emails_sent_by_date
            GROUP BY scheduled_send_date
          ),
          quotes_viewed_by_send_date AS (
            SELECT 
              es.scheduled_send_date,
              COUNT(DISTINCT tc.contact_id) as quotes_viewed
            FROM emails_sent_by_date es
            JOIN tracking_clicks tc ON es.contact_id = tc.contact_id
            GROUP BY es.scheduled_send_date
          ),
          health_completed_by_send_date AS (
            SELECT 
              es.scheduled_send_date,
              COUNT(DISTINCT ea.contact_id) as health_completed
            FROM emails_sent_by_date es
            JOIN eligibility_answers ea ON es.contact_id = ea.contact_id
            GROUP BY es.scheduled_send_date
          )
          SELECT 
            qs.scheduled_send_date,
            qs.quotes_sent,
            COALESCE(qv.quotes_viewed, 0) as quotes_viewed,
            COALESCE(hc.health_completed, 0) as health_completed
          FROM quotes_sent_summary qs
          LEFT JOIN quotes_viewed_by_send_date qv ON qs.scheduled_send_date = qv.scheduled_send_date
          LEFT JOIN health_completed_by_send_date hc ON qs.scheduled_send_date = hc.scheduled_send_date
          ORDER BY qs.scheduled_send_date DESC
        `;

        logger.info(`Send ranking: Executing SQL with params: [${startDateStr}, ${endDateStr}]`)
        logger.info(`Send ranking: SQL query: ${sendRankingSql}`)

        const sendRankingResult = await orgDb.fetchAll(sendRankingSql, [
          startDateStr, endDateStr
        ]);

        logger.info(`Send ranking: Raw SQL result count: ${sendRankingResult.length}`)
        logger.info(`Send ranking: Raw SQL first 3 results: ${JSON.stringify(sendRankingResult.slice(0, 3))}`)

        // Transform results into the expected format with ranking
        const sendRankingData = sendRankingResult.map((row: any, index: number) => ({
          rank: index + 1,
          sendDate: row.scheduled_send_date || row[0],
          quotesSent: parseInt(row.quotes_sent || row[1] || 0),
          quotesViewed: parseInt(row.quotes_viewed || row[2] || 0),
          healthCompleted: parseInt(row.health_completed || row[3] || 0)
        }));

        logger.info(`Send ranking: Transformed data count: ${sendRankingData.length}`)
        logger.info(`Send ranking: Transformed data first 3: ${JSON.stringify(sendRankingData.slice(0, 3))}`)

        logger.info(`Send ranking: Returning response with ${sendRankingData.length} entries`)

        return {
          success: true,
          data: sendRankingData
        }
      } catch (error) {
        logger.error(`=== SEND RANKING ERROR ===`)
        logger.error(`Send ranking error: ${error instanceof Error ? error.message : String(error)}`)
        logger.error(`Send ranking error stack: ${error instanceof Error ? error.stack : 'No stack trace'}`)
        set.status = 500
        return {
          success: false,
          error: 'Failed to load send ranking data'
        }
      }
    })
}

/**
 * Creates and configures dashboard activity-related routes
 */
export function createDashboardActivityRoutes() {
  return new Elysia({ prefix: '/api/dashboard' })
    .get('/activity', async ({ request, set, query }) => {
      try {
        const currentUser = await getUserFromSession(request)
        if (!currentUser || !currentUser.organization_id) {
          set.status = 401
          return {
            success: false,
            error: 'Authentication required'
          }
        }

        const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())

        const period = query?.period as string | undefined;
        let startDateStr: string, endDateStr: string;

        if (period === 'custom' && query?.startDate && query?.endDate) {
            startDateStr = query.startDate as string;
            endDateStr = query.endDate as string;
            // Basic validation for custom dates can be added here if needed
             logger.info(`Using custom date range for activity: ${startDateStr} to ${endDateStr}`);
        } else {
            const range = getDateRange(period);
            startDateStr = range.startDateStr;
            endDateStr = range.endDateStr;
        }

        logger.info(`Fetching dashboard activity stats for org ${currentUser.organization_id} for period: ${period || '30days'} (range: ${startDateStr} to ${endDateStr})`);

        // 0. "Total Emails Sent" - unique contacts who were sent an email in the period
        const emailsSentSql = `
          SELECT COUNT(DISTINCT contact_id) as count
          FROM email_schedules
          WHERE contact_id IS NOT NULL
            AND status IN ('scheduled', 'send', 'delivered')
            AND scheduled_send_date BETWEEN ? AND ?
        `;
        const emailsSentResult = await orgDb.fetchOne<{ count: number }>(emailsSentSql, [startDateStr, endDateStr])
        const emailsSent = emailsSentResult?.count || 0
        logger.info(`Emails Sent (Activity, unique contacts) count: ${emailsSent}`)

        // 1. "Links Clicked" - count unique contacts who clicked in the period (no double counting)
        const linksClickedSql = `
          SELECT COUNT(DISTINCT contact_id) as count
          FROM tracking_clicks
          WHERE contact_id IS NOT NULL
            AND DATE(clicked_at) BETWEEN ? AND ?
        `;
        const linksClickedResult = await orgDb.fetchOne<{ count: number }>(linksClickedSql, [startDateStr, endDateStr])
        const linksClicked = linksClickedResult?.count || 0
        logger.info(`Links Clicked (Activity, unique contacts) count: ${linksClicked}`)

        // 2. "Health Questions Completed" - unique contacts who completed eligibility_answers in the period
        const healthQuestionsCompletedActivitySql = `
          SELECT COUNT(DISTINCT contact_id) as count
          FROM eligibility_answers
          WHERE contact_id IS NOT NULL
            AND DATE(created_at) BETWEEN ? AND ?
        `;
        const healthQuestionsCompletedActivityResult = await orgDb.fetchOne<{ count: number }>(healthQuestionsCompletedActivitySql, [startDateStr, endDateStr])
        const healthQuestionsCompletedActivity = healthQuestionsCompletedActivityResult?.count || 0
        logger.info(`Health Questions Completed (Activity, unique contacts) count: ${healthQuestionsCompletedActivity}`)
        
        // For the activity tab, chartData might be simpler or not used extensively initially.
        // We can return raw values that could be used for simple bar charts if needed.
        const activityChartData = [
          {
            x: 0, // Representing Emails Sent
            value: emailsSent
          },
          {
            x: 1, // Representing Links Clicked
            value: linksClicked 
          },
          {
            x: 2, // Representing Health Questions Completed
            value: healthQuestionsCompletedActivity
          }
        ];
        set.status = 200
        return {
          success: true,
          stats: {
            emailsSent,
            linksClicked,
            healthQuestionsCompleted: healthQuestionsCompletedActivity,
            activityChartData // Sending a simple chart data structure
          }
        }
      } catch (error) {
        logger.error(`Error fetching dashboard activity stats: ${error instanceof Error ? error.message : String(error)}`)
        set.status = 500
        return {
          success: false,
          error: 'Failed to load dashboard activity stats'
        }
      }
    })
}

// Make sure to integrate this new route group in your main server setup, similar to createDashboardRoutes.
// For example, in src/index.ts or where Elysia app is instantiated:
// app.use(createDashboardRoutes())
//    .use(createDashboardActivityRoutes()) // Add this line

================
File: src/routes/eligibility.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';

interface EligibilityAnswers {
    quote_id?: string;
    contact_id?: string;
    answers: Record<string, {
        question_text: string;
        question_type: string;
        answer: boolean | string | null;
    }>;
}

export const eligibilityRoutes = (app: Elysia) => {
    app
        // Get organization details
        .get('/api/org/:orgId/details', async ({ params }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                // Get organization details from main database
                const mainDb = new Database();
                const orgDetails = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                    'SELECT name, logo_data FROM organizations WHERE id = ?',
                    [orgId]
                );

                if (!orgDetails) {
                    return {
                        success: false,
                        error: 'Organization not found'
                    };
                }

                return {
                    name: orgDetails.name,
                    logo_data: orgDetails.logo_data
                };
            } catch (error) {
                logger.error(`Error getting organization details: ${error}`);
                throw new Error('Failed to get organization details');
            }
        })

        // Get existing eligibility answers for a contact
        .get('/api/org/:orgId/eligibility-answers/:contactId', async ({ params }) => {
            try {
                const { orgId, contactId } = params;
                if (!orgId || !contactId) {
                    return {
                        success: false,
                        error: 'Missing required parameters'
                    };
                }

                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);

                // Get the most recent answers for this contact
                const result = await orgDb.fetchOne<{ answers: string }>(
                    'SELECT answers FROM eligibility_answers WHERE contact_id = ? ORDER BY created_at DESC LIMIT 1',
                    [contactId]
                );

                if (!result) {
                    return {
                        success: false,
                        error: 'No answers found'
                    };
                }

                // Get organization details from main database
                const mainDb = new Database();
                const orgDetails = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                    'SELECT name, logo_data FROM organizations WHERE id = ?',
                    [orgId]
                );

                return {
                    answers: JSON.parse(result.answers),
                    orgName: orgDetails?.name || 'Medicare Max',
                    orgLogo: orgDetails?.logo_data || null
                };
            } catch (error) {
                logger.error(`Error getting eligibility answers: ${error}`);
                throw new Error('Failed to get eligibility answers');
            }
        })

        // Create a temporary contact for collecting eligibility answers
        .post('/api/org/:orgId/temp-contact', async ({ params }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);
                
                // Create a minimal contact record for just eligibility assessment
                const result = await orgDb.execute(
                    `INSERT INTO contacts 
                    (first_name, last_name, email, current_carrier, plan_type, effective_date, birth_date, tobacco_user, gender, state, zip_code, phone_number, status) 
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    [
                        'Temporary', 
                        'Contact', 
                        `temp-${Date.now()}@example.com`, 
                        '', 
                        'G', 
                        '', 
                        '1950-01-01', 
                        0, 
                        'M', 
                        '', 
                        '00000', 
                        '', 
                        'temp'
                    ]
                );

                // Get the inserted ID from the result
                const contactId = result.lastInsertRowid?.toString();
                
                if (!contactId) {
                    throw new Error('Failed to create temporary contact');
                }

                // Add a record to contact_events to track this
                await orgDb.execute(
                    `INSERT INTO contact_events 
                    (contact_id, event_type, metadata) 
                    VALUES (?, ?, ?)`,
                    [
                        contactId,
                        'temp_contact_created',
                        JSON.stringify({ source: 'eligibility_assessment' })
                    ]
                );

                return contactId;
            } catch (error) {
                logger.error(`Error creating temporary contact: ${error}`);
                throw new Error('Failed to create temporary contact');
            }
        })

        // Save eligibility answers
        .post('/api/org/:orgId/eligibility-answers', async ({ params, body }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                const data = body as EligibilityAnswers;
                
                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);
                
                let contactId: string | null = null;
                
                // If quote_id is provided, get the contact_id from it
                if (data.quote_id) {
                    try {
                        const decodedQuoteId = decodeQuoteId(data.quote_id);
                        if (decodedQuoteId) {
                            contactId = decodedQuoteId.contactId.toString();
                            
                            // Verify the org ID matches
                            if (decodedQuoteId.orgId.toString() !== orgId) {
                                return {
                                    success: false,
                                    error: 'Invalid quote ID - organization mismatch'
                                };
                            }
                        }
                    } catch (error) {
                        logger.error(`Error decoding quote ID: ${error}`);
                        return {
                            success: false,
                            error: 'Invalid quote ID'
                        };
                    }
                } else if (data.contact_id) {
                    // If contact_id is provided directly, use it
                    contactId = data.contact_id;
                }
                
                if (!contactId) {
                    return {
                        success: false,
                        error: 'Missing contact ID'
                    };
                }
                
                // Ensure contactId is a number for database operations
                const contactIdNum = parseInt(contactId, 10);
                if (isNaN(contactIdNum)) {
                    return {
                        success: false,
                        error: 'Invalid contact ID format'
                    };
                }

                // Verify contact exists in this org using the number
                const contact = await orgDb.fetchOne(
                    'SELECT id FROM contacts WHERE id = ?',
                    [contactIdNum]
                );
                
                if (!contact) {
                    return {
                        success: false,
                        error: 'Contact not found'
                    };
                }

                // Get organization details from main database
                const mainDb = new Database();
                const orgDetails = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                    'SELECT name, logo_data FROM organizations WHERE id = ?',
                    [orgId]
                );
                
                // Store the eligibility answers
                const verifiedQuoteId = data.quote_id || "";
                const answersJson = JSON.stringify(data.answers);
                
                // Determine the quote ID to save, defaulting to empty string if null
                const finalQuoteId = verifiedQuoteId ?? "";
                
                logger.info(`Saving eligibility answers for contact_id: ${contactIdNum}, quote_id: ${finalQuoteId}`);
                
                // Check if we already have answers for this contact using the number
                const existingAnswers = await orgDb.fetchOne(
                    'SELECT id FROM eligibility_answers WHERE contact_id = ?',
                    [contactIdNum]
                );
                
                if (existingAnswers) {
                    // Update existing answers using the number
                    logger.info(`Updating existing answers for contact_id: ${contactIdNum}`);
                    await orgDb.execute(
                        'UPDATE eligibility_answers SET answers = ?, quote_id = ?, created_at = CURRENT_TIMESTAMP WHERE contact_id = ?',
                        [answersJson, finalQuoteId, contactIdNum]
                    );
                } else {
                    // Insert new answers using the number
                    logger.info(`Inserting new answers for contact_id: ${contactIdNum}`);
                    await orgDb.execute(
                        'INSERT INTO eligibility_answers (contact_id, quote_id, answers) VALUES (?, ?, ?)', 
                        [contactIdNum, finalQuoteId, answersJson]
                    );
                }
                
                // Extract analytics data from enhanced answers
                const analyticsData = {
                    answers_count: Object.keys(data.answers).length,
                    source: data.quote_id ? 'quote' : 'direct',
                    main_questions_yes_count: Object.values(data.answers).filter(a => 
                        a.question_type === 'main' && a.answer === true
                    ).length,
                    has_medical_conditions: Object.values(data.answers).some(a => 
                        a.question_type === 'main' && a.answer === true
                    )
                };
                
                // Add a record to contact_events using the number
                await orgDb.execute(
                    `INSERT INTO contact_events 
                    (contact_id, event_type, metadata) 
                    VALUES (?, ?, ?)`, 
                    [
                        contactIdNum,
                        'eligibility_answered',
                        JSON.stringify(analyticsData)
                    ]
                );
                
                return {
                    contactId: contactIdNum.toString(), // Return as string if needed by frontend
                    orgName: orgDetails?.name || 'Medicare Max',
                    orgLogo: orgDetails?.logo_data || null
                };
            } catch (error) {
                logger.error(`Error saving eligibility answers: ${error}`);
                throw new Error('Failed to save eligibility answers');
            }
        });

    return app;
};

================
File: src/routes/onboarding.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'
import { Database } from '../database'
import { config } from '../config'
import { cookie } from '@elysiajs/cookie'
import Stripe from 'stripe'

// Initialize Stripe with secret key from environment variables
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || 'sk_test_51Qyh7RCBUPXAZKNGFySALjap1pDAtEwPtuY5TAzEuKKDq7cfAmHhmQIn8W1UMf2CuOvQ1umjiUrlpPauOc159fpM00nfohCZH3')
const YOUR_DOMAIN = config.clientUrl || 'http://localhost:3000'

// Helper function for generating unique slugs from names
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

// Helper function to ensure emails are properly decoded before storing in the database
function ensureEmailDecoded(email: string): string {
  try {
    // Check if email appears to be encoded
    if (email.includes('%')) {
      let decoded = email;
      let previous = '';
      
      // Apply decoding until the string no longer changes
      // This handles scenarios where the email might be double-encoded
      while (decoded !== previous) {
        previous = decoded;
        decoded = decodeURIComponent(decoded);
      }
      
      // Log if we actually changed something
      if (decoded !== email) {
        logger.info(`Decoded email from ${email} to ${decoded}`);
        return decoded;
      }
    }
    return email;
  } catch (error) {
    logger.warn(`Error decoding email ${email}: ${error}`);
    return email; // Return original if decoding fails
  }
}

export function createOnboardingRoutes() {
  const dbInstance = new Database()
  
  // Log that we're creating the routes, for debugging
  logger.info('Initializing onboarding routes including resume endpoint');

  // Define the resume endpoint separately to ensure it's properly registered
  const resumeHandler = async ({ query, set, request }: { query: any, set: any, request: any }) => {
    // Log request headers for debugging authentication issues
    logger.info(`Request headers: ${JSON.stringify(request.headers)}`);
    logger.info(`Resume endpoint called with query: ${JSON.stringify(query)}`);
    
    try {
      const { email } = query as { email: string };
      
      if (!email) {
        set.status = 400;
        return {
          success: false,
          message: 'Email is required'
        };
      }
      
      // Properly decode the email parameter
      const decodedEmail = ensureEmailDecoded(email);
      logger.info(`Processing resume request for email: ${decodedEmail}`);
      
      // Find the user and their organization
      logger.info(`Searching for user with email: ${decodedEmail}`);
      let userInfo = await dbInstance.fetchOne<{ 
        id: number, 
        organization_id: number, 
        first_name: string,
        last_name: string,
        email: string,
        phone: string
      }>(
        'SELECT id, organization_id, first_name, last_name, email, phone FROM users WHERE email = ?',
        [decodedEmail]
      );
      
      if (!userInfo) {
        logger.warn(`User not found with email: ${decodedEmail}`);
        // Try a case-insensitive search as a fallback
        const userByLowercase = await dbInstance.fetchOne<{ 
          id: number, 
          organization_id: number, 
          first_name: string,
          last_name: string,
          email: string,
          phone: string
        }>(
          'SELECT id, organization_id, first_name, last_name, email, phone FROM users WHERE LOWER(email) = LOWER(?)',
          [decodedEmail]
        );
        
        if (userByLowercase) {
          logger.info(`Found user with case-insensitive email match: ${userByLowercase.email}`);
          // Continue with the found user
          userInfo = userByLowercase;
        } else {
          logger.error(`User not found with email (case insensitive): ${decodedEmail}`);
          set.status = 401;
          return {
            success: false,
            message: 'User not found'
          };
        }
      }
      
      const organizationId = userInfo.organization_id;
      logger.info(`Found user with organization ID: ${organizationId}`);
      
      // Get organization details
      let orgInfo;
      try {
        orgInfo = await dbInstance.fetchOne<{
          id: number,
          name: string,
          onboarding_completed: number,
          website: string,
          phone: string,
          primary_color: string,
          secondary_color: string,
          logo_data: string | null,
          org_settings: string | null,
          payment_completed: number,
          stripe_customer_id: string | null,
          stripe_subscription_id: string | null
        }>(
          `SELECT id, name, onboarding_completed, website, phone, 
           primary_color, secondary_color, logo_data, org_settings,
           payment_completed, stripe_customer_id, stripe_subscription_id
           FROM organizations WHERE id = ?`,
          [organizationId]
        );
        
        logger.info(`Organization query result: ${orgInfo ? 'Found' : 'Not found'}`);
        
        if (!orgInfo) {
          logger.warn(`Organization with ID ${organizationId} not found`);
          set.status = 404;
          return {
            success: false,
            message: 'Organization not found'
          };
        }
      } catch (error) {
        logger.error(`Error retrieving organization with ID ${organizationId}: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Error retrieving organization'
        };
      }
      
      // Check if onboarding is already completed
      if (orgInfo.onboarding_completed === 1) {
        set.status = 200;
        return {
          success: true,
          onboardingComplete: true,
          redirectToLogin: true
        };
      }
      
      // Get all agents/users for this organization
      const agents = await dbInstance.query<{
        id: number,
        first_name: string,
        last_name: string,
        email: string,
        phone: string,
        is_admin: number
      }>(
        `SELECT id, first_name, last_name, email, phone, is_admin 
         FROM users WHERE organization_id = ?`,
        [organizationId]
      );
      
      // Parse org settings if exists
      let orgSettings = {};
      if (orgInfo.org_settings) {
        try {
          orgSettings = JSON.parse(orgInfo.org_settings);
        } catch (e) {
          logger.warn(`Could not parse org_settings for org ${organizationId}: ${e}`);
        }
      }
      
      // Check if payment fields exist in orgInfo to prevent errors
      logger.info(`Payment data: completed=${orgInfo.payment_completed !== undefined}, customerID=${orgInfo.stripe_customer_id !== undefined}, subscriptionID=${orgInfo.stripe_subscription_id !== undefined}`);
      
      // Construct response data
      set.status = 200;
      return {
        success: true,
        onboardingComplete: false,
        organization: {
          id: orgInfo.id,
          name: orgInfo.name,
          website: orgInfo.website || '',
          phone: orgInfo.phone || '',
          primaryColor: orgInfo.primary_color || '#6B46C1',
          secondaryColor: orgInfo.secondary_color || '#9F7AEA',
          logo: orgInfo.logo_data || null
        },
        user: {
          id: userInfo.id,
          firstName: userInfo.first_name,
          lastName: userInfo.last_name,
          email: userInfo.email,
          phone: userInfo.phone || ''
        },
        agents: agents.map(agent => ({
          firstName: agent.first_name,
          lastName: agent.last_name,
          email: agent.email,
          phone: agent.phone || '',
          isAdmin: agent.is_admin === 1
        })),
        carrierSettings: {
          selectedCarriers: (orgSettings as any)?.carrierContracts || [],
          useSmartSend: (orgSettings as any)?.smartSendEnabled || true
        },
        paymentStatus: {
          paymentCompleted: orgInfo.payment_completed === 1,
          stripeCustomerId: orgInfo.stripe_customer_id || null,
          stripeSubscriptionId: orgInfo.stripe_subscription_id || null
        }
      };
      
    } catch (error) {
      logger.error(`Error resuming onboarding: ${error}`);
      set.status = 500;
      return {
        success: false,
        message: 'Failed to resume onboarding'
      };
    }
  };

  const app = new Elysia()
    // Register the resume endpoint with the correct path - bypass auth
    .get('/api/onboarding/resume', (context) => {
      // Explicitly set the status to 200
      context.set.status = 200;
      return resumeHandler(context);
    })
    
    // Create a Stripe checkout session
    .post('/api/create-checkout-session', async ({ body, set }) => {
      try {
        const { priceId, meteredPriceId, customerEmail, customerName } = body as { 
          priceId: string, 
          meteredPriceId?: string,
          customerEmail?: string,
          customerName?: string
        }
        
        if (!priceId) {
          set.status = 400
          return {
            success: false,
            message: 'Price ID is required'
          }
        }
        
        // Decode the email address if it exists and contains encoded characters
        let decodedEmail: string | undefined;
        if (customerEmail) {
          try {
            // Check if the email contains encoded characters
            if (customerEmail.includes('%')) {
              decodedEmail = decodeURIComponent(customerEmail);
            } else {
              decodedEmail = customerEmail;
            }
            logger.info(`Decoded email from ${customerEmail} to ${decodedEmail}`);
          } catch (error) {
            logger.warn(`Failed to decode email: ${customerEmail}. Using as-is.`);
            decodedEmail = customerEmail;
          }
        }
        
        logger.info(`Creating checkout session for base price: ${priceId}, metered price: ${meteredPriceId || 'none'}, customer: ${decodedEmail || 'anonymous'}`);
        
        // Build line items array for the checkout session
        const lineItems: any[] = [
          {
            price: priceId,
            //quantity: 1, // Required for regular subscription
          }
        ];
        
        // Add metered price if provided, WITHOUT a quantity (Stripe doesn't want quantity for metered prices)
        if (meteredPriceId) {
          lineItems.push({
            price: meteredPriceId,
            // No quantity for metered prices
          });
        }
        
        logger.info(`Creating checkout session with line items: ${JSON.stringify(lineItems)}`);
        
        // Create the session
        const session = await stripe.checkout.sessions.create({
          ui_mode: 'embedded',
          line_items: lineItems,
          mode: 'subscription',
          redirect_on_completion: 'never',
          automatic_tax: { enabled: true },
          ...(decodedEmail ? { customer_email: decodedEmail } : {})
        })
        
        set.status = 200;
        return {
          success: true,
          clientSecret: session.client_secret
        }
      } catch (error) {
        logger.error(`Error creating checkout session: ${error}`)
        set.status = 500
        return {
          success: false,
          message: 'Failed to create checkout session'
        }
      }
    })
    
    // Get session status
    .get('/api/session-status', async ({ query, set }) => {
      try {
        const { session_id } = query as { session_id: string }
        
        if (!session_id) {
          logger.error('No session ID provided in status request');
          set.status = 400
          return {
            success: false,
            message: 'Session ID is required'
          }
        }
        
        logger.info(`Checking status for session ID: ${session_id}`);
        const session = await stripe.checkout.sessions.retrieve(session_id)
        
        logger.info(`Retrieved session with status: ${session.status}, payment status: ${session.payment_status || 'unknown'}`);
        
        // If payment is complete, store the customer and subscription info in the database
        if (session.status === 'complete' && session.customer_details?.email) {
          const customerEmail = session.customer_details.email;
          // Ensure the email is decoded
          const decodedEmail = ensureEmailDecoded(customerEmail);
          const stripeCustomerId = session.customer as string;
          const stripeSubscriptionId = session.subscription as string;
          
          logger.info(`Payment completed for ${decodedEmail}, updating database records`);
          logger.info(`Customer ID: ${stripeCustomerId}, Subscription ID: ${stripeSubscriptionId}`);
          
          // Find the user by email
          const userInfo = await dbInstance.fetchOne<{ organization_id: number }>(
            'SELECT organization_id FROM users WHERE email = ?',
            [decodedEmail]
          );
          
          if (userInfo) {
            // Update the organization with payment info
            await dbInstance.execute(
              `UPDATE organizations SET 
                payment_completed = 1,
                stripe_customer_id = ?,
                stripe_subscription_id = ?
               WHERE id = ?`,
              [stripeCustomerId, stripeSubscriptionId, userInfo.organization_id]
            );
            
            logger.info(`Updated payment status for organization ID: ${userInfo.organization_id}`);
          } else {
            logger.warn(`Could not find user with email ${decodedEmail} to update payment status`);
          }
        } else if (session.status === 'open') {
          logger.info(`Session ${session_id} is still open, payment not completed yet`);
        } else {
          logger.info(`Session ${session_id} has status ${session.status}, no database update needed`);
        }
        
        return {
          success: true,
          status: session.status,
          payment_status: session.payment_status || null,
          customer_email: session.customer_details?.email || null,
          amount_total: session.amount_total,
          customer: session.customer,
          subscription: session.subscription
        }
      } catch (error) {
        logger.error(`Error checking session status: ${error}`)
        set.status = 500
        return {
          success: false,
          message: 'Failed to check session status'
        }
      }
    })
    
    // Get checkout session from client secret
    .get('/api/checkout-session', async ({ query, set }) => {
      try {
        const { clientSecret } = query as { clientSecret: string }
        
        if (!clientSecret) {
          logger.error('No client secret provided in checkout session request');
          set.status = 400
          return {
            success: false,
            message: 'Client secret is required'
          }
        }
        
        // Extract the session ID from the client secret (format: cs_<id>_secret_<secret>)
        const sessionId = clientSecret.split('_secret_')[0];
        if (!sessionId) {
          logger.error(`Could not extract session ID from client secret: ${clientSecret.substring(0, 10)}...`);
          set.status = 400;
          return {
            success: false,
            message: 'Invalid client secret format'
          };
        }
        
        logger.info(`Retrieving checkout session with ID: ${sessionId}`);
        
        // Retrieve the session from Stripe
        logger.info(`Calling Stripe API to retrieve session ${sessionId} with expanded subscription data`);
        const session = await stripe.checkout.sessions.retrieve(sessionId, {
          expand: ['subscription', 'subscription.items']
        });
        
        if (!session) {
          logger.error(`Could not find session with ID: ${sessionId}`);
          set.status = 404;
          return {
            success: false,
            message: 'Session not found'
          };
        }
        
        logger.info(`Session retrieved successfully. Status: ${session.status}, Customer: ${session.customer ? (session.customer as string).substring(0, 10) + '...' : 'none'}`);
        logger.info(`Session subscription data: ${session.subscription ? 'present' : 'missing'}`);
        
        // Get subscription item ID if it exists
        let subscriptionItemId = null;
        if (session.subscription && typeof session.subscription !== 'string') {
          const subscription = session.subscription;
          const items = subscription.items?.data || [];
          
          logger.info(`Found ${items.length} subscription items`);
          
          // Log item details for debugging
          items.forEach((item, index) => {
            logger.info(`Subscription item ${index + 1}:`);
            logger.info(`  ID: ${item.id}`);
            logger.info(`  Price: ${item.price ? item.price.id : 'unknown'}`);
            if (item.price && typeof item.price === 'object') {
              logger.info(`  Price Type: ${(item.price as any).type || 'unknown'}`);
              logger.info(`  Price Nickname: ${(item.price as any).nickname || 'unknown'}`);
            }
          });
          
          // Use a type-safe approach to identify the metered price item
          const meteredItem = items.find(item => {
            if (item.price && typeof item.price === 'object' && 'type' in item.price) {
              const priceType = (item.price as any).type;
              logger.info(`Checking item with price type: ${priceType}`);
              return priceType === 'metered';
            }
            return false;
          });
          
          if (meteredItem) {
            subscriptionItemId = meteredItem.id;
            logger.info(`Found metered subscription item: ${subscriptionItemId}`);
          } else {
            logger.info('No metered subscription item found');
            // Fallback: just use the last item if there are multiple items (often the metered item is second)
            if (items.length > 1) {
              subscriptionItemId = items[items.length - 1].id;
              logger.info(`Using last subscription item as fallback: ${subscriptionItemId}`);
            }
          }
        } else {
          logger.info(`Subscription data is not expanded or missing: ${typeof session.subscription}`);
        }
        
        const result = {
          success: true,
          customer: session.customer as string,
          subscription: session.subscription as string || null,
          subscription_item: subscriptionItemId
        };
        
        logger.info(`Returning checkout session data: ${JSON.stringify(result)}`);
        return result;
      } catch (error) {
        logger.error(`Error retrieving checkout session: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: `Failed to retrieve checkout session: ${error instanceof Error ? error.message : 'Unknown error'}`
        }
      }
    })
    
    // Save company details during onboarding
    .post('/api/onboarding/company', async ({ body, set }) => {
      try {
        const { 
          email,
          companyName, 
          companyPhone, 
          companyWebsite, 
          primaryColor, 
          secondaryColor, 
          logo,
          firstName,
          lastName,
          phone
        } = body as { 
          email: string,
          companyName?: string,
          companyPhone?: string,
          companyWebsite?: string,
          primaryColor?: string,
          secondaryColor?: string,
          logo?: string,
          firstName?: string,
          lastName?: string,
          phone?: string
        };
        
        if (!email) {
          set.status = 400;
          return {
            success: false,
            message: 'Email is required'
          };
        }
        
        // Ensure email is decoded
        const decodedEmail = ensureEmailDecoded(email);
        logger.info(`Processing onboarding company update for email: ${decodedEmail}`);
        
        // Find the organization by user email
        let userInfo = await dbInstance.fetchOne<{ id: number, organization_id: number }>(
          'SELECT id, organization_id FROM users WHERE email = ?',
          [decodedEmail]
        );
        
        let organizationId;
        
        if (!userInfo) {
          // Create new organization first
          const slug = await generateUniqueSlug(dbInstance, companyName || 'New Organization');
          
          // Insert the organization
          const orgResult = await dbInstance.query<{ id: number }>(
            `INSERT INTO organizations (
              name, 
              slug,
              phone,
              website,
              primary_color,
              secondary_color,
              logo_data,
              onboarding_completed
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            RETURNING id`,
            [
              companyName || 'New Organization',
              slug,
              companyPhone || '',
              companyWebsite || '',
              primaryColor || '#6B46C1',
              secondaryColor || '#9F7AEA',
              logo || null,
              0 // Not completed yet
            ]
          );
          
          if (!orgResult || orgResult.length === 0) {
            throw new Error('Failed to create organization');
          }
          
          organizationId = orgResult[0].id;
          logger.info(`Created new organization with ID: ${organizationId}`);
          
          // Create the user with all available fields
          const userResult = await dbInstance.query<{ id: number }>(
            `INSERT INTO users (
              email,
              first_name,
              last_name,
              phone,
              organization_id,
              is_admin,
              is_agent
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
            RETURNING id`,
            [
              decodedEmail,
              firstName || '',
              lastName || '',
              phone || '',
              organizationId,
              1, // Set as admin
              1  // Set as agent
            ]
          );
          
          if (!userResult || userResult.length === 0) {
            throw new Error('Failed to create user');
          }
          
          userInfo = {
            id: userResult[0].id,
            organization_id: organizationId
          };
          
          logger.info(`Created new user (${userInfo.id}) for organization (${organizationId})`);
          
          // Set success status
          set.status = 200;
          return {
            success: true,
            message: 'Organization and user created successfully',
            organizationId,
            userId: userInfo.id
          };
        } else {
          organizationId = userInfo.organization_id;
          
          // Update existing organization
          await dbInstance.execute(
            `UPDATE organizations SET 
              name = COALESCE(?, name),
              phone = COALESCE(?, phone),
              website = COALESCE(?, website),
              primary_color = COALESCE(?, primary_color),
              secondary_color = COALESCE(?, secondary_color),
              logo_data = COALESCE(?, logo_data)
            WHERE id = ?`,
            [
              companyName,
              companyPhone,
              companyWebsite,
              primaryColor,
              secondaryColor,
              logo,
              organizationId
            ]
          );
          
          // Update existing user if we have new information
          if (firstName || lastName || phone) {
            await dbInstance.execute(
              `UPDATE users SET 
                first_name = COALESCE(?, first_name),
                last_name = COALESCE(?, last_name),
                phone = COALESCE(?, phone)
              WHERE id = ?`,
              [firstName, lastName, phone, userInfo.id]
            );
          }
          
          logger.info(`Updated existing organization: ${organizationId} and user: ${userInfo.id}`);
          
          // Set success status
          set.status = 200;
          return {
            success: true,
            message: 'Organization and user updated successfully',
            organizationId,
            userId: userInfo.id
          };
        }
        
      } catch (error) {
        logger.error(`Error in company details endpoint: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to process company details'
        };
      }
    })
    
    // Save licensing settings during onboarding
    .post('/api/onboarding/licensing', async ({ body, set }) => {
      try {
        const { 
          email,
          selectedCarriers,
          useSmartSend
        } = body as { 
          email: string,
          selectedCarriers: string[],
          useSmartSend?: boolean
        };
        
        if (!email) {
          set.status = 400;
          return {
            success: false,
            message: 'Email is required'
          };
        }
        
        // Ensure email is decoded
        const decodedEmail = ensureEmailDecoded(email);
        logger.info(`Processing onboarding licensing for email: ${decodedEmail}`);
        
        // Find the organization by user email
        const userInfo = await dbInstance.fetchOne<{ organization_id: number }>(
          'SELECT organization_id FROM users WHERE email = ?',
          [decodedEmail]
        );
        
        if (!userInfo) {
          logger.warn(`User not found for email: ${decodedEmail}`);
          set.status = 404;
          return {
            success: false,
            message: 'User not found - please start from signup'
          };
        }
        
        const organizationId = userInfo.organization_id;
        
        // Verify organization exists
        const orgExists = await dbInstance.fetchOne<{ id: number }>(
          'SELECT id FROM organizations WHERE id = ?',
          [organizationId]
        );
        
        if (!orgExists) {
          logger.warn(`Organization ${organizationId} not found for user ${decodedEmail}`);
          set.status = 404;
          return {
            success: false,
            message: 'Organization not found - please start from signup'
          };
        }
        
        // Get current org settings if any
        const currentSettings = await dbInstance.fetchOne<{ org_settings: string | null }>(
          'SELECT org_settings FROM organizations WHERE id = ?',
          [organizationId]
        );
        
        // Parse existing settings or create empty object
        let settings = {};
        if (currentSettings?.org_settings) {
          try {
            settings = JSON.parse(currentSettings.org_settings);
          } catch (e) {
            logger.warn(`Could not parse existing org_settings for org ${organizationId}: ${e}`);
          }
        }
        
        // Update with new carrier contracts
        settings = {
          ...settings,
          carrierContracts: selectedCarriers || [],
          smartSendEnabled: useSmartSend !== undefined ? useSmartSend : ((settings as any)['smartSendEnabled'] || false)
        };
        
        // Convert back to JSON string
        const updatedSettingsJson = JSON.stringify(settings);
        
        // Update the organization
        await dbInstance.execute(
          'UPDATE organizations SET org_settings = ? WHERE id = ?',
          [updatedSettingsJson, organizationId]
        );
        
        logger.info(`Updated licensing settings for organization ID: ${organizationId}`);
        
        set.status = 200
        return {
          success: true,
          message: 'Licensing settings updated successfully'
        };
        
      } catch (error) {
        logger.error(`Error updating licensing settings: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to update licensing settings'
        };
      }
    })
    
    // Save agents during onboarding
    .post('/api/onboarding/agents', async ({ body, set }) => {
      try {
        const { 
          email,
          agents
        } = body as { 
          email: string,
          agents: Array<{
            firstName: string;
            lastName: string;
            email: string;
            phone: string;
            isAdmin: boolean;
          }>;
        };
        
        if (!email) {
          set.status = 400;
          return {
            success: false,
            message: 'Email is required'
          };
        }
        
        // Ensure owner email is decoded
        const decodedOwnerEmail = ensureEmailDecoded(email);
        logger.info(`Processing onboarding agents for owner email: ${decodedOwnerEmail}`);
        
        // Find the organization by user email
        const userInfo = await dbInstance.fetchOne<{ organization_id: number }>(
          'SELECT organization_id FROM users WHERE email = ?',
          [decodedOwnerEmail]
        );
        
        if (!userInfo) {
          logger.warn(`User not found for email: ${decodedOwnerEmail}`);
          set.status = 404;
          return {
            success: false,
            message: 'User not found - please start from signup'
          };
        }
        
        const organizationId = userInfo.organization_id;
        
        // Verify organization exists
        const orgExists = await dbInstance.fetchOne<{ id: number }>(
          'SELECT id FROM organizations WHERE id = ?',
          [organizationId]
        );
        
        if (!orgExists) {
          logger.warn(`Organization ${organizationId} not found for user ${decodedOwnerEmail}`);
          set.status = 404;
          return {
            success: false,
            message: 'Organization not found - please start from signup'
          };
        }
        
        // Process each agent
        let createdCount = 0;
        let skippedCount = 0;
        
        for (const agent of agents) {
          // Ensure agent email is decoded
          const decodedAgentEmail = ensureEmailDecoded(agent.email);
          
          // Skip if this is the owner (already in the database)
          if (decodedAgentEmail.toLowerCase() === decodedOwnerEmail.toLowerCase()) {
            skippedCount++;
            continue;
          }
          
          // Check if this email already exists
          const existingAgent = await dbInstance.fetchOne<{ count: number }>(
            'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
            [decodedAgentEmail]
          );
          
          if (existingAgent && existingAgent.count > 0) {
            skippedCount++;
            continue;
          }
          
          // Create the new user with decoded email
          await dbInstance.execute(
            `INSERT INTO users (
              first_name, 
              last_name, 
              email, 
              phone, 
              is_admin, 
              is_agent, 
              organization_id
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [
              agent.firstName,
              agent.lastName,
              decodedAgentEmail,
              agent.phone || '',
              agent.isAdmin ? 1 : 0,
              1, // All users in this context are agents
              organizationId
            ]
          );
          
          createdCount++;
        }
        
        // Mark onboarding as complete since this is the final step
        await dbInstance.execute(
          'UPDATE organizations SET onboarding_completed = 1 WHERE id = ?',
          [organizationId]
        );
        
        logger.info(`Created ${createdCount} agents, skipped ${skippedCount}, and marked onboarding as complete for organization ID: ${organizationId}`);
        
        return {
          success: true,
          message: `Successfully added ${createdCount} agents and completed onboarding`,
          created: createdCount,
          skipped: skippedCount
        };
        
      } catch (error) {
        logger.error(`Error adding agents: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to add agents'
        };
      }
    })
    
    // Simplified checkout endpoint that creates the account
    .post('/api/subscription/checkout', async ({ body, set }) => {
      try {
        logger.info(`Processing account creation request: ${JSON.stringify(body)}`);
        const { firstName, lastName, email, tierId = 'basic', 
                companyName, companyPhone, companyWebsite, 
                primaryColor, secondaryColor, logo } = body as { 
          firstName: string, 
          lastName: string, 
          email: string,
          tierId?: string,
          companyName?: string,
          companyPhone?: string,
          companyWebsite?: string,
          primaryColor?: string,
          secondaryColor?: string,
          logo?: string
        };
        
        logger.info(`User info: ${firstName} ${lastName} (${email})`);
        
        if (!firstName || !lastName || !email) {
          logger.warn(`Missing required user information. Received: firstName=${!!firstName}, lastName=${!!lastName}, email=${!!email}`);
          set.status = 400;
          return { 
            success: false,
            message: 'Missing required user information'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ id: number, organization_id: number, count: number }>(
          'SELECT id, organization_id, COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        let organizationId;
        
        if (existingUser[0]?.count > 0) {
          // User exists, check if their organization has completed onboarding
          const orgInfo = await dbInstance.query<{ onboarding_completed: number }>(
            'SELECT onboarding_completed FROM organizations WHERE id = ?',
            [existingUser[0].organization_id]
          );
          
          if (orgInfo[0]?.onboarding_completed === 1) {
            logger.warn(`Email ${email} is already registered with completed onboarding`);
            set.status = 400;
            return { 
              success: false, 
              message: 'This email address is already registered with completed onboarding'
            };
          }
          
          // Use the existing organization if onboarding is not complete
          logger.info(`Found existing organization ${existingUser[0].organization_id} with incomplete onboarding`);
          organizationId = existingUser[0].organization_id;
          
          // Update organization details if provided
          if (companyName || companyPhone || companyWebsite || primaryColor || secondaryColor || logo) {
            const updates = [];
            const params = [];
            
            if (companyName) {
              updates.push('name = ?');
              params.push(companyName);
            }
            
            if (companyPhone) {
              updates.push('phone = ?');
              params.push(companyPhone);
            }
            
            if (companyWebsite) {
              updates.push('website = ?');
              params.push(companyWebsite);
            }
            
            if (primaryColor) {
              updates.push('primary_color = ?');
              params.push(primaryColor);
            }
            
            if (secondaryColor) {
              updates.push('secondary_color = ?');
              params.push(secondaryColor);
            }
            
            if (logo) {
              updates.push('logo_data = ?');
              params.push(logo);
            }
            
            if (updates.length > 0) {
              params.push(organizationId);
              await dbInstance.execute(
                `UPDATE organizations SET ${updates.join(', ')} WHERE id = ?`,
                params
              );
              logger.info(`Updated organization details for ID: ${organizationId}`);
            }
          }
        } else {
          // Create new organization for new user
          // Generate a unique slug from the name
          const organizationName = companyName || `${firstName}'s Organization`;
          const slug = await generateUniqueSlug(dbInstance, organizationName);
          
          logger.info(`Generated organization name: "${organizationName}" and slug: "${slug}"`);
          
          // Create new organization with optional fields if provided
          const orgFields = ['name', 'slug'];
          const orgValues = [organizationName, slug];
          const orgPlaceholders = ['?', '?'];
          
          if (companyPhone) {
            orgFields.push('phone');
            orgValues.push(companyPhone);
            orgPlaceholders.push('?');
          }
          
          if (companyWebsite) {
            orgFields.push('website');
            orgValues.push(companyWebsite);
            orgPlaceholders.push('?');
          }
          
          if (primaryColor) {
            orgFields.push('primary_color');
            orgValues.push(primaryColor);
            orgPlaceholders.push('?');
          }
          
          if (secondaryColor) {
            orgFields.push('secondary_color');
            orgValues.push(secondaryColor);
            orgPlaceholders.push('?');
          }
          
          if (logo) {
            orgFields.push('logo_data');
            orgValues.push(logo);
            orgPlaceholders.push('?');
          }
          
          const result = await dbInstance.query<{ id: number }>(
            `INSERT INTO organizations (${orgFields.join(', ')}) VALUES (${orgPlaceholders.join(', ')})`,
            orgValues
          );
          
          if (result.length > 0) {
            organizationId = result[0].id;
          } else {
            throw new Error('Failed to create organization');
          }
        }
        
        // Create new user
        const resultUser = await dbInstance.query<{ id: number }>(
          'INSERT INTO users (firstName, lastName, email, organization_id) VALUES (?, ?, ?, ?)',
          [firstName, lastName, email, organizationId]
        );
        
        if (resultUser.length > 0) {
          logger.info(`User ${firstName} ${lastName} (${email}) successfully created`);
          set.status = 200;
          return {
            success: true,
            message: 'Account created successfully'
          };
        } else {
          throw new Error('Failed to create user');
        }
      } catch (error) {
        logger.error(`Error processing account creation: ${error}`)
        set.status = 500
        return {
          success: false,
          message: 'Failed to process account creation'
        }
      }
    })

    // Debug endpoint to list users (development only)
    .get('/api/debug/users', async ({ set }) => {
      // Only allow in development environment
      if (process.env.NODE_ENV === 'production') {
        set.status = 404;
        return { error: 'Not found' };
      }
      
      try {
        logger.info('Debug endpoint called to list users');
        
        // Get all users with email addresses
        const users = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users LIMIT 50'
        );
        
        logger.info(`Found ${users.length} users in the database`);
        
        // Map the results to include both the raw and decoded email
        const mappedUsers = users.map(user => {
          let decodedEmail;
          try {
            decodedEmail = user.email.includes('%') 
              ? decodeURIComponent(user.email) 
              : user.email;
          } catch (e: unknown) {
            decodedEmail = `[Decode error: ${e instanceof Error ? e.message : String(e)}]`;
          }
          
          return {
            id: user.id,
            email: user.email,
            decodedEmail: decodedEmail
          };
        });
        
        return mappedUsers;
      } catch (error) {
        logger.error(`Error in debug endpoint: ${error}`);
        set.status = 500;
        return { error: String(error) };
      }
    })

    // Debug endpoint to list and fix encoded emails (development only)
    .get('/api/debug/fix-emails', async ({ set }) => {
      // Only allow in development environment
      if (process.env.NODE_ENV === 'production') {
        set.status = 404;
        return { error: 'Not found' };
      }
      
      try {
        logger.info('Debug endpoint called to list and fix encoded emails');
        
        // Get all users with potentially encoded emails
        const users = await dbInstance.query<{ id: number, email: string }>(
          "SELECT id, email FROM users WHERE email LIKE '%\%%'"
        );
        
        logger.info(`Found ${users.length} users with potentially encoded emails`);
        
        // Process each user email
        const results = [];
        for (const user of users) {
          try {
            const originalEmail = user.email;
            const decodedEmail = ensureEmailDecoded(originalEmail);
            
            // Only update if there's a change
            if (decodedEmail !== originalEmail) {
              // Update the email in the database
              await dbInstance.execute(
                'UPDATE users SET email = ? WHERE id = ?',
                [decodedEmail, user.id]
              );
              
              results.push({
                id: user.id,
                originalEmail,
                fixedEmail: decodedEmail,
                status: 'fixed'
              });
              
              logger.info(`Fixed encoded email: ${originalEmail} -> ${decodedEmail} for user ID ${user.id}`);
            } else {
              results.push({
                id: user.id,
                email: originalEmail,
                status: 'no change needed'
              });
            }
          } catch (error) {
            results.push({
              id: user.id,
              email: user.email,
              status: 'error',
              message: String(error)
            });
            logger.error(`Error fixing email for user ${user.id}: ${error}`);
          }
        }
        
        return {
          success: true,
          processed: users.length,
          results
        };
      } catch (error) {
        logger.error(`Error in debug endpoint: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: String(error)
        };
      }
    })

    // Debug endpoint to check a specific email (development only)
    .get('/api/debug/check-email', async ({ query, set }) => {
      // Only allow in development environment
      if (process.env.NODE_ENV === 'production') {
        set.status = 404;
        return { error: 'Not found' };
      }
      
      try {
        const { email } = query as { email: string };
        if (!email) {
          set.status = 400;
          return { error: 'Email parameter is required' };
        }
        
        const decodedEmail = ensureEmailDecoded(email);
        logger.info(`Debug endpoint checking email: ${email} -> ${decodedEmail}`);
        
        // Try various methods to find the user
        const exactMatch = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users WHERE email = ?',
          [decodedEmail]
        );
        
        const lowercaseMatch = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users WHERE LOWER(email) = LOWER(?)',
          [decodedEmail]
        );
        
        const likeMatch = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users WHERE email LIKE ?',
          [`%${decodedEmail.split('@')[0]}%`]
        );
        
        // List all users for reference (limited to first 10)
        const allUsers = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users LIMIT 10'
        );
        
        return {
          searchEmail: email,
          decodedEmail: decodedEmail,
          exactMatch: exactMatch.length > 0 ? exactMatch : null,
          lowercaseMatch: lowercaseMatch.length > 0 ? lowercaseMatch : null,
          likeMatch: likeMatch.length > 0 ? likeMatch : null,
          allUsers: allUsers
        };
      } catch (error) {
        logger.error(`Error in email debug endpoint: ${error}`);
        set.status = 500;
        return { error: String(error) };
      }
    })

    // Debug endpoint to test the resume data for a specific organization ID
    .get('/api/debug/test-resume', async ({ query, set }) => {
      // Only allow in development environment
      if (process.env.NODE_ENV === 'production') {
        set.status = 404;
        return { error: 'Not found' };
      }
      
      try {
        const { orgId } = query as { orgId: string };
        if (!orgId) {
          set.status = 400;
          return { error: 'orgId parameter is required' };
        }
        
        const organizationId = parseInt(orgId, 10);
        logger.info(`Debug endpoint testing resume data for organization ID: ${organizationId}`);
        
        // Get organization details directly by ID
        const orgInfo = await dbInstance.fetchOne<{
          id: number,
          name: string,
          onboarding_completed: number,
          website: string,
          phone: string,
          primary_color: string,
          secondary_color: string,
          logo_data: string | null,
          org_settings: string | null,
          payment_completed: number,
          stripe_customer_id: string | null,
          stripe_subscription_id: string | null
        }>(
          `SELECT id, name, onboarding_completed, website, phone, 
           primary_color, secondary_color, logo_data, org_settings,
           payment_completed, stripe_customer_id, stripe_subscription_id
           FROM organizations WHERE id = ?`,
          [organizationId]
        );
        
        if (!orgInfo) {
          set.status = 404;
          return { error: `Organization ID ${organizationId} not found` };
        }
        
        // Get a user from this organization (first one found)
        const userInfo = await dbInstance.fetchOne<{ 
          id: number, 
          first_name: string,
          last_name: string,
          email: string,
          phone: string
        }>(
          'SELECT id, first_name, last_name, email, phone FROM users WHERE organization_id = ? LIMIT 1',
          [organizationId]
        );
        
        if (!userInfo) {
          return {
            organization: orgInfo,
            error: 'No users found for this organization'
          };
        }
        
        // Get all agents/users for this organization
        const agents = await dbInstance.query<{
          id: number,
          first_name: string,
          last_name: string,
          email: string,
          phone: string,
          is_admin: number
        }>(
          `SELECT id, first_name, last_name, email, phone, is_admin 
           FROM users WHERE organization_id = ?`,
          [organizationId]
        );
        
        // Parse org settings if exists
        let orgSettings = {};
        if (orgInfo.org_settings) {
          try {
            orgSettings = JSON.parse(orgInfo.org_settings);
          } catch (e) {
            logger.warn(`Could not parse org_settings for org ${organizationId}: ${e}`);
          }
        }
        
        // Format the response in the same way as the resume endpoint
        return {
          success: true,
          onboardingComplete: orgInfo.onboarding_completed === 1,
          organization: {
            id: orgInfo.id,
            name: orgInfo.name,
            website: orgInfo.website || '',
            phone: orgInfo.phone || '',
            primaryColor: orgInfo.primary_color || '#6B46C1',
            secondaryColor: orgInfo.secondary_color || '#9F7AEA',
            logo: orgInfo.logo_data || null
          },
          user: {
            id: userInfo.id,
            firstName: userInfo.first_name,
            lastName: userInfo.last_name,
            email: userInfo.email,
            phone: userInfo.phone || ''
          },
          agents: agents.map(agent => ({
            firstName: agent.first_name,
            lastName: agent.last_name,
            email: agent.email,
            phone: agent.phone || '',
            isAdmin: agent.is_admin === 1
          })),
          carrierSettings: {
            selectedCarriers: (orgSettings as any)?.carrierContracts || [],
            useSmartSend: (orgSettings as any)?.smartSendEnabled || true
          },
          paymentStatus: {
            paymentCompleted: orgInfo.payment_completed === 1,
            stripeCustomerId: orgInfo.stripe_customer_id || null,
            stripeSubscriptionId: orgInfo.stripe_subscription_id || null
          },
          // Include the raw data for debugging
          raw: {
            orgInfo,
            userInfo,
            orgSettings
          }
        };
      } catch (error) {
        logger.error(`Error in resume test endpoint: ${error}`);
        set.status = 500;
        return { error: String(error) };
      }
    })

  // Ensure we're properly registering all routes with explicit paths
  logger.info(`Registered routes: ${app.routes.map(r => r.path).join(', ')}`);
  
  return app;
}

================
File: src/routes/organizations.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { TursoService } from '../services/turso';
import { z } from 'zod';
import { sendMagicLink } from '../services/email';
import { generateToken, getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { AuthService } from '../services/auth';
import { config } from '../config';
import sgMail from '@sendgrid/mail';
import { cookie } from '@elysiajs/cookie';

// Update the validation schema to include slug rules
const signupSchema = z.object({
  organizationName: z.string()
    .min(1, "Organization name is required")
    .max(100, "Organization name must be less than 100 characters")
    .regex(/^[a-zA-Z0-9\s\-_.]+$/, "Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores"),
  adminFirstName: z.string().min(1, "First name is required"),
  adminLastName: z.string().min(1, "Last name is required"),
  adminEmail: z.string().email("Invalid email address"),
  phone: z.string().optional(),
  planType: z.string().optional(),
});

// Helper function to ensure emails are properly decoded before storing in the database
function ensureEmailDecoded(email: string): string {
  try {
    // First check if email contains encoded characters
    if (email.includes('%')) {
      const decoded = decodeURIComponent(email);
      // Check if decoding made a difference
      if (decoded !== email) {
        logger.info(`Decoded email from ${email} to ${decoded}`);
        return decoded;
      }
    }
    return email;
  } catch (error) {
    logger.warn(`Error decoding email ${email}: ${error}`);
    return email; // Return original if decoding fails
  }
}

// Enhanced slug generation with uniqueness check
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

// Add this function to handle the mapping from old tier to new contact-based tier
function mapLegacyTierToContactTier(tierId: string): number {
  // Extract tier number from ID if format is "tier-X"
  if (tierId.startsWith('tier-')) {
    const tierNumber = parseInt(tierId.substring(5), 10);
    if (!isNaN(tierNumber)) {
      return tierNumber;
    }
  }
  
  // Handle legacy tiers
  switch (tierId) {
    case 'basic':
      return 1; // 500 contacts
    case 'pro':
      return 2; // 1000 contacts
    case 'enterprise':
      return 5; // 2500 contacts
    default:
      return 1; // Default to Tier 1
  }
}

// Add this function to calculate the agent limit based on contact tier
function getAgentLimitForContactTier(contactTier: number): number {
  switch (contactTier) {
    case 1: return 5;    // 500 contacts
    case 2: return 10;   // 1,000 contacts
    case 5: return 25;   // 2,500 contacts
    case 10: return 50;  // 5,000 contacts
    case 20: return 100; // 10,000 contacts
    case 50: return 200; // 25,000 contacts
    case 100: return 300; // 50,000 contacts
    case 200: return 500; // 100,000 contacts
    default:
      // Formula for tiers not explicitly defined
      if (contactTier <= 0) return 5;
      if (contactTier <= 10) return contactTier * 5;
      if (contactTier <= 50) return contactTier * 4;
      if (contactTier <= 100) return contactTier * 3;
      return contactTier * 2.5; // For very high tiers
  }
}

export const organizationRoutes = new Elysia({ prefix: '/api' })
  .post('/organizations/signup', async ({ body, set }) => {
    const db = new Database();
    const turso = new TursoService();
    const auth = new AuthService();

    try {
      logger.info(`Attempting to create organization with data: ${JSON.stringify(body)}`);
      const data = signupSchema.parse(body);
      
      // Decode email to ensure it's stored properly
      const decodedEmail = ensureEmailDecoded(data.adminEmail);
      
      // Generate unique slug
      const slug = await generateUniqueSlug(db, data.organizationName);
      logger.info(`Generated unique slug: ${slug}`);
      
      // Check if email is already registered in any organization
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
        [decodedEmail]
      );

      logger.info(`Existing user check result: ${JSON.stringify(existingUser)}`);

      if (existingUser[0]?.count > 0) {
        logger.warn(`Email ${decodedEmail} is already registered`);
        set.status = 400;
        return {
          success: false,
          message: 'This email address is already registered. Please use a different email or contact support.'
        };
      }

      // Check if organization name or slug is taken
      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [data.organizationName, slug]
      );

      logger.info(`Existing org check result: ${JSON.stringify(existingOrg)}`);

      if (existingOrg[0]?.count > 0) {
        logger.warn(`Organization name ${data.organizationName} or slug ${slug} is already taken`);
        set.status = 400;
        return {
          success: false,
          message: 'Organization name is already taken'
        };
      }

      // Wrap all database operations in a transaction
      const orgId = await db.transaction('write', async (transactionDb) => {
        // Create organization
        logger.info('Creating organization');
        const org = await transactionDb.execute(
          `INSERT INTO organizations (
            name,
            slug,
            subscription_tier,
            agent_limit,
            contact_limit
          ) VALUES (?, ?, 'basic', 5, 100) RETURNING id`,
          [data.organizationName, slug]
        );

        const orgId = org.rows?.[0]?.id;
        if (!orgId) {
          throw new Error('Failed to create organization');
        }

        logger.info(`Organization created with ID: ${orgId}`);

        // Create inactive admin user
        logger.info('Creating admin user');
        await transactionDb.execute(
          `INSERT INTO users (
            email,
            organization_id,
            is_admin,
            is_agent,
            is_active,
            first_name,
            last_name,
            created_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            decodedEmail,
            orgId,
            1, // is_admin
            1, // is_agent - Set to 1 for basic tier since admin is also an agent
            1, // is_active
            data.adminFirstName,
            data.adminLastName,
            new Date().toISOString()
          ]
        );

        return orgId;
      });

      // Return success response without sending magic link
      set.status = 201;
      return { 
        success: true,
        message: 'Organization created successfully',
        slug: slug
      };

    } catch (error) {
      logger.error(`Organization creation error: ${error}`);
      set.status = 400;
      return {
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Failed to create organization. Please try again.'
      };
    }
  })
  .get('/organizations/check-name/:name', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedName = decodeURIComponent(params.name);
      const potentialSlug = decodedName
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');

      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [decodedName, potentialSlug]
      );

      const count = existingOrg[0]?.count || 0;

      if (count > 0) {
        return {
          available: false,
          message: 'Organization name is already taken'
        };
      }

      // Validate name format
      if (!/^[a-zA-Z0-9\s\-_.]+$/.test(decodedName)) {
        return {
          available: false,
          message: 'Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores'
        };
      }

      return {
        available: true,
        message: 'Organization name is available'
      };

    } catch (error) {
      logger.error(`Error checking organization name: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check organization name'
      };
    }
  })
  .get('/organizations/check-email/:email', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedEmailParam = decodeURIComponent(params.email);
      // Ensure the email is fully decoded
      const decodedEmail = ensureEmailDecoded(decodedEmailParam);
      
      logger.info(`Checking email availability for: "${decodedEmail}"`);
      
      // Basic email format validation
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(decodedEmail)) {
        logger.info(`Email validation failed for: "${decodedEmail}"`);
        return {
          available: false,
          message: 'Invalid email format'
        };
      }

      // Use LOWER() for case-insensitive comparison to match unique constraint behavior
      logger.info(`Running SQL query: SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER('${decodedEmail}')`);
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
        [decodedEmail]
      );

      const count = existingUser[0]?.count || 0;
      logger.info(`Email check query result count: ${count} for email: "${decodedEmail}"`);

      if (count > 0) {
        logger.info(`Email "${decodedEmail}" is already registered`);
        return {
          available: false,
          message: 'This email address is already registered'
        };
      }

      logger.info(`Email "${decodedEmail}" is available`);
      return {
        available: true,
        message: 'Email is available'
      };

    } catch (error) {
      logger.error(`Error checking email: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check email availability'
      };
    }
  })
  .get('/organizations/subscription-tiers', async ({ set }) => {
    try {
      // Define a broader range of contact-based pricing tiers
      const tiers = [
        {
          id: "tier-1",
          name: "Tier 1",
          price: "$60/mo",
          agentLimit: 5,
          contactLimit: 500,
          features: ["Up to 500 contacts", "Email scheduling", "CRM features", "Analytics dashboard", "5 agent accounts"]
        },
        {
          id: "tier-2",
          name: "Tier 2",
          price: "$100/mo", 
          agentLimit: 10,
          contactLimit: 1000,
          features: ["Up to 1,000 contacts", "Email scheduling", "CRM features", "Analytics dashboard", "10 agent accounts"]
        },
        {
          id: "tier-5",
          name: "Tier 5",
          price: "$220/mo",
          agentLimit: 25,
          contactLimit: 2500, 
          features: ["Up to 2,500 contacts", "Email scheduling", "CRM features", "Premium support", "25 agent accounts"]
        },
        {
          id: "tier-10",
          name: "Tier 10",
          price: "$420/mo",
          agentLimit: 50,
          contactLimit: 5000,
          features: ["Up to 5,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "50 agent accounts"]
        },
        {
          id: "tier-20",
          name: "Tier 20",
          price: "$820/mo",
          agentLimit: 100,
          contactLimit: 10000,
          features: ["Up to 10,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "100 agent accounts"]
        },
        {
          id: "tier-50",
          name: "Tier 50",
          price: "$2020/mo",
          agentLimit: 200,
          contactLimit: 25000,
          features: ["Up to 25,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "Dedicated account manager", "200 agent accounts"]
        },
        {
          id: "tier-100",
          name: "Tier 100",
          price: "$3820/mo",
          agentLimit: 300,
          contactLimit: 50000,
          features: ["Up to 50,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "Dedicated account manager", "300 agent accounts"]
        },
        {
          id: "tier-200",
          name: "Tier 200",
          price: "$7620/mo",
          agentLimit: 500,
          contactLimit: 100000,
          features: ["Up to 100,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "Dedicated account manager", "Custom integrations", "500 agent accounts"]
        }
      ];

      // Add an endpoint for calculating custom tier pricing
      return { success: true, tiers };
    } catch (error) {
      logger.error(`Error fetching subscription tiers: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to fetch subscription tiers' };
    }
  })
  .get('/organizations/:orgSlug/subscription', async ({ params, request, set }) => {
    try {
      const db = new Database();
      const orgSlug = params.orgSlug;
      
      logger.info(`GET /organizations/${orgSlug}/subscription - Request received`);
      
      // Get session cookie for debugging
      const sessionCookie = request.headers.get('cookie');
      logger.info(`Session cookie: ${sessionCookie ? 'Present' : 'Missing'}`);
      
      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('Subscription fetch failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Log request information for debugging
      logger.info(`Fetching subscription - orgSlug: ${orgSlug}, userId: ${currentUser.id}, orgId: ${currentUser.organization_id}`);
      
      // Get organization details
      const orgResult = await db.query<{ 
        id: number,
        subscription_tier: string,
        agent_limit: number,
        contact_limit: number
      }>(
        'SELECT id, subscription_tier, agent_limit, contact_limit FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`Subscription fetch failed: Organization not found - ${orgSlug}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Verify user has permission for this org
      if (organization.id !== currentUser.organization_id) {
        logger.error(`Subscription fetch failed: Permission denied - User from org ${currentUser.organization_id} attempted to access org ${organization.id}`);
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to view this organization'
        };
      }
      
      // Set up the response with subscription details
      const response = {
        success: true,
        tierId: organization.subscription_tier,
        agentLimit: organization.agent_limit,
        contactLimit: organization.contact_limit
      };

      logger.info(`Successfully fetched subscription for org ${organization.id}: tier=${organization.subscription_tier}, agents=${organization.agent_limit}, contacts=${organization.contact_limit}`);
      
      return response;
      
    } catch (error) {
      logger.error(`Error fetching organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to fetch subscription details'
      };
    }
  })
  .get('/organizations/my-subscription', async ({ request, set }) => {
    try {
      const db = new Database();
      
      logger.info('GET /organizations/my-subscription - Request received');
      
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('My subscription fetch failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Get organization details using user's organization_id
      const orgResult = await db.query<{ 
        id: number,
        name: string,
        slug: string,
        subscription_tier: string,
        agent_limit: number,
        contact_limit: number,
        stripe_subscription_id: string | null
      }>(
        'SELECT id, name, slug, subscription_tier, agent_limit, contact_limit, stripe_subscription_id FROM organizations WHERE id = ?',
        [currentUser.organization_id]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`My subscription fetch failed: Organization not found for user ${currentUser.id}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Get subscription tier details from subscription_tiers table
      const tierResult = await db.query<{
        name: string,
        agent_limit: number,
        contact_limit: number,
        features: string
      }>(
        'SELECT name, agent_limit, contact_limit, features FROM subscription_tiers WHERE id = ?',
        [organization.subscription_tier]
      );
      
      const tier = tierResult[0] || null;
      
      // Determine subscription status based on Stripe subscription
      const subscriptionStatus = organization.stripe_subscription_id ? 'active' : 'inactive';
      
      // Set up the response with complete subscription details
      const response = {
        success: true,
        organization: {
          id: organization.id,
          name: organization.name,
          slug: organization.slug
        },
        subscription: {
          tierId: organization.subscription_tier,
          tierName: tier?.name || organization.subscription_tier,
          status: subscriptionStatus,
          agentLimit: organization.agent_limit,
          contactLimit: organization.contact_limit,
          features: tier ? JSON.parse(tier.features) : []
        }
      };

      logger.info(`Successfully fetched my subscription for org ${organization.id}: tier=${organization.subscription_tier}, agents=${organization.agent_limit}, contacts=${organization.contact_limit}`);
      
      return response;
      
    } catch (error) {
      logger.error(`Error fetching my organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to fetch subscription details'
      };
    }
  })
  .post('/organizations/:orgSlug/subscription', async ({ params, body, request, set }) => {
    try {
      const db = new Database();
      const orgSlug = params.orgSlug;
      
      logger.info(`POST /organizations/${orgSlug}/subscription - Request received`);
      
      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('Subscription update failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Get organization details
      const orgResult = await db.query<{ 
        id: number, 
        subscription_tier: string,
        stripe_customer_id: string | null
      }>(
        'SELECT id, subscription_tier, stripe_customer_id FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`Subscription update failed: Organization not found - ${orgSlug}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Verify user has permission for this org
      if (organization.id !== currentUser.organization_id) {
        logger.error(`Subscription update failed: Permission denied - User from org ${currentUser.organization_id} attempted to access org ${organization.id}`);
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to update this organization'
        };
      }

      // Extract the tier ID and additional resources from the request body
      const { tierId, extraAgents, extraContacts } = body as { 
        tierId: 'basic' | 'pro' | 'enterprise' | string,
        extraAgents: number,
        extraContacts: number
      };
      
      // Map the legacy tier to a contact-based tier
      const contactTier = mapLegacyTierToContactTier(tierId);
      const agentLimit = getAgentLimitForContactTier(contactTier);
      
      logger.info(`Updating subscription - orgId: ${organization.id}, tier: ${tierId}, contactTier: ${contactTier}, agentLimit: ${agentLimit}`);

      // Check if we need to update the Stripe subscription
      if (organization.subscription_tier !== tierId) {
        logger.info(`Organization tier is changing from ${organization.subscription_tier} to ${tierId}`);
        
        // Update Stripe subscription
        const stripe = await import('../services/stripe');
        
        try {
          // Create or update the subscription with Stripe
          await stripe.createOrUpdateSubscription({
            tierId: tierId as any, // Type cast to avoid type error with new tier IDs
            organizationId: organization.id,
            email: currentUser.email,
            extraAgents,
            extraContacts,
            stripeCustomerId: organization.stripe_customer_id || undefined,
            userId: currentUser.id.toString() // Add the userId to fix the linter error
          });
          
          logger.info(`Successfully updated Stripe subscription for organization ${organization.id}`);
        } catch (stripeError) {
          logger.error(`Error updating Stripe subscription: ${stripeError}`);
        }
      } else {
        logger.info(`Organization tier is not changing, skipping Stripe update`);
      }

      // Update the organization's subscription tier in the database
      await db.execute(
        `UPDATE organizations 
         SET subscription_tier = ?,
             agent_limit = ?,
             contact_limit = ?
         WHERE id = ?`,
        [
          tierId,
          agentLimit,
          contactTier * 500, // Contact limit is based on tier
          organization.id
        ]
      );
      
      logger.info(`Successfully updated subscription in database for organization ${organization.id}`);
      
      // Return success
      return {
        success: true,
        message: 'Subscription updated successfully'
      };
      
    } catch (error) {
      logger.error(`Error updating organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to update subscription'
      };
    }
  })
  // Add new endpoint to create Turso database after plan selection
  .post('/organizations/:orgSlug/setup-database', async ({ params, set }) => {
    const db = new Database();
    const turso = new TursoService();

    try {
      const orgSlug = params.orgSlug;

      // Get organization ID from slug
      const orgResult = await db.query<{ id: number, has_db: number }>(
        'SELECT id, CASE WHEN turso_db_url IS NOT NULL THEN 1 ELSE 0 END as has_db FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        return {
          success: false,
          message: 'Organization not found'
        };
      }

      const orgId = orgResult[0].id;

      if (orgResult[0].has_db === 1) {
        set.status = 400;
        return {
          success: false,
          message: 'Organization already has a database'
        };
      }

      // Create Turso database for the organization
      const { url, token } = await turso.createOrganizationDatabase(orgId.toString());

      // Update organization with Turso database credentials and default org_signature to false
      await db.execute(
        'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ?, org_signature = 0 WHERE id = ?',
        [url, token, orgId]
      );

      logger.info(`Successfully created Turso database for organization ${orgId}`);

      return {
        success: true,
        message: 'Database created successfully'
      };

    } catch (error) {
      logger.error(`Error creating database for organization ${params.orgSlug}: ${error}`);
      set.status = 500;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return {
        success: false,
        message: `Failed to create database: ${errorMessage}`
      };
    }
  })
  // Get organization account status
  .get('/organizations/:orgSlug/account-status', async ({ params, set, request }) => {
    try {
      const db = new Database();
      
      // Authenticate the request
      const currentUser = await getUserFromSession(request);
      if (!currentUser) {
        set.status = 401;
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }
      
      // Get organization ID from slug
      const orgResult = await db.query<{ id: number }>(
        'SELECT id FROM organizations WHERE slug = ?',
        [params.orgSlug]
      );
      
      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        return {
          success: false,
          error: 'Organization not found'
        };
      }
      
      const organizationId = orgResult[0].id;
      
      // Verify user has permission to access this organization
      if (organizationId !== currentUser.organization_id) {
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to access this organization'
        };
      }
      
      // Import the subscription service
      const { checkAccountStatus } = await import('../services/subscription');
      
      // Check account status
      const statusDetails = await checkAccountStatus(organizationId);
      
      return {
        success: true,
        status: statusDetails
      };
      
    } catch (error) {
      logger.error(`Error checking account status: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  
  // Stripe webhook handler
  .post('/stripe-webhook', async ({ body, set, request }) => {
    try {
      const signature = request.headers.get('stripe-signature');
      
      if (!signature) {
        set.status = 400;
        return { success: false, error: 'Stripe signature missing' };
      }
      
      // Import Stripe to verify the webhook
      const Stripe = await import('stripe');
      const stripe = new Stripe.default(config.stripe.secretKey, {
        apiVersion: '2025-02-24.acacia',
      });
      
      const event = stripe.webhooks.constructEvent(
        JSON.stringify(body),
        signature,
        config.stripe.webhookSecret
      );
      
      // Import the Stripe service to handle the webhook
      const { handleStripeWebhook } = await import('../services/stripe');
      await handleStripeWebhook(event);
      
      logger.info(`Processed Stripe webhook: ${event.type}`);
      return { success: true };
      
    } catch (error) {
      logger.error(`Error processing Stripe webhook: ${error}`);
      set.status = 400;
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  // Add interface for enterprise contact form data
  .post('/enterprise-contact', async ({ body, set, request }: { 
    body: { name: string; email: string; phone: string; company: string; companySize?: string; message?: string }, 
    set: { status: number },
    request: Request 
  }) => {
    try {
      const { name, email, phone, company, companySize, message } = body;
      
      // Validate required fields
      if (!name || !email || !phone || !company) {
        set.status = 400;
        return { success: false, error: 'Missing required fields' };
      }
      
      // Try to get user/organization info from session if available
      let orgInfo = "";
      try {
        const user = await getUserFromSession(request);
        if (user) {
          orgInfo = `
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <p><strong>User is logged in with the following details:</strong></p>
            <p>Organization: ${user.organization_name} (ID: ${user.organization_id})</p>
            <p>User: ${user.first_name} ${user.last_name} (${user.email})</p>
          </div>`;
        }
      } catch (sessionError) {
        // Just log the error but continue - the session info is optional
        logger.warn(`Unable to get session info: ${sessionError}`);
      }
      
      // Format the email content
      const emailContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">New Enterprise Plan Inquiry</h2>
          
          <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
            <p><strong>Name:</strong> ${name}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Phone:</strong> ${phone}</p>
            <p><strong>Company:</strong> ${company}</p>
            <p><strong>Company Size:</strong> ${companySize || 'Not specified'}</p>
            <p><strong>Message:</strong></p>
            <p style="white-space: pre-line;">${message || 'No message provided'}</p>
          </div>
          ${orgInfo}
          <p style="color: #666; font-size: 14px;">
            This inquiry was submitted through the Enterprise Contact form on the MedicareMax portal.
          </p>
        </div>
      `;
      
      // Configure email
      const msg = {
        to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: `Enterprise Plan Inquiry from ${name} at ${company}`,
        text: `New Enterprise Plan Inquiry:\n\nName: ${name}\nEmail: ${email}\nPhone: ${phone}\nCompany: ${company}\nCompany Size: ${companySize || 'Not specified'}\n\nMessage: ${message || 'No message provided'}\n\n${orgInfo ? `User is logged in from organization: ${orgInfo}` : ''}\n\nThis inquiry was submitted through the Enterprise Contact form on the MedicareMax portal.`,
        html: emailContent
      };
      
      // Send the email
      await sgMail.send(msg);
      
      // Log successful submission
      logger.info(`Enterprise plan inquiry submitted by ${name} from ${company}`);
      
      // Return success response
      return { success: true };
    } catch (error) {
      logger.error(`Error processing enterprise contact submission: ${error}`);
      set.status = 500;
      return { 
        success: false, 
        error: 'Failed to process your request. Please try again later.' 
      };
    }
  })
  // Add endpoint for enterprise inquiry during onboarding
  .post('/enterprise-inquiry', async ({ body, set, request }: { 
    body: { companyName: string; contactName: string; email: string; phone: string; message?: string }, 
    set: { status: number },
    request: Request 
  }) => {
    try {
      const { companyName, contactName, email, phone, message } = body;
      
      // Validate required fields
      if (!companyName || !contactName || !email || !phone) {
        set.status = 400;
        return { success: false, error: 'Missing required fields' };
      }
      
      // Try to get user/organization info from session if available
      let orgInfo = "";
      try {
        const user = await getUserFromSession(request);
        if (user) {
          orgInfo = `
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <p><strong>User is logged in with the following details:</strong></p>
            <p>Organization: ${user.organization_name} (ID: ${user.organization_id})</p>
            <p>User: ${user.first_name} ${user.last_name} (${user.email})</p>
          </div>`;
        }
      } catch (sessionError) {
        // Just log the error but continue - the session info is optional
        logger.warn(`Unable to get session info: ${sessionError}`);
      }
      
      // Format the email content
      const emailContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">New Enterprise Plan Inquiry (Onboarding)</h2>
          
          <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
            <p><strong>Company:</strong> ${companyName}</p>
            <p><strong>Contact Name:</strong> ${contactName}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Phone:</strong> ${phone}</p>
            <p><strong>Message:</strong></p>
            <p style="white-space: pre-line;">${message || 'No message provided'}</p>
          </div>
          ${orgInfo}
          <p style="color: #666; font-size: 14px;">
            This inquiry was submitted through the Enterprise Form during the onboarding process on MedicareMax.
          </p>
        </div>
      `;
      
      // Configure email
      const msg = {
        to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: `Enterprise Plan Inquiry from ${contactName} at ${companyName} (Onboarding)`,
        text: `New Enterprise Plan Inquiry (Onboarding):\n\nCompany: ${companyName}\nContact Name: ${contactName}\nEmail: ${email}\nPhone: ${phone}\n\nMessage: ${message || 'No message provided'}\n\n${orgInfo ? `User is logged in from organization: ${orgInfo}` : ''}\n\nThis inquiry was submitted through the Enterprise Form during onboarding on MedicareMax.`,
        html: emailContent
      };
      
      // Send the email
      await sgMail.send(msg);
      
      // Log successful submission
      logger.info(`Enterprise plan inquiry (onboarding) submitted by ${contactName} from ${companyName}`);
      
      // Return success response
      return { success: true };
    } catch (error) {
      logger.error(`Error processing enterprise inquiry submission: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to process inquiry' };
    }
  })
  .post('/api/agents', async ({ body, request, set }) => {
    try {
      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request)
      if (!currentUser) {
        set.status = 401
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        }
      }

      // Check if user is an admin
      if (!currentUser.is_admin) {
        set.status = 403
        return {
          success: false,
          error: 'Only administrators can create new agents'
        }
      }

      const newAgent = body as NewAgentRequest
      
      // Decode the email to ensure it's stored properly
      newAgent.email = ensureEmailDecoded(newAgent.email);
      
      logger.info(`Creating new agent: ${newAgent.email} (org: ${currentUser.organization_id})`)

      // Ensure that the new user has at least one role
      if (!newAgent.is_admin && !newAgent.is_agent) {
        logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
        newAgent.is_agent = true
      }

      // ... rest of the function ...
    } catch (error) {
      logger.error(`Error creating new agent: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to create new agent'
      };
    }
  })
  .post('/organizations/exit-demo-mode', async ({ request, set }) => {
    const db = new Database();
    
    try {
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      
      if (!currentUser) {
        set.status = 401;
        return { success: false, message: 'Unauthorized' };
      }

      // Only allow admins to exit demo mode
      if (!currentUser.is_admin) {
        set.status = 403;
        return { success: false, message: 'Only administrators can exit demo mode' };
      }

      // Update the organization's demo_mode to false
      const result = await db.execute(
        `UPDATE organizations 
         SET demo_mode = 0
         WHERE id = ?`,
        [currentUser.organization_id]
      );

      /* TODO: Uncomment this when we have a way to enable regular and followup scheduling
      const result = await db.execute(
        `UPDATE organizations 
         SET demo_mode = 0, regular_scheduling_active = 1, followup_scheduling_active = 1
         WHERE id = ?`,
        [currentUser.organization_id]
      );
      */

      const rowsAffected = result.rowsAffected || 0;
      
      if (rowsAffected === 0) {
        logger.info(`No changes made when exiting demo mode for org ${currentUser.organization_id}`);
      } else {
        logger.info(`Successfully exited demo mode for organization ${currentUser.organization_id}`);
      }
      set.status = 200;
      return { success: true };
    } catch (error) {
      logger.error(`Error exiting demo mode: ${error}`);
      set.status = 500;
      return { success: false, message: 'Internal server error' };
    }
  });

export function createOrganizationRoutes() {
  const dbInstance = new Database();
  const authService = new AuthService();

  return new Elysia()
    .use(cookie())
    // Add a new endpoint for direct signup from UserDetails page
    .post('/api/organizations/signup', async ({ body, set, setCookie }) => {
      try {
        const { adminFirstName, adminLastName, adminEmail, phone, organizationName, planType } = body as {
          adminFirstName: string;
          adminLastName: string;
          adminEmail: string;
          phone?: string;
          organizationName: string;
          planType?: string;
        };

        // Decode email to ensure it's stored properly
        const decodedEmail = ensureEmailDecoded(adminEmail);

        // Validate input
        const validation = signupSchema.safeParse({
          ...body,
          adminEmail: decodedEmail // Use decoded email for validation
        });
        if (!validation.success) {
          set.status = 400;
          return {
            success: false,
            message: validation.error.errors[0].message
          };
        }

        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [decodedEmail]
        );

        if (existingUser[0]?.count > 0) {
          set.status = 400;
          return {
            success: false,
            message: 'This email address is already registered'
          };
        }

        // Generate a unique slug from the organization name
        const slug = await generateUniqueSlug(dbInstance, organizationName);

        // Create temporary session token
        const tempSessionId = generateToken();

        // Set session cookie for 24 hours
        setCookie('onboardingSession', tempSessionId, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/'
        });

        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/'
        });

        // Create organization
        const orgResult = await dbInstance.execute(`
          INSERT INTO organizations (
            name, 
            subscription_tier, 
            created_at, 
            onboarding_completed, 
            slug, 
            onboarding_step,
            temp_session_id
          ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
          [organizationName, planType || 'basic', slug, 2, tempSessionId]
        );

        const orgId = Number(orgResult.lastInsertRowid);
        logger.info(`Created organization: ${orgId} with slug: ${slug}`);

        // Create admin user with decoded email
        await dbInstance.execute(
          `INSERT INTO users (
            email, 
            first_name, 
            last_name, 
            phone, 
            is_admin, 
            is_agent, 
            organization_id, 
            created_at,
            is_active
          ) VALUES (?, ?, ?, ?, 1, 1, ?, datetime('now'), 0)`,
          [decodedEmail, adminFirstName, adminLastName, phone || '', orgId]
        );

        logger.info(`Created admin user for org ${slug} - Name: ${adminFirstName} ${adminLastName}, Email: ${decodedEmail}`);

        // Generate a magic link for verification
        const magicLink = `${config.clientUrl}/auth/verify/${slug}/${tempSessionId}`;

        // Send welcome email
        try {
          await sendMagicLink({
            email: decodedEmail,
            magicLink: magicLink,
            name: adminFirstName
          });
          logger.info(`Sent welcome email to ${decodedEmail}`);
        } catch (emailError) {
          logger.error(`Failed to send welcome email: ${emailError}`);
          // Continue even if email fails
        }

        return {
          success: true,
          message: 'Organization and admin user created successfully',
          slug: slug
        };

      } catch (error) {
        logger.error(`Error creating organization: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to create organization'
        };
      }
    })
    
    // Add a new endpoint to check email availability
    .get('/api/organizations/check-email/:email', async ({ params, set }) => {
      try {
        const { email } = params;
        
        if (!email || !email.trim()) {
          set.status = 400;
          return {
            available: false,
            message: 'Email is required'
          };
        }
        
        // Ensure email is fully decoded
        const decodedEmail = ensureEmailDecoded(email);
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(decodedEmail)) {
          return {
            available: false,
            message: 'Invalid email format'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [decodedEmail]
        );
        
        const count = existingUser[0]?.count || 0;
        
        if (count > 0) {
          return {
            available: false,
            message: 'This email address is already registered'
          };
        }
        
        // If we get here, the email is available
        return {
          available: true,
          message: 'Email is available'
        };
        
      } catch (error) {
        logger.error(`Error checking email availability: ${error}`);
        set.status = 500;
        return {
          available: false,
          message: 'Error checking email availability'
        };
      }
    });
}

================
File: src/routes/quotes.ts
================
import { Elysia } from 'elysia';
import axios from 'axios';
import { config } from '../config';
import { logger } from '../logger';
import { Database } from '../database';
import { generateQuoteId, decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';
import { readFile } from 'fs/promises';
import { join } from 'path';
import { readFileSync } from 'fs';


interface ZipInfo {
  state: string;
  counties: string[];
  // Add other ZIP info properties as needed
}


// Update ZIP_DATA declaration
let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'))
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}


interface Quote {
    age: number;
    gender: string;
    plan: string;
    tobacco: number;
    rate: number;
    discount_rate: number;
    discount_category: string;
}

interface QuoteResponse {
    naic: string;
    group: number;
    company_name: string;
    quotes: Quote[];
}

interface QuoteRequestBody {
    zip_code: string;
    state: string;
    age: string | number;
    tobacco: string | boolean;
    gender: string;
    county?: string;
    effective_date?: string;
}

interface QuoteRequest {
    zip_code: string;
    state: string;
    age: number;
    tobacco: boolean;
    gender: string;
    plans: string[];
    carriers: string;
    county?: string;
    effective_date?: string;
}

interface ContactQuoteInfo {
    zip_code: string;
    birth_date: string;
    age: number;
    tobacco_user: number;
    gender: string;
    email: string;
    first_name: string;
    last_name: string;
    current_carrier: string;
    phone_number: string;
    plan_type: string;
}

// Add new interface for org info response
interface OrgRedirectInfo {
    redirect_url: string | null;
    agent_name: string;
}

function calculateAgeOnFirstOfNextMonth(birthDate: string, currentDate: string): number {
    const birth = new Date(birthDate);
    const current = new Date(currentDate);
    
    // Get first day of next month
    const nextMonth = new Date(current.getFullYear(), current.getMonth() + 1, 1);
    
    // Calculate age based on year difference
    let age = nextMonth.getFullYear() - birth.getFullYear();
    
    // Adjust age if birthday hasn't occurred yet in the target month
    if (
        nextMonth.getMonth() < birth.getMonth() || 
        (nextMonth.getMonth() === birth.getMonth() && 1 < birth.getDate())
    ) {
        age--;
    }
    
    return age;
}


export const quotesRoutes = (app: Elysia) => {
    app
    .get('/api/quotes/generate/:contactId', async ({ params, request }) => {
        try {
            const user = await getUserFromSession(request);
            if (!user?.organization_id) {
                throw new Error('No organization ID found in session');
            }

            const contactId = parseInt(params.contactId);
            if (isNaN(contactId)) {
                throw new Error('Invalid contact ID');
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
            
            // Verify contact exists and belongs to this org
            const contact = await orgDb.fetchOne(
                'SELECT id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                throw new Error('Contact not found');
            }

            // Generate quote ID
            const quoteId = generateQuoteId(user.organization_id, contactId);

            return {
                success: true,
                quoteId,
                redirectUrl: `${process.env.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`
            };
        } catch (e) {
            logger.error(`Error generating quote ID: ${e}`);
            throw new Error(String(e));
        }
    })
    .get('/api/quotes/decode/:quoteId', async ({ params, set }) => {
        try {
            logger.info(`Decoding quote ID: ${params.quoteId}`);
            
            const decoded = decodeQuoteId(params.quoteId);
            if (!decoded) {
                logger.error(`Invalid quote ID format: ${params.quoteId}`);
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID format'
                };
            }
            
            logger.info(`Decoded quote ID: orgId=${decoded.orgId}, contactId=${decoded.contactId}`);

            // Get org-specific database
            logger.info(`Getting database for org: ${decoded.orgId}`);
            const orgDb = await Database.getOrInitOrgDb(decoded.orgId.toString());
            
            const mainDb = new Database();
            logger.info(`Fetching organization details for orgId: ${decoded.orgId}`);
            const result = await mainDb.fetchOne<{ slug: string, org_settings: string, name: string, logo_data: string, phone: string, redirect_url: string, org_signature: boolean, signature: string | null }>(
                'SELECT slug, org_settings, name, logo_data, phone, redirect_url, org_signature, signature FROM organizations WHERE id = ?',
                [decoded.orgId]
            );

            if (!result) {
                logger.error(`Organization not found: ${decoded.orgId}`);
                set.status = 404;
                return {
                    success: false,
                    error: 'Organization not found'
                };
            }

            const orgSlug = result.slug;
            logger.info(`Found organization: ${orgSlug} (ID: ${decoded.orgId})`);
            
            let orgSettings;
            try {
                orgSettings = JSON.parse(result.org_settings || '{}');
            } catch (e) {
                logger.warn(`Error parsing org settings for ${decoded.orgId}: ${e}`);
                orgSettings = {};
            }
            
            const carrierContracts = orgSettings?.carrierContracts || [];

            // Get signature from either orgSettings, database column, or fall back to org name
            let signature = orgSettings?.signature || result.signature || result.name;

            // First try to get the assigned agent from the contact
            const contactQuery = 'SELECT zip_code, birth_date, tobacco_user, gender, email, first_name, last_name, current_carrier, phone_number, plan_type, agent_id FROM contacts WHERE id = ?';
            const contactParams = [decoded.contactId];
            
            logger.info(`Executing contact query: ${contactQuery} with params: [${contactParams}]`);
            
            const contact = await orgDb.fetchOne<ContactQuoteInfo & { agent_id: number | null }>(contactQuery, contactParams);

            if (!contact) {
                logger.error(`Contact not found: contactId=${decoded.contactId} in orgId=${decoded.orgId}`);
                
                // Additional debugging: List all contacts in this org
                try {
                    const allContacts = await orgDb.query('SELECT id, email, first_name, last_name FROM contacts LIMIT 5');
                    logger.info(`First 5 contacts in org ${decoded.orgId}: ${JSON.stringify(allContacts)}`);
                } catch (e) {
                    logger.error(`Error listing contacts: ${e}`);
                }
                
                set.status = 404;
                return {
                    success: false,
                    error: `Contact not found: ID=${decoded.contactId}`
                };
            }

            // Get agent info - first try assigned agent, then default agent, then fall back to first user
            let agent = null;
            
            // Try assigned agent first
            if (contact.agent_id) {
                agent = await mainDb.fetchOne<{ first_name: string, last_name: string, email: string, phone: string }>(
                    'SELECT first_name, last_name, email, phone FROM users WHERE id = ?',
                    [contact.agent_id]
                );
            }
            
            // If no assigned agent, try default agent from org settings
            if (!agent) {
                const defaultAgentResult = await mainDb.fetchOne<{ default_agent_id: number }>(
                    'SELECT default_agent_id FROM organizations WHERE id = ?',
                    [decoded.orgId]
                );
                
                if (defaultAgentResult?.default_agent_id) {
                    agent = await mainDb.fetchOne<{ first_name: string, last_name: string, email: string, phone: string }>(
                        'SELECT first_name, last_name, email, phone FROM users WHERE id = ?',
                        [defaultAgentResult.default_agent_id]
                    );
                    
                    // If we found the default agent, update the contact's agent_id
                    if (agent) {
                        try {
                            await orgDb.execute(
                                'UPDATE contacts SET agent_id = ? WHERE id = ?',
                                [defaultAgentResult.default_agent_id, decoded.contactId]
                            );
                            logger.info(`Updated contact ${decoded.contactId} with default agent ${defaultAgentResult.default_agent_id}`);
                        } catch (e) {
                            logger.error(`Error updating contact's agent_id: ${e}`);
                        }
                    }
                }
            }
            
            // If still no agent, fall back to first active user
            if (!agent) {
                agent = await mainDb.fetchOne<{ first_name: string, last_name: string, email: string, phone: string }>(
                    'SELECT first_name, last_name, email, phone FROM users WHERE organization_id = ? AND is_active = 1 ORDER BY id ASC LIMIT 1',
                    [decoded.orgId]
                );
            }

            if (!agent) {
                logger.error(`No users found for organization: ${decoded.orgId}`);
                set.status = 404;
                return {
                    success: false,
                    error: 'No users found for organization'
                };
            }

            logger.info(`Found contact: ${contact.first_name} ${contact.last_name} (ID: ${decoded.contactId})`);
            
            const zipInfo = ZIP_DATA[contact.zip_code];
            const contactState = zipInfo?.state;
            
            if (!contactState) {
                logger.warn(`No state found for zip code: ${contact.zip_code}`);
            }

            const output = {
                success: true,
                orgId: decoded.orgId.toString(),
                orgSlug: orgSlug || null,
                orgName: result.name,
                orgLogo: result.logo_data || null,
                orgPhone: result.phone || null,
                orgRedirectUrl: result.redirect_url || null,
                orgSignature: Boolean(result.org_signature) || false,
                orgSignatureText: signature,
                carrierContracts: carrierContracts || null,
                agent: {
                    firstName: agent.first_name,
                    lastName: agent.last_name,
                    email: agent.email,
                    phone: agent.phone
                },
                contact: {
                    id: decoded.contactId,
                    zipCode: contact.zip_code,
                    state: contactState,
                    dateOfBirth: contact.birth_date,
                    age: calculateAgeOnFirstOfNextMonth(contact.birth_date, new Date().toISOString()),
                    tobacco: Boolean(contact.tobacco_user),
                    gender: contact.gender,
                    email: contact.email,
                    firstName: contact.first_name,
                    lastName: contact.last_name,
                    currentCarrier: contact.current_carrier,
                    planType: contact.plan_type,
                    phoneNumber: contact.phone_number
                }
            };

            logger.info(`Returning success response for quote ID: ${params.quoteId}`);
            logger.info(`Output: ${JSON.stringify(output, null, 2)}`);
            return output;
        } catch (e) {
            logger.error(`Error decoding quote ID: ${e}`);
            set.status = 500;
            return {
                success: false,
                error: String(e)
            };
        }
    })
    .post('/api/quotes', async ({ body, set }: { body: QuoteRequestBody, set: any }) => {
        try {
            // Format request body
            const requestBody: QuoteRequest = {
                zip_code: body.zip_code,
                state: body.state,
                age: Math.max(65, Math.min(110, Number(body.age))),
                tobacco: body.tobacco === 'true' || body.tobacco === true,
                gender: body.gender,
                plans: ['G', 'N'],
                carriers: 'supported',
                county: body.county
            };

            if (body.effective_date) {
                requestBody.effective_date = body.effective_date;
            }

            // Log incoming request details
            logger.info(`Incoming quote request body: ${JSON.stringify(requestBody, null, 2)}`);
            
            // Construct request config
            const quoteEngineUrl = 'https://quote-engine.replit.app/quotes/';
            const requestConfig = {
                url: quoteEngineUrl,
                method: 'POST' as const,
                headers: {
                    'X-API-Key': config.quoteApiKey,
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                data: requestBody
            };

            logger.info(`Making request to quote engine with config: ${JSON.stringify({
                url: requestConfig.url,
                method: requestConfig.method,
                headers: {
                    ...requestConfig.headers,
                    'X-API-Key': '[REDACTED]'
                }
            }, null, 2)}`);

            // Make request to quote engine API
            const response = await axios(requestConfig);
            
            logger.info(`Quote engine response status: ${response.status}`);
            logger.info(`Quote engine response headers: ${JSON.stringify(response.headers, null, 2)}`);
            logger.info(`Quote engine response data length: ${JSON.stringify(response.data).length} characters`);
            logger.info(`Quote engine response data preview: ${JSON.stringify(response.data).substring(0, 200)}...`);
            
            if (!response.data) {
                logger.error('Quote engine returned empty response data');
                set.status = 500;
                return { error: 'No quote data received from engine' };
            }

            // Return quotes from response data
            set.status = 200; // Explicitly set 200 status
            return response.data;
        } catch (error: any) {
            logger.error(`Error fetching quotes: ${error}`);
            if (axios.isAxiosError(error)) {
                logger.error(`Axios error details: ${JSON.stringify({
                    status: error.response?.status,
                    statusText: error.response?.statusText,
                    headers: error.response?.headers,
                    data: error.response?.data
                }, null, 2)}`);
            }
            set.status = error.response?.status || 500;
            throw new Error(String(error));
        }
    })
    .get('/api/contact-request/org-info/:orgId', async ({ params }) => {
        try {
            const db = new Database();
            
            // Get organization info including redirect URL and signature
            const orgResult = await db.fetchOne<{ redirect_url: string | null, name: string, signature: string | null, org_settings: string | null }>(
                'SELECT redirect_url, name, signature, org_settings FROM organizations WHERE id = ?',
                [params.orgId]
            );

            if (!orgResult) {
                throw new Error('Organization not found');
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(params.orgId);

            // Try to get default agent (first admin or agent)
            const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                `SELECT first_name, last_name 
                FROM users 
                WHERE (is_admin = 1 OR is_agent = 1) 
                AND is_active = 1 
                ORDER BY is_admin DESC, id ASC 
                LIMIT 1`
            );

            if (!defaultAgent) {
                throw new Error('No active agents or admins found');
            }

            // Parse org settings to try to get signature from there first
            let orgSettings = {};
            try {
                if (orgResult.org_settings) {
                    orgSettings = JSON.parse(orgResult.org_settings);
                }
            } catch (e) {
                logger.warn(`Error parsing org settings: ${e}`);
            }

            // Prioritize signature in this order: orgSettings, signature column, org name
            const signature = (orgSettings as any)?.signature || orgResult.signature || orgResult.name;

            return {
                success: true,
                redirect_url: orgResult.redirect_url,
                agent_name: `${defaultAgent.first_name} ${defaultAgent.last_name}`,
                org_name: orgResult.name,
                signature: signature
            };
        } catch (e) {
            logger.error(`Error getting org redirect info: ${e}`);
            throw new Error(String(e));
        }
    })
    .post('/api/contact-request', async ({ body }) => {
        try {
            const { name, email, type, quoteId } = body as { 
                name: string;
                email: string;
                type: 'accept' | 'decline' | 'generic';
                quoteId?: string;
            };

            // Get contact info from quoteId if available
            let orgId: number | undefined;
            let contactId: number | undefined;
            let agentName: string | undefined;

            if (!quoteId) {
                throw new Error('Quote ID is required');
            }

            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                throw new Error('Invalid quote ID');
            }

            orgId = decoded.orgId;
            contactId = decoded.contactId;

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // If we have a contact ID, try to get the assigned agent's name
            if (contactId) {
                const contact = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT u.first_name, u.last_name 
                    FROM contacts c
                    JOIN users u ON c.agent_id = u.id
                    WHERE c.id = ? AND u.is_active = 1`,
                    [contactId]
                );
                if (contact) {
                    agentName = `${contact.first_name} ${contact.last_name}`;
                }
            }

            // If no agent assigned to contact, get default agent
            if (!agentName) {
                const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT first_name, last_name 
                    FROM users 
                    WHERE (is_admin = 1 OR is_agent = 1) 
                    AND is_active = 1 
                    ORDER BY is_admin DESC, id ASC 
                    LIMIT 1`
                );
                if (defaultAgent) {
                    agentName = `${defaultAgent.first_name} ${defaultAgent.last_name}`;
                }
            }

            // Store request in org-specific database
            await orgDb.execute(
                `INSERT INTO contact_requests (
                    name, email, request_type, contact_id, status, agent_name, created_at
                ) VALUES (?, ?, ?, ?, 'new', ?, CURRENT_TIMESTAMP)`,
                [name, email, type, contactId || null, agentName || null]
            );

            // Get org redirect URL from central database
            const db = new Database();
            const orgResult = await db.fetchOne<{ redirect_url: string | null }>(
                'SELECT redirect_url FROM organizations WHERE id = ?',
                [orgId]
            );

            return { 
                success: true,
                redirect: orgResult?.redirect_url ? { redirect_url: orgResult.redirect_url } : null
            };
        } catch (e) {
            logger.error(`Error saving contact request: ${e}`);
            throw new Error(String(e));
        }
    })
    // Add new endpoint for zip code information
    .get('/api/zipinfo/:zipCode', async ({ params }) => {
        try {
            const { zipCode } = params;
            
            // Read the zip data file from the ROOT directory, not the backend directory
            const zipDataPath = join(process.cwd(), '..', 'zipData.json');
            logger.info(`Looking for zip data at: ${zipDataPath}`);
            const zipDataContent = await readFile(zipDataPath, 'utf-8');
            const zipData = JSON.parse(zipDataContent);
            
            // Look up the zip code
            if (zipData[zipCode]) {
                return {
                    success: true,
                    data: zipData[zipCode]
                };
            } else {
                return {
                    success: false,
                    error: 'Zip code not found'
                };
            }
        } catch (error) {
            logger.error(`Error fetching zip code info: ${error}`);
            return {
                success: false,
                error: 'Failed to fetch zip code information'
            };
        }
    })
    .get('/api/quotes/debug-generate/:orgId/:contactId', async ({ params }) => {
        try {
            logger.info(`Debug endpoint - generating quote ID for org: ${params.orgId}, contact: ${params.contactId}`);
            
            const orgId = parseInt(params.orgId);
            const contactId = parseInt(params.contactId);
            
            if (isNaN(orgId) || isNaN(contactId)) {
                return {
                    success: false,
                    error: 'Invalid organization or contact ID'
                };
            }
            
            // Get org-specific database to verify the contact exists
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());
            
            // Verify contact exists
            const contact = await orgDb.fetchOne(
                'SELECT id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                // List first 5 contacts in this org for debugging
                const contacts = await orgDb.query('SELECT id FROM contacts LIMIT 5');
                logger.info(`Available contacts in org ${orgId}: ${JSON.stringify(contacts)}`);
                
                return {
                    success: false,
                    error: 'Contact not found',
                    availableContacts: contacts
                };
            }
            
            // Generate quote ID
            const quoteId = generateQuoteId(orgId, contactId);
            
            logger.info(`Generated debug quote ID: ${quoteId} for orgId: ${orgId}, contactId: ${contactId}`);

            return {
                success: true,
                quoteId,
                redirectUrl: `${process.env.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`
            };
        } catch (e) {
            logger.error(`Error in debug quote generation: ${e}`);
            return {
                success: false,
                error: String(e)
            };
        }
    });

    return app;
};

================
File: src/routes/schedule.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { decodeQuoteId } from '../utils/quoteId';

export const scheduleRoutes = (app: Elysia) => {
    app.get('/api/schedule/info/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get main database instance
            const mainDb = new Database();
            
            // Get organization info including slug
            const orgResult = await mainDb.fetchOne<{ name: string, logo_data: string | null, slug: string, phone: string | null, redirect_url: string | null, org_signature: boolean }>(
                'SELECT name, logo_data, slug, phone, redirect_url, org_signature FROM organizations WHERE id = ?',
                [orgId]
            );

            if (!orgResult) {
                set.status = 404;
                return {
                    success: false,
                    error: 'Organization not found'
                };
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Get contact information and agent_id in a single query
            const contact = await orgDb.fetchOne<{ 
                first_name: string, 
                last_name: string, 
                email: string, 
                phone_number: string, 
                agent_id: number | null 
            }>(
                'SELECT first_name, last_name, email, phone_number, agent_id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                set.status = 404;
                return {
                    success: false,
                    error: 'Contact not found'
                };
            }

            // Get agent info - first try assigned agent, then fall back to first user
            const agent = contact.agent_id 
                ? await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE id = ? AND is_active = 1',
                    [contact.agent_id]
                  )
                : await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE organization_id = ? AND is_active = 1 ORDER BY id ASC LIMIT 1',
                    [orgId]
                  );

            if (!agent) {
                set.status = 404;
                return {
                    success: false,
                    error: 'No active agents found for organization'
                };
            }

            // Return all information in a single response
            return {
                success: true,
                contact: {
                    firstName: contact.first_name,
                    lastName: contact.last_name,
                    email: contact.email,
                    phoneNumber: contact.phone_number
                },
                organization: {
                    name: orgResult.name,
                    logo: orgResult.logo_data,
                    slug: orgResult.slug,
                    phone: orgResult.phone,
                    redirectUrl: orgResult.redirect_url
                },
                agent: {
                    name: `${agent.first_name} ${agent.last_name}`,
                    firstName: agent.first_name,
                    phone: agent.phone || ""
                },
                useOrg: Boolean(orgResult.org_signature)
            };

        } catch (error) {
            logger.error(`Error getting schedule info: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    // Keep the original endpoint for backward compatibility
    app.get('/api/schedule/org-info/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get main database instance
            const mainDb = new Database();
            
            // Get organization info
            const orgResult = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                'SELECT name, logo_data FROM organizations WHERE id = ?',
                [orgId]
            );

            if (!orgResult) {
                set.status = 404;
                return {
                    success: false,
                    error: 'Organization not found'
                };
            }

            logger.info(`logo data: ${orgResult.logo_data?.slice(0, 50)}`);

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Try to get the assigned agent from the contact
            const contact = await orgDb.fetchOne<{ agent_id: number | null }>(
                'SELECT agent_id FROM contacts WHERE id = ?',
                [contactId]
            );

            // Get agent info - first try assigned agent, then fall back to first user
            const agent = contact?.agent_id 
                ? await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE id = ? AND is_active = 1',
                    [contact.agent_id]
                  )
                : await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE organization_id = ? AND is_active = 1 ORDER BY id ASC LIMIT 1',
                    [orgId]
                  );

            if (!agent) {
                set.status = 404;
                return {
                    success: false,
                    error: 'No active agents found for organization'
                };
            }

            return {
                success: true,
                orgName: orgResult.name,
                orgLogo: orgResult.logo_data,
                agentName: `${agent.first_name} ${agent.last_name}`,
                agentPhone: agent.phone || ""
            };

        } catch (error) {
            logger.error(`Error getting schedule org info: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    app.post('/api/schedule/aep-request/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Update the contact with AEP request
            await orgDb.execute(
                'UPDATE contacts SET aep_request = TRUE, aep_request_date = CURRENT_TIMESTAMP WHERE id = ?',
                [contactId]
            );

            return {
                success: true,
                message: 'AEP request recorded successfully'
            };

        } catch (error) {
            logger.error(`Error recording AEP request: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    app.post('/api/schedule/request-follow-up/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Update the contact status to requested_follow_up
            await orgDb.execute(
                'UPDATE contacts SET status = ? WHERE id = ?',
                ['requested_follow_up', contactId]
            );

            return {
                success: true,
                message: 'Follow-up request recorded successfully'
            };

        } catch (error) {
            logger.error(`Error recording follow-up request: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    return app;
};

================
File: src/routes/self-service.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import crypto from 'crypto';
import { config } from '../config';
import { generateQuoteId, decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';
import { readFileSync } from 'fs';
import { EmailService } from '../services/email';
import { get } from 'http';

// Import ZIP_DATA
interface ZipInfo {
  state: string;
  counties: string[];
}

// Import Contact type
type Contact = {
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  dateOfBirth: string;
  gender: string;
  tobacco: boolean;
  state: string;
  zipCode: string;
  currentCarrier: string | null;
  planType: string | null;
  optInQuarterlyUpdates: boolean;
};

// Load ZIP data
let ZIP_DATA: Record<string, ZipInfo> = {};
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'));
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`);
}

// Import generateHash function - reimplementing it since it's not exported from email.ts
function generateHash(orgId: string, email: string): string {
  const SECRET = process.env.HASH_SECRET || 'default-hash-secret';
  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
}

export function createSelfServiceRoutes() {
  return new Elysia()
    .get('/api/self-service/init', async ({ query, set }) => {
      // Extract query parameters
      const { orgId, email, hash } = query as { 
        orgId?: string; 
        email?: string; 
        hash?: string;
      };

      // Validate required parameters
      if (!orgId) {
        set.status = 400;
        return { error: 'orgId is required' };
      }

      // Validate hash if email is provided
      if (email && hash) {
        const expectedHash = generateHash(orgId, email);
        if (hash !== expectedHash) {
          logger.warn(`Invalid hash for email ${email} and orgId ${orgId}`);
          set.status = 403;
          return { error: 'Invalid email or hash' };
        }
      }

      try {
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        
        // If email is provided, check for existing contact
        if (email) {
          const client = orgDb.getClient();
          const result = await client.execute({
            sql: `SELECT 
                  email, 
                  first_name AS firstName, 
                  last_name AS lastName
                FROM contacts 
                WHERE email = ?`,
            args: [email]
          });

          // If contact exists, return contact details
          if (result.rows.length > 0) {
            const contact = result.rows[0];
            logger.info(`Contact found for email ${email} in organization ${orgId}`);
            return { 
              contact, 
              email, 
              emailReadOnly: true 
            };
          }

          // If no contact exists but email is provided
          logger.info(`No contact found for email ${email} in organization ${orgId}`);
          return { 
            email, 
            emailReadOnly: true 
          };
        }

        // If no email is provided
        return { emailReadOnly: false };

      } catch (error) {
        logger.error(`Error in self-service init endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    .post('/api/self-service/signup', async ({ body, set }) => {
      logger.info('Starting signup process with detailed logging...');
      logger.info(`Request body: ${JSON.stringify(body, null, 2)}`);
      
      const { orgId, email, firstName, lastName, optInQuarterlyUpdates, zipCode, dateOfBirth, gender, tobacco, phoneNumber, currentPremium, currentCarrier, planType, state, county, agentId } = body as {
        orgId: string;
        email: string;
        firstName: string;
        lastName: string;
        optInQuarterlyUpdates: boolean;
        zipCode: string;
        dateOfBirth: string;
        gender: string;
        tobacco: boolean;
        phoneNumber: string;
        currentPremium: string;
        currentCarrier: string;
        planType: string;
        state: string;
        county: string;
        agentId?: number;
      };

      logger.info(`[1/6] Validating input parameters...`);
      logger.info(`Input validation data:
        - orgId: ${orgId ? 'present' : 'missing'}
        - email: ${email ? 'present' : 'missing'}
        - firstName: ${firstName ? 'present' : 'missing'}
        - lastName: ${lastName ? 'present' : 'missing'}
        - zipCode: ${zipCode ? 'present' : 'missing'}
        - dateOfBirth: ${dateOfBirth ? 'present' : 'missing'}
        - gender: ${gender ? 'present' : 'missing'}
        - state: ${state ? 'present' : 'missing'}`
      );

      // Validate required parameters
      if (!orgId || !email || !firstName || !lastName || !zipCode || !dateOfBirth || !gender || !state) {
        const missingFields = [];
        if (!orgId) missingFields.push('orgId');
        if (!email) missingFields.push('email');
        if (!firstName) missingFields.push('firstName');
        if (!lastName) missingFields.push('lastName');
        if (!zipCode) missingFields.push('zipCode');
        if (!dateOfBirth) missingFields.push('dateOfBirth');
        if (!gender) missingFields.push('gender');
        if (!state) missingFields.push('state');
        
        logger.error(`[ERROR] Missing required fields: ${missingFields.join(', ')}`);
        set.status = 400;
        return { error: 'Missing required fields', missingFields };
      }
      
      logger.info('[2/6] All required fields present, proceeding with database connection...');

      try {
        logger.info(`[3/6] Attempting to get org database for orgId: ${orgId}`);
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        logger.info('[4/6] Successfully connected to org database');
        
        const client = orgDb.getClient();
        logger.info('[4.5/6] Successfully got database client');
        
        // Get default agent ID from organization if not provided
        const mainDb = new Database();
        const defaultAgentResult = await mainDb.fetchOne<{ default_agent_id: number }>(
          'SELECT default_agent_id FROM organizations WHERE id = ?',
          [parseInt(orgId)]
        );
        const finalAgentId = agentId || defaultAgentResult?.default_agent_id || null;
        logger.info(`Using agent ID: ${finalAgentId}`);
        
        // Check if contact already exists
        logger.info(`[5/6] Checking for existing contact with email: ${email}`);
        const existingContact = await client.execute({
          sql: 'SELECT id FROM contacts WHERE email = ?',
          args: [email]
        });
        logger.info(`[5.5/6] Existing contact check complete. Found: ${existingContact.rows.length > 0}`);

        let contactId: number;
        let isNewContact = false;

        if (existingContact.rows.length > 0) {
          // Update existing contact
          contactId = existingContact.rows[0].id;
          logger.info(`[6/6] Updating existing contact ${contactId}`);
          
          try {
            await client.execute({
              sql: `UPDATE contacts SET 
                    first_name = ?, 
                    last_name = ?,
                    phone_number = ?,
                    zip_code = ?,
                    state = ?,
                    gender = ?,
                    birth_date = ?,
                    tobacco_user = ?,
                    current_carrier = ?,
                    plan_type = ?,
                    agent_id = ?
                    WHERE id = ?`,
              args: [
                firstName, 
                lastName, 
                phoneNumber || '', 
                zipCode, 
                state,
                gender,
                dateOfBirth,
                tobacco ? 1 : 0,
                currentCarrier || '', 
                planType || null,
                finalAgentId,
                contactId
              ]
            });
            
            logger.info(`Successfully updated contact ${contactId}`);
            
          } catch (updateError) {
            logger.error(`Error updating existing contact: ${updateError}`);
            throw updateError;
          }
        } else {
          // Create new contact
          logger.info('[6/6] Creating new contact');
          isNewContact = true;
          try {
            const result = await client.execute({
              sql: `INSERT INTO contacts (
                    email, 
                    first_name, 
                    last_name,
                    phone_number,
                    zip_code,
                    state,
                    gender,
                    birth_date,
                    tobacco_user,
                    current_carrier,
                    plan_type,
                    effective_date,
                    agent_id
                  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
              args: [
                email, 
                firstName, 
                lastName, 
                phoneNumber || '', 
                zipCode, 
                state,
                gender,
                dateOfBirth,
                tobacco ? 1 : 0,
                currentCarrier || null,
                planType || null,
                new Date().toISOString().split('T')[0],
                finalAgentId
              ]
            });
            logger.info('Successfully inserted new contact');
            
            // Get the ID of the newly created contact
            logger.info('Getting ID of new contact');
            const newContactResult = await client.execute({
              sql: 'SELECT id FROM contacts WHERE email = ?',
              args: [email]
            });
            
            contactId = newContactResult.rows[0]?.id;
            logger.info(`Got new contact ID: ${contactId}`);
            
          } catch (insertError) {
            logger.error(`Error creating new contact: ${insertError}`);
            throw insertError;
          }
        }
        
        // Send email to the contact
        /*
        try {
          logger.info(`[7/6] Sending welcome email to contact ${contactId}`);

          const mainDb = new Database();  
          const mainClient = mainDb.getClient();
          
          // Get organization name
          const orgResult = await mainClient.execute({
            sql: 'SELECT name, logo_data, primary_color, phone, website FROM organizations WHERE id = ?',
            args: [orgId]
          });
          
          const orgInfo = orgResult.rows.length > 0 ? {
            name: orgResult.rows[0].name,
            logo_data: orgResult.rows[0].logo_data,
            primary_color: orgResult.rows[0].primary_color, 
            phone: orgResult.rows[0].phone,
            website: orgResult.rows[0].website
          } : undefined;
          
          // Initialize email service
          const emailService = new EmailService();

          // Generate quote ID
          const quoteId = generateQuoteId(parseInt(orgId), contactId);
          
          // Create welcome email with quote link
          const baseUrl = process.env.PUBLIC_URL || 'https://medicaremax.ai';
          const quoteUrl = `${baseUrl}/compare?id=${quoteId}`;
          await emailService.sendQuoteEmail({
            email,
            firstName,
            lastName,
            quoteUrl,
            planType: planType || 'G',
            organization: orgInfo,
            phone: phoneNumber
          });
          
          // Record the email in tracking table
          await emailService.recordEmailSend(orgDb, {
            orgId: parseInt(orgId),
            contactId,
            emailType: 'onboarding_welcome',
            sendStatus: 'sent',
            sendMode: 'production',
            batchId: crypto.randomUUID()
          });
          
          logger.info(`Welcome email sent successfully to ${email}`);
        } catch (emailError) {
          // Log but don't fail if email sending fails
          logger.error(`Error sending welcome email: ${emailError}`);
          // We still want to return success for the signup even if email fails
        }
        */
       
        // Return success response
        set.status = 200;
        return { 
          success: true,
          contactId,
          email
        };
      } catch (error) {
        logger.error(`[ERROR] Error in self-service signup endpoint: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error stack trace: ${error.stack}`);
        }
        set.status = 500;
        return { error: 'Internal server error', details: error instanceof Error ? error.message : String(error) };
      }
    })
    .post('/api/self-service/update-location', async ({ body, set }) => {
      const { orgSlug, contactId, zipCode } = body as {
        orgSlug: string;
        contactId: string;
        zipCode: string;
      };

      // Validate required parameters
      if (!orgSlug || !contactId || !zipCode) {
        set.status = 400;
        return { error: 'Missing required fields' };
      }

      try {
        // Get state and county from ZIP_DATA
        const zipInfo = ZIP_DATA[zipCode];
        if (!zipInfo) {
          set.status = 400;
          return { error: 'Invalid zip code' };
        }
        logger.info(`Zip info: ${JSON.stringify(zipInfo)}`);

        // Get organization ID from slug
        const db = new Database();
        const orgResult = await db.fetchOne<{ id: number }>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!orgResult) {
          set.status = 404;
          return { error: 'Organization not found' };
        }

        // Get organization database
        const orgDb = await Database.getOrgDb(orgResult.id.toString());
        const client = orgDb.getClient();

  

        // Use provided county or first county if only one available

        // Update contact's zip code, state and county
        await client.execute({
          sql: `UPDATE contacts SET 
                zip_code = ?
                WHERE id = ?`,
          args: [
            zipCode,
            contactId
          ]
        });

        logger.info(`Updated location for contact ${contactId} in organization ${orgSlug} to ${zipCode}, ${zipInfo.state}`);

        let output = {
          success: true,
          zipCode,
          state: zipInfo.state,
          counties: zipInfo.counties
        };

        logger.info(`Output: ${JSON.stringify(output)}`);
        set.status = 200;
        return output;

      } catch (error) {
        logger.error(`Error updating location: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    // Add a new endpoint to generate a quote for a contact
    .post('/api/self-service/generate-quote', async ({ body, set }) => {
      const { orgId, contactEmail } = body as {
        orgId: string;
        contactEmail: string;
      };

      logger.info(`Generate quote request received: orgId=${orgId}, contactEmail=${contactEmail}`);

      // Validate required parameters
      if (!orgId || !contactEmail) {
        logger.error(`Missing required fields: orgId=${orgId}, contactEmail=${contactEmail}`);
        set.status = 400;
        return { error: 'Missing required fields (orgId and contactEmail)' };
      }

      try {
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        const client = orgDb.getClient();
        
        // Lookup contact by email
        const contactResult = await client.execute({
          sql: 'SELECT id FROM contacts WHERE email = ?',
          args: [contactEmail]
        });

        if (contactResult.rows.length === 0) {
          logger.error(`Contact not found for email ${contactEmail} in organization ${orgId}`);
          set.status = 404;
          return { error: 'Contact not found' };
        }

        const contactId = contactResult.rows[0].id;
        logger.info(`Found contact ID ${contactId} for email ${contactEmail} in organization ${orgId}`);
        
        // Generate quote ID using the proper utility function (with base36 encoding)
        const quoteId = generateQuoteId(parseInt(orgId), contactId);
        
        // Get plan type from contact
        let planType = 'MedSupp';
        try {
          const planTypeResult = await client.execute({
            sql: 'SELECT plan_type FROM contacts WHERE id = ?',
            args: [contactId]
          });
          
          if (planTypeResult.rows.length > 0 && planTypeResult.rows[0].plan_type) {
            planType = planTypeResult.rows[0].plan_type;
          } else {
            // Default to MedSupp if no plan type is set
            planType = 'MedSupp';
          }
          logger.info(`Found plan type ${planType} for contact ${contactId}`);
        } catch (error) {
          logger.warn(`Could not get plan type for contact ${contactId}: ${error}`);
          // Continue with default plan type
        }
        
        // Build redirect URL with just the quote ID
        const redirectUrl = `${config.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`;
        
        // Log response details
        logger.info(`Generated quote ID: ${quoteId}`);
        logger.info(`Redirect URL: ${redirectUrl}`);

        // Return successful response with quote information
        set.status = 200;
        return {
          success: true,
          contactId,
          quoteId,
          redirectUrl
        };
      } catch (error) {
        logger.error(`Error generating quote ID: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    .get('/api/self-service-info', async ({ params, set, request }) => {
      const userFromSession = await getUserFromSession(request);
    
      // Get organization from central database
      const db = new Database();
      const orgResult = await db.fetchOne<{ id: number, slug: string, logo_data: string | null }>(
        'SELECT id, slug, logo_data FROM organizations WHERE id = ?',
        [userFromSession?.organization_id]
      );

      // logger.info(`Org result: ${JSON.stringify(orgResult)}`);
      
      if (!orgResult) {
        set.status = 404;
        return { success: false, message: 'Organization not found' };
      }
      
      return {
        success: true,
        orgId: userFromSession?.organization_id.toString(),
        orgSlug: orgResult.slug,
        selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgResult.slug}`,
        logo: orgResult.logo_data
      };  
    })
    .get('/api/self-service/:orgSlug', async ({ params, query, set, request }) => {
      const { orgSlug } = params;
      const { email, id } = query as { email?: string; id?: string };
      
      
      logger.info(`Self-service request for orgSlug=${orgSlug}, email=${email || 'none'}, quoteId=${id || 'none'}`);
      
      try {
        // For the 'latest' slug, get the current user's organization
        if (orgSlug === 'latest') {
          const userFromSession = await getUserFromSession(request);
          logger.info(`User from session: ${JSON.stringify(userFromSession)}`);
          // Add type guard to check for organization_id
          if (!userFromSession || !('organization_id' in userFromSession) || !userFromSession.organization_id) {
            set.status = 401;
            return { success: false, error: 'Unauthorized' };
          }
          
          // Get organization from central database
          const db = new Database();
          const orgResult = await db.fetchOne<{ id: number, slug: string, logo_data: string | null }>(
            'SELECT id, slug, logo_data FROM organizations WHERE id = ?',
            [userFromSession.organization_id]
          );

          logger.info(`Org result: ${JSON.stringify(orgResult)}`);
          
          if (!orgResult) {
            set.status = 404;
            return { success: false, message: 'Organization not found' };
          }
          
          return {
            success: true,
            orgId: userFromSession.organization_id.toString(),
            orgSlug: orgResult.slug,
            selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgResult.slug}`,
            logo: orgResult.logo_data
          };
        }
        
        // Regular slug lookup
        const db = new Database();
        const result = await db.query(
          'SELECT id, name, logo_data FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!result || result.length === 0) {
          set.status = 404;
          return { success: false, message: 'Organization not found' };
        }

        const orgId = result[0].id;
        logger.info(`orgId: ${orgId}`);
        const orgIdStr = orgId.toString();
        const logo = result[0].logo_data;
        logger.info(`logo data: ${logo?.slice(0, 50)}`);
        const orgName = result[0].name;
        // Create response object with organization info
        const response = {
          success: true,
          orgId: orgIdStr,
          orgSlug,
          selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgSlug}`,
          logo,
          orgName
        };
        
        // Try to find contact information if email or quoteId provided
        if (email || id) {
          try {
            const orgDb = await Database.getOrgDb(orgIdStr);
            const client = orgDb.getClient();
            let contactResult;
            
            // First try by email if provided
            if (email) {
              logger.info(`Looking up contact by email: ${email}`);
              contactResult = await client.execute({
                sql: `SELECT 
                  id,
                  email, 
                  first_name AS firstName, 
                  last_name AS lastName,
                  phone_number AS phone,
                  zip_code AS zipCode,
                  state,
                  gender,
                  birth_date AS dateOfBirth,
                  tobacco_user AS tobacco,
                  current_carrier AS currentCarrier,
                  plan_type AS planType
                FROM contacts 
                WHERE email = ?`,
                args: [email]
              });
            }
            
            // If no results and we have a quoteId, try that
            if ((!contactResult || contactResult.rows.length === 0) && id) {
              try {
                logger.info(`Looking up contact by quoteId: ${id}`);
                // Decode the quoteId using our utility function
                const decoded = decodeQuoteId(id);
                if (decoded) {
                  const contactId = decoded.contactId;
                  
                  contactResult = await client.execute({
                    sql: `SELECT 
                      id,
                      email, 
                      first_name AS firstName, 
                      last_name AS lastName,
                      phone_number AS phone,
                      zip_code AS zipCode,
                      state,
                      gender,
                      birth_date AS dateOfBirth,
                      tobacco_user AS tobacco,
                      current_carrier AS currentCarrier,
                      plan_type AS planType
                    FROM contacts 
                    WHERE id = ?`,
                    args: [contactId]
                  });
                }
              } catch (err) {
                logger.warn(`Error decoding quoteId ${id}: ${err}`);
              }
            }
            
            // If we found a contact, add it to the response
            if (contactResult && contactResult.rows.length > 0) {
              const contact = contactResult.rows[0];
              // Convert tobacco_user from number to boolean
              contact.tobacco = contact.tobacco === 1;
              
              logger.info(`Found contact for ${email || id}`);
              let output = {
                ...response,
                contact: {
                  ...contact,
                  id: contactResult.rows[0].id
                }
              };
              logger.info(`Output: ${JSON.stringify(output)}`);
              return output;
            }
          } catch (contactError) {
            logger.error(`Error looking up contact: ${contactError}`);
            // Continue without contact info
          }
        }
        
        // Return basic organization info for the frontend if no contact was found
        return response;
      } catch (error) {
        logger.error(`Error in self-service org slug endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    });
}

================
File: src/routes/settings.ts
================
import { Elysia } from 'elysia';
import { validateSession } from '../services/auth';
import { Database } from '../database';
import { type User, type BaseSettings } from '../types';
import { logger } from '../logger';
import { cookie } from '@elysiajs/cookie';

interface StateCarrierSetting {
  state: string;
  carrier: string;
  active: boolean;
  targetGI: boolean;
}

interface SettingsBody {
    settings?: BaseSettings;
    inheritOrgSettings?: boolean;
}

interface AgentSettingsResponse {
  orgSettings: BaseSettings;
  agentSettings: {
    inheritOrgSettings: boolean;
    settings: BaseSettings;
  } | null;
  canEditOrgSettings: boolean;
}

const defaultSettings: BaseSettings = {
    stateLicenses: [],
    carrierContracts: [],
    stateCarrierSettings: [],
    allowAgentSettings: false,
    emailSendBirthday: false,
    emailSendPolicyAnniversary: false,
    emailSendAep: false,
    smartSendEnabled: false,
    brandName: "",
    logo: null,
    orgSignature: false,
    signature: ""
};

// Helper function to generate default state/carrier settings
function generateDefaultStateCarrierSettings(states: string[], carriers: string[]): StateCarrierSetting[] {
  return states.flatMap(state => 
    carriers.map(carrier => ({
      state,
      carrier,
      active: true,  // Default to active
      targetGI: false  // Default to no GI
    }))
  );
}

export const settingsRoutes = new Elysia()
  .get('/api/settings', async ({ cookie }) => {
    logger.info('GET /api/settings - Starting');
    
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization settings, logo, and name
        const orgRow = await db.fetchOne<{ org_settings: string | null, logo_data: string | null, name: string, org_signature: boolean, phone: string | null, redirect_url: string | null, signature: string | null }>(
            'SELECT org_settings, logo_data, name, org_signature, phone, redirect_url, signature FROM organizations WHERE id = ?',
            [user.organization_id]
        );
        
        logger.info(`Retrieved org settings row`);

        // Parse the JSON string into an object
        let orgSettings: BaseSettings;
        try {
            orgSettings = orgRow?.org_settings 
                ? { ...defaultSettings, ...JSON.parse(orgRow.org_settings) }
                : { ...defaultSettings };

            // Prioritize signature, then fall back to organization name
            if (!orgSettings.signature && orgRow?.signature) {
                orgSettings.signature = orgRow.signature;
            }
            
            // If signature is still not set, use organization name
            if (!orgSettings.signature && orgRow?.name) {
                orgSettings.signature = orgRow.name;
            }

            // If brandName is not set in settings, use the organization name
            if (!orgSettings.brandName && orgRow?.name) {
                orgSettings.brandName = orgRow.name;
            }

            // Add phone and redirectUrl from database columns if available
            if (orgRow?.phone) {
                orgSettings.phone = orgRow.phone;
            }
            
            if (orgRow?.redirect_url) {
                orgSettings.redirectUrl = orgRow.redirect_url;
            }
            
            // If we have states and carriers but no settings array, generate them
            if (orgSettings.stateLicenses.length > 0 && 
                orgSettings.carrierContracts.length > 0 && 
                !Array.isArray(orgSettings.stateCarrierSettings)) {
                
                logger.info('Generating default state/carrier settings');
                orgSettings.stateCarrierSettings = generateDefaultStateCarrierSettings(
                    orgSettings.stateLicenses,
                    orgSettings.carrierContracts
                );
            }
        } catch (parseError) {
            logger.error(`Error parsing org settings: ${parseError}`);
            orgSettings = { ...defaultSettings };
        }

        // Get agent settings if they exist
        const agentSettingsRow = await db.fetchOne<{ inherit_org_settings: boolean, settings: string | null }>(
            'SELECT inherit_org_settings, settings FROM agent_settings WHERE agent_id = ?',
            [user.id]
        );

        // Parse agent settings
        let agentSettings = null;
        if (agentSettingsRow) {
            try {
                const parsedSettings = agentSettingsRow.settings 
                    ? { ...defaultSettings, ...JSON.parse(agentSettingsRow.settings) }
                    : { ...defaultSettings };

                agentSettings = {
                    inheritOrgSettings: agentSettingsRow.inherit_org_settings,
                    settings: parsedSettings
                };
            } catch (parseError) {
                logger.error(`Error parsing agent settings: ${parseError}`);
            }
        }

        const canEditOrgSettings = user.is_admin;

        const response = {
            success: true,
            name: orgRow?.name || null,
            orgSettings,
            logo: orgRow?.logo_data || null,
            orgSignature: orgRow?.org_signature || false,
            agentSettings,
            canEditOrgSettings
        };

        logger.info(`Sending response`);
        return response;

    } catch (error) {
        logger.error(`Error fetching settings: ${error}`);
        return {
            success: false,
            error: 'Failed to load settings'
        };
    }
  })

  .put('/api/settings/:scope', async ({ cookie, body, params }) => {
    const { scope } = params;
    logger.info(`PUT /api/settings/${scope} - Starting`);
    
    const user = await validateSession(cookie?.session?.toString() || '');
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization's subscription tier
        const orgRow = await db.fetchOne<{ subscription_tier: string }>(
            'SELECT subscription_tier FROM organizations WHERE id = ?',
            [user.organization_id]
        );

        const isBasicTier = orgRow?.subscription_tier === 'basic';
        const typedBody = body as SettingsBody;

        if (scope === 'org') {
            logger.info('Updating organization settings');
            logger.info(`Organization settings body: ${JSON.stringify(typedBody, null, 2)}`);
            
            // Extract logo from settings if it exists
            const settingsObj = typedBody.settings || typedBody;
            const name = 'name' in settingsObj ? settingsObj.name : null;
            const logo = 'logo' in settingsObj ? settingsObj.logo : null;
            const orgSignature = 'orgSignature' in settingsObj ? settingsObj.orgSignature : false;
            const phone = 'phone' in settingsObj ? settingsObj.phone : null;
            const redirectUrl = 'redirectUrl' in settingsObj ? settingsObj.redirectUrl : null;
            const signature = 'signature' in settingsObj ? settingsObj.signature : null;
            const settingsWithoutLogo = { ...settingsObj };
            if ('logo' in settingsWithoutLogo) {
                delete (settingsWithoutLogo as any).logo;
            }
            
            // Update organization settings and logo separately
            await db.execute(
                'UPDATE organizations SET org_settings = ?, logo_data = ?, name = ?, org_signature = ?, phone = ?, redirect_url = ?, signature = ? WHERE id = ?',
                [JSON.stringify(settingsWithoutLogo), logo || null, name || null, orgSignature, 
                 orgSignature ? phone : null, orgSignature ? redirectUrl : null, orgSignature ? signature : null, user.organization_id]
            );

            
        } else if (scope === 'agent') {
            // For basic tier, don't allow direct agent settings updates
            if (isBasicTier) {
                return {
                    success: false,
                    error: 'Agent settings cannot be modified directly in basic tier - update organization settings instead'
                };
            }

            logger.info('Updating agent settings');
            logger.info(`Agent settings body: ${JSON.stringify(typedBody, null, 2)}`);

            try {
                await db.execute(
                    `INSERT INTO agent_settings (agent_id, inherit_org_settings, settings)
                     VALUES (?, ?, ?)
                     ON CONFLICT (agent_id) DO UPDATE
                     SET inherit_org_settings = ?, settings = ?`,
                    [
                        user.id,
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings),
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings)
                    ]
                );
                logger.info('Agent settings updated successfully');
            } catch (dbError) {
                logger.error(`Database execute error details: ${JSON.stringify(dbError, null, 2)}`);
                throw dbError;
            }
        }
        logger.info('Settings updated successfully');
        return {
            success: true,
            settings: typedBody.settings || typedBody,
            error: null
        };
    } catch (error) {
        logger.error(`Error updating settings: ${error}`);
        logger.error(`Error stack: ${(error as Error).stack}`);
        return {
            success: false,
            error: 'Failed to update settings'
        };
    }
  })

  // Update the GI recommendations endpoint to use Elysia style
  .get('/api/settings/gi-recommendations', async ({ cookie }) => {
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const recommendations = await db.fetchAll(
        `SELECT state, carrier
         FROM guaranteed_issue_recommendations
         ORDER BY carrier, state`
      );

      // Transform the results to match the expected format
      const formattedRecommendations = recommendations.map((rec: { state: string; carrier: string }) => ({
        state: rec.state,
        carrier: rec.carrier,
        active: true,
        targetGI: true
      }));

      return formattedRecommendations;

    } catch (error) {
      logger.error(`Error fetching GI recommendations: ${error}`);
      return { success: false, error: 'Failed to fetch GI recommendations' };
    }
  })

  // Fetch the logo for the organization
  .get('/api/settings/logo', async ({ cookie }) => {
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const logo = await db.fetchOne<{ logo_data: string | null }>(
        'SELECT logo_data FROM organizations WHERE id = ?',
        [user.organization_id]
      );

      if (!logo) {
        return { success: false, error: 'Organization not found' };
      }

      return {
        success: true,
        logo: logo.logo_data
      };

    } catch (error) {
      logger.error(`Error fetching organization logo: ${error}`);
      return { success: false, error: 'Failed to fetch organization logo' };
    }
  })
  .get('/api/settings/:orgId/logo', async ({ params }) => {
    const { orgId } = params;
    const db = new Database();

    try {
      const logo = await db.fetchOne<{ logo_data: string | null }>(
        'SELECT logo_data FROM organizations WHERE id = ?',
        [orgId]
      );

      if (!logo) {
        return { success: false, error: 'Organization logo not found' }; 
      }

      return {
        success: true,
        logo: logo.logo_data
      };
    } catch (error) {
      logger.error(`Error fetching organization logo: ${error}`);
      return { success: false, error: 'Failed to fetch organization logo' };
    }
  })
  

  // Update carriers endpoint to use Elysia style
  .get('/api/settings/carriers', async ({ cookie }) => {
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll(
        `SELECT name
         FROM carriers
         ORDER BY name`
      );

      return carriers;

    } catch (error) {
      logger.error(`Error fetching carriers: ${error}`);
      return { success: false, error: 'Failed to fetch carriers' };
    }
  })

  .get('/api/settings/carriers-with-aliases', async ({ cookie }) => {
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll(
        `SELECT name, aliases
         FROM carriers
         ORDER BY name`
      );

      return carriers.map((carrier: { name: string, aliases: string | null }) => ({
        name: carrier.name,
        aliases: carrier.aliases ? JSON.parse(carrier.aliases) : []
      }));

    } catch (error) {
      logger.error(`Error fetching carriers with aliases: ${error}`);
      return { success: false, error: 'Failed to fetch carriers with aliases' };
    }
  });

================
File: src/routes/signup.ts
================
import { Elysia } from 'elysia';
import { logger } from '../logger';
import { Database } from '../database';
import { EmailService } from '../services/email';
import { AuthService } from '../services/auth';
import { cookie } from '@elysiajs/cookie';

// Enhanced slug generation with uniqueness check
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

// Create a standalone email check handler that doesn't require authentication
// This function can be directly mounted at the root level
export async function checkEmailHandler({ params, set }: { params: { email: string }, set: { status: number } }) {
  try {
    const { email } = params;
    const dbInstance = new Database();
    
    logger.info(`Public email check for: "${email}"`);
    
    if (!email || !email.trim()) {
      set.status = 400;
      return {
        available: false,
        message: 'Email is required'
      };
    }
    
    // Basic email format validation
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      logger.info(`Email validation failed for: "${email}"`);
      return {
        available: false,
        message: 'Invalid email format'
      };
    }
    
    // Check if email already exists
    const existingUser = await dbInstance.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
      [email]
    );
    
    const count = existingUser[0]?.count || 0;
    logger.info(`Email check query result count: ${count} for email: "${email}"`);
    
    if (count > 0) {
      logger.info(`Email "${email}" is already registered`);
      return {
        available: false,
        message: 'This email address is already registered'
      };
    }
    
    logger.info(`Email "${email}" is available`);
    return {
      available: true,
      message: 'Email is available'
    };
    
  } catch (error) {
    logger.error(`Error checking email availability: ${error}`);
    set.status = 500;
    return {
      available: false,
      message: 'Failed to check email availability'
    };
  }
}

// Simple function to validate the token structure without strict verification
// For signup flow, we're just making sure the token format is valid
const validateSignupToken = (token: string): boolean => {
  try {
    // Token should have the format stored in our magic link
    const parts = token.split(':');
    return parts.length >= 2; // At minimum should have IV and encrypted data parts
  } catch (error) {
    logger.error(`Error validating signup token: ${error}`);
    return false;
  }
};

export function createSignupRoutes() {
  const dbInstance = new Database();
  const emailService = new EmailService();
  const authService = new AuthService();

  return new Elysia()
    .use(cookie())
    
    // New route for handling signup verification that just redirects to onboarding
    .get('/signup/verify', async ({ query, set }) => {
      try {
        // Extract query parameters
        const { token } = query as { 
          token: string, 
        };
        
        logger.info(`Processing signup verification for token: ${token}`);
        
        if (!token) {
          logger.warn('Missing token in signup verification');
          set.status = 400;
          set.redirect = '/signup';
          return { error: 'Invalid verification link' };
        }
        
        // Verify the token format is valid - simpler check for signup flow
        const { valid, email, redirectUrl } = await authService.verifySignupLink(token);
        
        logger.info(`Signup verified successfully, redirecting to: ${redirectUrl}`);
        set.redirect = redirectUrl;
        
        return {
          success: true,
          message: 'Email verified successfully'
        };
        
      } catch (error) {
        logger.error(`Error processing signup verification: ${error}`);
        set.status = 500;
        set.redirect = '/signup';
        return {
          success: false,
          message: 'Failed to verify email'
        };
      }
    })
    
    // Simplified signup process - only validate and send magic link
    .post('/api/signup', async ({ body, set }) => {
      try {
        const { name, email } = body as { name: string, email: string };
        
        logger.info(`Processing signup for name: "${name}", email: "${email}"`);
        
        if (!name || !name.trim() || !email || !email.trim()) {
          set.status = 400;
          return {
            success: false,
            message: 'Name and email are required'
          };
        }
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          logger.info(`Email validation failed for: "${email}"`);
          set.status = 400;
          return {
            success: false,
            message: 'Invalid email format'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        if (existingUser[0]?.count > 0) {
          logger.info(`Email "${email}" is already registered`);
          set.status = 400;
          return {
            success: false,
            message: 'This email address is already registered'
          };
        }
        
        // Split name into first and last
        const nameParts = name.trim().split(' ');
        const firstName = nameParts[0];
        const lastName = nameParts.length > 1 ? nameParts.slice(1).join(' ') : '';
        
        // Generate magic link with user info in query parameters
        const magicLink = await authService.createSignupLink(
          email,
          { 
            // Use signup-verify instead of auth/verify to use a different flow
            redirectUrl: `/onboarding?firstName=${encodeURIComponent(firstName)}&lastName=${encodeURIComponent(lastName)}&email=${encodeURIComponent(email)}` 
          }
        );
        
        // Send the email with magic link
        await emailService.sendMagicLink(email, magicLink, firstName);
        
        logger.info(`Sent signup magic link to ${email}`);
        
        set.status = 201;
        return {
          success: true,
          message: 'Please check your email to continue with account setup.'
        };
        
      } catch (error) {
        logger.error(`Error processing signup: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to create account'
        };
      }
    });
}

================
File: src/routes/stripe.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { config } from '../config';
import { getUserFromSession } from '../services/auth';
import { requireAuth } from '../middleware/auth';
import { checkPaymentStatus } from '../services/stripe';
import crypto from 'crypto';
import { cookie } from '@elysiajs/cookie';  

interface SubscriptionStatus {
  isActive: boolean;
  tier: string;
  currentPeriodEnd?: number;
  cancelAtPeriodEnd?: boolean;
  paymentStatus: string;
}

export const createStripeRoutes = (app: Elysia) => {
  app.use(requireAuth)
    .get('/api/stripe/subscription-status', async ({ user, set }) => {
      try {
        if (!user?.organization_id) {
          logger.info('No organization ID in request');
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const db = new Database();
        const status = await checkPaymentStatus(db, user.organization_id);
        logger.info(`Returning subscription status: ${JSON.stringify(status)}`);
        
        return {
          success: true,
          data: status as SubscriptionStatus
        };
      } catch (error) {
        logger.error(`Error in subscription status route: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to fetch subscription status',
          details: error instanceof Error ? error.message : 'Unknown error'
        };
      }
    });
    
  // Create separate instance without auth middleware for the payment-complete endpoint
  app.use(cookie())
    .post('/api/stripe/payment-complete', async ({ body, set, setCookie }) => {
      try {
        const { 
          email: encodedEmail, 
          firstName, 
          lastName,
          stripeCustomerId,
          stripeSubscriptionId,
          stripeUsageItemId
        } = body as { 
          email: string;
          firstName: string;
          lastName: string;
          stripeCustomerId?: string;
          stripeSubscriptionId?: string;
          stripeUsageItemId?: string;
        };

        // Decode the email in case it contains URL-encoded characters
        const email = decodeURIComponent(encodedEmail);

        logger.info(`Processing payment completion for email: ${email}`);
        logger.info(`Payment data: StripeCustomer=${stripeCustomerId ? (typeof stripeCustomerId === 'string' ? stripeCustomerId.substring(0, 10) + '...' : 'object') : 'missing'}, StripeSubscription=${stripeSubscriptionId ? (stripeSubscriptionId && typeof stripeSubscriptionId === 'string' ? stripeSubscriptionId.substring(0, 10) + '...' : 'object') : 'missing'}, UsageItem=${stripeUsageItemId ? (typeof stripeUsageItemId === 'string' ? stripeUsageItemId.substring(0, 10) + '...' : 'object') : 'missing'}`);

        const db = new Database();
        const client = db.getClient();

        // First get the user and organization
        logger.info(`Looking up user record for email: ${email}`);
        const userResult = await client.execute({
          sql: 'SELECT users.id, users.organization_id FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        logger.info(`User query returned ${userResult.rows.length} rows`);
        
        if (userResult.rows.length === 0) {
          logger.error(`No active user found for email: ${email}`);
          // Let's try a case-insensitive search as a fallback
          logger.info(`Trying case-insensitive search for email: ${email}`);
          const caseInsensitiveResult = await client.execute({
            sql: 'SELECT users.id, users.organization_id FROM users WHERE LOWER(email) = LOWER(?) AND is_active = 1',
            args: [email]
          });
          
          if (caseInsensitiveResult.rows.length === 0) {
            logger.error(`Still no user found with case-insensitive search for email: ${email}`);
            set.status = 404;
            return { success: false, error: 'User not found' };
          } else {
            logger.info(`Found user with case-insensitive match: ${caseInsensitiveResult.rows[0].id}`);
            // Continue with the found user
            userResult.rows = caseInsensitiveResult.rows;
          }
        }

        const userId = userResult.rows[0].id;
        const organizationId = userResult.rows[0].organization_id;
        logger.info(`Found user ID: ${userId}, organization ID: ${organizationId}`);

        // Construct the SQL update based on available Stripe data
        let sql = `UPDATE organizations 
                  SET payment_completed = 1, 
                      subscription_status = 'active',
                      onboarding_completed = TRUE`;
        
        const args = [];
        
        if (stripeCustomerId) {
          sql += ', stripe_customer_id = ?';
          args.push(stripeCustomerId);
        }
        
        if (stripeSubscriptionId) {
          sql += ', stripe_subscription_id = ?';
          args.push(typeof stripeSubscriptionId === 'object' ? JSON.stringify(stripeSubscriptionId) : stripeSubscriptionId);
        }
        
        if (stripeUsageItemId) {
          sql += ', stripe_usage_item_id = ?';
          args.push(typeof stripeUsageItemId === 'object' ? JSON.stringify(stripeUsageItemId) : stripeUsageItemId);
        }
        
        sql += ' WHERE id = ?';
        args.push(organizationId);

        // Update organization with payment and Stripe info
        logger.info(`Updating organization ${organizationId} with payment data`);
        const updateResult = await client.execute({ sql, args });
        logger.info(`Organization update affected ${updateResult.rowsAffected} rows`);

        // Create a new session
        const sessionId = crypto.randomBytes(32).toString('hex');
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

        logger.info(`Creating new session for user ${userId}: ${sessionId.substring(0, 16)}...`);
        const sessionResult = await client.execute({
          sql: 'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
          args: [sessionId, userId, expiresAt.toISOString()]
        });
        logger.info(`Session creation affected ${sessionResult.rowsAffected} rows`);

        // Set the session cookie
        logger.info(`Setting session cookie with expiry: ${expiresAt.toISOString()}`);
        setCookie('session', sessionId, {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 1 // 1 day -- shorter to force them to login again soon after onboarding
        });
        logger.info(`Session cookie set successfully`);

        // Get the subscription status to return to client
        logger.info(`Fetching subscription status for organization ${organizationId}`);
        const status = await checkPaymentStatus(db, organizationId);
        logger.info(`Subscription status: ${JSON.stringify(status)}`);

        logger.info(`Successfully completed payment setup for user ${userId} in organization ${organizationId}`);
        
        set.status = 200;
        return {
          success: true,
          data: status
        };

      } catch (error) {
        logger.error(`Error in payment completion: ${error}`);
        if (error instanceof Error && error.stack) {
          logger.error(`Stack trace: ${error.stack}`);
        }
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to complete payment setup',
          details: error instanceof Error ? error.message : 'Unknown error'
        };
      }
    });

  return app;
};

================
File: src/routes/waitlist.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { cors } from '@elysiajs/cors';
import sgMail from '@sendgrid/mail';

// Types for request body
interface WaitlistEntry {
    name: string;
    email: string;
    phone: string;
    numAgents: string;
    bookSize: string;
}

// Validation functions
function validateEmail(email: string): boolean {
    const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    return emailRegex.test(email.trim());
}

function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
    const digits = phone.replace(/\D/g, '').slice(0, 10);
    return {
        isValid: digits.length === 10,
        standardized: digits
    };
}

export const createWaitlistRoutes = () => {
    const app = new Elysia({ prefix: '/api/waitlist' })
    .use(cors({
        origin: process.env.NODE_ENV === 'development' 
            ? 'http://localhost:5173' 
            : false,
        methods: ['POST', 'OPTIONS'],
        allowedHeaders: ['Content-Type'],
        credentials: false  // Don't require credentials for waitlist
    }));
    
    const db = new Database(); // Create a new instance of the main database

    // Initialize SendGrid
    if (!process.env.SENDGRID_API_KEY) {
        throw new Error('Missing SENDGRID_API_KEY environment variable');
    }
    sgMail.setApiKey(process.env.SENDGRID_API_KEY);

    app.post('/', async ({ body, set }: { body: WaitlistEntry, set: any }) => {
        try {
            logger.info(`Received waitlist submission: ${JSON.stringify(body)}`);
            const { name, email, phone, numAgents, bookSize } = body;

            // Validate inputs
            if (!name || typeof name !== 'string' || name.trim().length === 0) {
                logger.warn(`Invalid name: ${name}`);
                set.status = 400;
                return { success: false, message: 'Name is required' };
            }

            if (!email || typeof email !== 'string' || !validateEmail(email)) {
                logger.warn(`Invalid email: ${email}`);
                set.status = 400;
                return { success: false, message: 'Invalid email format' };
            }

            const phoneResult = standardizePhoneNumber(phone);
            if (!phoneResult.isValid) {
                logger.warn(`Invalid phone: ${phone}`);
                set.status = 400;
                return { success: false, message: 'Phone number must be 10 digits' };
            }

            if (!numAgents || isNaN(Number(numAgents)) || Number(numAgents) <= 0) {
                logger.warn(`Invalid numAgents: ${numAgents}`);
                set.status = 400;
                return { success: false, message: 'Number of agents must be a positive number' };
            }

            if (!bookSize || isNaN(Number(bookSize)) || Number(bookSize) <= 0) {
                logger.warn(`Invalid bookSize: ${bookSize}`);
                set.status = 400;
                return { success: false, message: 'Book size must be a positive number' };
            }

            // Check if email exists first to determine if this is an update
            const existing = await db.execute(
                'SELECT id FROM waitlist WHERE email = ?',
                [email.trim()]
            );
            const isUpdate = existing.rows && existing.rows.length > 0;

            // Insert or update waitlist entry
            logger.info('Upserting waitlist entry');
            const upsertResult = await db.execute(`
                INSERT INTO waitlist (name, email, phone, num_agents, book_size)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(email) DO UPDATE SET
                    name = EXCLUDED.name,
                    phone = EXCLUDED.phone,
                    num_agents = EXCLUDED.num_agents,
                    book_size = EXCLUDED.book_size,
                    updated_at = CURRENT_TIMESTAMP
            `, [
                name.trim(),
                email.trim(),
                phoneResult.standardized,
                Number(numAgents),
                Number(bookSize)
            ]);

            logger.info(`Upsert result: ${JSON.stringify(upsertResult)}`);

            // Send confirmation email
            try {
                await sgMail.send({
                    to: email.trim(),
                    from: {
                        email: process.env.HELLO_EMAIL || 'information@medicaremax.ai',
                        name: 'Medicare Max'
                    },
                    replyTo: process.env.HELLO_EMAIL || 'information@medicaremax.ai',
                    subject: "You're In. Time to Max What's Yours.",
                    text: `Hey ${name.trim()},

You made it on the Medicare Max waitlistand not a moment too soon. 

You're doing the work, building the book, and watching revenue slip through the cracks. That stops here.

It's time to keep more, earn smarter, and finally get what's yours.

Early access is on the way. Stay ready.

Have questions? Just reply to this email and we'll get back to you.

Cheers,
THe Medicare Max Team`,
                    html: `
                        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #ffffff; padding: 40px 20px;">
                            <div style="text-align: center; margin-bottom: 30px;">
                                <a href="https://medicaremax.ai" style="text-decoration: none; display: inline-block;">
                                    <img src="https://medicaremax.ai/images/medicare-max-logo.png" alt="Medicare Max Logo" style="height: 40px; margin: 0 auto;">
                                </a>
                            </div>
                            <div style="background-color: #f0f9ff; border-radius: 12px; padding: 30px; margin: 20px 0;">
                                <h2 style="color: #03045E; font-size: 24px; margin-bottom: 20px;">Hey ${name.trim()},</h2>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                                    You made it on the Medicare Max waitlistand not a moment too soon.
                                </p>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                                    You're doing the work, building the book, and watching revenue slip through the cracks. That stops here.
                                </p>
                                <div style="text-align: center;">
                                    <div style="background-color: #03045E; color: white; padding: 15px 25px; border-radius: 8px; display: inline-block; margin: 20px 0;">
                                        <span style="font-size: 20px; vertical-align: middle; margin-right: 8px;"></span>
                                        <span style="vertical-align: middle;">Time to max what's yours</span>
                                    </div>
                                </div>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                                    It's time to keep more, earn smarter, and finally get what's yours.
                                </p>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                                    Early access is on the way. Stay ready.
                                </p>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-top: 20px; font-style: italic;">
                                    Have questions? Just reply to this email and we'll get back to you.
                                </p>
                            </div>
                            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center;">
                                <p style="color: #6b7280; font-size: 14px;">
                                    Cheers,<br>
                                    The Medicare Max Team
                                </p>
                            </div>
                        </div>
                    `
                });
                logger.info(`Confirmation email sent to ${email}`);
            } catch (emailError) {
                // Log the error but don't fail the request
                logger.error(`Failed to send confirmation email: ${emailError instanceof Error ? emailError.message : String(emailError)}`);
            }

            // Explicitly set success status
            set.status = 200;
            
            return { 
                success: true, 
                message: isUpdate ? 'Successfully updated your waitlist entry' : 'Successfully joined waitlist'
            };
        } catch (error) {
            logger.error(`Waitlist error: ${error instanceof Error ? error.message : String(error)}`);
            set.status = 500;
            return { 
                success: false, 
                message: 'Internal server error' 
            };
        }
    });

    return app;
};

================
File: src/scripts/apply_nullable_fields_migration.ts
================
/**
 * Script to apply the make_optional_fields_nullable migration to all organizations
 * 
 * Usage: 
 * bun run backend/src/scripts/apply_nullable_fields_migration.ts
 */

import fs from 'fs';
import path from 'path';
import { Database } from '../database';
import { logger } from '../logger';

const migrationPath = path.resolve(__dirname, '../../../backend/migrations/20250425_make_optional_fields_nullable.sql');

if (!fs.existsSync(migrationPath)) {
  logger.error(`Migration file not found: ${migrationPath}`);
  process.exit(1);
}

const migrationSQL = fs.readFileSync(migrationPath, 'utf-8');

// Function to split SQL dump into individual statements
// This handles SQL statements more precisely than just splitting on semicolons
function splitSqlStatements(sql: string): string[] {
  const statements: string[] = [];
  let currentStatement = "";
  let inString = false;
  let inComment = false;
  let inBlockComment = false;
  let stringQuote: string | null = null;

  for (let i = 0; i < sql.length; i++) {
    const char = sql[i];
    const nextChar = i + 1 < sql.length ? sql[i + 1] : null;

    // Handle comments
    if (!inString) {
      if (char === "-" && nextChar === "-" && !inBlockComment) {
        inComment = true;
        i++; // Skip next char
        currentStatement += char + nextChar;
        continue;
      }
      if (char === "/" && nextChar === "*" && !inComment) {
        inBlockComment = true;
        i++;
        currentStatement += char + nextChar;
        continue;
      }
      if (inComment && char === "\n") {
        inComment = false;
        currentStatement += char;
        continue;
      }
      if (inBlockComment && char === "*" && nextChar === "/") {
        inBlockComment = false;
        i++;
        currentStatement += char + nextChar;
        continue;
      }
      if (inComment || inBlockComment) {
        currentStatement += char;
        continue;
      }
    }

    // Handle string literals
    if ((char === "'" || char === '"') && !inComment && !inBlockComment) {
      if (!inString) {
        inString = true;
        stringQuote = char;
      } else if (char === stringQuote) {
        // Check for escaped quotes
        if (i > 0 && sql[i - 1] !== "\\") {
          inString = false;
          stringQuote = null;
        }
      }
    }

    // Handle statement termination
    if (char === ";" && !inString && !inComment && !inBlockComment) {
      currentStatement += char;
      statements.push(currentStatement.trim());
      currentStatement = "";
      continue;
    }

    currentStatement += char;
  }

  // Add the last statement if it exists
  if (currentStatement.trim()) {
    statements.push(currentStatement.trim());
  }

  return statements.filter(stmt => stmt.length > 0);
}

async function applyMigration() {
  try {
    // Get list of all organizations
    const mainDb = new Database();
    const orgs = await mainDb.fetchAll('SELECT id, name, turso_db_url, turso_auth_token FROM organizations WHERE active = 1');
    
    logger.info(`Found ${orgs.length} active organizations`);
    
    // Split SQL statements properly
    const statements = splitSqlStatements(migrationSQL);
    logger.info(`Parsed ${statements.length} SQL statements from migration file`);
    
    // Apply migration to each organization
    for (const org of orgs) {
      try {
        logger.info(`Applying migration to organization ${org.id} (${org.name})...`);
        
        // Connect to the org's database
        const orgDb = new Database(org.turso_db_url, org.turso_auth_token);
        
        // Execute each statement in a transaction if possible
        try {
          await orgDb.transaction(async (tx) => {
            for (const stmt of statements) {
              if (stmt.trim()) {
                try {
                  logger.info(`Executing statement: ${stmt.substring(0, 50)}...`);
                  await tx.execute(stmt);
                } catch (err) {
                  logger.error(`Error executing statement for org ${org.id}: ${err}`);
                  logger.error(`Statement: ${stmt}`);
                  throw err; // Rethrow to trigger transaction rollback
                }
              }
            }
            logger.info(`All statements executed successfully for organization ${org.id}`);
          });
        } catch (txError) {
          // If transaction fails, try executing statements individually without transaction
          logger.warn(`Transaction failed, trying to execute statements individually: ${txError}`);
          
          for (const stmt of statements) {
            if (stmt.trim()) {
              try {
                // Skip transaction control statements when executing individually
                if (!/^\s*(BEGIN|COMMIT|ROLLBACK|PRAGMA)/i.test(stmt)) {
                  await orgDb.execute(stmt);
                }
              } catch (err) {
                logger.error(`Error executing individual statement for org ${org.id}: ${err}`);
                logger.error(`Statement: ${stmt}`);
                // Continue with next statement
              }
            }
          }
        }
        
        logger.info(`Migration applied successfully to organization ${org.id} (${org.name})`);
      } catch (err) {
        logger.error(`Error applying migration to organization ${org.id} (${org.name}): ${err}`);
        // Continue with next organization even if one fails
      }
    }
    
    logger.info('Migration process completed for all organizations');
  } catch (err) {
    logger.error(`Fatal error in migration process: ${err}`);
    process.exit(1);
  }
}

// Run the migration
applyMigration().then(() => {
  logger.info('Migration process completed successfully');
  process.exit(0);
}).catch((err) => {
  logger.error(`Unhandled error: ${err}`);
  process.exit(1);
});

================
File: src/scripts/apply_org_migrations.ts
================
#!/usr/bin/env bun

/**
 * Script to apply email unique constraint migration to all organization databases
 * 
 * Usage: 
 * - Apply to all orgs: bun run scripts/apply_org_migrations.ts
 * - Apply to specific org: bun run scripts/apply_org_migrations.ts 7
 */
import { Database } from '../database';
import { TursoService } from '../services/turso';
import { logger } from '../logger';
import fs from 'fs';
import path from 'path';

async function main() {
  try {
    // Check if we're targeting a specific org
    const targetOrgId = process.argv[2];
    
    // Initialize main database connection
    const mainDb = new Database();
    
    // Get organizations with their database URLs and tokens
    let orgs;
    if (targetOrgId) {
      // If targeting specific org
      orgs = await mainDb.fetchAll(`
        SELECT id, name, turso_db_url, turso_auth_token 
        FROM organizations 
        WHERE id = ? AND turso_db_url IS NOT NULL AND turso_auth_token IS NOT NULL
      `, [targetOrgId]);
      
      if (orgs.length === 0) {
        logger.error(`Organization with ID ${targetOrgId} not found or has no database configuration`);
        process.exit(1);
      }
      logger.info(`Targeting specific organization: ${targetOrgId}`);
    } else {
      // Get all orgs
      orgs = await mainDb.fetchAll(`
        SELECT id, name, turso_db_url, turso_auth_token 
        FROM organizations 
        WHERE turso_db_url IS NOT NULL AND turso_auth_token IS NOT NULL
      `);
    }
    
    logger.info(`Found ${orgs.length} organizations with databases`);
    
    // Get the migration SQL
    const migrationPath = path.join(process.cwd(), 'migrations', '20250329_fix_email_unique_constraint.sql');
    const migrationSql = fs.readFileSync(migrationPath, 'utf8');
    
    // Process each organization
    for (const org of orgs) {
      const orgId = org.id || org[0];
      const orgName = org.name || org[1];
      const dbUrl = org.turso_db_url || org[2];
      const authToken = org.turso_auth_token || org[3];
      
      try {
        logger.info(`Processing organization: ${orgName} (ID: ${orgId})`);
        
        // Get database connection for this organization
        const orgDb = new Database(dbUrl, authToken);
        
        // Check if contacts table exists and if updated_at column exists
        let tableCheck, hasUpdatedAtColumn;
        try {
          tableCheck = await orgDb.fetchOne(`
            SELECT name FROM sqlite_master WHERE type='table' AND name='contacts'
          `);
          
          if (tableCheck) {
            // Check if updated_at column exists
            const columnCheck = await orgDb.fetchOne(`
              SELECT COUNT(*) as count FROM pragma_table_info('contacts') WHERE name = 'updated_at'
            `);
            hasUpdatedAtColumn = columnCheck && 
              (typeof columnCheck === 'object' ? 
                ((columnCheck as any).count > 0 || (Array.isArray(columnCheck) && columnCheck[0] && Number(columnCheck[0]) > 0)) : 
                false);
            
            logger.info(`Table check: contacts table exists=${!!tableCheck}, has updated_at column=${hasUpdatedAtColumn}`);
          }
        } catch (checkError) {
          logger.warn(`Error checking table schema: ${checkError}`);
        }
        
        // Apply migration in separate chunks to handle potential errors
        
        // Start with dropping views that depend on contacts
        try {
          await orgDb.execute('DROP VIEW IF EXISTS v_contact_stats');
          logger.info('Dropped dependent views');
        } catch (viewError) {
          logger.warn(`Error dropping views: ${viewError}`);
        }
        
        // Check and backup eligibility_answers if it exists
        try {
          const eligibilityCheck = await orgDb.fetchOne(`
            SELECT name FROM sqlite_master WHERE type='table' AND name='eligibility_answers'
          `);
          
          if (eligibilityCheck) {
            // Create backup table and copy data
            await orgDb.execute(`
              CREATE TABLE IF NOT EXISTS eligibility_answers_backup AS 
              SELECT * FROM eligibility_answers
            `);
            
            // Drop the table to avoid foreign key issues
            await orgDb.execute('DROP TABLE IF EXISTS eligibility_answers');
            logger.info('Backed up and dropped eligibility_answers table');
          }
        } catch (backupError) {
          logger.warn(`Error handling eligibility_answers: ${backupError}`);
        }
        
        // Handle updated_at column if contacts table exists
        if (tableCheck) {
          try {
            if (!hasUpdatedAtColumn) {
              logger.info('Adding missing updated_at column');
              await orgDb.execute('ALTER TABLE contacts ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP');
            } else {
              logger.info('updated_at column already exists, skipping addition');
            }
          } catch (columnError) {
            // If error contains "duplicate column" we can ignore it
            if ((columnError as Error).toString().includes('duplicate column')) {
              logger.info('Ignoring duplicate column error for updated_at - column already exists');
            } else {
              logger.warn(`Error handling updated_at column: ${columnError}`);
            }
          }
        }
        
        // Apply the main migration script with error handling for each statement
        try {
          // Split migration SQL into individual statements
          const migrationStatements = migrationSql
            .split(';')
            .map(stmt => stmt.trim())
            .filter(stmt => stmt.length > 0 && !stmt.startsWith('--'));
          
          // Skip statements that add updated_at column since we've handled it above
          const filteredStatements = migrationStatements.filter(stmt => {
            // Skip the problematic statements
            return !stmt.includes('ADD COLUMN updated_at') && 
                   !stmt.includes('pragma_table_info') &&
                   !stmt.includes('_vars') &&
                   !stmt.includes('_commands');
          });
          
          logger.info(`Applying ${filteredStatements.length} migration statements`);
          
          // Execute each statement with individual error handling
          for (const statement of filteredStatements) {
            try {
              // Skip empty statements or diagnostic queries
              if (statement.trim().length === 0 || 
                  statement.includes('PRAGMA table_info') ||
                  statement.includes('SELECT name, sql FROM sqlite_master')) {
                continue;
              }
              
              await orgDb.execute(statement);
            } catch (stmtError) {
              const errorString = (stmtError as Error).toString();
              
              // Handle specific errors gracefully
              if (errorString.includes('duplicate column name: updated_at')) {
                logger.info('Ignoring duplicate updated_at column error');
              } else if (errorString.includes('no such table: contacts_temp')) {
                logger.warn('Contacts temporary table not found, may have already been renamed');
              } else {
                logger.error(`Error executing statement: ${stmtError}`);
                logger.error(`Failed statement: ${statement.substring(0, 100)}...`);
              }
              // Continue with next statement, errors shouldn't fail the whole migration
            }
          }
          
          // Verify the migration results
          try {
            // Check if email unique constraint exists
            const uniqueCheck = await orgDb.fetchOne(`
              SELECT COUNT(*) as count FROM sqlite_master 
              WHERE type='index' AND name='contact_email_unique'
            `);
            
            const hasUniqueConstraint = uniqueCheck && 
              (typeof uniqueCheck === 'object' ? 
                ((uniqueCheck as any).count > 0 || (Array.isArray(uniqueCheck) && uniqueCheck[0] && Number(uniqueCheck[0]) > 0)) : 
                false);
                
            if (hasUniqueConstraint) {
              logger.info('Email unique constraint created successfully');
            } else {
              logger.warn('Email unique constraint may not have been created');
              
              // Try to create it if missing
              try {
                await orgDb.execute(`
                  CREATE UNIQUE INDEX IF NOT EXISTS contact_email_unique ON contacts(email)
                `);
                logger.info('Created missing email unique constraint');
              } catch (createError) {
                logger.error(`Error creating missing constraint: ${createError}`);
              }
            }
            
            // Test if ON CONFLICT works
            try {
              await orgDb.execute(`
                INSERT OR IGNORE INTO contacts (
                  first_name, last_name, email, current_carrier, plan_type, 
                  effective_date, birth_date, tobacco_user, gender, state, zip_code, phone_number
                ) 
                VALUES ('Test', 'Migration', 'test.migration@example.com', 'Test', 'Test', 
                  '2025-01-01', '1970-01-01', 0, 'M', 'TX', '12345', '123-456-7890')
                ON CONFLICT(email) DO NOTHING
              `);
              logger.info('ON CONFLICT query test successful');
            } catch (testError) {
              logger.error(`ON CONFLICT test failed: ${testError}`);
            }
            
          } catch (verifyError) {
            logger.warn(`Error verifying migration results: ${verifyError}`);
          }
          
          logger.info(`Successfully migrated organization ${orgName} (ID: ${orgId})`);
        } catch (migrationError) {
          logger.error(`Migration failed for organization ${orgName} (ID: ${orgId}): ${migrationError}`);
        }
      } catch (orgError) {
        logger.error(`Error processing organization ${orgName} (ID: ${orgId}): ${orgError}`);
      }
    }
    
    logger.info('Migration process completed');
  } catch (error) {
    logger.error(`Script error: ${error}`);
    process.exit(1);
  }
}

main().catch(error => {
  logger.error(`Unhandled error: ${error}`);
  process.exit(1);
});

================
File: src/scripts/migrate-add-aep-columns.ts
================
import { Database } from '../database';
import { logger } from '../logger';

async function migrateAddAepColumns() {
  try {
    logger.info('Starting migration to add AEP request columns to all org databases');
    
    // Connect to main database
    const mainDb = new Database();
    
    // Get all organization IDs, database URLs and tokens
    const orgs = await mainDb.fetchAll(
      'SELECT id, turso_db_url, turso_auth_token FROM organizations WHERE turso_db_url IS NOT NULL'
    );
    
    logger.info(`Found ${orgs.length} organizations with databases to migrate`);
    
    for (const org of orgs) {
      const orgId = org.id || org[0];
      const dbUrl = org.turso_db_url || org[1];
      const authToken = org.turso_auth_token || org[2];
      
      if (!dbUrl || !authToken) {
        logger.warn(`Skipping org ${orgId} due to missing database credentials`);
        continue;
      }
      
      logger.info(`Migrating org ${orgId} with database URL ${dbUrl}`);
      
      try {
        // Connect to org database
        const orgDb = new Database(dbUrl, authToken);
        
        // Check if columns already exist
        const tableInfo = await orgDb.fetchAll("PRAGMA table_info(contacts)");
        const columns = tableInfo.map((col: any) => col.name || col[1]);
        
        if (!columns.includes('aep_request')) {
          logger.info(`Adding aep_request column to contacts table for org ${orgId}`);
          await orgDb.execute('ALTER TABLE contacts ADD COLUMN aep_request BOOLEAN DEFAULT FALSE');
        } else {
          logger.info(`aep_request column already exists for org ${orgId}`);
        }
        
        if (!columns.includes('aep_request_date')) {
          logger.info(`Adding aep_request_date column to contacts table for org ${orgId}`);
          await orgDb.execute('ALTER TABLE contacts ADD COLUMN aep_request_date DATETIME');
        } else {
          logger.info(`aep_request_date column already exists for org ${orgId}`);
        }
        
        logger.info(`Successfully migrated org ${orgId}`);
      } catch (error) {
        logger.error(`Error migrating org ${orgId}: ${error}`);
      }
    }
    
    logger.info('Migration completed');
  } catch (error) {
    logger.error(`Migration failed: ${error}`);
    throw error;
  }
}

// Execute migration if this file is run directly
if (import.meta.main) {
  migrateAddAepColumns()
    .then(() => {
      logger.info('Migration script completed successfully');
      process.exit(0);
    })
    .catch((error) => {
      logger.error(`Migration script failed: ${error}`);
      process.exit(1);
    });
}

export { migrateAddAepColumns };

================
File: src/services/agentSettings.ts
================
import { db } from '../database';
import { NotFoundError } from '../errors';
import { logger } from '../logger';

export interface StateCarrierSetting {
  active: boolean;
  targetGI: boolean;
}

export interface AgentSettings {
  id: number;
  agentId: number;
  stateLicenses: string[];
  carrierContracts: string[];
  stateCarrierSettings: {
    [state: string]: {
      [carrier: string]: StateCarrierSetting;
    };
  };
  emailSendBirthday: boolean;
  emailSendPolicyAnniversary: boolean;
  emailSendAep: boolean;
  smartSendEnabled: boolean;
}

export async function getAgentSettings(agentId: number): Promise<AgentSettings> {
  try {
    const result = await db.oneOrNone(
      'SELECT * FROM agent_settings WHERE agent_id = $1',
      [agentId]
    )

    if (!result) {
      // Return default settings instead of creating them
      return {
        id: 0,
        agentId: agentId,
        stateLicenses: [],
        carrierContracts: [],
        stateCarrierSettings: {},
        emailSendBirthday: false,
        emailSendPolicyAnniversary: false,
        emailSendAep: false,
        smartSendEnabled: false
      }
    }

    return {
      id: result.id,
      agentId: result.agent_id,
      stateLicenses: result.state_licenses || [],
      carrierContracts: result.carrier_contracts || [],
      stateCarrierSettings: result.state_carrier_settings || {},
      emailSendBirthday: result.email_send_birthday || false,
      emailSendPolicyAnniversary: result.email_send_policy_anniversary || false,
      emailSendAep: result.email_send_aep || false,
      smartSendEnabled: result.smart_send_enabled || false,
    }
  } catch (error) {
    logger.error(`Error fetching agent settings: ${error}`)
    // Return default settings on error
    return {
      id: 0,
      agentId: agentId,
      stateLicenses: [],
      carrierContracts: [],
      stateCarrierSettings: {},
      emailSendBirthday: false,
      emailSendPolicyAnniversary: false,
      emailSendAep: false,
      smartSendEnabled: false
    }
  }
}

async function createDefaultSettings(agentId: number): Promise<AgentSettings> {
  const result = await db.one(
    `INSERT INTO agent_settings 
     (agent_id, state_licenses, carrier_contracts, state_carrier_settings)
     VALUES ($1, $2, $3, $4)
     RETURNING *`,
    [agentId, [], [], {}]
  );

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

export async function updateAgentSettings(
  agentId: number,
  settings: Partial<AgentSettings>
): Promise<AgentSettings> {
  const result = await db.oneOrNone(
    `UPDATE agent_settings
     SET state_licenses = COALESCE($1, state_licenses),
         carrier_contracts = COALESCE($2, carrier_contracts),
         state_carrier_settings = COALESCE($3, state_carrier_settings),
         email_send_birthday = COALESCE($4, email_send_birthday),
         email_send_policy_anniversary = COALESCE($5, email_send_policy_anniversary),
         email_send_aep = COALESCE($6, email_send_aep),
         smart_send_enabled = COALESCE($7, smart_send_enabled)
     WHERE agent_id = $8
     RETURNING *`,
    [
      settings.stateLicenses,
      settings.carrierContracts,
      settings.stateCarrierSettings,
      settings.emailSendBirthday,
      settings.emailSendPolicyAnniversary,
      settings.emailSendAep,
      settings.smartSendEnabled,
      agentId,
    ]
  );

  if (!result) {
    throw new NotFoundError('Agent settings not found');
  }

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

================
File: src/services/auth.ts
================
import crypto from 'crypto';
import { logger } from '../logger';
import { db } from '../database';
import { Database } from '../database';
import type { User } from '../types';
import { config } from '../config';

const algorithm = "aes-256-gcm";
const IV_LENGTH = 12;
const UTF8 = "utf8";
const HEX = "hex";

// Initialize encryption key
let secret = process.env.MAGIC_LINK_SECRET;
if (!secret) {
  if (process.env.NODE_ENV === "production") {
    throw new Error("Must set MAGIC_LINK_SECRET in production");
  }
  secret = "dev-secret-key";
}

const ENCRYPTION_KEY = crypto.scryptSync(secret, "salt", 32);

interface MagicLinkPayload {
  email: string;
  organizationSlug: string;
  expiresAt: number;
  redirectUrl: string;
  orgId?: number;
  name?: string;
}

interface SignupLinkPayload {
  email: string;
  firstName: string;
  lastName: string;
  redirectUrl: string;
}

export class AuthService {
  constructor(private baseUrl?: string) {
    // If no baseUrl is provided, get it from config
    if (!baseUrl) {
      this.baseUrl = config.PUBLIC_URL;
    } else {
      // Ensure baseUrl doesn't end with a slash
      this.baseUrl = baseUrl.replace(/\/$/, '');
    }
    
    logger.info(`AuthService initialized with baseUrl: ${this.baseUrl}`);
  }

  async createSignupLink(
    email: string,
    options?: {
      redirectUrl?: string;
      firstName?: string;
      lastName?: string;
    }
  ): Promise<string> {
    const payload: SignupLinkPayload = {
      email,
      firstName: options?.firstName || '',
      lastName: options?.lastName || '',
      redirectUrl: options?.redirectUrl || '/onboarding'
    };

    logger.info(`Creating signup link with payload: ${JSON.stringify(payload)}`);
    logger.info(`redirectUrl: ${payload.redirectUrl}`);
    const token = this.encrypt(JSON.stringify(payload));
    // URL encode the entire token
    const encodedToken = encodeURIComponent(token);
    logger.info(`Generated magic link token: ${token}`);
    
    return `${this.baseUrl}/signup/verify/${encodedToken}`;
  }

  async verifySignupLink(token: string): Promise<{
    valid: boolean;
    email?: string;
    redirectUrl?: string;
  }> {
    try { 
      const decodedToken = decodeURIComponent(token);
      const decrypted = this.decrypt(decodedToken);
      const payload: SignupLinkPayload = JSON.parse(decrypted);

      if (!payload.email) {
        logger.warn('Missing email in signup link payload');
        return { valid: false };
      }

      if (!payload.redirectUrl) {
        logger.warn('Missing redirectUrl in signup link payload');
        return { valid: false };  
      }

      logger.info('Signup link verification successful, returning payload');
      return {
        valid: true,
        email: payload.email,
        redirectUrl: payload.redirectUrl
      };

    } catch (error) {
      logger.error(`Signup link verification failed: ${error}`);
      return { valid: false };  
    }
  }

  async createMagicLink(
    email: string, 
    organizationSlug: string, 
    options?: { 
      redirectUrl?: string;
      orgId?: number;
      name?: string;
    }
  ): Promise<string> {
    const payload: MagicLinkPayload = {
      email,
      organizationSlug,
      expiresAt: Date.now() + (30 * 60 * 1000), // 30 minutes
      redirectUrl: options?.redirectUrl || '/dashboard',
      ...(options?.orgId && { orgId: options.orgId }),
      ...(options?.name && { name: options.name })
    };

    logger.info(`Creating magic link with payload: ${JSON.stringify(payload)}`);
    logger.info(`redirectUrl: ${payload.redirectUrl}`);
    const token = this.encrypt(JSON.stringify(payload));
    // URL encode the entire token
    const encodedToken = encodeURIComponent(token);
    logger.info(`Generated magic link token: ${token}`);
    return `${this.baseUrl}/auth/verify/${organizationSlug}/${encodedToken}`;
  }

  async verifyMagicLink(token: string, organizationSlug: string): Promise<{
    valid: boolean;
    email?: string;
    redirectUrl?: string;
  }> {
    try {
      logger.info('Starting magic link verification');
      logger.info(`Organization slug: ${organizationSlug}`);

      const decodedToken = decodeURIComponent(token);
      const decrypted = this.decrypt(decodedToken);
      const payload: MagicLinkPayload = JSON.parse(decrypted);

      // Verify organization and expiration
      if (payload.organizationSlug !== organizationSlug) {
        logger.error(`Organization slug mismatch: ${payload.organizationSlug} !== ${organizationSlug}`);
        return { valid: false };
      }

      if (payload.expiresAt < Date.now()) {
        logger.error(`Token expired: ${new Date(payload.expiresAt)} < ${new Date()}`);
        return { valid: false };
      }

      // No need to check agent status here since we only send links to valid agents

      logger.info('Verification successful, returning payload');
      return {
        valid: true,
        email: payload.email,
        redirectUrl: payload.redirectUrl
      };

    } catch (error) {
      logger.error(`Magic link verification failed: ${error}`);
      return { valid: false };
    }
  }

  private encrypt(text: string): string {
    try {
      const iv = crypto.randomBytes(IV_LENGTH);
      const cipher = crypto.createCipheriv(algorithm, ENCRYPTION_KEY, iv);
      let encrypted = cipher.update(text, UTF8, HEX);
      encrypted += cipher.final(HEX);
      const authTag = cipher.getAuthTag();
      
      const token = `${iv.toString(HEX)}:${authTag.toString(HEX)}:${encrypted}`;
      return token;
    } catch (error) {
      logger.error(`Encryption failed: ${error}`);
      throw error;
    }
  }

  private decrypt(text: string): string {
    try {
      const [ivPart, authTagPart, encryptedText] = text.split(":");
      if (!ivPart || !authTagPart || !encryptedText) {
        throw new Error("Invalid token format - missing parts");
      }

      logger.info('Decrypting token parts:');
      logger.info(`IV length: ${ivPart.length}`);
      logger.info(`Auth tag length: ${authTagPart.length}`);
      logger.info(`Encrypted text length: ${encryptedText.length}`);

      const iv = Buffer.from(ivPart, HEX);
      const authTag = Buffer.from(authTagPart, HEX);
      const decipher = crypto.createDecipheriv(algorithm, ENCRYPTION_KEY, iv);
      decipher.setAuthTag(authTag);
      let decrypted = decipher.update(encryptedText, HEX, UTF8);
      decrypted += decipher.final(UTF8);
      return decrypted;
    } catch (error) {
      logger.error(`Decryption failed: ${error}`);
      throw error;
    }
  }

  async getUserFromSession(request: Request): Promise<Partial<User> | null> {
    // Check for bypass header for testing
    const bypassHeader = request.headers.get('X-Bypass-Auth');
    if (bypassHeader) {
      const bypassUserId = bypassHeader === 'true' ? 'test-user-id' : bypassHeader;
      logger.info(`Bypassing authentication with header for user ID: ${bypassUserId}`);
      return {
        id: bypassUserId,
        email: 'test@example.com',
        organization_id: 'test-org-id',
        is_admin: true,
        is_agent: true,
        first_name: 'Test',
        last_name: 'User',
        is_active: true,
        organization_name: 'Test Organization'
      };
    }
    
    // Check if this is a public endpoint that should bypass auth
    const url = new URL(request.url);
    const pathname = url.pathname;
    
    // Log all requested pathnames for debugging
    logger.info(`Auth check for pathname: ${pathname}`);
    
    // Skip auth for subscription/checkout endpoint
    if (pathname === '/api/subscription/checkout') {
      logger.info('Skipping auth check for subscription/checkout endpoint');
      return { skip_auth: true }; // Return a dummy user that won't trigger auth failures
    }
    
    // Skip auth for all self-service endpoints
    if (pathname.startsWith('/api/self-service/')) {
      logger.info(`Skipping auth check for self-service endpoint: ${pathname}`);
      
      return { skip_auth: true }; // Return a dummy user that won't trigger auth failures
    }

    // Test both regex patterns for debugging
    const comparePathTest1 = /^\/compare\/[^\/]+$/.test(pathname);
    const comparePathTest2 = pathname.startsWith('/compare/');
    
    logger.info(`Compare path tests: regex=${comparePathTest1}, startsWith=${comparePathTest2} for ${pathname}`);

    // Skip auth for compare pages with path parameters
    if (pathname.startsWith('/compare/')) {
      logger.info(`Skipping auth check for compare path parameter endpoint: ${pathname}`);
      return { skip_auth: true }; // Return a dummy user that won't trigger auth failures
    }
    
    // Skip auth check for static files
    if (
      pathname.endsWith('.js') || 
      pathname.endsWith('.css') || 
      pathname.endsWith('.png') || 
      pathname.endsWith('.jpg') || 
      pathname.endsWith('.svg') || 
      pathname.endsWith('.ico') ||
      pathname.endsWith('.ttf') ||
      pathname.endsWith('.woff') ||
      pathname.endsWith('.woff2')
    ) {
      logger.info(`Skipping auth check for static file: ${pathname}`);
      return { skip_auth: true };
    }

    const cookieHeader = request.headers.get('Cookie') || '';

    // Get session cookie
    const sessionId = cookieHeader.split('session=')[1]?.split(';')[0];
    
    if (!sessionId) {
      logger.warn('No session cookie found');
      return null;
    }

    // Initialize database
    const db = new Database();

    // Get session data
    const sessionResult = await db.fetchAll(
      'SELECT user_id FROM sessions WHERE id = ?',
      [sessionId]
    );

    if (!sessionResult || sessionResult.length === 0) {
      logger.warn(`No session found for ID: ${sessionId}`);
      return null;
    }

    const userId = sessionResult[0][0];

    // Updated query to use is_admin and is_agent
    const userResult = await db.fetchAll(
      `SELECT 
        u.id,
        u.email,
        u.organization_id,
        u.is_admin,
        u.is_agent,
        u.first_name,
        u.last_name,
        u.is_active,
        u.phone,
        o.name as organization_name
       FROM users u
       JOIN organizations o ON u.organization_id = o.id 
       WHERE u.id = ?`,
      [userId]
    );

    if (!userResult || userResult.length === 0) {
      logger.warn('No user found for session');
      return null;
    }

    const user = {
      id: userResult[0][0],
      email: userResult[0][1],
      organization_id: userResult[0][2],
      is_admin: Boolean(userResult[0][3]),
      is_agent: Boolean(userResult[0][4]),
      first_name: userResult[0][5],
      last_name: userResult[0][6],
      is_active: userResult[0][7],
      phone: userResult[0][8],
      organization_name: userResult[0][9]
    };

    return user;
  }
}

export async function validateSession(sessionId: string): Promise<User | null> {
  logger.info(`Validating session: ${sessionId}`);
  
  const db = new Database();

  // Get the session
  const session = await db.fetchOne<{
    id: string;
    user_id: number;
    expires_at: string;
  }>('SELECT * FROM sessions WHERE id = ?', [sessionId]);

  logger.info(`Session lookup result: ${session ? JSON.stringify(session) : 'not found'}`);

  if (!session) {
    logger.warn('No session found in database');
    return null;
  }

  // Check if session is expired
  const expiresAt = new Date(session.expires_at);
  const now = new Date();
  logger.info(`Session expires: ${expiresAt}, current time: ${now}`);

  if (expiresAt < now) {
    logger.warn('Session is expired');
    await db.execute('DELETE FROM sessions WHERE id = ?', [sessionId]);
    return null;
  }

  // Get the user associated with this session with updated columns
  const user = await db.fetchOne<User>(
    `SELECT 
      u.id,
      u.email,
      u.organization_id,
      u.is_admin,
      u.is_agent,
      u.first_name,
      u.last_name,
      u.is_active,
      u.phone,
      o.name as organization_name 
     FROM users u
     JOIN organizations o ON u.organization_id = o.id 
     WHERE u.id = ?`,
    [session.user_id]
  );

  logger.info(`User lookup result: ${user ? JSON.stringify(user) : 'not found'}`);

  return user;
}

export function generateToken(): string {
  return crypto.randomBytes(32).toString('hex');
}

export async function getUserFromSession(request: Request) {
  try {
    // Check for X-Bypass-Auth header
    const bypassAuth = request.headers.get('X-Bypass-Auth');
    if (bypassAuth) {
      logger.info(`Bypassing auth check due to X-Bypass-Auth header`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Check if this is a public endpoint that should bypass auth
    const url = new URL(request.url);
    const pathname = url.pathname;
    
    // Log all requested pathnames for debugging
    logger.info(`Auth check for pathname: ${pathname}`);
    
    // COMPREHENSIVE SPA ROUTES CHECK - any frontend route should bypass auth
    // Check for non-API paths with no file extension (SPA routes)
    if (!pathname.startsWith('/api/') && 
        !pathname.includes('.')) {
      logger.info(`[AUTH BYPASS] SPA route detected (non-API, no extension): ${pathname}`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Explicit checks for known SPA routes
    if (pathname.startsWith('/compare/') || 
        pathname.startsWith('/quote/') || 
        pathname.startsWith('/eligibility') ||
        pathname.startsWith('/schedule')) {
      logger.info(`[AUTH BYPASS] Known SPA route detected: ${pathname}`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Skip auth for subscription/checkout endpoint
    if (pathname === '/api/subscription/checkout') {
      logger.info('Skipping auth check for subscription/checkout endpoint');
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Skip auth for all self-service endpoints
    if (pathname.startsWith('/api/self-service/')) {
      logger.info(`Skipping auth check for self-service endpoint: ${pathname}`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Skip auth check for static files
    if (
      pathname.endsWith('.js') || 
      pathname.endsWith('.css') || 
      pathname.endsWith('.png') || 
      pathname.endsWith('.jpg') || 
      pathname.endsWith('.svg') || 
      pathname.endsWith('.ico') ||
      pathname.endsWith('.ttf') ||
      pathname.endsWith('.woff') ||
      pathname.endsWith('.woff2')
    ) {
      logger.info(`Skipping auth check for static file: ${pathname}`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }

    const cookieHeader = request.headers.get('Cookie') || '';

    // Get session cookie
    const sessionId = cookieHeader.split('session=')[1]?.split(';')[0];
    
    if (!sessionId) {
      logger.warn('No session cookie found');
      return null;
    }

    // Initialize database
    const db = new Database();

    // Get session data
    const sessionResult = await db.fetchAll(
      'SELECT user_id FROM sessions WHERE id = ?',
      [sessionId]
    );

    if (!sessionResult || sessionResult.length === 0) {
      logger.warn(`No session found for ID: ${sessionId}`);
      return null;
    }

    const userId = sessionResult[0][0];

    // Updated query to use is_admin and is_agent
    const userResult = await db.fetchAll(
      `SELECT 
        u.id,
        u.email,
        u.organization_id,
        u.is_admin,
        u.is_agent,
        u.first_name,
        u.last_name,
        u.is_active,
        u.phone,
        o.name as organization_name
       FROM users u
       JOIN organizations o ON u.organization_id = o.id 
       WHERE u.id = ?`,
      [userId]
    );

    if (!userResult || userResult.length === 0) {
      logger.warn('No user found for session');
      return null;
    }

    const user = {
      id: userResult[0][0],
      email: userResult[0][1],
      organization_id: userResult[0][2],
      is_admin: Boolean(userResult[0][3]),
      is_agent: Boolean(userResult[0][4]),
      first_name: userResult[0][5],
      last_name: userResult[0][6],
      is_active: userResult[0][7],
      phone: userResult[0][8],
      organization_name: userResult[0][9]
    };

    return user;

  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

================
File: src/services/contactCount.ts
================
import { Database } from '../database';
import { logger } from '../logger';

/**
 * Updates the contact count for a user and handles subscription tier changes if needed
 */
export async function updateContactCount(userId: string, totalContacts: number): Promise<{
  success: boolean;
  error?: string;
}> {
  const db = new Database();
  
  try {
   
    // Update the contact count in the database
    await upsertContactCount(userId, totalContacts);

    // Check if auto-upgrade is enabled
    const user = await db.fetchOne<{ auto_upgrade_limit: number }>(
      'SELECT user_id FROM users WHERE id = ?',
      [userId]
    );
    
    if (!user) {
      return {
        success: false,
        error: 'User not found',
      };
    }
  } catch (error) {
    logger.error(`Error updating contact count for user ${userId}: ${error}`);
    return {
      success: false,
      error: 'Failed to update contact count',
    };
  }
  
  // Return success if no errors occurred
  return {
    success: true
  };
}

/**
 * Updates or inserts a contact count record for a user
 */
export async function upsertContactCount(userId: string, count: number): Promise<void> {
  const db = new Database();
  
  try {
    // Check if a record already exists
    const existingCount = await db.fetchOne<{ count: number }>(
      'SELECT count FROM contact_counts WHERE user_id = ?',
      [userId]
    );
    
    if (existingCount) {
      // Update existing record
      await db.execute(
        'UPDATE contact_counts SET count = ?, last_updated = CURRENT_TIMESTAMP WHERE user_id = ?',
        [count, userId]
      );
    } else {
      // Insert new record
      await db.execute(
        'INSERT INTO contact_counts (user_id, count, last_updated) VALUES (?, ?, CURRENT_TIMESTAMP)',
        [userId, count]
      );
    }
    
    logger.info(`Updated contact count for user ${userId} to ${count}`);
  } catch (error) {
    logger.error(`Error upserting contact count for user ${userId}:`, error);
    throw error;
  }
}

/**
 * Gets the current contact count for a user
 */
export async function getContactCount(userId: string): Promise<number> {
  const db = new Database();
  
  try {
    const countRecord = await db.fetchOne<{ count: number }>(
      'SELECT count FROM contact_counts WHERE user_id = ?',
      [userId]
    );
    
    return countRecord?.count || 0;
  } catch (error) {
    logger.error(`Error getting contact count for user ${userId}:`, error);
    throw error;
  }
}

/**
 * Gets the current subscription tier limit for a user
 */
export async function getContactLimit(userId: string): Promise<number> {
  const db = new Database();
  
  try {
    const subscription = await db.fetchOne<{ tier: number }>(
      'SELECT tier FROM subscriptions WHERE user_id = ? AND status = "active" ORDER BY created_at DESC LIMIT 1',
      [userId]
    );
    
    // Each tier represents 500 contacts
    return subscription ? subscription.tier * 500 : 0;
  } catch (error) {
    logger.error(`Error getting contact limit for user ${userId}:`, error);
    throw error;
  }
}

/**
 * Updates the auto-upgrade limit for a user
 */
export async function updateAutoUpgradeLimit(userId: string, limit: number): Promise<boolean> {
  const db = new Database();
  
  try {
    await db.execute(
      'UPDATE users SET auto_upgrade_limit = ? WHERE id = ?',
      [limit, userId]
    );
    
    logger.info(`Updated auto-upgrade limit for user ${userId} to ${limit}`);
    return true;
  } catch (error) {
    logger.error(`Error updating auto-upgrade limit for user ${userId}:`, error);
    return false;
  }
}

/**
 * Checks if adding a specified number of contacts would exceed the user's current tier
 */
export async function checkContactAddition(userId: string, additionalContacts: number): Promise<{
  canAdd: boolean;
  currentCount: number;
  limit: number;
  newTotal: number;
  requiredTier: number;
  currentTier: number;
}> {
  const db = new Database();
  
  try {
    // Get the current count
    const currentCount = await getContactCount(userId);
    
    // Get the current tier
    const subscription = await db.fetchOne<{ tier: number }>(
      'SELECT tier FROM subscriptions WHERE user_id = ? AND status = "active" ORDER BY created_at DESC LIMIT 1',
      [userId]
    );
    
    const currentTier = subscription?.tier || 0;
    const limit = currentTier * 500;
    const newTotal = currentCount + additionalContacts;
    const requiredTier = Math.ceil(newTotal / 500);
    
    return {
      canAdd: newTotal <= limit,
      currentCount,
      limit,
      newTotal,
      requiredTier,
      currentTier,
    };
  } catch (error) {
    logger.error(`Error checking contact addition for user ${userId}:`, error);
    throw error;
  }
}

================
File: src/services/contactTracking.ts
================
/**
 * Contact Tracking Service
 * 
 * This service handles tracking unique contacts for usage-based billing.
 * It ensures that:
 * 1. Each unique contact is only counted once per billing cycle
 * 2. Contact counts are properly reported to Stripe
 * 3. Organizations can see their current usage
 */

import { Database } from '../database';
import { logger } from '../logger';
import { reportContactUsage } from './stripe';
import { v4 as uuidv4 } from 'uuid';

/**
 * Generate a unique ID for database records
 */
function generateId(): string {
  return uuidv4();
}

/**
 * Get the current billing cycle key for an organization
 * Format: YYYY-MM for monthly cycles
 */
export async function getCurrentBillingCycle(organizationId: string): Promise<string> {
  const db = new Database();
  
  try {
    // Check if organization has a current billing cycle
    const org = await db.fetchOne<{
      current_billing_cycle_key: string | null;
      contact_count_billing_date: string | null;
    }>('SELECT current_billing_cycle_key, contact_count_billing_date FROM organizations WHERE id = ?', [organizationId]);
    
    if (!org) {
      throw new Error(`Organization not found: ${organizationId}`);
    }
    
    // If organization has a current billing cycle, return it
    if (org.current_billing_cycle_key) {
      return org.current_billing_cycle_key;
    }
    
    // If not, create a new billing cycle
    const now = new Date();
    const cycleKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
    
    // Determine billing start date (default to 1st of month if not set)
    const billingDay = org.contact_count_billing_date || '01';
    const month = now.getMonth();
    const year = now.getFullYear();
    
    // Create start and end dates for the cycle
    const startDate = new Date(year, month, parseInt(billingDay, 10));
    const endDate = new Date(year, month + 1, parseInt(billingDay, 10));
    
    // Handle case where current date is before billing day in current month
    if (now.getDate() < parseInt(billingDay, 10)) {
      startDate.setMonth(startDate.getMonth() - 1);
      endDate.setMonth(endDate.getMonth() - 1);
    }
    
    // Create the billing cycle record
    await db.execute(`
      INSERT INTO billing_cycle_history (
        id, organization_id, cycle_key, start_date, end_date
      ) VALUES (?, ?, ?, ?, ?)
    `, [
      generateId(),
      organizationId,
      cycleKey,
      startDate.toISOString(),
      endDate.toISOString()
    ]);
    
    // Update the organization with the new billing cycle
    await db.execute(`
      UPDATE organizations 
      SET current_billing_cycle_key = ? 
      WHERE id = ?
    `, [cycleKey, organizationId]);
    
    logger.info(`Created new billing cycle ${cycleKey} for organization ${organizationId}`);
    
    return cycleKey;
  } catch (error) {
    logger.error(`Error getting current billing cycle: ${error}`);
    throw error;
  }
}

/**
 * Track a contact upload to ensure it's counted properly for billing
 */
export async function trackContact(
  organizationId: string, 
  userId: string, 
  contactEmail: string, 
  firstName?: string, 
  lastName?: string
): Promise<{ isNew: boolean; contactId: string }> {
  const db = new Database();
  
  try {
    // Validate inputs
    if (!organizationId || !userId || !contactEmail) {
      throw new Error('Missing required parameters for contact tracking');
    }
    
    // Normalize email for consistent lookups
    const normalizedEmail = contactEmail.trim().toLowerCase();
    
    // Get current billing cycle
    const billingCycle = await getCurrentBillingCycle(organizationId);
    
    // Check if contact already exists in this organization
    const existingContact = await db.fetchOne<{ id: string; billing_cycle_key: string | null }>(
      'SELECT id, billing_cycle_key FROM contact_history WHERE organization_id = ? AND email = ?',
      [organizationId, normalizedEmail]
    );
    
    let isNew = false;
    let contactId: string;
    
    if (existingContact) {
      // Contact exists - update last_uploaded timestamp
      contactId = existingContact.id;
      await db.execute(`
        UPDATE contact_history 
        SET last_uploaded = CURRENT_TIMESTAMP,
            first_name = COALESCE(?, first_name),
            last_name = COALESCE(?, last_name)
        WHERE id = ?
      `, [
        firstName || null,
        lastName || null,
        contactId
      ]);
      
      // If contact was from a different billing cycle, count it as new for this cycle
      if (existingContact.billing_cycle_key !== billingCycle) {
        isNew = true;
        await db.execute(`
          UPDATE contact_history 
          SET billing_cycle_key = ? 
          WHERE id = ?
        `, [billingCycle, contactId]);
      }
    } else {
      // New contact - insert into history
      isNew = true;
      contactId = generateId();
      
      await db.execute(`
        INSERT INTO contact_history (
          id, organization_id, user_id, email, first_name, last_name, billing_cycle_key
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `, [
        contactId,
        organizationId,
        userId,
        normalizedEmail,
        firstName || null,
        lastName || null,
        billingCycle
      ]);
    }
    
    // If this is a new contact for this billing cycle, increment the count
    if (isNew) {
      await incrementUniqueContactCount(organizationId);
    }
    
    return { isNew, contactId };
  } catch (error) {
    logger.error(`Error tracking contact: ${error}`);
    throw error;
  }
}

/**
 * Track a batch of contacts
 */
export async function trackContactBatch(
  organizationId: string,
  userId: string,
  contacts: Array<{ email: string; firstName?: string; lastName?: string }>
): Promise<{ newCount: number; totalProcessed: number }> {
  const db = new Database();
  
  try {
    let newCount = 0;
    const totalProcessed = contacts.length;
    
    // Process contacts in batches to avoid transaction timeouts
    const batchSize = 100;
    for (let i = 0; i < contacts.length; i += batchSize) {
      const batch = contacts.slice(i, i + batchSize);
      
      await db.transaction('write', async (tx) => {
        for (const contact of batch) {
          const result = await trackContact(
            organizationId,
            userId,
            contact.email,
            contact.firstName,
            contact.lastName
          );
          
          if (result.isNew) {
            newCount++;
          }
        }
      });
      
      logger.info(`Processed ${i + batch.length}/${totalProcessed} contacts for organization ${organizationId}`);
    }
    
    // Get total unique contacts in current billing cycle
    const uniqueCount = await getUniqueContactCount(organizationId);
    
    // Report usage to Stripe
    await updateStripeUsage(organizationId, uniqueCount);
    
    return { newCount, totalProcessed };
  } catch (error) {
    logger.error(`Error tracking contact batch: ${error}`);
    throw error;
  }
}

/**
 * Increment the unique contact count for an organization
 */
async function incrementUniqueContactCount(organizationId: string): Promise<number> {
  const db = new Database();
  
  try {
    // Get current unique contact count
    const org = await db.fetchOne<{ current_unique_contacts: number }>(
      'SELECT current_unique_contacts FROM organizations WHERE id = ?',
      [organizationId]
    );
    
    if (!org) {
      throw new Error(`Organization not found: ${organizationId}`);
    }
    
    // Increment the count
    const newCount = (org.current_unique_contacts || 0) + 1;
    
    // Update the organization
    await db.execute(`
      UPDATE organizations 
      SET current_unique_contacts = ? 
      WHERE id = ?
    `, [newCount, organizationId]);
    
    // Update the billing cycle history
    const billingCycle = await getCurrentBillingCycle(organizationId);
    await db.execute(`
      UPDATE billing_cycle_history 
      SET contact_count = ? 
      WHERE organization_id = ? AND cycle_key = ?
    `, [newCount, organizationId, billingCycle]);
    
    return newCount;
  } catch (error) {
    logger.error(`Error incrementing unique contact count: ${error}`);
    throw error;
  }
}

/**
 * Get the count of unique contacts in the current billing cycle
 */
export async function getUniqueContactCount(organizationId: string): Promise<number> {
  const db = new Database();
  
  try {
    // Get current billing cycle
    const billingCycle = await getCurrentBillingCycle(organizationId);
    
    // Get unique contact count for this cycle
    const result = await db.fetchOne<{ count: number }>(
      'SELECT COUNT(*) as count FROM contact_history WHERE organization_id = ? AND billing_cycle_key = ?',
      [organizationId, billingCycle]
    );
    
    return result ? result.count : 0;
  } catch (error) {
    logger.error(`Error getting unique contact count: ${error}`);
    throw error;
  }
}

/**
 * Get the subscription info and update Stripe usage
 */
async function updateStripeUsage(organizationId: string, contactCount: number): Promise<void> {
  const db = new Database();
  
  try {
    // Get the organization's Stripe subscription info
    const org = await db.fetchOne<{ 
      id: number;
      stripe_subscription_id: string;
    }>('SELECT id, stripe_subscription_id FROM organizations WHERE id = ?', [organizationId]);
    
    if (!org || !org.stripe_subscription_id) {
      logger.info(`Organization ${organizationId} has no Stripe subscription, skipping usage update`);
      return;
    }
    
    // Get the subscription item for usage reporting
    const subscriptionItem = await db.fetchOne<{ stripe_usage_item_id: string }>(
      'SELECT stripe_usage_item_id FROM subscriptions WHERE stripe_subscription_id = ? AND status = "active" LIMIT 1',
      [org.stripe_subscription_id]
    );
    
    if (!subscriptionItem || !subscriptionItem.stripe_usage_item_id) {
      logger.warn(`No active subscription item found for organization ${organizationId}`);
      return;
    }
    
    // Calculate the number of 500-contact blocks beyond the initial 500
    const additionalBlocks = Math.max(0, Math.ceil((contactCount - 500) / 500));
    
    // Report usage to Stripe
    await reportContactUsage(subscriptionItem.stripe_usage_item_id, additionalBlocks);
    
    logger.info(`Reported usage of ${additionalBlocks} additional contact blocks for organization ${organizationId}`);
    
    // Mark the billing cycle as reported
    const billingCycle = await getCurrentBillingCycle(organizationId);
    await db.execute(`
      UPDATE billing_cycle_history 
      SET usage_reported = TRUE 
      WHERE organization_id = ? AND cycle_key = ?
    `, [organizationId, billingCycle]);
  } catch (error) {
    logger.error(`Error updating Stripe usage: ${error}`);
    throw error;
  }
}

/**
 * Get contact usage stats for an organization
 */
export async function getContactUsageStats(organizationId: string): Promise<{
  currentCycle: string;
  uniqueContacts: number;
  billingCycleStart: string;
  billingCycleEnd: string;
  contactsRemaining: number;
  isOverLimit: boolean;
}> {
  const db = new Database();
  
  try {
    // Get current billing cycle
    const billingCycle = await getCurrentBillingCycle(organizationId);
    
    // Get billing cycle details
    const cycle = await db.fetchOne<{
      start_date: string;
      end_date: string;
      contact_count: number;
    }>(`
      SELECT start_date, end_date, contact_count 
      FROM billing_cycle_history 
      WHERE organization_id = ? AND cycle_key = ?
    `, [organizationId, billingCycle]);
    
    if (!cycle) {
      throw new Error(`Billing cycle not found for organization ${organizationId}`);
    }
    
    // Calculate remaining contacts in the base tier (500)
    const contactsRemaining = Math.max(0, 500 - cycle.contact_count);
    const isOverLimit = cycle.contact_count > 500;
    
    return {
      currentCycle: billingCycle,
      uniqueContacts: cycle.contact_count,
      billingCycleStart: cycle.start_date,
      billingCycleEnd: cycle.end_date,
      contactsRemaining,
      isOverLimit
    };
  } catch (error) {
    logger.error(`Error getting contact usage stats: ${error}`);
    throw error;
  }
}

/**
 * Reset contact count for a specific email (for admin/support use)
 */
export async function resetContactCount(
  organizationId: string,
  email: string,
  reason: string
): Promise<boolean> {
  const db = new Database();
  
  try {
    // Normalize email
    const normalizedEmail = email.trim().toLowerCase();
    
    // Find the contact
    const contact = await db.fetchOne<{ id: string }>(
      'SELECT id FROM contact_history WHERE organization_id = ? AND email = ?',
      [organizationId, normalizedEmail]
    );
    
    if (!contact) {
      logger.warn(`Contact not found for reset: ${email} in organization ${organizationId}`);
      return false;
    }
    
    // Set the status to deleted
    await db.execute(`
      UPDATE contact_history 
      SET status = 'deleted' 
      WHERE id = ?
    `, [contact.id]);
    
    // Log the operation for audit purposes
    await db.execute(`
      INSERT INTO admin_action_log (
        id, organization_id, action, details, reason
      ) VALUES (?, ?, ?, ?, ?)
    `, [
      generateId(),
      organizationId,
      'reset_contact',
      JSON.stringify({ email: normalizedEmail }),
      reason
    ]);
    
    // Recalculate the contact count
    await recalculateContactCount(organizationId);
    
    return true;
  } catch (error) {
    logger.error(`Error resetting contact count: ${error}`);
    throw error;
  }
}

/**
 * Recalculate contact count for an organization
 */
async function recalculateContactCount(organizationId: string): Promise<number> {
  const db = new Database();
  
  try {
    // Get current billing cycle
    const billingCycle = await getCurrentBillingCycle(organizationId);
    
    // Count active contacts in current billing cycle
    const result = await db.fetchOne<{ count: number }>(
      'SELECT COUNT(*) as count FROM contact_history WHERE organization_id = ? AND billing_cycle_key = ? AND status = "active"',
      [organizationId, billingCycle]
    );
    
    const count = result ? result.count : 0;
    
    // Update the organization
    await db.execute(`
      UPDATE organizations 
      SET current_unique_contacts = ? 
      WHERE id = ?
    `, [count, organizationId]);
    
    // Update the billing cycle history
    await db.execute(`
      UPDATE billing_cycle_history 
      SET contact_count = ? 
      WHERE organization_id = ? AND cycle_key = ?
    `, [count, organizationId, billingCycle]);
    
    // Update Stripe usage
    await updateStripeUsage(organizationId, count);
    
    return count;
  } catch (error) {
    logger.error(`Error recalculating contact count: ${error}`);
    throw error;
  }
}

================
File: src/services/email.ts
================
import sgMail from '@sendgrid/mail';
import { logger } from '../logger';
import crypto from 'crypto';
import { Database } from '../database';
import { generateTrackingId, addTrackingToUrl } from '../utils/tracking';
import twilio from 'twilio';

interface MagicLinkEmailParams {
  email: string;
  token: string;
  orgId: number;
  name: string;
}

interface EmailTrackingRecord {
  orgId: number;
  contactId: string | number;
  emailType: string;
  sendStatus: 'pending' | 'processing' | 'accepted' | 'delivered' | 'sent' | 'deferred' | 'bounced' | 'dropped' | 'failed' | 'skipped';
  sendMode: 'test' | 'production';
  testEmail?: string;
  batchId: string;
  messageId?: string;
}

export class EmailService {
  constructor() {
    if (!process.env.SENDGRID_API_KEY) {
      throw new Error('Missing SENDGRID_API_KEY environment variable');
    }
    sgMail.setApiKey(process.env.SENDGRID_API_KEY);
  }

  /**
   * Generates a tracking ID for an email link
   * Format: tid-[orgId]-[contactId]-[timestamp]
   * @param orgId Organization ID
   * @param contactId Contact ID
   * @returns Tracking ID string
   */
  generateTrackingId(orgId: number | string, contactId: number | string): string {
    return generateTrackingId(orgId, contactId, 'em');
  }

  /**
   * Records an email send in the email_send_tracking table
   * @param orgDb Organization database instance
   * @param tracking Email tracking data
   * @returns Result of the database operation
   */
  async recordEmailSend(orgDb: Database, tracking: EmailTrackingRecord): Promise<any> {
    try {
      const now = new Date().toISOString();
      
      return await orgDb.execute(
        `INSERT INTO email_send_tracking (
          org_id, 
          contact_id, 
          email_type, 
          scheduled_date, 
          send_status,
          send_mode,
          test_email,
          batch_id,
          message_id,
          last_attempt_date
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          tracking.orgId,
          tracking.contactId.toString(),
          tracking.emailType,
          now,
          tracking.sendStatus,
          tracking.sendMode,
          tracking.testEmail || null,
          tracking.batchId,
          tracking.messageId || null,
          now
        ]
      );
    } catch (error) {
      logger.error(`Error recording email send: ${error}`);
      throw new Error(`Failed to record email send: ${error}`);
    }
  }

  async sendMagicLink(email: string, magicLink: string, organizationSlug: string) {
    try {
      const fromEmail = process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai';
      const msg = {
        to: email,
        from: {
          email: fromEmail,
          name: organizationSlug ? organizationSlug.charAt(0).toUpperCase() + organizationSlug.slice(1) : 'MedicareMax'
        },
        subject: 'Your Login Link',
        text: `Click this link to log in: ${magicLink}\n\nThis link will expire in 30 minutes.`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">Welcome to MedicareMax</h2>
            <p>Click the button below to log in to your account. This link will expire in 30 minutes.</p>
            <div style="margin: 30px 0;">
              <a href="${magicLink}" 
                 style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                        text-decoration: none; border-radius: 4px; display: inline-block;">
                Log In
              </a>
            </div>
            <p style="color: #666; font-size: 14px;">
              If the button doesn't work, copy and paste this link into your browser:
              <br>
              <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
            </p>
          </div>
        `
      };

      await sgMail.send(msg);
      logger.info(`Magic link email sent successfully to ${email}`);
    } catch (error) {
      logger.error(`Error sending magic link email: ${error}`);
      throw new Error('Failed to send magic link email');
    }
  }

  async sendQuoteEmail(params: {
    email: string;
    firstName: string;
    lastName: string;
    quoteUrl: string;
    planType: string;
    organization?: {
      id?: number;
      name?: string;
      logo_data?: string;
      primary_color?: string;
      phone?: string;
      website?: string;
    };
    phone?: string;
    contactId?: number | string;
  }) {
    try {
      const { email, firstName, lastName, quoteUrl, planType, organization } = params;
      const fullName = `${firstName} ${lastName}`;
      const orgName = organization?.name || '';
      const primaryColor = organization?.primary_color || '#4F46E5';
      const phone = organization?.phone || '';
      const website = organization?.website || '';
      const websiteUrl = website.startsWith('http') ? website : `https://${website}`;
      
      // Generate tracking ID if organization and contactId are available
      let trackedQuoteUrl = quoteUrl;
      if (organization?.id && params.contactId) {
        const trackingId = this.generateTrackingId(organization.id, params.contactId);
        
        // Add tracking ID to quote URL
        trackedQuoteUrl = addTrackingToUrl(quoteUrl, trackingId);
        
        logger.info(`Added tracking ID ${trackingId} to quote URL for contact ${params.contactId}`);
      }
      
      // Format phone number if present
      const formatPhoneNumber = (phoneStr: string): string => {
        // Remove any non-digit characters
        const digitsOnly = phoneStr.replace(/\D/g, '');
        if (digitsOnly.length === 10) {
          return `(${digitsOnly.substring(0, 3)}) ${digitsOnly.substring(3, 6)}-${digitsOnly.substring(6)}`;
        } else if (digitsOnly.length === 11 && digitsOnly.startsWith('1')) {
          return `(${digitsOnly.substring(1, 4)}) ${digitsOnly.substring(4, 7)}-${digitsOnly.substring(7)}`;
        }
        // Return original if not a standard format
        return phoneStr;
      };
      
      // Format phone number to E.164 format for Twilio
      const formatE164 = (phoneStr: string): string => {
        // Remove any non-digit characters
        const digitsOnly = phoneStr.replace(/\D/g, '');
        // Handle US numbers
        if (digitsOnly.length === 10) {
          return `+1${digitsOnly}`;
        } else if (digitsOnly.length === 11 && digitsOnly.startsWith('1')) {
          return `+${digitsOnly}`;
        }
        // Return with + prefix if not matching expected formats
        return `+${digitsOnly}`;
      };
      
      const formattedPhone = phone ? formatPhoneNumber(phone) : '';
      const e164Phone = phone ? formatE164(phone) : '';
      
      const fromEmail = process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai';
      
      // Prepare email message
      const msg: any = {
        to: email,
        from: {
          email: fromEmail,
          name: orgName || 'MedicareMax'
        },
        subject: 'Your Personalized Medicare Quote',
        text: `Hello ${fullName},\n\nWe recently reviewed Medigap premiums for your zip code and found some options that might interest you. These plans offer the same comprehensive benefits you currently enjoy, potentially at a better value. We've done the research to find plans that maintain your coverage while possibly reducing your costs.\n\nReview your options here: ${trackedQuoteUrl}\n\nMany Medicare beneficiaries don't realize they can be paying different rates for identical coverage. We'd be happy to show you your options and potential savings. If we don't find a better value now, we'll keep monitoring rates and reach out when we find something promising.\n\nIf you have any questions, please give me a call: ${formattedPhone}\n\nBest,\n${orgName}\nYour Medicare Specialist\n${formattedPhone}`,
        attachments: []
      };
      
      // Handle logo as attachment if present
      let logoHtml = '';
      if (organization?.logo_data) {
        // Extract the base64 content, removing data URL prefix if present
        let logoBase64 = organization.logo_data;
        if (logoBase64.startsWith('data:image/')) {
          const base64Parts = logoBase64.split(',');
          if (base64Parts.length > 1) {
            logoBase64 = base64Parts[1];
          }
        }
        
        // Add as attachment with content ID
        msg.attachments.push({
          content: logoBase64,
          filename: 'organization-logo.png',
          type: 'image/png',
          disposition: 'inline',
          content_id: 'organizationLogo'
        });
        
        // Reference the content ID in HTML
        logoHtml = `<div class="logo">
          <img src="cid:organizationLogo" alt="${orgName} Logo" width="160" 
               style="max-width: 250px; height: auto; margin-bottom: 25px; display: block; object-fit: contain; border: 0; outline: none;" />
        </div>`;
      } else {
        // Fallback if no logo
        logoHtml = `<div class="logo" style="margin-bottom: 25px;">
          <h1 style="font-size: 24px; font-weight: bold; color: ${primaryColor}; margin: 0;">${orgName}</h1>
        </div>`;
      }
      
      // Set HTML content
      msg.html = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
          <title>Your Medicare Coverage Update</title>
          <style type="text/css">
            /* GLOBAL RESETS */
            body {
              margin: 0;
              padding: 0;
              background-color: #f8f8f8;
              font-family: Arial, sans-serif;
            }
            table {
              border-collapse: collapse;
            }
            img {
              display: block;
              border: 0;
              outline: none;
              text-decoration: none;
              -ms-interpolation-mode: bicubic;
            }
            a {
              text-decoration: none;
              color: inherit;
            }
            h1, h2, h3, h4, h5, h6 {
              margin: 0;
              padding: 0;
              font-weight: bold;
            }

            /* CONTAINER STYLES */
            .email-container {
              width: 100%;
              max-width: 600px;
              background-color: #ffffff;
              border-radius: 8px;
              overflow: hidden;
            }

            /* CONTENT STYLES */
            .content {
              padding: 30px 40px;
              text-align: left;
              color: #333333;
              font-size: 16px;
              line-height: 24px;
            }
            .logo img {
              max-width: 100px;
              margin-bottom: 20px;
              display: block;
            }
            .message {
              margin: 0 0 30px 0;
            }
            /* BUTTON STYLES */
            .button-wrapper {
              text-align: left;
              margin-top: 20px;
              margin-bottom: 25px;
            }
            .cta-button {
              color: #ffffff !important;
              padding: 14px 28px;
              font-size: 16px;
              font-weight: bold;
              border-radius: 4px;
              display: inline-block;
              text-decoration: none;
              box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
          </style>
        </head>
        <body style="margin:0; padding:0; background-color:#f8f8f8;">
          <table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#f8f8f8">
            <tr>
              <td align="center" style="padding: 40px 0;">
                <table class="email-container" border="0" cellspacing="0" cellpadding="0">
                  <tr>
                    <td>
                      <div class="content">
                        ${logoHtml}
                        
                        <div class="message">
                          <p>Hi ${firstName},</p>
                          <p>We recently reviewed Medigap premiums for your zip code and found some options that might interest you.</p>
                          <p>These plans offer the same comprehensive benefits you currently enjoy, potentially at a better value. We've done the research to find plans that maintain your coverage while possibly reducing your costs.</p>
                        </div>
                        
                        <div class="button-wrapper">
                          <a href="${trackedQuoteUrl}" target="_blank" class="cta-button" style="background-color:rgb(3, 3, 20); color: #ffffff !important; text-decoration: none; font-weight: bold;">  
                            Review Your Medicare Options
                          </a>
                        </div>
                        
                        <div class="message" style="margin-top: 30px;">
                          <p>Many Medicare beneficiaries don't realize they can be paying different rates for identical coverage. We'd be happy to show you your options and potential savings. If we don't find a better value now, we'll keep monitoring rates and reach out when we find something promising.</p>
                          ${formattedPhone ? `<p>If you have any questions, give me a call: ${formattedPhone}</p>` : ''}
                          <p style="margin-top: 25px; margin-bottom: 5px;">
                            Best,<br>
                            <strong>${orgName}</strong><br>
                            Your Medicare Specialist<br>
                            ${formattedPhone ? `<span style="color: #444;">${formattedPhone}</span>` : ''}
                          </p>
                        </div>

                        <div style="font-size: 12px; color: #666666; margin-top: 30px; padding-top: 15px; border-top: 1px solid #eeeeee;">
                          <p style="margin: 5px 0;">
                            #${orgName ? orgName : ''}<br>
                            ${formattedPhone ? `Phone: <a href="tel:${phone}" style="color: #0066cc; text-decoration: none;">${formattedPhone}</a><br>` : ''}
                            ${website ? `Website: <a href="${websiteUrl}" target="_blank" style="color: #0066cc; text-decoration: underline;">${website}</a>` : ''}
                          </p>
                        </div>
                      </div>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </body>
        </html>
      `;
      
      const result = await sgMail.send(msg);
      logger.info(`Quote email sent successfully to ${email}`);

      // also send out text via twilio / mds endpoint
      
      
      // const tempRetoolEndpoint = "https://api.retool.com/v1/workflows/2dfd31e1-b979-4f4d-a572-ca92879a3c09/startTrigger?workflowApiKey=retool_wk_e06f6026e4be4854bce04b77c90ee4c3"
      const msgContent = `
        Hi ${firstName}, this is the team from ${orgName}. We recently reviewed Medigap premiums for your zip code and found some options that might interest you. Click the link below to review your options:
        ${trackedQuoteUrl}  
      `

      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const authToken = process.env.TWILIO_AUTH_TOKEN;
      const client = twilio(accountSid, authToken);
      // Get client's phone number from params
      const clientPhone = params.phone;
      const clientE164Phone = clientPhone ? formatE164(clientPhone) : null;

      if (clientE164Phone) {
        logger.info(`clientE164Phone: ${clientE164Phone}`);
        /*
        const bodyToSend = {
          phone: clientE164Phone,
          firstName: firstName,
          quoteUrl: trackedQuoteUrl,
          orgName: orgName
        }
        logger.info(JSON.stringify(bodyToSend));
        
        const twilioResponse = await fetch(tempRetoolEndpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(bodyToSend)
        });
        */


        const twilioResponse = await client.messages.create({
          body: msgContent,
          from: process.env.TWILIO_PHONE_NUMBER,
          to: clientE164Phone
        });
        logger.info(`Text sent successfully to ${clientE164Phone}`);
        logger.info(JSON.stringify(twilioResponse));
      } else {
        logger.info('No client phone number provided - skipping text message');
      }

      // Return the SendGrid response and message ID if available
      return { 
        success: true,
        messageId: result && result[0] && result[0].headers ? result[0].headers['x-message-id'] : undefined
      };
    } catch (error) {
      logger.error(`Error sending quote email: ${error}`);
      throw new Error('Failed to send quote email');
    }
  }
}

// For the organization signup flow
export async function sendMagicLink({ email, magicLink, name }: {
  email: string;
  magicLink: string;
  name: string;
}) {
  try {
    const fromEmail = process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai';
    const msg = {
      to: email,
      from: {
        email: fromEmail,
        name: 'MedicareMax'
      },
      subject: 'Verify Your MedicareMax Account',
      text: `Hi ${name},\n\nClick this link to verify your account: ${magicLink}\n\nThis link will expire in 30 minutes.`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Welcome to MedicareMax</h2>
          <p>Hi ${name},</p>
          <p>Click the button below to verify your account and complete your organization setup. This link will expire in 30 minutes.</p>
          <div style="margin: 30px 0;">
            <a href="${magicLink}" 
               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 4px; display: inline-block;">
              Verify Account
            </a>
          </div>
          <p style="color: #666; font-size: 14px;">
            If the button doesn't work, copy and paste this link into your browser:
            <br>
            <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
          </p>
        </div>
      `
    };

    await sgMail.send(msg);
    logger.info('Magic link email sent successfully');
  } catch (error) {
    logger.error(`Failed to send magic link email: ${error}`);
    throw error;
  }
}

// Generate a hash for onboarding link validation
function generateHash(orgId: string, email: string): string {
  const SECRET = process.env.HASH_SECRET || 'default-hash-secret'; // Ensure this is set in your environment
  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
}

/**
 * Sends an onboarding link that includes organizationId, and optionally email and hash
 * @param orgId Organization ID to include in the link
 * @param email Optional email to include in the link and use as recipient
 * @param orgName Optional organization name to use as sender name
 */
export async function sendOnboardingLink(orgId: string, email?: string, orgName?: string) {
  try {
    // Base onboarding URL with orgId
    const baseUrl = process.env.FRONTEND_URL || 'https://medicaremax.ai';
    let onboardingUrl = `${baseUrl}/onboard?orgId=${orgId}`;
    
    // If email is provided, add email and hash to the URL
    if (email) {
      const hash = generateHash(orgId, email);
      onboardingUrl += `&email=${encodeURIComponent(email)}&hash=${hash}`;
    }
    
    const fromEmail = process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai';
    // Create email message
    const msg = {
      to: email || process.env.FALLBACK_EMAIL || 'information@medicaremax.ai', // Fallback if no email provided
      from: {
        email: fromEmail,
        name: orgName || 'MedicareMax'
      },
      subject: 'Join MedicareMax',
      text: `Click this link to create or update your profile: ${onboardingUrl}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Welcome to MedicareMax</h2>
          <p>Click the button below to create or update your profile:</p>
          <div style="margin: 30px 0;">
            <a href="${onboardingUrl}" 
               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 4px; display: inline-block;">
              Get Started
            </a>
          </div>
          <p style="color: #666; font-size: 14px;">
            If the button doesn't work, copy and paste this link into your browser:
            <br>
            <a href="${onboardingUrl}" style="color: #4F46E5;">${onboardingUrl}</a>
          </p>
          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
            <p style="color: #888; font-size: 14px;">
              If you have any questions, please don't hesitate to contact us.
              <br>
              The MedicareMax Team
            </p>
          </div>
        </div>
      `
    };

    await sgMail.send(msg);
    logger.info(`Onboarding link email sent successfully${email ? ` to ${email}` : ''}`);
    return { success: true };
  } catch (error) {
    logger.error(`Error sending onboarding link email: ${error}`);
    throw new Error('Failed to send onboarding link email');
  }
}

================
File: src/services/stripe.ts
================
import Stripe from 'stripe';
import { config } from '../config';
import { logger } from '../logger';
import { Database } from '../database';
import { Elysia, t } from 'elysia';
import type { UserContext } from '../types';
import { requireAuth } from '../middleware/auth';

const stripe = new Stripe(config.stripeSecretKey, {
  apiVersion: '2025-02-24.acacia'
});

export type SubscriptionStatus = {
  isActive: boolean;
  tier: string;
  currentPeriodEnd?: number;
  cancelAtPeriodEnd?: boolean;
  paymentStatus: 'paid' | 'unpaid' | 'no_subscription';
};

export async function checkPaymentStatus(db: Database, organizationId: number): Promise<SubscriptionStatus> {
  // First check local database
  const org = await db.fetchOne<{
    stripe_customer_id: string;
    stripe_subscription_id: string;
    subscription_status: string;
    payment_completed: number;
  }>(
    'SELECT stripe_customer_id, stripe_subscription_id, subscription_status, payment_completed FROM organizations WHERE id = ?',
    [organizationId]
  );

  if (!org) {
    throw new Error('Organization not found');
  }

  // If payment is already marked as completed locally, no need to check Stripe
  if (org.payment_completed === 1) {
    return {
      isActive: org.subscription_status === 'active',
      tier: 'paid',
      paymentStatus: 'paid'
    };
  }

  // If no Stripe subscription yet, return unpaid status0
  if (!org.stripe_subscription_id) {
    return {
      isActive: false,
      tier: 'basic',
      paymentStatus: 'no_subscription'
    };
  }

  // Check Stripe for current status
  try {
    const subscription = await stripe.subscriptions.retrieve(org.stripe_subscription_id);
    
    // Update local payment_completed status if paid
    if (subscription.status === 'active' && !subscription.cancel_at_period_end) {
      await db.execute(
        'UPDATE organizations SET payment_completed = 1 WHERE id = ?',
        [organizationId]
      );
    }

    return {
      isActive: subscription.status === 'active',
      tier: subscription.items.data[0].price.nickname || 'paid',
      currentPeriodEnd: subscription.current_period_end,
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
      paymentStatus: subscription.status === 'active' ? 'paid' : 'unpaid'
    };
  } catch (error) {
    logger.error(`Error checking Stripe subscription status: ${error}`);
    return {
      isActive: false,
      tier: 'basic',
      paymentStatus: 'unpaid'
    };
  }
}

export async function activateSubscription(db: Database, organizationId: number): Promise<void> {
  await db.execute(
    'UPDATE organizations SET payment_completed = 1, subscription_status = ? WHERE id = ?',
    ['active', organizationId]
  );
}

export async function reportContactUsage(db: Database, organizationId: number): Promise<void> {
  const org = await db.fetchOne<{
    stripe_subscription_id: string;
    contact_count: number;
  }>(
    'SELECT stripe_subscription_id, (SELECT COUNT(*) FROM contacts WHERE organization_id = organizations.id) as contact_count FROM organizations WHERE id = ?',
    [organizationId]
  );

  if (!org?.stripe_subscription_id) {
    logger.info(`No subscription found for organization ${organizationId}`);
    return;
  }

  try {
    // Get subscription items to find the metered price item
    const subscription = await stripe.subscriptions.retrieve(org.stripe_subscription_id);
    const meteredItem = subscription.items.data.find(item => 
      item.price.id === config.stripe.prices.additionalContacts
    );

    if (!meteredItem) {
      logger.info(`No metered item found for subscription ${org.stripe_subscription_id}`);
      return;
    }

    // Report current contact count as usage
    await stripe.subscriptionItems.createUsageRecord(
      meteredItem.id,
      {
        quantity: org.contact_count,
        timestamp: Math.floor(Date.now() / 1000),
        action: 'set'
      }
    );

    logger.info(`Successfully reported contact usage for organization ${organizationId} (${org.contact_count} contacts)`);
  } catch (error) {
    logger.error(`Error reporting contact usage to Stripe: ${error}`);
    throw error;
  }
}

================
File: src/services/subscription.ts
================
import { Database } from '../database';
import { logger } from '../logger';
import Stripe from 'stripe';
import { config } from '../config';

// Define possible account statuses
export type AccountStatus = 
  | 'good_standing'           // Everything is fine
  | 'inactive'                // Subscription inactive (canceled, past_due, etc.)
  | 'agent_limit_exceeded'    // Too many agents for current plan
  | 'contact_limit_exceeded'; // Too many contacts for current plan

export interface AccountStatusDetails {
  status: AccountStatus;
  message: string;
  organizationId: number;
  organizationName: string;
  organizationSlug: string;
  subscriptionTier: string;
  subscriptionStatus: string;
  agentLimit: number;
  contactLimit: number;
  currentAgentCount: number;
  currentContactCount: number;
  billingCycleEnd?: Date;
  paymentFailureCount: number;
  paymentCompleted: boolean;
}

/**
 * Updates organization subscription status from Stripe
 */
export async function syncSubscriptionStatus(organizationId: number): Promise<void> {
  const db = new Database();
  
  try {
    // Get organization details
    const orgResult = await db.execute(
      'SELECT stripe_subscription_id, stripe_customer_id FROM organizations WHERE id = ?', 
      [organizationId]
    );
    
    if (!orgResult.rows || orgResult.rows.length === 0) {
      logger.error(`Organization not found: ${organizationId}`);
      return;
    }
    
    const org = orgResult.rows[0];
    
    // If no Stripe subscription ID, nothing to sync
    if (!org[0]) {
      logger.info(`No Stripe subscription for organization ${organizationId}`);
      return;
    }
    
    // Initialize Stripe client
    const stripe = new Stripe(config.stripe.secretKey, {
      apiVersion: '2025-02-24.acacia' as Stripe.LatestApiVersion,
    });
    
    // Fetch the subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(org[0]);
    
    // Map Stripe status to our status
    let subscriptionStatus = 'active';
    if (subscription.status === 'active' || subscription.status === 'trialing') {
      subscriptionStatus = 'active';
    } else if (subscription.status === 'past_due') {
      subscriptionStatus = 'past_due';
    } else {
      subscriptionStatus = 'inactive';
    }
    
    // Get the billing cycle end
    const billingCycleEnd = new Date(subscription.current_period_end * 1000);
    
    // Get trial end if applicable
    const trialEnd = subscription.trial_end 
      ? new Date(subscription.trial_end * 1000) 
      : null;
    
    // Get extra agents and contacts from subscription metadata
    const extraAgents = parseInt(subscription.metadata.extraAgents || '0', 10);
    const extraContacts = parseInt(subscription.metadata.extraContacts || '0', 10);
    
    // Update the organization with Stripe data
    await db.execute(`
      UPDATE organizations 
      SET 
        subscription_status = ?,
        billing_cycle_end = ?,
        trial_end_date = ?,
        extra_agents = ?,
        extra_contacts = ?
      WHERE id = ?
    `, [
      subscriptionStatus,
      billingCycleEnd.toISOString(),
      trialEnd?.toISOString() || null,
      extraAgents,
      extraContacts,
      organizationId
    ]);
    
    logger.info(`Updated subscription status for organization ${organizationId}: ${subscriptionStatus}`);
    
  } catch (error) {
    logger.error(`Error syncing subscription status for organization ${organizationId}:`, error);
    throw error;
  }
}

/**
 * Checks if an organization's account is in good standing
 */
export async function checkAccountStatus(organizationId: number): Promise<AccountStatusDetails> {
  const db = new Database();
  
  try {
    // Try to sync with Stripe first
    try {
      await syncSubscriptionStatus(organizationId);
    } catch (error) {
      logger.warn(`Could not sync with Stripe for organization ${organizationId}:`, error);
    }
    
    // Get basic organization info first (this should always work)
    const orgResult = await db.execute(
      'SELECT id, name, slug, subscription_tier, subscription_status, agent_limit, contact_limit, extra_agents, extra_contacts, billing_cycle_end, payment_failure_count, payment_completed FROM organizations WHERE id = ?', 
      [organizationId]
    );
    
    if (!orgResult.rows || orgResult.rows.length === 0) {
      throw new Error(`Organization not found: ${organizationId}`);
    }
    
    const org = orgResult.rows[0];
    
    try {
      // Try to query the organization_status view
      const statusResult = await db.execute(
        'SELECT * FROM organization_status WHERE id = ?', 
        [organizationId]
      );
      
      if (statusResult.rows && statusResult.rows.length > 0) {
        const status = statusResult.rows[0];
        const columns = statusResult.columns || [];
        
        // Create an object from the row array using column names
        const statusObj: any = {};
        columns.forEach((col, i) => {
          statusObj[col] = status[i];
        });
        
        // Prepare status details with appropriate message
        let message = '';
        switch (statusObj.account_status) {
          case 'inactive':
            message = `Your subscription is ${statusObj.subscription_status}. Please update your payment method.`;
            break;
            
          case 'agent_limit_exceeded':
            message = `Your account has ${statusObj.current_agent_count} agents, but your plan only allows for ${statusObj.agent_limit + statusObj.extra_agents}. Please remove some agents or upgrade your plan.`;
            break;
            
          case 'contact_limit_exceeded':
            message = `Your account has ${statusObj.current_contact_count} contacts, but your plan only allows for ${statusObj.contact_limit + statusObj.extra_contacts}. Please remove some contacts or upgrade your plan.`;
            break;
            
          case 'good_standing':
          default:
            message = 'Your account is in good standing.';
            break;
        }
        
        return {
          status: statusObj.account_status,
          message,
          organizationId: statusObj.id,
          organizationName: statusObj.name,
          organizationSlug: statusObj.slug,
          subscriptionTier: statusObj.subscription_tier,
          subscriptionStatus: statusObj.subscription_status,
          agentLimit: statusObj.agent_limit + statusObj.extra_agents,
          contactLimit: statusObj.contact_limit + statusObj.extra_contacts,
          currentAgentCount: statusObj.current_agent_count,
          currentContactCount: statusObj.current_contact_count,
          billingCycleEnd: statusObj.billing_cycle_end ? new Date(statusObj.billing_cycle_end) : undefined,
          paymentFailureCount: statusObj.payment_failure_count,
          paymentCompleted: statusObj.payment_completed
        };
      }
    } catch (viewError) {
      // If there's an error querying the view (e.g., it doesn't exist),
      // we'll fall through to the default implementation below
      logger.warn(`Error querying organization_status view: ${viewError}`);
    }
    
    // If we get here, either the view doesn't exist or there was no result
    // Provide default values based on the organization record
    
    // Default to good standing
    const accountStatus: AccountStatus = 'good_standing';
    const message = 'Your account is in good standing.';
    
    // Extract values from the row array
    const columns = orgResult.columns || [];
    const orgObj: any = {};
    columns.forEach((col, i) => {
      orgObj[col] = org[i];
    });
    
    // Use defaults for missing values
    const subscriptionStatus = orgObj.subscription_status || 'active';
    const agentLimit = orgObj.agent_limit || 5;
    const contactLimit = orgObj.contact_limit || 100;
    const extraAgents = orgObj.extra_agents || 0;
    const extraContacts = orgObj.extra_contacts || 0;
    
    return {
      status: accountStatus,
      message,
      organizationId: orgObj.id,
      organizationName: orgObj.name,
      organizationSlug: orgObj.slug,
      subscriptionTier: orgObj.subscription_tier,
      subscriptionStatus,
      agentLimit: agentLimit + extraAgents,
      contactLimit: contactLimit + extraContacts,
      currentAgentCount: 0, // Default to 0 since we can't query agents table
      currentContactCount: 0, // Default to 0 since we can't query contacts table
      billingCycleEnd: orgObj.billing_cycle_end ? new Date(orgObj.billing_cycle_end) : undefined,
      paymentFailureCount: orgObj.payment_failure_count || 0,
      paymentCompleted: orgObj.payment_completed || false
    };
    
  } catch (error) {
    logger.error(`Error checking account status for organization ${organizationId}:`, error);
    throw error;
  }
}

================
File: src/services/turso.ts
================
import { createClient } from '@libsql/client';
import { TURSO_CONFIG } from '../config/turso';
import { logger } from '../logger';
import { config } from '../config'
import fetch from 'node-fetch'
import * as fs from 'fs';

// Use non-null assertion since we check these values immediately
const TURSO_DB_URL = config.TURSO_DATABASE_URL!;
const TURSO_AUTH_TOKEN = config.TURSO_AUTH_TOKEN!;

if (!config.TURSO_DATABASE_URL) {
  throw new Error('TURSO_DATABASE_URL is not set');
}

if (!config.TURSO_AUTH_TOKEN) {
  throw new Error('TURSO_AUTH_TOKEN is not set');
}

export const tursoClient = createClient({
  url: TURSO_DB_URL,
  authToken: TURSO_AUTH_TOKEN,
});

export async function getTursoClient() {
  try {
    await tursoClient.execute('SELECT 1');
    return tursoClient;
  } catch (error) {
    logger.error(`Error connecting to Turso: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// Export a function to check if the client is healthy
export async function checkTursoHealth(): Promise<boolean> {
  try {
    await tursoClient.execute('SELECT 1');
    return true;
  } catch (error) {
    logger.error(`Turso health check failed: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

interface TursoResponse {
  databases?: Array<{
    Name: string;
    DbId: string;
    Hostname: string;
    Region: string;
  }>;
  jwt?: string;
  [key: string]: unknown;
}

export class TursoService {
  private apiToken: string
  private client;

  constructor() {
    const token = config.TURSO_API_TOKEN;
    if (!token) {
      throw new Error('TURSO_API_TOKEN is not set');
    }
    this.apiToken = token;
    this.client = tursoClient;
    
    logger.info('TursoService initialized with API token')
  }

  async createDatabaseForImport(orgId: string): Promise<{dbName: string, url: string, token: string}> {
    const dbName = `org-${orgId}-${Date.now()}`

    try {
      // Create database
      logger.info(`Creating Turso database for org ${orgId} with name ${dbName}`)
      const createResponse = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: dbName,
          group: TURSO_CONFIG.GROUP_NAME,
          "seed": { "type": "database_upload" }
        }),
      })

      const newDbData = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
        },
      })

      const newDbDataJson = await newDbData.json() as any
      const newDbUrl = newDbDataJson.database.Hostname

      const tokenResponse = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}/auth/tokens`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
        },
      })

      const newTokenData = await tokenResponse.json() as any
      const newToken = newTokenData.jwt

      // Verify the database is available by checking the databases list
      let dbFound = false;
      let attempts = 0;
      const maxAttempts = 5;
      
      while (!dbFound && attempts < maxAttempts) {
        const listResponse = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${this.apiToken}`,
          }
        });
        
        if (listResponse.ok) {
          const data = await listResponse.json();
          dbFound = data.databases.some((db: any) => db.Name === dbName);
          
          if (!dbFound) {
            logger.info(`Database ${dbName} not found in list, waiting 1 second before retry (attempt ${attempts + 1}/${maxAttempts})`);
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
          }
        } else {
          logger.warn(`Failed to list databases, status: ${listResponse.status}`);
          break;
        }
      }
      
      if (!dbFound) {
        logger.warn(`Database ${dbName} not found in databases list after ${maxAttempts} attempts, continuing anyway`);
      } else {
        logger.info(`Database ${dbName} confirmed in databases list`);
      }

      return {
        dbName: dbName,
        url: newDbUrl,
        token: newToken,
      }
    } catch (error) {
      logger.error(`Error creating database for import: ${error instanceof Error ? error.message : String(error)}`)
      throw error
    }
  }

  async uploadDatabase(dbName: string, authToken: string, filePath: string): Promise<any> {
    try {
      // Strip file: protocol if present
      const normalizedPath = filePath.replace(/^file:/, '');
      
      logger.info(`Attempting to upload database from file: ${normalizedPath}`);
      
      // Verify file exists before attempting upload
      if (!fs.existsSync(normalizedPath)) {
        const error = new Error(`File not found at path: ${normalizedPath}`);
        logger.error(`Upload failed - ${error.message}`);
        throw error;
      }

      const uploadUrl = `https://${dbName}-${TURSO_CONFIG.ORG_SLUG}.turso.io/v1/upload`;
      logger.info(`Uploading to URL: ${uploadUrl}`);

      const response = await fetch(uploadUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
        },
        body: fs.createReadStream(normalizedPath),
      });

      if (!response.ok) {
        const errorText = await response.text();
        logger.error(`Failed to upload database (status ${response.status}): ${errorText}`);
        
        // Log headers for debugging
        const headers: Record<string, string> = {};
        response.headers.forEach((value, key) => {
          headers[key] = value;
        });
        logger.error(`Response headers: ${JSON.stringify(headers)}`);
        
        throw new Error(`Failed to upload database: ${errorText}`);
      }
      
      const result = await response.json();
      logger.info(`Upload successful: ${JSON.stringify(result)}`);
      return result;
    } catch (error: unknown) {
      logger.error(`Error uploading database: ${error instanceof Error ? error.message : String(error)}`);
      if (error instanceof Error && error.stack) {
        logger.error(`Stack trace: ${error.stack}`);
      }
      throw error;
    }
  }

  async createOrganizationDatabase(orgId: string): Promise<{url: string, token: string}> {
    const dbName = `org-${orgId}-${Date.now()}`
    
    try {
      // Create database
      logger.info(`Creating Turso database for org ${orgId} with name ${dbName}`)
      const createResponse = await fetch('https://api.turso.tech/v1/databases', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: dbName,
          group: TURSO_CONFIG.GROUP_NAME,
        }),
      })

      if (!createResponse.ok) {
        const errorText = await createResponse.text()
        logger.error(`Failed to create database: ${errorText}`)
        throw new Error(`Failed to create database: ${errorText}`)
      }

      const createData = await createResponse.json() as any
      logger.info(`Database creation response: ${JSON.stringify(createData)}`)
      
      const hostname = createData.database?.Hostname
      if (!hostname) {
        logger.error(`Invalid database creation response - missing hostname: ${JSON.stringify(createData)}`)
        throw new Error('Failed to get database hostname')
      }
      logger.info(`Successfully created database with hostname: ${hostname}`)
      
      // Create access token
      logger.info(`Creating access token for database ${dbName}`)
      const tokenUrl = `https://api.turso.tech/v1/databases/${dbName}/auth/tokens`
      logger.info(`Token creation URL: ${tokenUrl}`)
      
      const tokenResponse = await fetch(tokenUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          expiration: 'never',
        }),
      })

      if (!tokenResponse.ok) {
        const errorText = await tokenResponse.text()
        logger.error(`Failed to create token (status ${tokenResponse.status}): ${errorText}`)
        // Log response headers for debugging
        const headers: Record<string, string> = {}
        tokenResponse.headers.forEach((value, key) => {
          headers[key] = value
        })
        logger.error(`Token response headers: ${JSON.stringify(headers)}`)
        throw new Error(`Failed to create token: ${errorText}`)
      }

      const tokenData = await tokenResponse.json() as any
      logger.info(`Token creation response: ${JSON.stringify(tokenData)}`)
      
      const token = tokenData.jwt
      if (!token) {
        logger.error(`Invalid token response - missing jwt: ${JSON.stringify(tokenData)}`)
        throw new Error('Failed to get database access token')
      }
      
      logger.info(`Successfully created token for database ${dbName}`)
      
      return {
        url: hostname,
        token,
      }
    } catch (error) {
      logger.error(`Error creating organization database: ${error instanceof Error ? error.message : String(error)}`)
      if (error instanceof Error && error.stack) {
        logger.error(`Stack trace: ${error.stack}`)
      }
      throw error
    }
  }

  async deleteOrganizationDatabase(dbName: string): Promise<void> {
    try {
      logger.info(`Deleting Turso database ${dbName}`)
      const response = await fetch(`https://api.turso.tech/v1/databases/${dbName}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
        },
      })

      if (!response.ok) {
        const errorText = await response.text()
        logger.error(`Failed to delete database: ${errorText}`)
        throw new Error(`Failed to delete database: ${errorText}`)
      }
      
      logger.info(`Successfully deleted database ${dbName}`)
    } catch (error) {
      logger.error(`Error deleting organization database: ${error}`)
      throw error
    }
  }

  // Helper function to normalize database URLs
  private normalizeDbUrl(url: string): { hostname: string, apiUrl: string, dbUrl: string } {
    // Strip any protocol prefix
    const hostname = url.replace(/(^https?:\/\/)|(^libsql:\/\/)/, '');
    return {
      hostname,  // Raw hostname without protocol
      apiUrl: `https://${hostname}`,  // For API calls
      dbUrl: `libsql://${hostname}`   // For database connections
    };
  }

  async downloadDatabaseDump(dbUrl: string, authToken: string): Promise<string> {
    try {
      const { apiUrl } = this.normalizeDbUrl(dbUrl);
      logger.info(`Downloading database dump from ${apiUrl}/dump`);
      
      const response = await fetch(`${apiUrl}/dump`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`,
        },
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to download dump: ${errorText}`);
      }

      return await response.text();
    } catch (error) {
      logger.error(`Error downloading database dump: ${error}`);
      throw error;
    }
  }

  async createDatabaseFromDump(orgId: string, suffix: string, dumpContent: string): Promise<{url: string, token: string}> {
    const dbName = `org-${orgId}-${suffix}`;

    try {
      logger.info(`Creating new database: ${dbName}`);
      
      // Step 1: Create the database with a unique name
      const createDbResponse = await fetch(
        `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, 
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: dbName,
            group: TURSO_CONFIG.GROUP_NAME
          })
        }
      );

      if (!createDbResponse.ok) {
        const errorText = await createDbResponse.text();
        throw new Error(`Failed to create database: ${errorText}`);
      }

      const dbData = await createDbResponse.json() as { database: { Hostname: string } };
      const { dbUrl, apiUrl } = this.normalizeDbUrl(dbData.database.Hostname);
      logger.info(`Database created: ${dbUrl}`);
      
      // Step 2: Generate an auth token for the database
      logger.info(`Generating auth token for database ${dbName}`);
      const tokenResponse = await fetch(
        `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}/auth/tokens`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      if (!tokenResponse.ok) {
        const errorText = await tokenResponse.text();
        // Try to clean up the created database
        try {
          await this.deleteOrganizationDatabase(dbName);
        } catch (cleanupError) {
          logger.warn(`Failed to delete database after token error: ${cleanupError}`);
        }
        throw new Error(`Failed to create auth token: ${errorText}`);
      }

      const tokenData = await tokenResponse.json() as { jwt: string };
      const token = tokenData.jwt;
      
      logger.info(`Successfully created database ${dbName} with auth token`);
      
      // Create client for the new database using libsql:// URL
      const client = createClient({
        url: dbUrl,
        authToken: token
      });
      
      // Split dump into logical statement groups for more reliable execution
      const statements = dumpContent
        .split(';')
        .map(stmt => stmt.trim())
        .filter(stmt => stmt.length > 0);
      
      logger.info(`Split SQL dump into ${statements.length} statements`);
      
      // Execute statements in phases - first schema statements, then data statements
      // Parse and categorize statements
      const schemaStatements = statements.filter(stmt => 
        stmt.toUpperCase().startsWith('CREATE TABLE')
      );
      
      const indexStatements = statements.filter(stmt => 
        stmt.toUpperCase().startsWith('CREATE INDEX') || 
        stmt.toUpperCase().startsWith('CREATE UNIQUE INDEX')
      );
      
      const insertStatements = statements.filter(stmt => 
        stmt.toUpperCase().startsWith('INSERT')
      );
      
      const otherStatements = statements.filter(stmt => 
        !schemaStatements.includes(stmt) && 
        !indexStatements.includes(stmt) && 
        !insertStatements.includes(stmt)
      );
      
      logger.info(`Processing ${schemaStatements.length} tables, ${indexStatements.length} indexes, ${insertStatements.length} data inserts, and ${otherStatements.length} other statements`);
      
      // Phase 1: Create tables
      for (const tableStatement of schemaStatements) {
        try {
          logger.info(`Creating table: ${tableStatement.substring(0, 60)}...`);
          await client.execute(tableStatement);
        } catch (error) {
          // If there's an error with the contacts table missing updated_at, add it
          if (tableStatement.includes('contacts') && 
              (error as Error).toString().includes('no column named updated_at')) {
            logger.warn('Error creating contacts table, attempting to fix missing updated_at column');
            
            // Add the updated_at column if it's missing
            try {
              // First create the table without the updated_at column
              await client.execute(tableStatement);
              
              // Then add the updated_at column
              await client.execute(`
                ALTER TABLE contacts
                ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
              `);
              
              logger.info('Successfully added missing updated_at column to contacts table');
            } catch (altError) {
              logger.error(`Failed to fix contacts table: ${altError}`);
              throw altError;
            }
          } else {
            // For other errors, just throw them
            throw error;
          }
        }
      }
      
      // Phase 2: Execute other statements (drops, alters, etc)
      for (const statement of otherStatements) {
        await client.execute(statement);
      }
      
      // Phase 3: Insert data
      logger.info(`Inserting data (${insertStatements.length} statements)...`);
      let successCount = 0;
      let errorCount = 0;
      
      // Check if we've already detected updated_at missing
      let updatedAtMissing = false;
      let checkedUpdatedAt = false;
      
      for (const insertStatement of insertStatements) {
        try {
          // Skip if we know the statement will fail due to updated_at missing
          if (updatedAtMissing && insertStatement.includes('updated_at')) {
            // Try to fix the insert statement by removing the updated_at column
            const fixedInsert = insertStatement
              .replace(/updated_at\s*,/i, '')  // Remove updated_at from column list
              .replace(/(\w+\s*,\s*)CURRENT_TIMESTAMP(\s*\))/gi, '$1$2')  // Remove corresponding value in VALUES
              .replace(/,\s*\)/g, ')');  // Fix any trailing commas
            
            try {
              await client.execute(fixedInsert);
              successCount++;
              
              // Log progress periodically
              if (successCount % 50 === 0) {
                logger.info(`Imported ${successCount}/${insertStatements.length} data statements (with fixes)`);
              }
            } catch (fixError) {
              errorCount++;
              logger.error(`Error executing fixed INSERT: ${fixError}`);
              // Continue with next statement
            }
            continue;
          }
          
          // Try the original statement
          await client.execute(insertStatement);
          successCount++;
          
          // Log progress periodically
          if (successCount % 50 === 0) {
            logger.info(`Imported ${successCount}/${insertStatements.length} data statements`);
          }
        } catch (error) {
          // Check if this is the updated_at missing error
          if (!checkedUpdatedAt && (error as Error).toString().includes('no column named updated_at')) {
            updatedAtMissing = true;
            checkedUpdatedAt = true;
            logger.warn('Detected missing updated_at column in contacts table, will attempt to fix INSERT statements');
            
            // Try to add the column if it's missing
            try {
              await client.execute(`
                ALTER TABLE contacts
                ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
              `);
              logger.info('Added missing updated_at column to contacts table');
              
              // Now we have the column, try the statement again
              try {
                await client.execute(insertStatement);
                successCount++;
                logger.info('Successfully executed INSERT after adding updated_at column');
                
                // We fixed the table, so we don't need to modify statements anymore
                updatedAtMissing = false;
              } catch (retryError) {
                errorCount++;
                logger.error(`Error retrying INSERT after adding column: ${retryError}`);
              }
            } catch (alterError) {
              logger.warn(`Could not add updated_at column: ${alterError}`);
              // Still mark as missing so we can fix the statements
            }
          } else {
            errorCount++;
            logger.error(`Error executing INSERT: ${error}`);
            // Continue with next statement - don't fail everything for one bad insert
          }
        }
      }
      
      // Phase 4: Create indexes (do this last for better performance)
      logger.info(`Creating ${indexStatements.length} indexes...`);
      for (const indexStatement of indexStatements) {
        try {
          await client.execute(indexStatement);
        } catch (error) {
          logger.warn(`Error creating index: ${error}`);
          // Continue with next index - not fatal
        }
      }
      
      // Log summary
      logger.info(`Database import complete: ${successCount} successful inserts, ${errorCount} errors`);
      
      // Verify the database
      try {
        const result = await client.execute('SELECT COUNT(*) as count FROM contacts');
        const count = result.rows?.[0]?.[0];
        logger.info(`Database verification: ${count} contacts found`);
      } catch (error) {
        logger.warn(`Error verifying database: ${error}`);
      }
      
      return { url: dbUrl, token };
    } catch (error) {
      logger.error(`Error creating database from dump: ${error}`);
      throw error;
    }
  }
  

  private handleError(error: unknown): never {
    logger.error(`Turso service error: ${error instanceof Error ? error.message : String(error)}`);
    throw error instanceof Error ? error : new Error(String(error));
  }

  private validateResponse(data: unknown): TursoResponse {
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid response from Turso API');
    }
    return data as TursoResponse;
  }
}

================
File: src/utils/quoteId.ts
================
import { createHash } from 'crypto';

// Function to generate a unique quote ID from org ID and contact ID
export function generateQuoteId(orgId: number, contactId: number): string {
    // Create a string to hash that includes org, contact, and secret

    const secret = process.env.QUOTE_SECRET || 'your-default-secret-key';

    const dataToHash = `${orgId}-${contactId}-${secret}`;
    console.log('dataToHash', dataToHash);
    
    // Generate hash using crypto
    const hash = createHash('sha256')
        .update(dataToHash)
        .digest('hex')
        .slice(0, 8); // Take first 8 characters for brevity
    
    // Combine components into quote ID
    const finalQuoteId = `${orgId}-${contactId}-${hash}`;
    console.log('finalQuoteId', finalQuoteId);
    return finalQuoteId;
}

// Function to decode a quote ID back to org ID and contact ID
export function decodeQuoteId(quoteId: string): { orgId: number; contactId: number } | null {
    try {
        const parts = quoteId.split('-');
        if (parts.length !== 3) {
            return null;
        }

        const [orgId, contactId, providedHash] = parts;
        
        // Recreate hash to validate
        const secret = process.env.QUOTE_SECRET || 'your-default-secret-key';
        const dataToHash = `${orgId}-${contactId}-${secret}`;
        console.log('dataToHash', dataToHash);
        const expectedHash = createHash('sha256')
            .update(dataToHash)
            .digest('hex')
            .slice(0, 8);

        // Compare hashes
        if (providedHash !== expectedHash) {
            return null;
        }

        return {
            orgId: parseInt(orgId),
            contactId: parseInt(contactId)
        };
    } catch (e) {
        return null;
    }
}

================
File: src/utils/tracking.ts
================
/**
 * Utilities for tracking URLs and link analytics
 */

/**
 * Generates a tracking ID for a particular URL
 * Format: tid-[orgId]-[contactId]-[timestamp]
 * @param orgId Organization ID
 * @param contactId Contact ID
 * @param prefix Optional prefix for the tracking ID (defaults to 'tid')
 * @returns Tracking ID string
 */
export const generateTrackingId = (orgId: number | string, contactId: number | string, prefix: string = 'tid'): string => {
  const timestamp = Date.now();
  return `${prefix}-${orgId}-${contactId}-${timestamp}`;
};

/**
 * Adds tracking parameters to a URL
 * @param url The original URL
 * @param trackingId The tracking ID to add
 * @returns URL with tracking parameters
 */
export const addTrackingToUrl = (url: string, trackingId: string): string => {
  try {
    const urlObj = new URL(url);
    urlObj.searchParams.append('tid', trackingId);
    return urlObj.toString();
  } catch (error) {
    // If URL parsing fails, append as a simple query parameter
    const separator = url.includes('?') ? '&' : '?';
    return `${url}${separator}tid=${trackingId}`;
  }
};

/**
 * Extracts information from a tracking ID
 * @param trackingId The tracking ID to parse
 * @returns Object with parsed tracking info or null if invalid
 */
export const parseTrackingId = (trackingId: string): { prefix: string, orgId: string, contactId: string, timestamp: number } | null => {
  const parts = trackingId.split('-');
  if (parts.length < 4) {
    return null;
  }
  
  const [prefix, orgId, contactId, timestampStr] = parts;
  const timestamp = parseInt(timestampStr, 10);
  
  if (isNaN(timestamp)) {
    return null;
  }
  
  return {
    prefix,
    orgId,
    contactId,
    timestamp
  };
};

================
File: src/config.ts
================
import { config as dotenvConfig } from 'dotenv'
import { resolve } from 'path'
import { logger } from './logger'
import { existsSync } from 'fs'
import dotenv from 'dotenv'
import fs from 'fs'
import path from 'path'

// Get absolute path to .env file
const envPath = resolve(__dirname, '../.env')

// Check if .env file exists - but don't exit if using Replit Secrets
const envFileExists = existsSync(envPath)
if (!envFileExists) {
  console.log(` .env file not found at: ${envPath}, will attempt to use Replit Secrets instead`)
} else {
  // Load .env file with override option only if it exists
  const result = dotenvConfig({ 
    path: envPath,
    override: true // This tells dotenv to override existing env vars
  })

  if (result.error) {
    console.warn(' Error loading .env file:', result.error)
  } else {
    console.log(' Loading .env from:', envPath)
  }
}

// Log environment variables (safely)
console.log(' Environment variables available:', {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL ? '[PRESENT]' : '[MISSING]',
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN ? '[PRESENT]' : '[MISSING]',
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH ? '[PRESENT]' : '[MISSING]'
})

// Load environment variables from .env file
if (fs.existsSync(path.join(process.cwd(), '.env'))) {
  dotenv.config()
}

// Look for mockStripe: true in the environment, if not found, default to true in development and false in production
const useMockStripe = process.env.USE_MOCK_STRIPE === 'true' || 
  (process.env.NODE_ENV === 'development' && process.env.USE_REAL_STRIPE !== 'true');

export const config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  TURSO_API_TOKEN: process.env.TURSO_API_TOKEN,
  TURSO_ORG_GROUP: process.env.TURSO_ORG_GROUP || 'maxretain',
  TURSO_ORG_SLUG: process.env.TURSO_ORG_SLUG || 'pyrex41',
  USE_LOCAL_SQLITE: process.env.USE_LOCAL_SQLITE === 'true',
  LOCAL_DB_PATH: process.env.LOCAL_DB_PATH || './.data',
  quoteApiKey: process.env.QUOTE_API_KEY,
  quoteSecret: process.env.QUOTE_SECRET,
  magicLinkSecret: process.env.MAGIC_LINK_SECRET,
  sendgridApiKey: process.env.SENDGRID_API_KEY,
  sendgridFromEmail: process.env.SENDGRID_FROM_EMAIL,
  PUBLIC_URL: process.env.PUBLIC_URL || (process.env.NODE_ENV === 'development' 
    ? 'http://localhost:5173'
    : 'http://localhost:3000'),
  stripe: {
    secretKey: process.env.STRIPE_SECRET_KEY,
    publishableKey: process.env.STRIPE_PUBLISHABLE_KEY,
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
    useMock: useMockStripe,
    pricingTableId: process.env.STRIPE_PRICING_TABLE_ID || 'prctbl_1RAfz9CBUPXAZKNG0EyV8bRU',
    prices: {
      basic: process.env.STRIPE_PRICE_BASIC || 'price_basic',
      pro: process.env.STRIPE_PRICE_PRO || 'price_pro',
      enterprise: process.env.STRIPE_PRICE_ENTERPRISE || 'price_enterprise',
      contactBaseTier: process.env.STRIPE_PRICE_CONTACT_BASE_TIER || 'price_contact_base',
      additionalContacts: process.env.STRIPE_PRICE_ADDITIONAL_CONTACTS || 'price_additional_contacts',
      // Optional price IDs for legacy support
      extraAgent: process.env.STRIPE_PRICE_EXTRA_AGENT,
      extraContact: process.env.STRIPE_PRICE_EXTRA_CONTACT,
    },
    publicKey: process.env.STRIPE_PUBLIC_KEY,
    connectAccount: process.env.STRIPE_CONNECT_ACCOUNT,
  },
  stripeApiKey: process.env.STRIPE_SECRET_KEY,
  stripeWebhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
  clientUrl: process.env.PUBLIC_URL || 'http://localhost:5173',
  stripeSecretKey: process.env.STRIPE_SECRET_KEY || '',
}

// Log loaded config (safely)
logger.info(`Config loaded ${envFileExists ? `from ${envPath}` : 'from environment'}`)

================
File: src/database.ts
================
import { createClient } from '@libsql/client'
import { config } from './config'
import { logger } from './logger'
import { TursoService } from './services/turso'
import { Database as BunDatabase } from 'bun:sqlite'
import fs from 'fs'
import path from 'path'
import { parse } from 'csv-parse'
import { pipeline } from 'stream/promises'
import fetch, { Response } from 'node-fetch'
import type { RequestInit, RequestInfo, BodyInit } from 'node-fetch'
import type { ContactCreate } from './types'

import fsPromises from 'fs/promises'
import Bun from 'bun'
import { ZIP_DATA } from './index' // Import ZIP_DATA for state lookup

// Connection pool to reuse database connections
interface ConnectionInfo {
  client: any;
  url: string;
  lastUsed: number;
}

class ConnectionPool {
  private static instance: ConnectionPool;
  private connections: Map<string, ConnectionInfo> = new Map();
  private readonly MAX_IDLE_TIME = 60000; // 60 seconds max idle time
  private readonly MAX_POOL_SIZE = 20; // Maximum connections to keep in the pool
  private cleanupInterval: any;

  private constructor() {
    // Start the cleanup interval to remove idle connections
    this.cleanupInterval = setInterval(() => this.cleanupIdleConnections(), 30000);
  }

  public static getInstance(): ConnectionPool {
    if (!ConnectionPool.instance) {
      ConnectionPool.instance = new ConnectionPool();
    }
    return ConnectionPool.instance;
  }

  public getConnection(url: string, authToken: string): any {
    // Check if we have a connection for this URL
    if (this.connections.has(url)) {
      const conn = this.connections.get(url)!;
      conn.lastUsed = Date.now();
      return conn.client;
    }

    // If we've reached max pool size, remove the oldest connection
    if (this.connections.size >= this.MAX_POOL_SIZE) {
      let oldestTime = Infinity;
      let oldestUrl = '';
      
      for (const [connUrl, conn] of this.connections.entries()) {
        if (conn.lastUsed < oldestTime) {
          oldestTime = conn.lastUsed;
          oldestUrl = connUrl;
        }
      }
      
      if (oldestUrl) {
        logger.info(`Connection pool: removing oldest connection ${oldestUrl}`);
        this.connections.delete(oldestUrl);
      }
    }

    // Create a new connection
    logger.info(`Creating new Turso connection for ${url}`);
    const client = createClient({
      url,
      authToken,
      concurrency: 25, // Lower concurrency to prevent rate limits
      fetch: async (fetchUrl: RequestInfo, options: RequestInit) => {
        // Add custom fetch with retry for 429 errors
        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            const response = await fetch(fetchUrl, options);
            if (response.status === 429) {
              // Rate limited, wait with exponential backoff
              const delay = Math.pow(2, attempt) * 1000;
              logger.warn(`Rate limit hit in Turso API call, retry ${attempt+1}/${maxRetries} after ${delay}ms`);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue;
            }
            return response;
          } catch (error) {
            if (attempt === maxRetries - 1) throw error;
            const delay = Math.pow(2, attempt) * 1000;
            logger.warn(`Error in Turso API call, retry ${attempt+1}/${maxRetries} after ${delay}ms: ${error}`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
        throw new Error('Max retries reached for Turso API call');
      }
    });

    // Store in the pool
    this.connections.set(url, {
      client,
      url,
      lastUsed: Date.now()
    });

    return client;
  }

  private cleanupIdleConnections() {
    const now = Date.now();
    let cleanedCount = 0;
    
    for (const [url, conn] of this.connections.entries()) {
      if (now - conn.lastUsed > this.MAX_IDLE_TIME) {
        this.connections.delete(url);
        cleanedCount++;
      }
    }
    
    if (cleanedCount > 0) {
      logger.info(`Connection pool: cleaned up ${cleanedCount} idle connections, remaining: ${this.connections.size}`);
    }
  }

  public shutdown() {
    clearInterval(this.cleanupInterval);
    this.connections.clear();
  }
}

type ColumnMapping = {
  firstName: string;
  lastName: string;
  email: string;
  phoneNumber: string;
  state?: string; // Make state optional since we'll infer it from zip code
  currentCarrier: string;
  effectiveDate: string;
  birthDate: string;
  tobaccoUser: string;
  gender: string;
  zipCode: string;
  planType: string;
};

type CarrierMapping = {
  detectedCarriers: string[];
  mappings: Record<string, string>;
};

interface FetchOptions extends RequestInit {
  method?: string;
  headers?: Record<string, string>;
  body?: BodyInit;
}

export class Database {
  private client: any
  private url: string
  private isLocal: boolean
  private bunDb: BunDatabase | null = null

  public static normalizeDbUrl(url: string): { hostname: string, apiUrl: string, dbUrl: string, dbName: string } {
    // Strip any protocol prefix
    const hostname = url.replace(/(^https?:\/\/)|(^libsql:\/\/)/, '');
    const dbName = hostname.split('/').pop()?.split('.')[0] || '';
    return {
      hostname,  // Raw hostname without protocol
      apiUrl: `https://${hostname}`,  // For API calls
      dbUrl: `libsql://${hostname}`,   // For database connections
      dbName // For local SQLite files
    };
  }

  constructor(dbUrl?: string, authToken?: string) {
    const url = dbUrl || config.TURSO_DATABASE_URL
    const token = authToken || config.TURSO_AUTH_TOKEN

    if (!url) {
      logger.error('Missing database URL')
      throw new Error('Missing database URL')
    }

    const { dbUrl: normalizedUrl, dbName } = Database.normalizeDbUrl(url)
    this.url = normalizedUrl
    this.isLocal = config.USE_LOCAL_SQLITE

    if (this.isLocal) {
      const dbPath = path.join(process.cwd(), config.LOCAL_DB_PATH, `${dbName}.sqlite`)
      logger.info(`Using local SQLite database at: ${dbPath}`)
      
      // Create directory if it doesn't exist
      const dbDir = path.dirname(dbPath)
      if (!fs.existsSync(dbDir)) {
        fs.mkdirSync(dbDir, { recursive: true })
      }
      
      this.bunDb = new BunDatabase(dbPath)
      this.client = this.bunDb
      
      // Enable foreign keys
      this.bunDb.exec('PRAGMA foreign_keys = ON;')
    } else {
      if (!token) {
        logger.error('Missing database token')
        throw new Error('Missing database token')
      }
      this.client = createClient({
        url: normalizedUrl,
        authToken: token,
        concurrency: 25, // Reduced concurrency to prevent rate limits
        fetch: async (fetchUrl: RequestInfo, options: RequestInit) => {
          // Add custom fetch with retry for 429 errors
          const maxRetries = 3;
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const response = await fetch(fetchUrl, options);
              if (response.status === 429) {
                // Rate limited, wait with exponential backoff
                const delay = Math.pow(2, attempt) * 1000;
                logger.warn(`Rate limit hit in Turso API call, retry ${attempt+1}/${maxRetries} after ${delay}ms`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
              }
              return response;
            } catch (error) {
              if (attempt === maxRetries - 1) throw error;
              const delay = Math.pow(2, attempt) * 1000;
              logger.warn(`Error in Turso API call, retry ${attempt+1}/${maxRetries} after ${delay}ms: ${error}`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
          throw new Error('Max retries reached for Turso API call');
        }
      })
    }
    
    logger.info(`Database connected to: ${this.isLocal ? dbName : this.url}`)
  }

  static async getOrgDb(orgId: string): Promise<Database> {
    logger.info(`Getting org database for org ${orgId}`);
    const mainDb = new Database();
    
    try {
      const org = await mainDb.fetchOne<{ turso_db_url: string; turso_auth_token: string }>(
        'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
        [orgId]
      );
      logger.info(`[OrgDB] Organization record: ${JSON.stringify(org)}`);

      if (!org) {
        logger.warn(`[OrgDB] Organization record not found for orgId: ${orgId}`);
        throw new Error('Organization database not configured');
      }
      if (!org.turso_db_url) {
        logger.warn(`[OrgDB] No turso_db_url found in organization record for orgId: ${orgId}. Record: ${JSON.stringify(org)}`);
        throw new Error('Organization database not configured');
      }
      if (!org.turso_auth_token) {
        logger.warn(`[OrgDB] No turso_auth_token found in organization record for orgId: ${orgId}. Record: ${JSON.stringify(org)}`);
        // Depending on policy, you might still proceed or throw an error.
        // For now, let's assume a URL without a token is also a configuration issue.
        throw new Error('Organization database not configured (missing token)');
      }

      logger.info(`[OrgDB] Found credentials for org ${orgId}. URL: ${org.turso_db_url.substring(0, 20)}... Token: ${org.turso_auth_token ? 'present' : 'MISSING'}`);
      const db = new Database(org.turso_db_url, org.turso_auth_token);

      // Validate connection by running a simple query with timeout
      logger.info(`[OrgDB] Validating database connection for org ${orgId}...`);
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Database validation timed out after 5 seconds')), 5000);
        });
        
        const queryPromise = db.execute('SELECT 1');
        
        const result = await Promise.race([queryPromise, timeoutPromise]);
        logger.info(`Database connection validation successful for org ${orgId}. Result: ${JSON.stringify(result)}`);
        return db;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger.error(`Database connection validation failed for org ${orgId}. Error: ${errorMessage}`);
        if (error instanceof Error && error.stack) {
          logger.error(`Stack trace: ${error.stack}`);
        }
        throw new Error(`Failed to establish database connection: ${errorMessage}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Error getting org database for org ${orgId}: ${errorMessage}`);
      if (error instanceof Error && error.stack) {
        logger.error(`Stack trace: ${error.stack}`);
      }
      throw error;
    }
  }

  /**
   * Get organization's database or initialize it if it doesn't exist
   * This method is used as a fallback when the database needs to be created on the fly
   */
  static async getOrInitOrgDb(orgId: string): Promise<Database> {
    const mainDb = new Database();
    const MAX_RETRIES = 10;
    const RETRY_DELAY_MS = 500;
    let retries = 0;

    logger.info(`[GetOrInitOrgDb] Entered for orgId: ${orgId}`);

    while (true) {
      try {
        // Try to get the org DB as usual
        logger.info(`[GetOrInitOrgDb] Attempting to get OrgDB (attempt ${retries + 1}) for orgId: ${orgId}`);
        const db = await Database.getOrgDb(orgId)
        logger.info(`[GetOrInitOrgDb] Successfully got OrgDB for orgId: ${orgId}. Ensuring schema.`);
        await Database.ensureOrgSchema(db)
        logger.info(`[GetOrInitOrgDb] Schema ensured for orgId: ${orgId}. Returning DB.`);
        return db
      } catch (error) {
        logger.warn(`[GetOrInitOrgDb] Failed to get OrgDB for orgId: ${orgId}. Error: ${error instanceof Error ? error.message : String(error)}`);
        if (error instanceof Error && (error.message === 'Organization database not configured' || error.message === 'Organization database not configured (missing token)')) {
          logger.info(`[GetOrInitOrgDb] Database not configured for orgId: ${orgId}. Attempting to provision.`);
          // Try to atomically claim the right to provision the DB
          logger.info(`[GetOrInitOrgDb] Attempting to claim provisioning lock for orgId: ${orgId}`);
          const claimResult = await mainDb.execute(
            `UPDATE organizations
             SET is_db_provisioning = 1
             WHERE id = ? AND is_db_provisioning = 0 AND (turso_db_url IS NULL OR turso_db_url = '' OR turso_auth_token IS NULL OR turso_auth_token = '')`,
            [orgId]
          );

          logger.info(`[GetOrInitOrgDb] Claim lock result for orgId: ${orgId}: rowsAffected = ${claimResult.rowsAffected}`);
          if (claimResult.rowsAffected === 0) {
            // Someone else is provisioning, wait and retry
            logger.warn(`[GetOrInitOrgDb] Failed to claim lock for orgId: ${orgId} (possibly locked or already provisioned). Retrying...`);
            if (retries++ >= MAX_RETRIES) {
              logger.error(`[GetOrInitOrgDb] Timed out waiting for organization DB provisioning for orgId: ${orgId} after ${MAX_RETRIES} retries.`);
              throw new Error('Timed out waiting for organization DB provisioning');
            }
            await new Promise(res => setTimeout(res, RETRY_DELAY_MS));
            continue;
          }

          // We have the lock, proceed to provision
          logger.info(`[GetOrInitOrgDb] Successfully claimed provisioning lock for orgId: ${orgId}. Proceeding with provisioning.`);
          try {
            const orgExists = await mainDb.fetchOne<{ id: number }>(
              'SELECT id FROM organizations WHERE id = ?',
              [orgId]
            )
            if (!orgExists) {
              logger.error(`[GetOrInitOrgDb] Organization ${orgId} not found during provisioning.`);
              throw new Error('Organization not found')
            }

            const turso = new TursoService()
            logger.info(`[GetOrInitOrgDb] Creating new Turso database for org ${orgId} via TursoService.`);
            const { url, token } = await turso.createOrganizationDatabase(orgId)
            logger.info(`[GetOrInitOrgDb] TursoService returned new database URL: ${url} and token (length: ${token.length}) for org ${orgId}.`);

            // Verify we can connect with the new credentials
            try {
              logger.info(`[GetOrInitOrgDb] Verifying connection with new credentials for org ${orgId}...`)
              const testDb = new Database(url, token)
              await testDb.execute('SELECT 1')
              logger.info(`[GetOrInitOrgDb] Successfully verified connection with new credentials for org ${orgId}.`)
            } catch (connError) {
              logger.error(`[GetOrInitOrgDb] Failed to verify connection with new credentials for org ${orgId}: ${connError instanceof Error ? connError.message : String(connError)}`)
              throw new Error('Failed to verify connection with new database credentials')
            }

            // Update organization with new credentials and clear provisioning flag
            logger.info(`[GetOrInitOrgDb] Updating organization ${orgId} in main DB with new Turso credentials.`);
            await mainDb.execute(
              'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ?, is_db_provisioning = 0 WHERE id = ?',
              [url, token, orgId]
            )
            logger.info(`[GetOrInitOrgDb] Successfully updated organization ${orgId} with new credentials. Clearing provisioning flag.`);

            // Verify the update
            const updatedOrg = await mainDb.fetchOne<{ turso_db_url: string, turso_auth_token: string }>(
              'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
              [orgId]
            )
            if (!updatedOrg) {
              logger.error('[GetOrInitOrgDb] Failed to fetch updated organization after credential update for org ${orgId}.')
              throw new Error('Failed to update organization credentials')
            }
            if (updatedOrg.turso_db_url !== url || updatedOrg.turso_auth_token !== token) {
              logger.error(`[GetOrInitOrgDb] Organization credentials mismatch after update for org ${orgId}.`);
              logger.error(`Expected URL: ${url}, got: ${updatedOrg.turso_db_url}`);
              logger.error(`Expected token length: ${token.length}, got: ${updatedOrg.turso_auth_token.length}`);
              throw new Error('Organization credentials mismatch after update')
            }

            logger.info(`[GetOrInitOrgDb] Successfully initialized and verified database for organization ${orgId}. URL: ${url}`);
            const newDb = new Database(url, token)
            logger.info(`[GetOrInitOrgDb] Ensuring schema for newly provisioned DB for org ${orgId}.`);
            await Database.ensureOrgSchema(newDb)
            logger.info(`[GetOrInitOrgDb] Schema ensured for newly provisioned DB for org ${orgId}. Returning DB.`);
            return newDb
          } catch (provisionError) {
            logger.error(`[GetOrInitOrgDb] Error during provisioning for orgId: ${orgId}. Error: ${provisionError instanceof Error ? provisionError.message : String(provisionError)}`);
            // On error, clear the provisioning flag so future attempts can retry
            logger.info(`[GetOrInitOrgDb] Clearing provisioning lock for orgId: ${orgId} due to provisioning error.`);
            await mainDb.execute(
              'UPDATE organizations SET is_db_provisioning = 0 WHERE id = ?',
              [orgId]
            )
            throw provisionError
          }
        }
        logger.error(`[GetOrInitOrgDb] Unhandled error in getOrInitOrgDb for orgId ${orgId}: ${error instanceof Error ? error.message : String(error)}`)
        if (error instanceof Error && error.stack) {
          logger.error(`Stack trace: ${error.stack}`)
        }
        throw error
      }
    }
  }

  /**
   * Ensure that the organization database has all required tables
   * This can be used to add new tables to existing databases when the schema changes
   */
  static async ensureDatabaseSchema(orgId: string): Promise<void> {
    const orgDb = await Database.getOrgDb(orgId);
    
    // Define tables and their schema
    const tables = [
      {
        name: 'contacts',
        createStatement: `
          CREATE TABLE IF NOT EXISTS contacts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            last_name TEXT NOT NULL,
            email TEXT NOT NULL,
            current_carrier TEXT NOT NULL,
            plan_type TEXT NOT NULL,
            effective_date TEXT NOT NULL,
            birth_date TEXT NOT NULL,
            tobacco_user INTEGER NOT NULL,
            gender TEXT NOT NULL,
            state TEXT NOT NULL,
            zip_code TEXT NOT NULL,
            agent_id INTEGER,
            last_emailed DATETIME,
            phone_number TEXT NOT NULL DEFAULT '',
            status TEXT NOT NULL DEFAULT '',
            aep_request BOOLEAN DEFAULT FALSE,
            aep_request_date DATETIME,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email)`,
          `CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))`,
        ],
      },
      {
        name: 'eligibility_answers',
        createStatement: `CREATE TABLE IF NOT EXISTS eligibility_answers (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          contact_id INTEGER NOT NULL,
          quote_id TEXT NOT NULL,
          answers TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id)
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_eligibility_answers_contact_id ON eligibility_answers(contact_id)`
        ]
      },
      {
        name: 'contact_events',
        createStatement: `CREATE TABLE IF NOT EXISTS contact_events (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          contact_id INTEGER,
          lead_id INTEGER,
          event_type TEXT NOT NULL,
          metadata TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE,
          FOREIGN KEY (lead_id) REFERENCES leads(id) ON DELETE CASCADE
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id)`,
          `CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id)`,
          `CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type)`
        ]
      },
      {
        name: 'tracking_clicks',
        createStatement: `CREATE TABLE IF NOT EXISTS tracking_clicks (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          tracking_id TEXT NOT NULL,
          path TEXT NOT NULL,
          query TEXT,
          contact_id INTEGER,
          ip_address TEXT,
          user_agent TEXT,
          referrer TEXT,
          clicked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_tracking_id ON tracking_clicks(tracking_id)`,
          `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_contact_id ON tracking_clicks(contact_id)`,
          `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_clicked_at ON tracking_clicks(clicked_at)`
        ]
      },
      {
        name: 'leads',
        createStatement: `CREATE TABLE IF NOT EXISTS leads (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          email TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          UNIQUE(email)
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email)`
        ]
      },
      {
        name: 'email_send_tracking',
        createStatement: `CREATE TABLE IF NOT EXISTS email_send_tracking (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          org_id INTEGER NOT NULL,
          contact_id INTEGER NOT NULL,
          email_type TEXT NOT NULL,
          scheduled_date TEXT NOT NULL,
          send_status TEXT NOT NULL CHECK(send_status IN ('pending', 'processing', 'accepted', 'delivered', 'sent', 'deferred', 'bounced', 'dropped', 'failed', 'skipped')) DEFAULT 'pending',
          send_mode TEXT NOT NULL CHECK(send_mode IN ('test', 'production')) DEFAULT 'test',
          test_email TEXT,
          send_attempt_count INTEGER NOT NULL DEFAULT 0,
          last_attempt_date TEXT,
          last_error TEXT,
          batch_id TEXT NOT NULL,
          message_id TEXT,
          delivery_status TEXT,
          status_checked_at TEXT,
          status_details TEXT,
          created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
          updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_batch_id ON email_send_tracking(batch_id)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_send_status ON email_send_tracking(send_status)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_send_mode ON email_send_tracking(send_mode)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_id ON email_send_tracking(contact_id)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_type ON email_send_tracking(contact_id, email_type)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_status_date ON email_send_tracking(send_status, scheduled_date)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_message_id ON email_send_tracking(message_id)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_delivery_status ON email_send_tracking(delivery_status)`,
          `CREATE TRIGGER IF NOT EXISTS update_email_tracking_timestamp AFTER UPDATE ON email_send_tracking BEGIN UPDATE email_send_tracking SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; END`
        ]
      },
      {
        name: 'email_schedules',
        createStatement: `
          CREATE TABLE IF NOT EXISTS email_schedules (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            org_id INTEGER NOT NULL,
            contact_id INTEGER NOT NULL,
            email_type TEXT NOT NULL,
            scheduled_send_date TEXT NOT NULL,
            scheduled_send_time TEXT NOT NULL DEFAULT '08:30:00',
            batch_id TEXT,
            status TEXT NOT NULL DEFAULT 'pre-scheduled',
            skip_reason TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_contact ON email_schedules (contact_id)`,
          `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_send_date ON email_schedules (scheduled_send_date)`,
          `CREATE INDEX IF NOT EXISTS idx_email_schedules_status ON email_schedules (status)`,
          `CREATE TRIGGER IF NOT EXISTS update_email_schedules_updated_at
AFTER UPDATE ON email_schedules
FOR EACH ROW
BEGIN
    UPDATE email_schedules
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = OLD.id;
END;`
        ]
      },
      {
        name: 'deleted_contacts',
        createSql: `
          CREATE TABLE IF NOT EXISTS deleted_contacts (
              original_contact_id INTEGER NOT NULL, -- The ID from the original 'contacts' table
              first_name TEXT,
              last_name TEXT,
              email TEXT NOT NULL,        -- Must be normalized: lowercase, trimmed
              phone_number TEXT,
              current_carrier TEXT,       -- Optional: Include other relevant fields
              plan_type TEXT,             -- Optional
              effective_date TEXT,        -- Optional
              birth_date TEXT,            -- Optional
              tobacco_user INTEGER,       -- Optional
              gender TEXT,                -- Optional
              state TEXT,                 -- Optional
              zip_code TEXT,              -- Optional
              agent_id INTEGER,           -- Optional
              status TEXT,                -- Optional: Original status before deletion
              deleted_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL
          )
        `,
        indexSqls: [
          `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_email_org ON deleted_contacts (LOWER(TRIM(email)))`,
          `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_deleted_at ON deleted_contacts (deleted_at)`,
          `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_original_id ON deleted_contacts (original_contact_id)`
        ]
      }
    ];
    
    // Get all existing tables in one query for efficiency
    const existingTables = await orgDb.fetchAll(
      `SELECT name FROM sqlite_master WHERE type='table' AND name IN (${tables.map(t => `'${t.name}'`).join(', ')})`
    );
    
    // Create a set of existing table names for faster lookup
    const tableSet = new Set(existingTables.map((row: any) => row.name || row[0]));
    
    // Prepare batch operations
    const batchOperations = [];
    
    for (const table of tables) {
      if (!tableSet.has(table.name)) {
        logger.info(`Adding create table operation for ${table.name}`);
        if (table.createStatement) {
          batchOperations.push({
            sql: table.createStatement,
            args: []
          });
        }
      }
      
      // Always add index creation statements, even for existing tables
      // This ensures all necessary indexes exist in all databases
      if (table.indexStatements) {
        for (const indexStatement of table.indexStatements) {
          logger.info(`Ensuring index for ${table.name}: ${indexStatement}`);
          batchOperations.push({
            sql: indexStatement,
            args: []
          });
        }
      }
    }
    
    // Execute all schema operations in a single batch if there are any
    if (batchOperations.length > 0) {
      logger.info(`Executing ${batchOperations.length} schema operations in batch for org ${orgId}`);
      await orgDb.batch(batchOperations, 'write');
      logger.info(`Schema setup completed successfully for org ${orgId}`);
    } else {
      logger.info(`No schema changes needed for org ${orgId}`);
    }
  }

  getClient() {
    return this.client
  }

  async execute(sql: string, args: any[] = []) {
    try {
      if (this.isLocal && this.bunDb) {
        // For local SQLite
        const stmt = this.bunDb.prepare(sql)
        const result = stmt.run(...args)
        return {
          rows: Array.isArray(result) ? result : result.changes > 0 ? [result] : [],
          rowsAffected: result.changes
        }
      } else {
        // For Turso
        const result = await this.client.execute({
          sql,
          args
        })
        return result
      }
    } catch (error) {
      logger.error(`Database execute error: ${error}`)
      throw error
    }
  }
  
  /**
   * Execute a batch of SQL statements in an implicit transaction
   * @param statements Array of SQL statements with args
   * @param mode Transaction mode (read or write)
   * @returns Result of the batch operation
   */
  async batch(statements: { sql: string, args: any[] }[], mode: 'read' | 'write' = 'write') {
    try {
      if (this.isLocal && this.bunDb) {
        // For local SQLite, implement batch manually with transaction
        this.bunDb.exec('BEGIN TRANSACTION');
        const results = [];
        
        try {
          for (const { sql, args } of statements) {
            const stmt = this.bunDb.prepare(sql);
            const result = stmt.run(...args);
            results.push({
              rows: Array.isArray(result) ? result : result.changes > 0 ? [result] : [],
              rowsAffected: result.changes
            });
          }
          
          this.bunDb.exec('COMMIT');
          return results;
        } catch (error) {
          this.bunDb.exec('ROLLBACK');
          throw error;
        }
      } else {
        // For Turso, use native batch support
        const batchStatements = statements.map(({ sql, args }) => ({
          sql,
          args: args || []
        }));
        
        return await this.client.batch(batchStatements, mode);
      }
    } catch (error) {
      logger.error(`Database batch error: ${error}`);
      throw error;
    }
  }

  async fetchAll(sql: string, args: any[] = []) {
    try {
      if (this.isLocal && this.bunDb) {
        // For local SQLite
        const stmt = this.bunDb.prepare(sql)
        const rows = stmt.all(...args)
        return rows || []
      } else {
        // For Turso
        const result = await this.client.execute({
          sql,
          args
        })
        return result.rows || []
      }
    } catch (error) {
      logger.error(`Database fetchAll error: ${error}`)
      throw error
    }
  }

  async fetchOne<T>(sql: string, args: any[] = []): Promise<T | null> {
    if (this.isLocal && this.bunDb) {
      // For local SQLite
      const stmt = this.bunDb.prepare(sql)
      const row = stmt.get(...args)
      return row as T || null
    } else {
      // For Turso
      const result = await this.execute(sql, args)
      if (!result.rows || result.rows.length === 0) return null
      const row = result.rows[0]
      const columns = result.columns || []
      const obj: any = {}
      columns.forEach((col: string, i: number) => (obj[col] = row[i]))
      return obj as T
    }
  }

  // Compatibility method for old query interface
  async query<T = any>(sql: string, args: any[] = []): Promise<T[]> {
    return this.fetchAll(sql, args)
  }

  // Add transaction support for local SQLite
  async transaction<T>(callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(mode: 'read' | 'write', callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(
    callbackOrMode: ((tx: Database) => Promise<T>) | 'read' | 'write',
    callback?: (tx: Database) => Promise<T>
  ): Promise<T> {
    let mode: 'read' | 'write' = 'write'
    let fn: ((tx: Database) => Promise<T>) | null = null

    if (typeof callbackOrMode === 'string') {
      mode = callbackOrMode
      fn = callback || null
    } else {
      fn = callbackOrMode
    }
    
    if (!fn) {
      throw new Error('Transaction callback is required')
    }

    if (this.isLocal && this.bunDb) {
      // For local SQLite
      try {
        this.bunDb.exec('BEGIN TRANSACTION')
        const result = await fn(this)
        this.bunDb.exec('COMMIT')
        return result
      } catch (error) {
        this.bunDb.exec('ROLLBACK')
        throw error
      }
    } else {
      // For Turso
      const tx = await this.client.transaction(mode)
      try {
        const txWrapper = new Database()
        txWrapper.client = tx
        const result = await fn(txWrapper)
        await tx.commit()
        return result
      } catch (error) {
        await tx.rollback()
        throw error
      }
    }
  }

  /**
   * Bulk import contacts from CSV directly into the database
   */
  static async bulkImportContacts(
    orgId: string,
    csvFilePath: string,
    overwriteExisting: boolean = false,
    columnMapping?: ColumnMapping,
    carrierMapping?: CarrierMapping,
    agentId?: number | null
  ): Promise<string> {
    logger.info(`Starting bulk import for organization ${orgId} from ${csvFilePath}`);
    
    try {
      // get the main db
      const mainDb = new Database();
      
      // get the org db url / auth token
      const orgData = await mainDb.fetchOne<{ turso_db_url: string, turso_auth_token: string }>(
        'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
        [orgId]
      );

      if (!orgData) {
        throw new Error(`Organization ${orgId} not found`);
      }

      const { turso_db_url, turso_auth_token } = orgData;

      if (!turso_db_url || !turso_auth_token) {
        throw new Error(`Could not get database configuration for organization ${orgId}`);
      }

      // First, download the existing database from Turso
      const tursoService = new TursoService();
      logger.info(`Downloading existing database from Turso for org ${orgId}`);
      logger.info(`Turso DB URL: ${turso_db_url}`);
      logger.info(`Turso Auth Token: ${turso_auth_token}`);
      const dumpContent = await tursoService.downloadDatabaseDump(turso_db_url, turso_auth_token);
      logger.info(`Downloaded ${dumpContent.length} bytes of database dump`);

      // Create a temporary file for the dump
      const tempDumpFile = `dump-${Date.now()}.sql`;
      const tempDbFile = `temp-${Date.now()}.db`;
      let localDb: BunDatabase | null = null;
      
      try {
        // Write dump to temporary file
        await fsPromises.writeFile(tempDumpFile, dumpContent);

        // Use sqlite3 CLI to create and populate the database
        logger.info('Creating temporary database from dump...');
        await new Promise((resolve, reject) => {
          const sqlite = Bun.spawn(['sqlite3', tempDbFile], {
            stdin: Bun.file(tempDumpFile),
            onExit(proc, exitCode, signalCode, error) {
              if (exitCode === 0) {
                resolve(null);
              } else {
                reject(new Error(`SQLite process exited with code ${exitCode}: ${error}`));
              }
            }
          });
        });

        logger.info('Successfully created temporary database from dump');

        // Now connect to the temporary database using BunSQLite
        localDb = new BunDatabase(tempDbFile);

        // Use DELETE journal mode instead of WAL for direct file writes
        localDb.exec('PRAGMA journal_mode = DELETE');
        localDb.exec('PRAGMA foreign_keys = OFF');

        // Drop the unique index on email temporarily to allow the import
        logger.info('Dropping unique email index for import...');
        localDb.exec('DROP INDEX IF EXISTS idx_contacts_email_unique');

        // Verify the database state before CSV import
        const tables = ['contacts', 'contact_events', 'leads', 'eligibility_answers', 'email_send_tracking'];
        for (const table of tables) {
          try {
            const count = localDb.prepare(`SELECT COUNT(*) as count FROM ${table}`).get() as { count: number };
            logger.info(`Table ${table} before CSV import: ${count.count} rows`);
          } catch (error) {
            logger.error(`Error counting rows in ${table}: ${error}`);
          }
        }

        // Now process the new contacts from CSV
        logger.info(`Processing new contacts from CSV file`);
        
        // Read the CSV file
        const fileContents = await fsPromises.readFile(csvFilePath, 'utf8');
        const rows = await new Promise<any[]>((resolve, reject) => {
          const results: any[] = [];
          const parser = parse(fileContents, { columns: true });
          
          parser.on('readable', function() {
            let record;
            while ((record = parser.read()) !== null) {
              results.push(record);
            }
          });
          
          parser.on('error', function(err) {
            reject(err);
          });
          
          parser.on('end', function() {
            resolve(results);
          });
        });
        
        logger.info(`Processing ${rows.length} rows from CSV`);
        
        // Find the email column (required for deduplication)
        const emailColumn = columnMapping ? columnMapping.email : 'email';
        if (!rows[0]?.[emailColumn]) {
          throw new Error(`Email column "${emailColumn}" not found in CSV`);
        }
        
        // Map columns based on provided mapping or use default field names
        const processRow = (row: any) => {
          const mappedRow: any = {};
          
          // Apply column mappings if provided
          if (columnMapping) {
            // Map each field using the provided column mapping
            mappedRow.first_name = row[columnMapping.firstName] || '';
            mappedRow.last_name = row[columnMapping.lastName] || '';
            mappedRow.email = row[columnMapping.email] || '';
            mappedRow.phone_number = row[columnMapping.phoneNumber] || '';
            mappedRow.zip_code = row[columnMapping.zipCode] || '';
            
            // Infer state from zip code
            if (mappedRow.zip_code && ZIP_DATA[mappedRow.zip_code]) {
              mappedRow.state = ZIP_DATA[mappedRow.zip_code].state;
              logger.info(`Inferred state ${mappedRow.state} from zip code ${mappedRow.zip_code}`);
            } else if (columnMapping.state && row[columnMapping.state]) {
              // Fallback to provided state if zip code lookup fails
              mappedRow.state = row[columnMapping.state] || '';
              logger.info(`Using provided state ${mappedRow.state} (zip code lookup failed)`);
            } else {
              logger.warn(`No state found for zip code ${mappedRow.zip_code}, defaulting to empty string`);
              mappedRow.state = '';
            }
            
            // Apply carrier mapping if provided
            let carrierValue = '';
            if (columnMapping.currentCarrier && row[columnMapping.currentCarrier]) {
              const originalCarrier = row[columnMapping.currentCarrier];
              
              // Use carrier mapping if available
              if (carrierMapping && carrierMapping.mappings[originalCarrier]) {
                carrierValue = carrierMapping.mappings[originalCarrier];
                
                // If mapped to "Other", preserve original value
                if (carrierValue === 'Other') {
                  carrierValue = originalCarrier;
                }
              } else {
                carrierValue = originalCarrier;
              }
            }
            
            mappedRow.current_carrier = carrierValue;
            mappedRow.effective_date = row[columnMapping.effectiveDate] || '';
            mappedRow.birth_date = row[columnMapping.birthDate] || '';
            mappedRow.tobacco_user = row[columnMapping.tobaccoUser] === 'true' || row[columnMapping.tobaccoUser] === 'yes' || row[columnMapping.tobaccoUser] === '1';
            mappedRow.gender = row[columnMapping.gender] || '';
            mappedRow.plan_type = row[columnMapping.planType] || '';
          } else {
            // Use default field names if no mapping provided
            mappedRow.first_name = row.first_name || row.firstName || '';
            mappedRow.last_name = row.last_name || row.lastName || '';
            mappedRow.email = row.email || '';
            mappedRow.phone_number = row.phone_number || row.phoneNumber || '';
            mappedRow.zip_code = row.zip_code || row.zipCode || '';
            
            // Infer state from zip code
            if (mappedRow.zip_code && ZIP_DATA[mappedRow.zip_code]) {
              mappedRow.state = ZIP_DATA[mappedRow.zip_code].state;
              logger.info(`Inferred state ${mappedRow.state} from zip code ${mappedRow.zip_code}`);
            } else if (row.state) {
              // Fallback to provided state if zip code lookup fails
              mappedRow.state = row.state || '';
              logger.info(`Using provided state ${mappedRow.state} (zip code lookup failed)`);
            } else {
              logger.warn(`No state found for zip code ${mappedRow.zip_code}, defaulting to empty string`);
              mappedRow.state = '';
            }
            
            mappedRow.current_carrier = row.current_carrier || row.currentCarrier || '';
            mappedRow.effective_date = row.effective_date || row.effectiveDate || '';
            mappedRow.birth_date = row.birth_date || row.birthDate || '';
            mappedRow.tobacco_user = row.tobacco_user === 'true' || row.tobacco_user === 'yes' || row.tobacco_user === '1' ||
                                   row.tobaccoUser === 'true' || row.tobaccoUser === 'yes' || row.tobaccoUser === '1';
            mappedRow.gender = row.gender || '';
            mappedRow.plan_type = row.plan_type || row.planType || '';
          }
          
          // Add standard fields
          mappedRow.created_at = new Date().toISOString();
          mappedRow.updated_at = new Date().toISOString();
          
          // Add agent_id if provided
          if (agentId !== undefined && agentId !== null) {
            mappedRow.agent_id = agentId;
          }
          
          return mappedRow;
        };
        
        // Begin transaction for CSV import
        localDb.exec('BEGIN TRANSACTION');
        
        try {
          // First, get all existing emails (for manual deduplication)
          const existingEmails = new Set(
            localDb.prepare('SELECT LOWER(TRIM(email)) as email FROM contacts')
              .all()
              .map((row: any) => row.email || row[0])
          );

          logger.info(`Found ${existingEmails.size} existing emails in database`);

          // Prepare insert statement (without ON CONFLICT since we're handling it manually)
          const stmt = localDb.prepare(`
            INSERT INTO contacts (
              first_name, last_name, email, phone_number, state,
              current_carrier, effective_date, birth_date, tobacco_user,
              gender, zip_code, plan_type, agent_id, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `);

          let totalProcessed = 0;
          let totalAdded = 0;
          let totalSkipped = 0;

          // Process each row
          for (const row of rows) {
            totalProcessed++;
            const processedRow = processRow(row);
            const email = processedRow.email.toLowerCase().trim();
            
            if (!email) {
              logger.warn('Skipping row with no email address');
              totalSkipped++;
              continue;
            }

            try {
              if (existingEmails.has(email)) {
                if (overwriteExisting) {
                  // Update existing record
                  localDb.prepare(`
                    UPDATE contacts SET
                      first_name = ?, last_name = ?, phone_number = ?, state = ?,
                      current_carrier = ?, effective_date = ?, birth_date = ?,
                      tobacco_user = ?, gender = ?, zip_code = ?, plan_type = ?,
                      agent_id = ?, updated_at = ?
                    WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))
                  `).run(
                    processedRow.first_name,
                    processedRow.last_name,
                    processedRow.phone_number,
                    processedRow.state,
                    processedRow.current_carrier,
                    processedRow.effective_date,
                    processedRow.birth_date,
                    processedRow.tobacco_user ? 1 : 0,
                    processedRow.gender,
                    processedRow.zip_code,
                    processedRow.plan_type,
                    processedRow.agent_id || null,
                    processedRow.updated_at,
                    email
                  );
                  totalAdded++;
                } else {
                  totalSkipped++;
                }
              } else {
                stmt.run(
                  processedRow.first_name,
                  processedRow.last_name,
                  email,
                  processedRow.phone_number,
                  processedRow.state,
                  processedRow.current_carrier,
                  processedRow.effective_date,
                  processedRow.birth_date,
                  processedRow.tobacco_user ? 1 : 0,
                  processedRow.gender,
                  processedRow.zip_code,
                  processedRow.plan_type,
                  processedRow.agent_id || null,
                  processedRow.created_at,
                  processedRow.updated_at
                );
                existingEmails.add(email);
                totalAdded++;
              }
            } catch (err) {
              logger.error(`Error processing row with email ${email}: ${err}`);
              totalSkipped++;
            }
          }

          // Recreate the unique index after import
          logger.info('Recreating unique email index...');
          localDb.exec('CREATE UNIQUE INDEX idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))');

          // Commit CSV import transaction
          localDb.exec('COMMIT');
          
          // Force a checkpoint to ensure all changes are written to disk
          localDb.exec('PRAGMA wal_checkpoint(TRUNCATE)');
          
          logger.info(`Successfully processed all rows from CSV`);
          logger.info(`Total processed: ${totalProcessed}, added: ${totalAdded}, skipped: ${totalSkipped}`);

          // Verify final counts
          const finalCount = localDb.prepare('SELECT COUNT(*) as count FROM contacts').get() as { count: number };
          logger.info(`Final contact count in database: ${finalCount.count} (should be ${existingEmails.size} + new additions)`);

          // Close the database to ensure all changes are flushed
          localDb.close();
          localDb = null;

          try {
            // Create new database and upload data
            logger.info(`Creating new Turso database for import`);
            const { dbName: newOrgDbName, url: newOrgDbUrl, token: newOrgDbToken } = await tursoService.createDatabaseForImport(orgId);
            
            // Upload the local db to the new org db
            logger.info(`Uploading data to new Turso database at ${newOrgDbUrl}`);
            await tursoService.uploadDatabase(newOrgDbName, newOrgDbToken, `file:${tempDbFile}`);
            
            // Update main db with new org db url / auth token 
            logger.info(`Updating organization ${orgId} with new database credentials`);
            await mainDb.execute(`
              UPDATE organizations 
              SET turso_db_url = ?, turso_auth_token = ?
              WHERE id = ?
            `, [newOrgDbUrl, newOrgDbToken, orgId]);
            
            logger.info(`Successfully completed import for organization ${orgId}`);
            
            // Return success message with import stats
            return `Successfully imported ${totalAdded} contacts (${totalSkipped} skipped) to new database: ${newOrgDbUrl}`;
          } catch (importError) {
            logger.error(`Error during Turso database creation or upload: ${importError}`);
            throw importError;
          }
        } catch (error) {
          // Rollback transaction on error
          try {
            if (localDb) {
              localDb.exec('ROLLBACK');
            }
          } catch (rollbackError) {
            logger.error(`Error during transaction rollback: ${rollbackError}`);
          }
          throw error;
        }
      } finally {
        // Clean up temporary files
        try {
          if (localDb) {
            localDb.close();
          }
          await fsPromises.unlink(tempDumpFile);
          await fsPromises.unlink(tempDbFile);
          logger.info('Cleaned up temporary files');
        } catch (cleanupError) {
          logger.error(`Error cleaning up temporary files: ${cleanupError}`);
        }
      }
    } catch (error) {
      logger.error(`Error in bulk import for organization ${orgId}: ${error}`);
      throw error;
    }
  }

  static getUserFromSession = getUserFromSession;
  static getOrganizationById = getOrganizationById;

  static async ensureOrgSchema(orgDb: Database): Promise<void> {
    try {
      // Get all existing tables at once
      const existingTables = await orgDb.fetchAll(
        "SELECT name FROM sqlite_master WHERE type='table' AND name IN ('contacts', 'contact_events', 'tracking_clicks', 'leads', 'eligibility_answers', 'email_send_tracking', 'email_schedules', 'deleted_contacts')"
      );

      // Create a set of existing table names for faster lookup
      const tableSet = new Set(existingTables.map((row: any) => row.name || row[0]));
      
      // Define tables with their schema and indexes
      const tables = [
        {
          name: 'contacts',
          createSql: `
            CREATE TABLE IF NOT EXISTS contacts (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              first_name TEXT NOT NULL,
              last_name TEXT NOT NULL,
              email TEXT NOT NULL UNIQUE,
              current_carrier TEXT,
              plan_type TEXT,
              effective_date TEXT,
              birth_date TEXT,
              tobacco_user INTEGER NOT NULL,
              gender TEXT,
              state TEXT,
              zip_code TEXT,
              agent_id INTEGER,
              last_emailed DATETIME,
              phone_number TEXT,
              status TEXT NOT NULL DEFAULT '',
              aep_request BOOLEAN DEFAULT FALSE,
              aep_request_date DATETIME,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email)`,
            `CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))`,
            `CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id)`,
            `CREATE INDEX IF NOT EXISTS idx_contacts_status ON contacts(status)`,
            `CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp AFTER UPDATE ON contacts BEGIN UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; END`
          ]
        },
        {
          name: 'contact_events',
          createSql: `
            CREATE TABLE IF NOT EXISTS contact_events (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              contact_id INTEGER,
              lead_id INTEGER,
              event_type TEXT NOT NULL,
              metadata TEXT,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE,
              FOREIGN KEY (lead_id) REFERENCES leads(id) ON DELETE CASCADE
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id)`,
            `CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id)`,
            `CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type)`
          ]
        },
        {
          name: 'tracking_clicks',
          createSql: `
            CREATE TABLE IF NOT EXISTS tracking_clicks (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              tracking_id TEXT NOT NULL,
              contact_id INTEGER,
              quote_id TEXT,
              clicked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_tracking_id ON tracking_clicks(tracking_id)`,
            `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_contact_id ON tracking_clicks(contact_id)`,
            `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_clicked_at ON tracking_clicks(clicked_at)`,
          ]
        },
        {
          name: 'leads',
          createSql: `
            CREATE TABLE IF NOT EXISTS leads (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL,
              email TEXT NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              UNIQUE(email)
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email)`
          ]
        },
        {
          name: 'eligibility_answers',
          createSql: `
            CREATE TABLE IF NOT EXISTS eligibility_answers (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              contact_id INTEGER NOT NULL,
              quote_id TEXT NOT NULL,
              answers TEXT NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_eligibility_answers_contact_id ON eligibility_answers(contact_id)`
          ]
        },
        {
          name: 'email_send_tracking',
          createSql: `
            CREATE TABLE IF NOT EXISTS email_send_tracking (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              org_id INTEGER NOT NULL,
              contact_id INTEGER NOT NULL,
              email_type TEXT NOT NULL,
              scheduled_date TEXT NOT NULL,
              send_status TEXT NOT NULL CHECK(send_status IN ('pending', 'processing', 'accepted', 'delivered', 'sent', 'deferred', 'bounced', 'dropped', 'failed', 'skipped')) DEFAULT 'pending',
              send_mode TEXT NOT NULL CHECK(send_mode IN ('test', 'production')) DEFAULT 'test',
              test_email TEXT,
              send_attempt_count INTEGER NOT NULL DEFAULT 0,
              last_attempt_date TEXT,
              last_error TEXT,
              batch_id TEXT NOT NULL,
              message_id TEXT,
              delivery_status TEXT,
              status_checked_at TEXT,
              status_details TEXT,
              created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
              updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_batch_id ON email_send_tracking(batch_id)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_send_status ON email_send_tracking(send_status)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_send_mode ON email_send_tracking(send_mode)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_id ON email_send_tracking(contact_id)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_type ON email_send_tracking(contact_id, email_type)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_status_date ON email_send_tracking(send_status, scheduled_date)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_message_id ON email_send_tracking(message_id)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_delivery_status ON email_send_tracking(delivery_status)`,
            `CREATE TRIGGER IF NOT EXISTS update_email_tracking_timestamp AFTER UPDATE ON email_send_tracking BEGIN UPDATE email_send_tracking SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; END`
          ]
        },
        {
          name: 'email_schedules',
          createSql: `
            CREATE TABLE IF NOT EXISTS email_schedules (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              contact_id INTEGER NOT NULL,
              email_type TEXT NOT NULL,
              scheduled_send_date TEXT NOT NULL,
              scheduled_send_time TEXT NOT NULL DEFAULT '08:30:00',
              batch_id TEXT,
              status TEXT NOT NULL DEFAULT 'pre-scheduled',
              skip_reason TEXT,
              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
              updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_contact ON email_schedules (contact_id)`,
            `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_send_date ON email_schedules (scheduled_send_date)`,
            `CREATE INDEX IF NOT EXISTS idx_email_schedules_status ON email_schedules (status)`,
            `CREATE TRIGGER IF NOT EXISTS update_email_schedules_updated_at
AFTER UPDATE ON email_schedules
FOR EACH ROW
BEGIN
    UPDATE email_schedules
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = OLD.id;
END;`
          ]
        },
        {
          name: 'deleted_contacts',
          createSql: `
            CREATE TABLE IF NOT EXISTS deleted_contacts (
                original_contact_id INTEGER NOT NULL, -- The ID from the original 'contacts' table
                first_name TEXT,
                last_name TEXT,
                email TEXT NOT NULL,        -- Must be normalized: lowercase, trimmed
                phone_number TEXT,
                current_carrier TEXT,       -- Optional: Include other relevant fields
                plan_type TEXT,             -- Optional
                effective_date TEXT,        -- Optional
                birth_date TEXT,            -- Optional
                tobacco_user INTEGER,       -- Optional
                gender TEXT,                -- Optional
                state TEXT,                 -- Optional
                zip_code TEXT,              -- Optional
                agent_id INTEGER,           -- Optional
                status TEXT,                -- Optional: Original status before deletion
                deleted_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_email_org ON deleted_contacts (LOWER(TRIM(email)))`,
            `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_deleted_at ON deleted_contacts (deleted_at)`,
            `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_original_id ON deleted_contacts (original_contact_id)`
          ]
        }
      ];
      
      // Prepare batch operations
      const schemaOperations = [];
      
      // Process each table
      for (const table of tables) {
        // Create table if it doesn't exist
        if (!tableSet.has(table.name)) {
          logger.info(`Creating ${table.name} table schema`);
          schemaOperations.push({
            sql: table.createSql,
            args: []
          });
        }
        
        // Always add indexes regardless of whether table existed before
        // This ensures all necessary indexes exist in all databases
        for (const indexSql of table.indexSqls) {
          logger.info(`Ensuring index for ${table.name}: ${indexSql}`);
          schemaOperations.push({
            sql: indexSql,
            args: []
          });
        }
      }
      
      // Execute all schema operations in a single batch if there are any
      if (schemaOperations.length > 0) {
        logger.info(`Executing ${schemaOperations.length} schema operations in batch`);
        await orgDb.batch(schemaOperations, 'write');
        logger.info('Schema setup completed successfully');
      } else {
        logger.info('All required tables exist, checking indexes...');
        
        // Even if all tables exist, we still need to ensure all indexes exist
        const indexOperations = [];
        for (const table of tables) {
          for (const indexSql of table.indexSqls) {
            indexOperations.push({
              sql: indexSql,
              args: []
            });
          }
        }
        
        if (indexOperations.length > 0) {
          logger.info(`Ensuring ${indexOperations.length} indexes exist`);
          await orgDb.batch(indexOperations, 'write');
          logger.info('Index verification completed');
        }
      }
    } catch (error) {
      logger.error(`Error ensuring org schema: ${error}`);
      throw error;
    }
  }

  close() {
    if (this.isLocal && this.bunDb) {
      this.bunDb.close()
    }
  }

  private async fetch(fetchUrl: RequestInfo, options: RequestInit | undefined = undefined): Promise<Response> {
    const response = await fetch(fetchUrl, options || {});
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response;
  }

  private async fetchWithRetry(fetchUrl: RequestInfo, options: RequestInit | undefined = undefined): Promise<Response> {
    const maxRetries = 3;
    let lastError: Error | null = null;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const response = await this.fetch(fetchUrl, options);
        if (response.status === 429) {
          // Rate limited, wait with exponential backoff
          const delay = Math.pow(2, attempt) * 1000;
          logger.warn(`Rate limit hit, retry ${attempt + 1}/${maxRetries} after ${delay}ms`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        return response;
      } catch (error) {
        lastError = error as Error;
        if (attempt < maxRetries - 1) {
          const delay = Math.pow(2, attempt) * 1000;
          logger.warn(`Request failed, retry ${attempt + 1}/${maxRetries} after ${delay}ms: ${error}`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError || new Error('Max retries reached');
  }
}

export const db = new Database() 

/**
 * Get user from session cookie
 */
export async function getUserFromSession(request: any): Promise<any> {
  try {
    const db = new Database();
    let sessionCookie: string | undefined;

    // Handle different request header formats
    if (request.headers) {
      if (typeof request.headers.get === 'function') {
        // Standard Request object
        sessionCookie = request.headers.get('cookie')?.split(';')
          .find((c: string) => c.trim().startsWith('session='))
          ?.split('=')[1];
      } else if (typeof request.headers === 'object') {
        // Raw headers object or Express request
        const cookieHeader = request.headers.cookie || request.headers['cookie'] || request.headers['Cookie'];
        if (typeof cookieHeader === 'string') {
          sessionCookie = cookieHeader.split(';')
            .find((c: string) => c.trim().startsWith('session='))
            ?.split('=')[1];
        }
      }
    }

    if (!sessionCookie) {
      logger.info('No session cookie found');
      return null;
    }

    // Log the session ID for debugging
    logger.info(`Session lookup result: ${JSON.stringify(await db.fetchOne('SELECT * FROM sessions WHERE id = ?', [sessionCookie]))}`);
    
    // Check if the session exists and hasn't expired
    const session = await db.fetchOne<{ id: string, user_id: number, expires_at: string, created_at: string }>(
      'SELECT * FROM sessions WHERE id = ?',
      [sessionCookie]
    );

    if (!session) {
      logger.info('No valid session found');
      return null;
    }

    // Check if session has expired
    const expiresAt = new Date(session.expires_at);
    const now = new Date();
    
    logger.info(`Session expires: ${expiresAt}, current time: ${now}`);
    
    if (expiresAt < now) {
      logger.info('Session has expired');
      return null;
    }

    // Get the user associated with the session
    const user = await db.fetchOne(
      'SELECT u.*, o.name as organization_name FROM users u JOIN organizations o ON u.organization_id = o.id WHERE u.id = ?',
      [session.user_id]
    );

    logger.info(`User lookup result: ${JSON.stringify(user)}`);

    if (!user) {
      logger.info('No user found for session');
      return null;
    }
    
    return user;
  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

/**
 * Get organization by ID
 */
export async function getOrganizationById(orgId: number): Promise<any> {
  try {
    const db = new Database();
    const org = await db.query('SELECT * FROM organizations WHERE id = ?', [orgId]);
    if (!org || org.length === 0) return null;
    return org[0];
  } catch (error) {
    logger.error(`Error getting organization: ${error}`);
    return null;
  }
}

// Function to split SQL dump into individual statements
function splitSqlStatements(sql: string): string[] {
  const statements: string[] = [];
  let currentStatement = "";
  let inString = false;
  let inComment = false;
  let inBlockComment = false;
  let stringQuote: string | null = null;

  for (let i = 0; i < sql.length; i++) {
    const char = sql[i];
    const nextChar = i + 1 < sql.length ? sql[i + 1] : null;

    // Handle comments
    if (!inString) {
      if (char === "-" && nextChar === "-" && !inBlockComment) {
        inComment = true;
        i++; // Skip next char
        continue;
      }
      if (char === "/" && nextChar === "*" && !inComment) {
        inBlockComment = true;
        i++;
        continue;
      }
      if (inComment && char === "\n") {
        inComment = false;
        continue;
      }
      if (inBlockComment && char === "*" && nextChar === "/") {
        inBlockComment = false;
        i++;
        continue;
      }
      if (inComment || inBlockComment) {
        continue;
      }
    }

    // Handle string literals
    if ((char === "'" || char === '"') && !inComment && !inBlockComment) {
      if (!inString) {
        inString = true;
        stringQuote = char;
      } else if (char === stringQuote) {
        // Check for escaped quotes
        if (sql[i - 1] !== "\\") {
          inString = false;
          stringQuote = null;
        }
      }
    }

    // Handle statement termination
    if (char === ";" && !inString && !inComment && !inBlockComment) {
      statements.push(currentStatement.trim());
      currentStatement = "";
      continue;
    }

    currentStatement += char;
  }

  // Add the last statement if it exists
  if (currentStatement.trim()) {
    statements.push(currentStatement.trim());
  }

  return statements.filter(stmt => stmt.length > 0);
}

================
File: src/errors.ts
================
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'NotFoundError'
  }
}

export class UnauthorizedError extends Error {
  constructor(message: string = 'Unauthorized') {
    super(message)
    this.name = 'UnauthorizedError'
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'ValidationError'
  }
}

export class DatabaseError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'DatabaseError'
  }
}

================
File: src/index.ts
================
import { Elysia, t } from 'elysia'
import { cors } from '@elysiajs/cors'
import { Database } from './database'
import { logger } from './logger'
import type { ContactCreate, ContactCreateTemp, AgentCreate } from './types'
import { readFileSync } from 'fs'
import { staticPlugin } from '@elysiajs/static'
import { parse as csvParse } from 'csv-parse/sync'
import { Readable } from 'stream'
import { Buffer } from 'buffer'
import { createAuthRoutes } from './routes/auth'
import { settingsRoutes } from './routes/settings'
import { organizationRoutes } from './routes/organizations'
import { createBrandRoutes } from './routes/brand'
import { quotesRoutes } from './routes/quotes'
import { createOnboardingRoutes } from './routes/onboarding'
import { createWaitlistRoutes } from './routes/waitlist'
import { createSignupRoutes, checkEmailHandler } from './routes/signup'
import { createStripeRoutes } from './routes/stripe'
import { createDashboardRoutes, createDashboardActivityRoutes } from './routes/dashboard'
import { errorHandler } from './middleware/error'
import { getUserFromSession } from './services/auth'
import { join } from 'path'
import { existsSync } from 'fs'
import { EmailService } from './services/email'
import * as cron from 'node-cron'
import { eligibilityRoutes } from './routes/eligibility'
import { generateQuoteId } from './utils/quoteId'
import { createSelfServiceRoutes } from './routes/self-service'
import { scheduleRoutes } from './routes/schedule'
import { contactsRoutes } from './routes/contacts'
import * as fs from 'fs/promises'
import * as path from 'path'
import * as os from 'os'
import { readdirSync } from 'fs'
import { parseTrackingId } from './utils/tracking'
import { createBillingRoutes } from './routes/billing'


// At the top of the file, add interface for ZIP data
export interface ZipInfo {
  state: string;
  counties: string[];
}

// Update ZIP_DATA declaration
export let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  const dataPath = path.join(process.cwd(), 'data', 'zipData.json');
  logger.info(`Loading ZIP data from: ${dataPath}`);
  ZIP_DATA = JSON.parse(readFileSync(dataPath, 'utf-8'))
  logger.info('Successfully loaded ZIP data');
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}

// Add with the other type imports
type NewAgentRequest = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

type AgentUpdate = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

interface DbRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  phone: string | null;
  is_admin: number;
  is_agent: number;
  settings: string | null;
}

// Add at the top with other interfaces
interface ContactRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  current_carrier: string;
  plan_type: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: number;
  gender: string;
  state: string;
  zip_code: string;
  agent_id: number | null;
  last_emailed: string | null;
  phone_number: string;
}

interface CarrierRow {
  name: string;
  aliases: string | null;
}

// Add this helper function before startServer
function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
  const digits = phone.replace(/\D/g, '').slice(0, 10);
  return {
    isValid: digits.length === 10,
    standardized: digits
  };
}

// Add this helper function near the other validation functions
function validateEmail(email: string): boolean {
  // RFC 5322 compliant email regex
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  return emailRegex.test(email.trim());
}

// Add this helper function near the other validation functions
function validateISODate(dateStr: string, allowFuture: boolean = false): { isValid: boolean; isoDate: string | null } {
  try {
    const trimmed = dateStr.trim();
    
    // Try to parse the date - will throw if invalid
    const date = new Date(trimmed);
    
    // Check if date is invalid
    if (isNaN(date.getTime())) {
      return { isValid: false, isoDate: null };
    }
    
    // Convert to ISO format (YYYY-MM-DD)
    const isoDate = date.toISOString().split('T')[0];
    
    // Verify the date is not in the future (unless allowed)
    if (!allowFuture && date > new Date()) {
      return { isValid: false, isoDate: null };
    }
    
    return { isValid: true, isoDate };
  } catch (e) {
    return { isValid: false, isoDate: null };
  }
}

// Add this helper function near the other validation functions
async function validateCarrier(carrier: string, db: Database): Promise<{ isValid: boolean; standardizedName: string; wasConverted: boolean }> {
  try {
    // Trim and standardize input
    const trimmedCarrier = carrier.trim();
    logger.info(`Validating carrier: "${trimmedCarrier}"`);
    
    // Create a new instance of the central database
    const centralDb = new Database();
    
    // Get all carriers with their aliases from the central database
    const result = await centralDb.execute(
      'SELECT name, aliases FROM carriers'
    );
    
    logger.info(`Found ${result.rows.length} carriers in database`);
    
    // Check each carrier and its aliases
    for (const row of result.rows) {
      logger.info(`Checking against carrier: "${row.name}", aliases: ${row.aliases || '[]'}`);
      
      // Check exact name match (case insensitive)
      if (row.name.toLowerCase() === trimmedCarrier.toLowerCase()) {
        logger.info(`Found exact match with carrier: ${row.name}`);
        return { isValid: true, standardizedName: row.name, wasConverted: false };
      }
      
      // Check aliases if they exist
      if (row.aliases) {
        const aliases = JSON.parse(row.aliases);
        logger.info(`Checking aliases for ${row.name}: ${JSON.stringify(aliases)}`);
        if (Array.isArray(aliases) && aliases.some(alias => alias.toLowerCase() === trimmedCarrier.toLowerCase())) {
          logger.info(`Found match in aliases for carrier: ${row.name}`);
          return { isValid: true, standardizedName: row.name, wasConverted: false };
        }
      }
    }
    
    // If no match found, keep the original carrier name but mark as converted
    logger.info(`No matching carrier found for: "${trimmedCarrier}", keeping original name`);
    return { isValid: true, standardizedName: trimmedCarrier, wasConverted: true };
  } catch (e) {
    logger.error(`Error validating carrier: ${e}`);
    return { isValid: true, standardizedName: carrier.trim(), wasConverted: true };
  }
}

// Interface for validation result
interface ValidationResult {
  isValid: boolean;
  error?: string;
  value?: any;
}

// Validation functions
const validateRow = async (row: any, rowNum: number, carrierMap: Map<string, string>): Promise<ValidationResult> => {
  try {
    logger.info(`Starting validation for row ${rowNum}:`)
    logger.info(`Row data: ${JSON.stringify(row)}`)

    // Required fields check with detailed logging
    const requiredFields = [
      'First Name', 'firstName',
      'Last Name', 'lastName', 
      'Email', 'email',
      'Current Carrier', 'currentCarrier',
      'Plan Type', 'planType',
      'Effective Date', 'effectiveDate',
      'Birth Date', 'birthDate',
      'Tobacco User', 'tobaccoUser',
      'Gender', 'gender',
      'ZIP Code', 'zipCode',
      'Phone Number', 'phoneNumber'
    ]

    logger.info(`Checking required fields: ${requiredFields.join(', ')}`)
    const missingValues = requiredFields.filter(field => {
      const value = row[field]?.trim()
      const isMissing = !value
      if (isMissing) {
        logger.warn(`Missing required field "${field}" in row ${rowNum}`)
      }
      return isMissing
    })

    // Group the missing fields by their base name (e.g. both "First Name" and "firstName" count as one missing field)
    const missingFieldGroups = new Set<string>()
    for (let i = 0; i < missingValues.length; i += 2) {
      if (missingValues[i] && missingValues[i+1]) {
        missingFieldGroups.add(missingValues[i])
      }
    }

    if (missingFieldGroups.size > 0) {
      logger.warn(`Row ${rowNum} missing required fields: ${Array.from(missingFieldGroups).join(', ')}`)
      return {
        isValid: false,
        error: `Missing values for: ${Array.from(missingFieldGroups).join(', ')}`
      }
    }

    // Email validation with logging
    const email = (row['Email'] || row['email'] || '').trim().toLowerCase()
    logger.info(`Validating email: "${email}"`)
    if (!validateEmail(email)) {
      logger.warn(`Row ${rowNum} has invalid email format: ${email}`)
      return {
        isValid: false,
        error: `Invalid email format: ${email}`
      }
    }

    // Phone validation with logging
    logger.info(`Validating phone number: "${row['Phone Number'] || row['phoneNumber']}"`)
    const phoneResult = standardizePhoneNumber(row['Phone Number'] || row['phoneNumber'])
    if (!phoneResult.isValid) {
      logger.warn(`Row ${rowNum} has invalid phone number: ${row['Phone Number'] || row['phoneNumber']}`)
      return {
        isValid: false,
        error: `Invalid phone number: ${row['Phone Number'] || row['phoneNumber']}. Must be exactly 10 digits.`
      }
    }

    // ZIP validation with logging
    const zipCode = (row['ZIP Code'] || row['zipCode'] || '').trim()
    logger.info(`Validating ZIP code: "${zipCode}"`)

    // First check if ZIP code exists and has the right format
    if (!zipCode) {
      logger.warn(`Row ${rowNum} is missing ZIP code`)
      return {
        isValid: false,
        error: `Missing ZIP code. This field is required for determining state coverage and eligibility.`
      }
    }

    // Check if ZIP code is in the correct format (5 digits)
    if (!/^\d{5}$/.test(zipCode)) {
      logger.warn(`Row ${rowNum} has invalid ZIP code format: ${zipCode}`)
      return {
        isValid: false,
        error: `Invalid ZIP code format: ${zipCode}. Must be exactly 5 digits.`
      }
    }

    // Check if ZIP code exists in our database
    const zipInfo = ZIP_DATA[zipCode]
    if (!zipInfo) {
      logger.warn(`Row ${rowNum} has invalid ZIP code: ${zipCode} (not found in database)`)
      return {
        isValid: false,
        error: `Invalid ZIP code: ${zipCode}. This ZIP code is not recognized in our database.`
      }
    }

    // If we get here, we have a valid ZIP code with state information
    logger.info(`Valid ZIP code ${zipCode} maps to state: ${zipInfo.state}`)

    // Gender validation with logging
    const gender = (row['Gender'] || row['gender'] || '').trim().toUpperCase()
    logger.info(`Validating gender: "${gender}"`)
    if (!['M', 'F'].includes(gender)) {
      logger.warn(`Row ${rowNum} has invalid gender: ${gender}`)
      return {
        isValid: false,
        error: `Invalid gender: ${gender}. Must be 'M' or 'F'`
      }
    }

    // Carrier validation with logging
    const carrierInput = (row['Current Carrier'] || row['currentCarrier'] || '').trim().toLowerCase()
    logger.info(`Validating carrier: "${carrierInput}"`)
    const standardizedCarrier = carrierMap.get(carrierInput) || carrierInput
    const wasCarrierConverted = !carrierMap.has(carrierInput)
    if (wasCarrierConverted) {
      logger.warn(`Row ${rowNum} has non-standard carrier: ${carrierInput} (will be kept as-is)`)
    }

    // Date validations with logging
    logger.info(`Validating effective date: "${row['Effective Date'] || row['effectiveDate']}"`)
    const effectiveDateResult = validateISODate(row['Effective Date'] || row['effectiveDate'], true)
    if (!effectiveDateResult.isValid) {
      logger.warn(`Row ${rowNum} has invalid effective date: ${row['Effective Date'] || row['effectiveDate']}`)
      return {
        isValid: false,
        error: `Invalid effective date format: ${row['Effective Date'] || row['effectiveDate']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
      }
    }

    logger.info(`Validating birth date: "${row['Birth Date'] || row['birthDate']}"`)
    const birthDateResult = validateISODate(row['Birth Date'] || row['birthDate'])
    if (!birthDateResult.isValid) {
      logger.warn(`Row ${rowNum} has invalid birth date: ${row['Birth Date'] || row['birthDate']}`)
      return {
        isValid: false,
        error: `Invalid birth date format: ${row['Birth Date'] || row['birthDate']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
      }
    }

    // If all validations pass, return processed data
    logger.info(`Row ${rowNum} passed all validations successfully`)
    return {
      isValid: true,
      value: {
        data: [
          (row['First Name'] || row['firstName'] || '').trim(),
          (row['Last Name'] || row['lastName'] || '').trim(),
          email,
          standardizedCarrier,
          (row['Plan Type'] || row['planType'] || '').trim(),
          effectiveDateResult.isoDate,
          birthDateResult.isoDate,
          ['yes', 'true', '1', 'y'].includes((row['Tobacco User'] || row['tobaccoUser'] || '').trim().toLowerCase()),
          gender,
          zipInfo.state,
          zipCode,
          phoneResult.standardized,
          null // agentId - will be set later
        ],
        carrierConverted: wasCarrierConverted ? {
          Row: rowNum,
          ...row,
          OriginalCarrier: row['Current Carrier'] || row['currentCarrier']
        } : null
      }
    }
  } catch (e) {
    // Log the full error details
    logger.error(`Unexpected error in row ${rowNum}:`)
    logger.error(`Error message: ${e instanceof Error ? e.message : String(e)}`)
    logger.error(`Row data: ${JSON.stringify(row)}`)
    if (e instanceof Error && e.stack) {
      logger.error(`Stack trace: ${e.stack}`)
    }
    return {
      isValid: false,
      error: `Unexpected error processing row ${rowNum}. Please check all fields are in the correct format. Error: ${e instanceof Error ? e.message : String(e)}`
    }
  }
};

const startServer = async () => {
  try {
    // Log environment information at startup
    logger.info(`Environment: NODE_ENV = "${process.env.NODE_ENV}"`)
    logger.info(`Current working directory: ${process.cwd()}`)
    logger.info(`Is production mode: ${process.env.NODE_ENV === 'production'}`)
    
    // Check for frontend files
    logger.info(`Checking for SPA files:`)
    const locations = [
      { name: 'public', path: join(process.cwd(), 'public') },
      { name: 'parent dist', path: join(process.cwd(), '..', 'dist') }
    ];
    
    for (const loc of locations) {
      const exists = existsSync(loc.path);
      logger.info(`${loc.name} directory (${loc.path}): ${exists ? 'EXISTS' : 'MISSING'}`);
      
      if (exists) {
        try {
          const files = readdirSync(loc.path);
          logger.info(`${loc.name} contents: ${files.join(', ')}`);
          
          const indexPath = join(loc.path, 'index.html');
          if (existsSync(indexPath)) {
            logger.info(` Found SPA at: ${indexPath}`);
          }
        } catch (err) {
          logger.error(`Error reading ${loc.name} directory: ${err}`);
        }
      }
    }
    
    // Log available environment variables (without values for security)
    logger.info(`Available environment variables: ${Object.keys(process.env).join(', ')}`)
    
    // Try loading directly from process.env
    if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
      logger.warn('Critical environment variables missing. Check Replit Secrets are properly set:')
      logger.warn('Required: TURSO_DATABASE_URL, TURSO_AUTH_TOKEN')
      logger.warn('Available env vars: ' + Object.keys(process.env).join(', '))
    } else {
      logger.info('Required environment variables found')
    }
    
    const db = new Database()
    logger.info('Database initialized successfully')

    const app = new Elysia()
      // Add error handler
      .use(errorHandler)
      // Add CORS middleware
      .use(cors({
        // In development, allow the Vite dev server origin
        origin: process.env.NODE_ENV === 'development' 
          ? 'http://localhost:5173'
          : false, // Disable CORS in production
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Cookie'],  // Add Cookie to allowed headers
        credentials: true,
        preflight: true
      }))
      // Add static file serving
      .use(staticPlugin({
        assets: join(process.cwd(), 'public'), // Public static files
        prefix: '/'
      }))
      // Try parent dist directory if it exists
      .use(staticPlugin({
        assets: join(process.cwd(), '..', 'dist'), // Parent dist static files
        prefix: '/'
      }))
      // Add data directory for specific files
      .use(staticPlugin({
        assets: join(process.cwd(), 'data/public'), // Data files
        prefix: '/api/data/public'
      }))
      // Add SPA route auth bypass handler
      .onRequest(({ request }) => {
        const url = new URL(request.url);
        const path = url.pathname;
        
        // Log all requests (combined from the other handler)
        const method = request.method;
        logger.info(` ${method} ${path}`);
        
        // Bypass auth for all SPA routes (non-API paths with no file extension)
        if ((!path.startsWith('/api/') && !path.includes('.')) || 
            path.startsWith('/compare/') ||
            path.startsWith('/quote/') ||
            path.startsWith('/eligibility') ||
            path.startsWith('/schedule')) {
          
          logger.info(`[Auth Bypass] Setting bypass header for SPA route: ${path}`);
          // Modify the request headers to include X-Bypass-Auth
          const newHeaders = new Headers(request.headers);
          newHeaders.set('X-Bypass-Auth', 'true');
          
          // Create a new request with the modified headers
          Object.defineProperty(request, 'headers', {
            value: newHeaders,
            writable: true
          });
        }
      })
      // Add explicit OPTIONS handler for preflight
      .options('/api/contacts/:id', ({ set }) => {
        set.headers = {
          'Access-Control-Allow-Origin': 'http://localhost:5173',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Allow-Credentials': 'true'
        }
        return new Response(null, { status: 204 })
      })
      // Log all responses
      .onResponse((context) => {
        const { request: { method }, path, set } = context
        logger.info(` ${method} ${path} ${set.status}`)
      })
      // Enhanced error handling
      .onError(({ code, error, request }: {
        code: string;
        error: Error;
        request: { url: string; method: string };
      }) => {
        const path = new URL(request.url).pathname
        const errorMessage = ` ${request.method} ${path} - ${error.message}`
        logger.error(errorMessage)

        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), { 
          status: code === 'NOT_FOUND' ? 404 : 500,
          headers: {
            'Content-Type': 'application/json'
          }
        })
      })
      // Add health check endpoint
      .get('/health', () => ({ status: 'OK' }))
      // Register public routes that shouldn't be auth-protected
      .get('/api/signup/check-email/:email', checkEmailHandler)
      // GET /api/contacts is now handled by the contactsRoutes module
      .get('/api/contacts/check-email/:email', async ({ params: { email }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          const result = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          return {
            exists: result !== null
          }
        } catch (e) {
          logger.error(`Error checking email existence: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/:id', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id} - Fetching contact for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Fetch the contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            logger.info(`GET /api/contacts/${id} - Contact not found`)
            return new Response('Contact not found', { status: 404 })
          }

          // Return the contact with mapped fields
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error fetching contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .post('/api/contacts/create', async ({ body, request }) => {
        console.log('body', body)
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contact = body as ContactCreate // With an explicit schema, 'body' will be correctly typed
          logger.info(`Attempting to create contact for org ${user.organization_id}: ${contact.first_name} ${contact.last_name}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Check for existing email
          const existingContact = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [contact.email]
          )

          if (existingContact) {
            throw new Error('A contact with this email already exists')
          }
          
          // Map contact_owner_id to agent_id if it exists and agent_id is not set
          if (contact.contact_owner_id && !contact.agent_id) {
            contact.agent_id = contact.contact_owner_id
            logger.info(`Mapped contact_owner_id: ${contact.contact_owner_id} to agent_id`)
          }
          
          const query = `
            INSERT INTO contacts (
              first_name, last_name, email, current_carrier, plan_type,
              effective_date, birth_date, tobacco_user, gender,
              state, zip_code, agent_id, phone_number
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `
          
          const params = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier || null,
            contact.plan_type || null,
            contact.effective_date || null,
            contact.birth_date || null,
            contact.tobacco_user ? 1 : 0, // Convert boolean to integer
            contact.gender || null,
            contact.state || null,
            contact.zip_code || null,
            contact.agent_id || null,
            contact.phone_number || null
          ]

          logger.info(`Executing query with params: ${JSON.stringify(params)}`)
          await orgDb.execute(query, params)

          // Fetch the newly created contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE email = ? ORDER BY id DESC LIMIT 1',
            [contact.email]
          )

          if (!result) {
            throw new Error('Failed to fetch created contact')
          }

          // Match response format to schema
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error creating contact: ${e}`)
          throw new Error(String(e))
        }
      }, // End of handler function
      { // Start of schema object
        body: t.Object({
          first_name: t.String(),
          last_name: t.String(),
          email: t.String({ format: 'email' }),
          phone_number: t.String(),
          state: t.String(),
          contact_owner_id: t.Optional(t.Union([t.Number(), t.Null()])),
          current_carrier: t.Optional(t.Union([t.String(), t.Null()])),
          effective_date: t.String(),
          birth_date: t.String(),
          tobacco_user: t.Boolean(),
          gender: t.String(),
          zip_code: t.String(),
          plan_type: t.Optional(t.Union([t.String(), t.Null()])),
          agent_id: t.Optional(t.Union([t.Number(), t.Null()]))
        })
      }) // End of schema object and route definition
      .put('/api/contacts/:id', async ({ params: { id }, body, request }: { params: { id: string }, body: ContactCreate, request: Request }) => {
        try {
          // Get user and org info
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          const contact = body as ContactCreate
          logger.info(`PUT /api/contacts/${id} - Updating contact for org ${user.organization_id}`)

          // Get state from ZIP code
          const zipInfo = ZIP_DATA[contact.zip_code]
          if (!zipInfo) {
            throw new Error(`Invalid ZIP code: ${contact.zip_code}`)
          }

          // First update the contact
          const updateQuery = /* sql */ `
            UPDATE contacts SET 
              first_name = ?,
              last_name = ?,
              email = ?,
              current_carrier = ?,
              plan_type = ?,
              effective_date = ?,
              birth_date = ?,
              tobacco_user = ?,
              gender = ?,
              state = ?,
              zip_code = ?,
              phone_number = ?
            WHERE id = ?
          `

          const updateParams = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            zipInfo.state, // Use state from ZIP code
            contact.zip_code,
            contact.phone_number || '',
            id
          ]

          // Execute the update
          await orgDb.execute(updateQuery, updateParams)

          // Then fetch the updated contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            throw new Error(`Contact ${id} not found after update`)
          }

          logger.info(`Successfully updated contact ${id} in org ${user.organization_id}`)

          // Return the updated contact
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number
          }
        } catch (e) {
          logger.error(`Error updating contact: ${e}`)
          throw new Error(String(e))
        }
      },
      {
        body: t.Object({
          first_name: t.String(),
          last_name: t.String(),
          email: t.String({ format: 'email' }),
          phone_number: t.String(),
          state: t.String(),
          contact_owner_id: t.Optional(t.Union([t.Number(), t.Null()])),
          current_carrier: t.Optional(t.Union([t.String(), t.Null()])),
          effective_date: t.String(),
          birth_date: t.String(),
          tobacco_user: t.Boolean(),
          gender: t.String(),
          zip_code: t.String(),
          plan_type: t.Optional(t.Union([t.String(), t.Null()])),
          agent_id: t.Optional(t.Union([t.Number(), t.Null()]))
        })
      })
      // Add DELETE endpoint for contacts
      .delete('/api/contacts', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Parse contact IDs from the request
          const url = new URL(request.url)
          const ids = url.searchParams.get('ids')
          if (!ids) {
            throw new Error('No contact IDs provided')
          }

          const contactIds = ids.split(',').map(id => parseInt(id.trim(), 10))
          
          logger.info(`DELETE /api/contacts - Attempting to delete ${contactIds.length} contacts for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contactIds.map(() => '?').join(',')
          
          const query = `
            DELETE FROM contacts 
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const result = await orgDb.execute(query, contactIds)
          const deletedIds = result.rows?.map((row: { id: number }) => row.id) || []

          logger.info(`DELETE /api/contacts - Successfully deleted ${deletedIds.length} contacts from org ${user.organization_id}`)

          return {
            success: true,
            deleted_ids: deletedIds,
            message: `Successfully deleted ${deletedIds.length} contacts`
          }
        } catch (e) {
          logger.error(`Error deleting contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add endpoint for reassigning contacts to a different agent
      .put('/api/contacts/reassign', async ({ request, body }: { request: Request, body: { contact_ids: number[], agent_id: number | null } }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const { contact_ids, agent_id } = body
          if (!contact_ids || !Array.isArray(contact_ids) || contact_ids.length === 0) {
            throw new Error('Invalid or empty contact_ids array')
          }

          logger.info(`PUT /api/contacts/reassign - Reassigning ${contact_ids.length} contacts to agent ${agent_id} for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contact_ids.map(() => '?').join(',')
          
          const query = `
            UPDATE contacts 
            SET agent_id = ?
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const params = [agent_id, ...contact_ids]
          const result = await orgDb.execute(query, params)
          const updatedIds = result.rows?.map((row: { id: number }) => row.id) || []

          logger.info(`PUT /api/contacts/reassign - Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`)

            return {
            success: true,
            updated_ids: updatedIds,
            message: `Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`
          }
        } catch (e) {
          logger.error(`Error reassigning contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add file upload endpoint
      .post('/api/contacts/upload', async ({ request, body, set }: { request: Request, body: { file: File, overwrite_duplicates?: boolean | string, duplicateStrategy?: string, agent_id?: string }, set: any }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Extract file and overwrite flag from form data
          const formData = body
          const file = formData.file
          
          // Support both naming conventions - overwrite_duplicates (old) and duplicateStrategy (new)
          let overwriteDuplicates = false
          if (formData.overwrite_duplicates !== undefined) {
            // Convert string 'false'/'true' to boolean
            overwriteDuplicates = formData.overwrite_duplicates === 'true' || formData.overwrite_duplicates === true
          } else if (formData.duplicateStrategy !== undefined) {
            // Support the new 'duplicateStrategy' parameter
            overwriteDuplicates = formData.duplicateStrategy === 'overwrite'
          }

          logger.info(`Processing ${file.name} with overwriteDuplicates=${overwriteDuplicates}`)

          // Save file to temp directory
          const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'import-'));
          const tempFilePath = path.join(tempDir, 'contacts.csv');
          await fs.writeFile(tempFilePath, Buffer.from(await file.arrayBuffer()));

          logger.info(`CSV file saved to ${tempFilePath}, starting import`);

          // Start bulk import process
          const importPromise = Database.bulkImportContacts(
            user.organization_id.toString(),
            tempFilePath,
            overwriteDuplicates
          );

          importPromise
            .then(() => fs.rm(tempDir, { recursive: true, force: true }))
            .catch((error: Error) => {
              logger.error(`Background import failed: ${error}`);
              fs.rm(tempDir, { recursive: true, force: true }).catch(() => {});
            });

          return {
            success: true,
            message: 'Started import of contacts',
            errors: []
          };
        } catch (error) {
          const err = error as Error;
          logger.error(`Error processing CSV upload: ${err}`);
          throw err;
        }
      })
      // Add error handler
      .use(errorHandler)
      // Add explicit debug log for auth routes
      .use(app => {
        logger.info('Registering auth routes...')
        return app.use(createAuthRoutes())
      })
      // Add signup routes
      .use(app => {
        logger.info('Registering signup routes...')
        return app.use(createSignupRoutes())
      })
      // Add settings routes
      .use(settingsRoutes)
      // Add organization routes
      .use(organizationRoutes)
      // Add brand routes
      .use(createBrandRoutes())
      // Add quotes routes
      .use(quotesRoutes)
      // Add onboarding routes
      .use(createOnboardingRoutes())
      // Add eligibility routes
      .use(eligibilityRoutes)
      // Add self-service routes
      .use(createSelfServiceRoutes())
      // Add schedule routes
      .use(scheduleRoutes)
      // Add contacts routes
      .use(contactsRoutes)
      // Add waitlist routes
      .use(createWaitlistRoutes())  // Waitlist routes use their own database connection
      // Add dashboard routes
      .use(createDashboardRoutes())
      // Add dashboard activity routes
      .use(createDashboardActivityRoutes())
      // Serve backend static files from public directory
      .use(createStripeRoutes)
      .use(createBillingRoutes)
      // Add this endpoint within the app definition
      .post('/api/agents', async ({ body, request, set }) => {
        try {
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent: ${newAgent.email} (org: ${currentUser.organization_id})`)

          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Check if the organization has reached its agent limit
          const orgLimitResult = await client.execute({
            sql: `
              SELECT 
                o.agent_limit, 
                COUNT(u.id) as current_agent_count
              FROM 
                organizations o
              LEFT JOIN 
                users u ON o.id = u.organization_id AND (u.is_agent = 1 OR u.is_admin = 1) AND u.is_active = 1
              WHERE 
                o.id = ?
              GROUP BY 
                o.id
            `,
            args: [currentUser.organization_id]
          })
          
          if (orgLimitResult.rows.length > 0) {
            const { agent_limit, current_agent_count } = orgLimitResult.rows[0]
            
            if (Number(current_agent_count) >= Number(agent_limit)) {
              logger.warn(`Organization ${currentUser.organization_id} has reached its agent limit (${agent_limit}). Cannot create new agent.`)
              set.status = 403
              return {
                success: false,
                error: `You have reached your plan's agent limit (${agent_limit}). Please upgrade your plan to add more agents.`
              }
            }
            
            logger.info(`Organization has ${current_agent_count}/${agent_limit} agents (before adding new agent)`)
          }
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add an alias endpoint for POST /api/agents/create to match frontend expectations
      .post('/api/agents/create', async ({ body, request, set }) => {
        try {
          // Log the request to the alias endpoint
          logger.info(`POST /api/agents/create - Using the same implementation as /api/agents`)
          
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent via /api/agents/create: ${newAgent.email} (org: ${currentUser.organization_id})`)
          
          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent via /api/agents/create: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add this GET endpoint within the app definition, near the POST /api/agents endpoint
      .get('/api/agents', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Remove admin check - allow any authenticated user to fetch agents for their organization
          // All users should be able to see the agent list for assignment purposes
          logger.info(`GET /api/agents - Fetching agents for org ${currentUser.organization_id}`)

          // Get the libSQL client
          const client = db.getClient()

          // Fetch the default agent ID for this organization
          const orgResult = await client.execute({
            sql: `SELECT default_agent_id FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          const defaultAgentId = orgResult.rows[0]?.default_agent_id ? String(orgResult.rows[0].default_agent_id) : null
          logger.info(`GET /api/agents - Default agent ID for org ${currentUser.organization_id} is ${defaultAgentId || 'not set'}`)

          // Fetch all agents (users) from the organization along with their settings
          const result = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.first_name,
                u.last_name,
                u.email,
                u.phone,
                u.is_admin,
                u.is_agent,
                a.settings
              FROM users u
              LEFT JOIN agent_settings a ON u.id = a.agent_id
              WHERE u.organization_id = ?
              AND u.is_active = 1
              ORDER BY u.first_name, u.last_name
            `,
            args: [currentUser.organization_id]
          })

          logger.info(`GET /api/agents - Found ${result.rows.length} agents`)

          // Map the database results to the expected format with camelCase field names
          const agents = result.rows.map((row: any) => {
            const settings = row.settings ? JSON.parse(row.settings) : {
              stateLicenses: [],
              carrierContracts: [],
              stateCarrierSettings: []
            }
            
            // Check if this agent is the default agent
            const isDefault = defaultAgentId ? String(row.id) === defaultAgentId : false

            return {
              id: String(row.id),
              firstName: row.first_name,
              lastName: row.last_name,
              email: row.email,
              phone: row.phone || '',
              isAdmin: Boolean(row.is_admin),
              isAgent: Boolean(row.is_agent),
              isDefault: isDefault,
              carriers: settings.carrierContracts || [],
              stateLicenses: settings.stateLicenses || []
            }
          })

          logger.info(`GET /api/agents - Returning ${agents.length} agents`)
          // Return both agents and the default agent ID
          return {
            agents,
            defaultAgentId
          }

        } catch (e) {
          logger.error(`Error fetching agents: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .post('/api/agents/set_default_agent', async ({ body, request, set }: { body: { agentId: string | number }, request: Request, set: any }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          const { agentId } = body  
          logger.info(`Setting default agent to ${agentId} for user ${currentUser.id}`)

          // Get the libSQL client
          const client = db.getClient()

          // Update the default agent for the organization
          await client.execute({
            sql: `UPDATE organizations SET default_agent_id = ? WHERE id = ?`,
            args: [agentId, currentUser.organization_id]
          })

          logger.info(`Default agent set to ${agentId} for organization ${currentUser.organization_id}`)
          
          set.status = 200
          return {
            success: true,
            message: 'Default agent set successfully'
          }
        } catch (e) {
          logger.error(`Error setting default agent: ${e}`) 
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Update PUT endpoint for updating agent details - moved here to be with other agent endpoints
      .put('/api/agents/:id', async ({ params, body, request, set }: {
        params: { id: string },
        body: AgentUpdate,
        request: Request,
        set: any
      }) => {
        console.log('DEBUG: PUT handler hit', { params, path: request.url })
        logger.info(`Starting update for agent ${params.id}`)
        logger.info(`Request body: ${JSON.stringify(body, null, 2)}`)
        
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            logger.error('Authentication failed: No user in session')
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Allow users to update their own details or admins to update any agent
          if (!currentUser.is_admin && currentUser.id.toString() !== params.id) {
            logger.error(`Authorization failed: User ${currentUser.id} is not an admin and trying to update another user`)
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can update other agents'
            }
          }
          
          // Security protection: NEVER allow ANY user to remove their own admin status,
          // even if they are an admin themselves
          if (currentUser.id.toString() === params.id) {
            // If this is a self-update and user is trying to change admin status
            if (body.is_admin !== Boolean(currentUser.is_admin)) {
              // If they're trying to REMOVE admin status
              if (Boolean(currentUser.is_admin) && !body.is_admin) {
                logger.warn(`Security protection: Admin user ${currentUser.id} attempted to remove their own admin status`)
                // Prevent admin from removing their own admin status - keep it as is
                body.is_admin = true;
              }
              // Note: We still allow non-admins to be promoted by an admin
            }
          }

          const agent = body
          logger.info(`Updating agent ${params.id} - Name: ${agent.firstName} ${agent.lastName}, Phone: ${agent.phone}`)

          // Get the libSQL client
          const client = db.getClient()

          // Determine if this is a self-update by a non-admin
          const isSelfUpdate = currentUser.id.toString() === params.id && !currentUser.is_admin
          
          // Create dynamic SQL that excludes is_admin for self-updates
          let sql, args
          if (isSelfUpdate) {
            // For self-updates, exclude is_admin from the update
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
            logger.info(`Self-update detected: excluding admin status from update for user ${params.id}`)
          } else {
            // For admin updates or other users, include all fields
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      is_admin = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.is_admin ? 1 : 0,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
          }

          // Execute the update with the appropriate SQL and args
          const userUpdateResult = await client.execute({
            sql,
            args
          })

          logger.info(`User update result: ${JSON.stringify(userUpdateResult.rows, null, 2)}`)

          if (!userUpdateResult.rows || userUpdateResult.rows.length === 0) {
            logger.error('User update failed: No rows affected')
            throw new Error('User update failed - no rows affected')
          }

          logger.info('User details updated successfully')

          // Update agent settings
          const settings = {
            stateLicenses: agent.stateLicenses,
            carrierContracts: agent.carriers,
            stateCarrierSettings: [],
            emailSendBirthday: false,
            emailSendPolicyAnniversary: false,
            emailSendAep: false,
            smartSendEnabled: false
          }

          logger.info(`Agent settings to update: ${JSON.stringify(settings, null, 2)}`)

          const settingsUpdateResult = await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)
            ON CONFLICT (agent_id) 
            DO UPDATE SET settings = EXCLUDED.settings
            RETURNING *`,
            args: [
              params.id,
              JSON.stringify(settings)
            ]
          })

          logger.info(`Settings update result: ${JSON.stringify(settingsUpdateResult.rows, null, 2)}`)

          if (!settingsUpdateResult.rows || settingsUpdateResult.rows.length === 0) {
            logger.error('Settings update failed: No rows affected')
            throw new Error('Settings update failed - no rows affected')
          }

          logger.info('Settings updated successfully')

          const updatedUser = userUpdateResult.rows[0]
          const updatedSettings = JSON.parse(settingsUpdateResult.rows[0].settings)

          return {
            success: true,
            message: 'Agent updated successfully',
            agent: {
              id: updatedUser.id.toString(),
              firstName: updatedUser.first_name,
              lastName: updatedUser.last_name,
              email: updatedUser.email,
              phone: updatedUser.phone || '',
              is_admin: Boolean(updatedUser.is_admin),
              is_agent: Boolean(updatedUser.is_agent),
              carriers: updatedSettings.carrierContracts,
              stateLicenses: updatedSettings.stateLicenses
            }
          }

        } catch (error: unknown) {
          const dbError = error as Error
          logger.error(`Database error: ${dbError.message}`)
          set.status = 500
          return {
            success: false,
            error: dbError.message
          }
        }
      })
      // Add DELETE endpoint for agent deletion with contact reassignment
      .delete('/api/agents/:id', async ({ params, request, set, query }: {
        params: { id: string },
        request: Request,
        set: any,
        query: { reassignTo?: string }
      }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Only admins can delete agents
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can delete agents'
            }
          }

          const agentId = params.id
          
          // Prevent users from deleting themselves
          if (String(currentUser.id) === agentId) {
            set.status = 403
            return {
              success: false,
              error: 'You cannot delete your own account'
            }
          }
          
          const reassignToAgentId = query.reassignTo

          // Get the main database client for user/agent operations
          const client = db.getClient()

          // Also get the organization-specific database for contact operations
          const orgDb = await Database.getOrgDb(currentUser.organization_id.toString())

          // First handle contact operations in org database
          try {
            // Using the transaction method instead of direct SQL commands
            await orgDb.transaction(async (orgTx) => {
            // If reassignToAgentId is provided, reassign contacts to the new agent
            if (reassignToAgentId && reassignToAgentId !== agentId) {
              logger.info(`Reassigning contacts from agent ${agentId} to agent ${reassignToAgentId}`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = ?
                   WHERE agent_id = ?`,
                  [reassignToAgentId, agentId]
                )
            } else {
              // Set agent_id to NULL for contacts associated with this agent
              logger.info(`Setting contacts from agent ${agentId} to have no assigned agent`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = NULL
                   WHERE agent_id = ?`,
                  [agentId]
                )
              }
            })
            
            logger.info(`Successfully updated contacts for agent ${agentId}`)
            
            // Now handle agent operations in the main database
            await db.transaction(async (tx) => {
              // First, check if the user has any other related records that need to be deleted

            // Delete agent's settings
              await tx.execute(
                `DELETE FROM agent_settings
                 WHERE agent_id = ?`,
                [agentId]
              )
              
              // Check for any related records in other tables that might reference this user
              // For example, delete from sessions table if it exists
              await tx.execute(
                `DELETE FROM sessions
                 WHERE user_id = ?`,
                [agentId]
              )
              
              // IMPORTANT: Add any other related tables that might have foreign keys to users
              
              // Finally, completely delete the user record instead of just marking as inactive
              await tx.execute(
                `DELETE FROM users
                 WHERE id = ?`,
                [agentId]
              )
            })
            
            logger.info(`Successfully deleted agent ${agentId}`)

            return {
              success: true,
              message: 'Agent deleted successfully'
            }
          } catch (error) {
            logger.error(`Error in agent deletion: ${error}`)
            throw error;
          }
        } catch (e) {
          logger.error(`Error deleting agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: 'An error occurred while deleting the agent'
          }
        }
      })
      // Add this endpoint within the app definition
      .get('/api/me', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          logger.info(`GET /api/me - Current user from session: ${JSON.stringify(currentUser)}`)
          
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          // Get user details including agent settings if they exist
          const client = db.getClient()
          const userDetails = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.email,
                u.first_name as firstName,
                u.last_name as lastName,
                u.is_admin,
                u.is_agent,
                u.phone,
                u.organization_id,
                o.slug as organization_slug,
                o.subscription_tier,
                o.created_at as orgCreateDate,
                a.settings as agentSettings
              FROM users u
              JOIN organizations o ON u.organization_id = o.id
              LEFT JOIN agent_settings a ON a.agent_id = u.id
              WHERE u.id = ?
            `,
            args: [currentUser.id]
          })

          logger.info(`GET /api/me - Raw user details from DB: (omitted)`)

          if (!userDetails.rows[0]) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          const user = userDetails.rows[0]
          const response = {
            success: true,
            user: {
              id: user.id,
              email: user.email,
              firstName: user.firstName,
              lastName: user.lastName,
              is_admin: Boolean(user.is_admin),
              is_agent: Boolean(user.is_agent),
              phone: user.phone || '',
              organization_id: user.organization_id,
              organization_slug: user.organization_slug,
              subscription_tier: user.subscription_tier,
              orgCreateDate: user.orgCreateDate.split(/[ T]/)[0],
              agentSettings: user.agentSettings ? JSON.parse(user.agentSettings) : null
            }
          }
          logger.info(`GET /api/me - Sending response ${JSON.stringify(response)}`)
          return response

        } catch (e) {
          logger.error(`Error fetching current user: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/:redirect', async ({ params, set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for redirect to: ${params.redirect}`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`

          // Handle redirect
          const redirectPath = params.redirect === 'add-agent' ? 'agents/add' : params.redirect
          set.redirect = `/${redirectPath}`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/login', async ({ set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for login page`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add ZIP lookup endpoint
      .get('/api/zip-lookup/:zipCode', ({ params: { zipCode } }) => {
        try {
          const zipInfo = ZIP_DATA[zipCode]
          if (!zipInfo) {
            return {
              success: false,
              error: `Invalid ZIP code: ${zipCode}`
            }
          }
          return {
            success: true,
            ...zipInfo
          }
        } catch (e) {
          logger.error(`Error looking up ZIP code ${zipCode}: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })

      .get('/api/contacts/email-tracking/:contactId', async ({ params, request }) => {
        try {
          logger.info(`Fetching email tracking records for contact ID: ${params.contactId}`);
          
          const user = await getUserFromSession(request);
          if (!user) {
            logger.warn(`Authentication failed when fetching email tracking for contact ID: ${params.contactId}`);
            return {
              success: false,
              message: 'Authentication required'
            };
          }

          const contactId = Number(params.contactId);
          if (isNaN(contactId)) {
            logger.warn(`Invalid contact ID provided: ${params.contactId}`);
            return {
              success: false,
              message: 'Invalid contact ID'
            };
          }

          logger.info(`User requesting email tracking for contact ID: ${contactId}`);
          const orgDb = await Database.getOrgDb(user.organization_id.toString());
          logger.info(`Fetching email tracking records from organization database`);

          const trackingRecords = await orgDb.fetchAll(
            `SELECT email_type,scheduled_date,send_status,send_mode FROM email_send_tracking 
             WHERE contact_id = ? 
             ORDER BY created_at DESC`,
            [contactId.toString()]
          );
          
          logger.info(`Found ${trackingRecords.length} email tracking records for contact ID: ${contactId}`);

          return {
            success: true,
            trackingRecords
          };
        } catch (error) {
          logger.error(`Error fetching email tracking records: ${error}`);
          return {
            success: false,
            message: 'Failed to fetch email tracking records',
            error: String(error)
          };
        }
      })
      // Add API endpoint for tracking clicks
      .post('/api/tracking/log-tracking-click', async ({ body, request }: { body: { tid: string, orgId: string, contactId?: string, quoteId?: string }, request: Request }) => {
        try {
          logger.info(`Received tracking click: ${JSON.stringify(body)}`);
          
          // Extract tracking data from request
          const { tid, orgId, contactId, quoteId } = body;
          
          if (!tid) {
            logger.warn('Missing tracking ID in click tracking request');
            return { success: false, message: 'Missing tracking ID' };
          }
          
          if (!orgId) {
            logger.warn('Missing organization ID in click tracking request');
            return { success: false, message: 'Missing organization ID' };
          }
          
          try {
            // Get organization database using the provided orgId
            const orgDb = await Database.getOrInitOrgDb(orgId);
            
            // Insert the tracking click record with the updated schema
            await orgDb.execute(
              `INSERT INTO tracking_clicks (
                tracking_id, contact_id, quote_id
              ) VALUES (?, ?, ?)`,
              [tid, contactId ? parseInt(contactId, 10) : null, quoteId || null]
            );
            
            logger.info(`Successfully logged tracking click with ID: ${tid} for organization ${orgId}`);
            
            return { success: true };
          } catch (dbError) {
            logger.error(`Error storing tracking data: ${dbError}`);
            return { 
              success: false, 
              message: 'Error recording tracking click', 
              error: 'Database error' 
            };
          }
        } catch (error) {
          logger.error(`Error processing tracking click: ${error}`);
          return { 
            success: false, 
            message: 'Failed to process tracking click', 
            error: 'Internal server error' 
          };
        }
      })
      // Send quote email to contact
      .post('/api/contacts/:contactId/send-quote-email', async ({ params, request, body }) => {
        try {
          const user = await getUserFromSession(request);
          if (!user) {
            return {
              success: false,
              message: 'Authentication required'
            };
          }

          const contactId = Number(params.contactId);
          if (isNaN(contactId)) {
            return {
              success: false,
              message: 'Invalid contact ID'
            };
          }

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString());

          // Fetch contact details
          const contact = await orgDb.fetchOne<{id: number, first_name: string, last_name: string, email: string, plan_type: string, phone_number: string}>(
            'SELECT id, first_name, last_name, email, plan_type, phone_number FROM contacts WHERE id = ?',
            [contactId]
          );

          if (!contact) {
            return {
              success: false,
              message: 'Contact not found'
            };
          }

          logger.info(`Contact: ${JSON.stringify(contact)}`);

          // Use the proper generateQuoteId function
          const quoteId = generateQuoteId(user.organization_id, contactId);
          
          // Calculate base URL
          const baseUrl = process.env.PUBLIC_URL || 'http://localhost:5173';
          let quoteUrl = `${baseUrl}/compare?id=${quoteId}&planType=${contact.plan_type}`;

          // Add organization ID to URL
          quoteUrl += `&orgId=${user.organization_id}`;

          // Send the email via SendGrid
          const emailService = new EmailService();
          
          // Fetch organization data
          const organization = await db.fetchOne<{
            id: number;
            name: string;
            logo_data: string;
            primary_color: string;
            phone: string;
            website: string;
          }>(
            'SELECT id, name, logo_data, primary_color, phone, website FROM organizations WHERE id = ?',
            [user.organization_id]
          );
          
          // Log more details about the logo data
          if (organization?.logo_data) {
            const logoDataPrefix = organization.logo_data.substring(0, 50);
            logger.info(`Logo data prefix: ${logoDataPrefix}...`);
          }
          
          // Log the presence of logo data
          logger.info(`Sending quote email for org ${user.organization_id} with logo: ${organization?.logo_data ? 'Present' : 'Missing'}`);
          
          const result = await emailService.sendQuoteEmail({
            email: contact.email,
            firstName: contact.first_name,
            lastName: contact.last_name,
            quoteUrl,
            planType: contact.plan_type,
            organization: organization || undefined,
            phone: contact.phone_number,
            contactId: contactId
          });

          // Record in email tracking table
          const now = new Date().toISOString();
          const batchId = `manual-${Date.now()}-${contactId}`;
          
          await emailService.recordEmailSend(orgDb, {
            orgId: user.organization_id,
            contactId: contactId,
            emailType: 'quote_email',
            sendStatus: 'sent',
            sendMode: 'production',
            batchId: batchId,
            messageId: result.messageId
          });

          const trackingRecord = await orgDb.fetchOne<{id: number, email_type: string, scheduled_date: string, send_status: string, send_mode: string}>(
            'SELECT id, email_type, scheduled_date, send_status, send_mode FROM email_send_tracking WHERE batch_id = ?',
            [batchId]
          );

          // Update last_emailed timestamp
          await orgDb.execute(
            'UPDATE contacts SET last_emailed = CURRENT_TIMESTAMP WHERE id = ?',
            [contactId]
          );

          return {
            success: true,
            message: 'Quote email sent successfully',
            trackingRecords: trackingRecord ? {
              id: trackingRecord.id,
              email_type: trackingRecord.email_type,
              scheduled_date: trackingRecord.scheduled_date,
              send_status: trackingRecord.send_status,
              send_mode: trackingRecord.send_mode
            } : null
          };
        } catch (error) {
          logger.error(`Error sending quote email: ${error}`);
          return {
            success: false,
            message: 'Failed to send quote email',
            error: String(error)
          };
        }
      })
      
      .post('/api/contact-request', async ({ body, request }: { body: { name: string; email: string; type: string; quoteId?: string }, request: Request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contactRequest = body as { name: string, email: string, type: string, quoteId: string }
          const { name, email, type, quoteId } = contactRequest
          logger.info(`Processing contact request for ${email} (type: ${type})`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Check for existing contact
          const existingContact = await orgDb.fetchOne<{ id: number }>(
            'SELECT id FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          let eventTargetId: number
          let isLead = false

          if (existingContact) {
            // Use existing contact
            logger.info(`Found existing contact with ID ${existingContact.id}`)
            eventTargetId = existingContact.id
          } else {
            // Create new lead
            logger.info(`No existing contact found, creating lead for ${email}`)
            const leadResult = await orgDb.execute(
              `INSERT INTO leads (name, email) VALUES (?, ?) RETURNING id`,
              [name, email]
            )
            
            if (!leadResult.rows?.[0]?.id) {
              throw new Error('Failed to create lead')
            }
            
            eventTargetId = leadResult.rows[0].id
            isLead = true
          }

          // Record the event
          const metadata = {
            quoteId,
            requestType: type
          }

          const eventQuery = isLead
            ? `INSERT INTO contact_events (lead_id, event_type, metadata) VALUES (?, 'followup_request', ?)`
            : `INSERT INTO contact_events (contact_id, event_type, metadata) VALUES (?, 'followup_request', ?)`

          await orgDb.execute(eventQuery, [eventTargetId, JSON.stringify(metadata)])
          logger.info(`Recorded followup request event for ${isLead ? 'lead' : 'contact'} ${eventTargetId}`)

          // Return success response
          return {
            success: true,
            message: 'Contact request recorded successfully'
          }

        } catch (e: unknown) {
          logger.error(`Error processing contact request: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      .get('/api/contacts/:id/eligibility', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/eligibility - Fetching eligibility results`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get most recent eligibility answers for this contact
          const result = await orgDb.fetchOne(
            `SELECT answers 
             FROM eligibility_answers 
             WHERE contact_id = ? 
             ORDER BY created_at DESC 
             LIMIT 1`,
            [id]
          ) as { answers: string } | null

          if (!result) {
            return {
              status: "incomplete",
              answers: null
            }
          }

          // Parse answers JSON and determine status
          const answers = JSON.parse(result.answers)
          const allTrue = Object.values(answers).every(value => value === true)

          return {
            status: allTrue ? "pass" : "flagged",
            answers: result.answers  // Return the raw JSON string instead of the parsed object
          }

        } catch (e) {
          logger.error(`Error fetching eligibility results: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add new endpoint to get follow-up requests
      .get('/api/contacts/:id/follow-ups', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/follow-ups - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get follow-up requests from contact_events table
          const result = await orgDb.execute(
            `SELECT 
              event_type,
              metadata,
              created_at
             FROM contact_events 
             WHERE contact_id = ? 
               AND event_type = 'followup_request'
             ORDER BY created_at DESC`,
            [id]
          )

          // Map results to a more friendly format
          const followUps = result.rows?.map((row: { metadata: string, created_at: string }) => {
            const metadata = JSON.parse(row.metadata)
            return {
              type: metadata.requestType,
              quoteId: metadata.quoteId,
              createdAt: row.created_at
            }
          }) || []

          return followUps

        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      // Add profile update endpoint
      .put('/api/profile', async ({ request, body, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          const { firstName, lastName, phone } = body as { 
            firstName: string;
            lastName: string;
            phone: string;
          }

          // Get the libSQL client
          const client = db.getClient()

          // Update only allowed profile fields
          const result = await client.execute({
            sql: `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      phone = ?
                  WHERE id = ?
                  RETURNING *`,
            args: [firstName, lastName, phone, currentUser.id]
          })

          if (!result.rows || result.rows.length === 0) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          return {
            success: true,
            message: 'Profile updated successfully'
          }

        } catch (error) {
          logger.error(`Error updating profile: ${error}`)
          set.status = 500
          return {
            success: false,
            error: String(error)
          }
        }
      })
      .get('/api/agents/:id/contacts', async ({ params, request }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser?.organization_id) {
            throw new Error('No organization ID found in session')
          }
          
          logger.info(`GET /api/agents/${params.id}/contacts - Fetching contacts for agent ${params.id}`)
          
          // Get organization-specific database
          const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())
          
          // Fetch all contacts for the agent
          const result = await orgDb.fetchAll('SELECT * FROM contacts WHERE agent_id = ?', [params.id])
          
          logger.info(`GET /api/agents/${params.id}/contacts - Found ${result.length} contacts`)
          
          // Map the database results to the expected format with camelCase field names
          const contacts = result.map((contact: { 
            id: number;
            first_name: string;
            last_name: string;
            email: string;
            current_carrier: string;
            plan_type: string;
            effective_date: string;
            birth_date: string;
            tobacco_user: number;
            gender: string;
            state: string;
            zip_code: string;
            agent_id: number | null;
            last_emailed: string | null;
            phone_number: string;
          }) => ({
            id: contact.id,
            first_name: contact.first_name,
            last_name: contact.last_name,
            email: contact.email,
            current_carrier: contact.current_carrier,
            plan_type: contact.plan_type,
            effective_date: contact.effective_date,
            birth_date: contact.birth_date,
            tobacco_user: Boolean(contact.tobacco_user),
            gender: contact.gender,
            state: contact.state,
            zip_code: contact.zip_code,
            agent_id: contact.agent_id,
            last_emailed: contact.last_emailed,
            phone_number: contact.phone_number || ''
          }))
          
          return {
            success: true,
            contacts: contacts
          }
        } catch (e: unknown) {
          logger.error(`Error fetching contacts for agent ${params.id}: ${e instanceof Error ? e.message : String(e)}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .get('/api/contact-requests', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contact-requests - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Fetch all follow-up requests
          const result = await orgDb.fetchAll('SELECT * FROM contact_events WHERE event_type = ?', ['followup_request'])
          
          logger.info(`GET /api/contact-requests - Found ${result.length} follow-up requests`)
          
          // Map the database results to the expected format with camelCase field names
          const followUps = result.map((followUp: { id: number, event_type: string, metadata: string, created_at: string }) => ({
            id: followUp.id,
            event_type: followUp.event_type,
            metadata: JSON.parse(followUp.metadata),
            created_at: followUp.created_at
          }))
          
          return {
            success: true,
            followUps: followUps
          }
        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .get('/api/contacts/:id/follow-ups', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/follow-ups - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get follow-up requests from contact_events table
          const result = await orgDb.execute(
            `SELECT 
              event_type,
              metadata,
              created_at
             FROM contact_events 
             WHERE contact_id = ? 
               AND event_type = 'followup_request'
             ORDER BY created_at DESC`,
            [id]
          )

          // Map results to a more friendly format
          const followUps = result.rows?.map((row: { metadata: string, created_at: string }) => {
            const metadata = JSON.parse(row.metadata)
            return {
              type: metadata.requestType,
              quoteId: metadata.quoteId,
              createdAt: row.created_at
            }
          }) || []

          return followUps

        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      // Add a catch-all route handler for SPA routes
      .all('*', async ({ request, set }) => {
        const url = new URL(request.url);
        const path = url.pathname;
        
        // Skip API routes
        if (path.startsWith('/api/')) {
          set.status = 404;
          return { error: 'API endpoint not found' };
        }
        
        // Skip files with extensions (static assets)
        if (path.includes('.') && !path.endsWith('/')) {
          set.status = 404;
          return { error: 'File not found' };
        }
        
        // For all other routes, serve the SPA index.html
        logger.info(`Serving SPA for route: ${path}`);
        
        // Determine the path to index.html based on environment
        let indexPath = '';
        
        // Check multiple possible locations for the index.html file
        const possiblePaths = [
          join(process.cwd(), 'dist', 'index.html'),  // Main dist directory
          join(process.cwd(), '..', 'dist', 'index.html'), // Parent dist directory
          join(process.cwd(), 'public', 'index.html'), // Public directory
          join(process.cwd(), '..', 'frontend', 'dist', 'index.html') // Frontend dist directory
        ];
        
        // Try each path until we find one that exists
        for (const possiblePath of possiblePaths) {
          logger.info(`Checking for SPA at: ${possiblePath}`);
          if (existsSync(possiblePath)) {
            indexPath = possiblePath;
            logger.info(`Found SPA at: ${indexPath}`);
            break;
          }
        }
        
        if (!indexPath || !existsSync(indexPath)) {
          logger.error(`Cannot find SPA index.html file to serve for route: ${path}`);
          set.status = 404;
          return { error: 'SPA file not found' };
        }
        
        // Read and serve the index.html file
        try {
          const content = readFileSync(indexPath, 'utf-8');
          set.headers['Content-Type'] = 'text/html';
          return content;
        } catch (error) {
          logger.error(`Error reading SPA index.html: ${error}`);
          set.status = 500;
          return { error: 'Error serving SPA' };
        }
      })
      .listen(8000)

    logger.info('Server started on port 8000')

    // Schedule the cleanup job to run daily at midnight
    cron.schedule('0 0 * * *', () => {
      logger.info('Running scheduled cleanup job for old organizations');
      // cleanupOldOrganizations().catch(error => {
      //   logger.error(`Error in scheduled cleanup job: ${error}`);
      // });
    });
    
    logger.info('Scheduled daily cleanup job for old organizations');

    return app
  } catch (error) {
    logger.error(`Error starting server: ${error}`)
    throw error
  }
}

startServer()

================
File: src/logger.ts
================
export const logger = {
  info: (message: string) => {
    const timestamp = new Date().toISOString()
    console.log(`[${timestamp}] [INFO] ${message}`)
  },
  error: (message: string) => {
    const timestamp = new Date().toISOString()
    console.error(`[${timestamp}] [ERROR] ${message}`)
  },
  warn: (message: string) => {
    const timestamp = new Date().toISOString()
    console.warn(`[${timestamp}] [WARN] ${message}`)
  }
}

================
File: src/types.ts
================
import { Database } from './database';
import { cookie } from '@elysiajs/cookie';

export interface ContactCreate {
  first_name: string
  last_name: string
  email: string
  phone_number: string
  state: string
  contact_owner_id?: number | null
  current_carrier?: string | null
  effective_date: string
  birth_date: string
  tobacco_user: boolean
  gender: string
  zip_code: string
  plan_type?: string | null
  agent_id?: number | null
}

export interface ContactCreateTemp {
  first_name: string
  last_name: string
  email: string
  phone_number: string
  state: string
  effective_date: string
  birth_date: string
  tobacco_user: boolean
  gender: string
  zip_code: string
  contact_owner_id?: number | null
}

export interface AgentCreate {
  first_name: string
  last_name: string
  email: string
  phone: string
}

export interface User {
  id: number;
  email: string;
  organization_id: number;
  organizationId?: number;
  is_admin: boolean;
  is_agent: boolean;
  is_active: boolean;
  first_name: string;
  last_name: string;
  phone: string;
  organization_name?: string;
}

export interface BaseSettings {
  stateLicenses: string[];
  carrierContracts: string[];
  stateCarrierSettings: any[];
  allowAgentSettings: boolean;
  emailSendBirthday: boolean;
  emailSendPolicyAnniversary: boolean;
  emailSendAep: boolean;
  smartSendEnabled: boolean;
  brandName?: string;
  logo?: string | null;
  orgSignature?: boolean;
  phone?: string;
  redirectUrl?: string;
  signature?: string;
}

export interface UserContext {
  store: {
    db: Database;
  };
  user: User;
  set: {
    status?: number;
    headers?: Record<string, string>;
  };
  cookie: ReturnType<typeof cookie>;
  query: Record<string, string | undefined>;
  body: unknown;
}

================
File: .env.example
================
# Database connection
TURSO_URL=
TURSO_AUTH_TOKEN=

# Authentication
JWT_SECRET=your-very-long-jwt-secret-at-least-32-characters
COOKIE_SECRET=your-cookie-secret

# Server
PORT=3001
HOST=0.0.0.0
PUBLIC_URL=http://localhost:5173

# Email
EMAIL_FROM=support@yourcompany.com
SENDGRID_API_KEY=

# Stripe Integration
STRIPE_SECRET_KEY=sk_test_51XXXXXXXXXXXXXXXXXXXXXXXX
STRIPE_PUBLISHABLE_KEY=pk_test_51XXXXXXXXXXXXXXXXXXXXXXXX
STRIPE_WEBHOOK_SECRET=whsec_XXXXXXXXXXXXXXXXXXXXXXXX

# Stripe Products and Prices
STRIPE_PRICE_BASIC=price_XXXXXXXXXXXXX
STRIPE_PRICE_PRO=price_XXXXXXXXXXXXX
STRIPE_PRICE_ENTERPRISE=price_XXXXXXXXXXXXX

# Contact-based Pricing
STRIPE_PRICE_CONTACT_BASE_TIER=price_XXXXXXXXXXXXX
STRIPE_PRICE_ADDITIONAL_CONTACTS=price_XXXXXXXXXXXXX

# For example mode in local development (uncomment to enable)
# USE_MOCK_STRIPE=true

================
File: .gitignore
================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

================
File: BULK-IMPORT-IMPLEMENTATION.md
================
# Bulk Contact Import Implementation Summary

## Overview

This document provides a summary of the bulk contact import implementation.

## Core Components

1. **Database Class Enhancement**:
   - Added a streamlined `bulkImportContacts` method
   - Handles contact validation, deduplication, and SQL generation
   - Creates timestamped database names to avoid conflicts

2. **TursoService Enhancement**:
   - Improved `createDatabaseFromDump` method
   - Added phased SQL execution (schema  data  indexes)
   - Enhanced error handling and cleanup operations

3. **API Integration**:
   - Created a new `POST /api/contacts/bulk-import` endpoint
   - Handles CSV file upload with form data multipart processing
   - Launches the import process asynchronously

4. **Command Line Tools**:
   - Created `test-bulk-import.ts` for command line importing
   - Added `generate-test-data.ts` for sample data generation
   - Both accessible through npm scripts

5. **Web Interface**:
   - Created a simple test form at `/test-bulk-import.html`
   - Provides visual feedback on import process

## Technical Implementation

### Efficient Data Processing

The implementation features several optimizations:

1. **Multi-row INSERT statements**:
   ```sql
   INSERT INTO contacts (...) VALUES (...), (...), (...) ...
   ```

2. **Transaction management**:
   - Batches operations into groups of 500 records
   - Uses proper transaction boundaries

3. **Index optimization**:
   - Schema created first
   - Data loaded next
   - Indexes created last for best performance

4. **Asynchronous processing**:
   - API returns immediately while import runs in background
   - Client doesn't need to maintain an open connection

### Error Handling

The implementation includes comprehensive error handling:

1. **Input validation**:
   - Validates CSV fields
   - Normalizes property names (camelCase and snake_case)
   - Reports validation errors

2. **Database operations**:
   - Handles database creation failures
   - Manages SQL execution errors
   - Cleans up resources on failure

3. **Logging**:
   - Detailed logging throughout the process
   - Verification steps to confirm successful operations

## Testing

The implementation includes tools for testing:

1. **Small-scale testing**:
   - Sample CSV with 10 contacts for basic testing
   - Command-line testing script

2. **Large-scale testing**:
   - Data generator for performance testing
   - Support for testing 35,000+ contacts

## Usage

See [README-bulk-import.md](./README-bulk-import.md) for detailed usage instructions.

================
File: out.txt
================
migrations/show_org.sql db shell medicare-portal

================
File: package.json
================
{
  "name": "backend",
  "module": "index.ts",
  "type": "module",
  "scripts": {
    "dev": "bun run --watch --env-file .env src/index.ts",
    "add-agent": "bun run scripts/add-agent.ts",
    "manage-recommendations": "bun run scripts/manage-recommendations.ts",
    "manage-turso": "bun run scripts/manage-turso.ts",
    "test-import": "bun run scripts/test-bulk-import.ts",
    "generate-data": "bun run scripts/generate-test-data.ts",
    "fix-contacts": "bun run scripts/apply-contact-migration.ts",
    "start": "NODE_ENV=production bun run --no-env-file src/index.ts"
  },
  "dependencies": {
    "@clack/prompts": "^0.7.0",
    "@elysiajs/cookie": "^0.8.0",
    "@elysiajs/cors": "^0.8.0",
    "@elysiajs/static": "^1.2.0",
    "@libsql/client": "^0.15.0-pre.1",
    "@sendgrid/mail": "^8.1.4",
    "@types/bun": "latest",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/multer": "^1.4.12",
    "chalk": "^5.4.1",
    "csv-parse": "^5.6.0",
    "csv-stringify": "^6.5.2",
    "dotenv": "^16.3.1",
    "elysia": "^0.8.9",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.2",
    "node-cron": "^3.0.3",
    "openai": "^4.90.0",
    "prompts": "^2.4.2",
    "sqlite3": "^5.1.7",
    "stripe": "^17.7.0",
    "twilio": "^5.6.1",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/node-cron": "^3.0.11",
    "bun-types": "latest"
  }
}

================
File: README-bulk-import.md
================
# Bulk Contact Import Functionality

This document describes the bulk contact import feature that allows importing large numbers of contacts (35,000+) into organizational databases efficiently.

## Overview

The bulk import process works by:
1. Processing and validating input contacts
2. Getting the schema from the existing organization database 
3. Creating a new database with a timestamp-based name
4. Generating optimized SQL with multi-row INSERT statements
5. Uploading the SQL to the new database
6. Updating the organization to point to the new database
7. Cleaning up the old database

## Duplicate Email Handling

The system now handles duplicate emails in three ways:

1. **During Import**: The email field has a unique index that enforces case-insensitive uniqueness.
   - With `overwriteExisting = false`, duplicates are skipped (using `INSERT OR IGNORE`)
   - With `overwriteExisting = true`, existing records are updated (using `INSERT OR REPLACE`) 

2. **Deduplicate Existing Data**: A migration script (`bun run fix-contacts`) can be run to:
   - Find all organization databases with duplicate email entries
   - Keep only the most recently updated record for each email
   - Create the necessary unique index to prevent future duplicates

3. **Schema Protection**: The database schema setup now always creates the unique index on email, regardless of whether the table is being created or already exists.

## Usage

Three options are provided for using the bulk import functionality:

### 1. Web Interface

A simple HTML form is provided for testing the bulk import API:

```bash
# Start the backend server
cd backend && bun run dev

# Access the test page in your browser
open http://localhost:8000/test-bulk-import.html

# Log in as an admin user first (required for the import API)
# You can use the development login helper:
open http://localhost:8000/api/dev/session/login
```

### 2. Generate Test Data

Generate test data for performance testing with:

```bash
# Generate 1,000 test contacts
bun run generate-data 1000

# Generate 50,000 test contacts in a specific file
bun run generate-data 50000 path/to/output.csv
```

### 3. Command Line Import

Import contacts directly from the command line with:

```bash
# Import contacts for organization ID 1
bun run test-import 1 ./scripts/sample-contacts.csv

# Import and overwrite existing contacts with the same email
bun run test-import 1 ./scripts/sample-contacts.csv --overwrite
```

### 4. API Endpoint

The API endpoint for bulk imports can be accessed programmatically:

```javascript
// Example fetch request
const formData = new FormData();
formData.append('file', csvFile); // File object
formData.append('overwriteExisting', true); // Optional, defaults to false

const response = await fetch('/api/contacts/bulk-import', {
  method: 'POST',
  body: formData,
  credentials: 'include'
});

const result = await response.json();

// To check import status:
const statusResponse = await fetch(`/api/contacts/import-status/${organizationId}`, {
  method: 'GET',
  credentials: 'include'
});

const statusResult = await statusResponse.json();
```

## CSV Format

The CSV file should have headers that match the contact fields. Both camelCase and snake_case property names are supported:

```csv
first_name,last_name,email,current_carrier,plan_type,effective_date,birth_date,tobacco_user,gender,state,zip_code,phone_number
John,Doe,john.doe@example.com,Aetna,F,2023-01-01,1955-08-21,0,Male,FL,33101,123-456-7890
```

## Monitoring Import Progress

You can monitor the progress of an import using the import status endpoint:

```bash
# Get import status for organization 123
curl http://localhost:8000/api/contacts/import-status/123
```

The status endpoint returns:

```json
{
  "status": "in progress" | "completed" | "error" | "none",
  "message": "Description of the current status",
  "timestamp": "ISO date when the import was started",
  "age": 5 // Age in minutes
}
```

This endpoint is also available through the web interface at `/test-bulk-import.html` for easy testing.

## Performance Considerations

- The implementation is optimized for large datasets with:
  - Transaction batching (500 contacts per INSERT statement)
  - Index manipulation (drop before bulk insert, recreate after)
  - Property name normalization for CSV flexibility
  - In-memory validation and deduplication
  - Asynchronous processing with status monitoring

## Implementation Details

The core implementation is in two main files:

1. `/backend/src/database.ts` - Contains the `bulkImportContacts` method and email uniqueness enforcement
2. `/backend/src/services/turso.ts` - Contains the `createDatabaseFromDump` method

The process works by:
- Using timestamped database names to avoid conflicts
- Maintaining schema consistency by copying existing table structure
- Processing SQL in phases (schema, data, indexes) for reliability
- Using detailed logging for troubleshooting

## Error Handling

The implementation includes robust error handling:
- Database connection failures
- SQL execution errors
- Validation errors for malformed contacts
- Cleanup operations for partial failures

## Fixing Duplicate Contacts

If you're experiencing duplicate contacts in your database, run the contact fix script:

```bash
# In the backend directory
bun run fix-contacts
```

This script will:
1. Check all organization databases for duplicate email addresses
2. For each database with duplicates:
   - Create a backup of the contacts table
   - Deduplicate contacts by keeping the most recently updated record for each email
   - Create the necessary unique index to prevent future duplicates
3. For databases without duplicates:
   - Only create the unique index if it doesn't exist

The script is safe to run multiple times and will only make changes where needed.

================
File: README.md
================
# backend

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.1.45. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.

================
File: tsconfig.json
================
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}



================================================================
End of Codebase
================================================================

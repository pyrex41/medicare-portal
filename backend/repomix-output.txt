This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.ts, **/*.html, **/package.json, **/*.js
- Files matching these patterns are excluded: backend/node_modules/*, frontend/node_modules/*, node_modules/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
scripts/
  add-agent.ts
  generateQuoteId.ts
  generateQuoteUrl.ts
  manage-recommendations.ts
  manage-turso.ts
src/
  config/
    turso.ts
  middleware/
    auth.ts
    error.ts
  routes/
    admin-portal.ts
    admin.ts
    auth.ts
    brand.ts
    contacts.ts
    organizations.ts
    quotes.ts
    settings.ts
  services/
    agentSettings.ts
    auth.ts
    email.ts
    stripe.ts
    turso.ts
  utils/
    quoteId.ts
  config.ts
  database.ts
  errors.ts
  index.ts
  logger.ts
  types.ts
package.json

================================================================
Files
================================================================

================
File: scripts/add-agent.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for agent data
const AgentSchema = z.object({
  first_name: z.string().min(1),
  last_name: z.string().min(1),
  email: z.string().email(),
  phone: z.string().min(1),
  organization_id: z.number(),
});

async function main() {
  p.intro(chalk.green('âœ¨ Interactive Agent Creation Tool âœ¨'));

  const db = new Database();

  // Get all organizations
  const orgs = await db.fetchAll<{ id: number; name: string }>('SELECT id, name FROM organizations');
  
  if (orgs.length === 0) {
    p.outro(chalk.red('No organizations found. Please create an organization first.'));
    exit(1);
  }

  // Gather information
  const firstName = await p.text({
    message: 'Enter agent first name:',
    validate: (value) => {
      if (value.length === 0) return 'First name cannot be empty';
    },
  });

  const lastName = await p.text({
    message: 'Enter agent last name:',
    validate: (value) => {
      if (value.length === 0) return 'Last name cannot be empty';
    },
  });

  const email = await p.text({
    message: 'Enter agent email:',
    validate: (value) => {
      if (!value.includes('@')) return 'Invalid email address';
    },
  });

  const phone = await p.text({
    message: 'Enter agent phone:',
    validate: (value) => {
      if (value.length === 0) return 'Phone cannot be empty';
    },
  });

  const organization = await p.select({
    message: 'Select organization:',
    options: orgs.map(org => ({
      value: org.id,
      label: org.name,
    })),
  });

  if (p.isCancel(firstName) || p.isCancel(lastName) || p.isCancel(email) || p.isCancel(phone) || p.isCancel(organization)) {
    p.outro(chalk.yellow('Operation cancelled'));
    exit(0);
  }

  try {
    // Validate data
    const agentData = AgentSchema.parse({
      first_name: firstName,
      last_name: lastName,
      email,
      phone,
      organization_id: organization,
    });

    // Start a transaction
    await db.execute('BEGIN TRANSACTION');

    try {
      // Insert into agents table
      await db.execute(
        `INSERT INTO agents (first_name, last_name, email, phone, organization_id)
         VALUES (?, ?, ?, ?, ?)`,
        [
          agentData.first_name,
          agentData.last_name,
          agentData.email,
          agentData.phone,
          agentData.organization_id
        ]
      );

      // Insert into users table
      await db.execute(
        `INSERT INTO users (email, organization_id, is_admin, is_agent, is_active)
         VALUES (?, ?, ?, ?, true)`,
        [agentData.email, agentData.organization_id, false, true]
      );

      // Commit the transaction
      await db.execute('COMMIT');

      p.outro(chalk.green('Agent created successfully! ðŸŽ‰'));

    } catch (error) {
      // Rollback on error
      await db.execute('ROLLBACK');
      throw error;
    }

  } catch (error) {
    if (error instanceof z.ZodError) {
      p.outro(chalk.red(`Validation error: ${error.errors.map(e => e.message).join(', ')}`));
    } else {
      p.outro(chalk.red(`Error creating agent: ${error}`));
    }
    exit(1);
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/generateQuoteId.ts
================
import { generateQuoteId } from '../src/utils/quoteId';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteId.ts <orgId> <contactId>');
  process.exit(1);
}

// Generate quote ID
const quoteId = generateQuoteId(orgId, contactId);

// Output results
console.log('Generated Quote ID:', quoteId);
console.log('Quote URL:', `http://localhost:5173/quote?id=${quoteId}`);

================
File: scripts/generateQuoteUrl.ts
================
import axios, { AxiosError } from 'axios';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteUrl.ts <orgId> <contactId>');
  process.exit(1);
}

// Call the API to generate a quote ID
const generateQuoteUrl = async () => {
  try {
    // First get a session token
    const sessionResponse = await axios.get('http://localhost:8000/api/dev/session/login');
    
    // Then generate the quote ID
    const response = await axios.get(`http://localhost:8000/api/quotes/generate/${contactId}`, {
      headers: {
        Cookie: sessionResponse.headers['set-cookie']?.[0]
      }
    });

    if (response.data.success) {
      console.log('Quote ID:', response.data.quoteId);
      console.log('Quote URL:', response.data.redirectUrl);
    } else {
      console.error('Failed to generate quote ID:', response.data.error);
    }
  } catch (error) {
    if (error instanceof AxiosError) {
      console.error('Error:', error.response?.data || error.message);
    } else {
      console.error('Error:', error);
    }
  }
};

generateQuoteUrl();

================
File: scripts/manage-recommendations.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for GI recommendation data
const RecommendationSchema = z.object({
  state: z.string().length(2),
  carrier: z.string().min(1),
});

async function main() {
  p.intro(chalk.green('âœ¨ Guaranteed Issue Recommendations Manager âœ¨'));

  const db = new Database();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all GI recommendations' },
        { value: 'add', label: 'Add new GI recommendation' },
        { value: 'remove', label: 'Remove GI recommendation' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listRecommendations(db);
          break;
        case 'add':
          await addRecommendation(db);
          break;
        case 'remove':
          await removeRecommendation(db);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listRecommendations(db: Database) {
  const results = await db.fetchAll<{ state: string; carrier: string; created_at: string }>(
    `SELECT state, carrier, created_at 
     FROM guaranteed_issue_recommendations 
     ORDER BY carrier, state`
  );

  if (results.length === 0) {
    p.note('No GI recommendations found', 'Empty');
    return;
  }

  const groupedByCarrier = results.reduce((acc, curr) => {
    if (!acc[curr.carrier]) {
      acc[curr.carrier] = [];
    }
    acc[curr.carrier].push(curr.state);
    return acc;
  }, {} as Record<string, string[]>);

  p.note(
    Object.entries(groupedByCarrier)
      .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
      .join('\n\n'),
    'Current GI Recommendations'
  );
}

async function addRecommendation(db: Database) {
  // Get available carriers first
  const carriers = await db.fetchAll<{ name: string }>(
    'SELECT name FROM carriers ORDER BY name'
  );

  if (carriers.length === 0) {
    p.note(chalk.red('No carriers found in database'));
    return;
  }

  const carrier = await p.select({
    message: 'Select carrier:',
    options: carriers.map(c => ({
      value: c.name,
      label: c.name,
    })),
  });

  if (p.isCancel(carrier)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const states = await p.text({
    message: 'Enter state codes (comma/space separated, e.g., TX CA FL):',
    validate: (value) => {
      const stateList = value.toUpperCase().split(/[\s,]+/).filter(Boolean);
      if (stateList.length === 0) return 'At least one state code is required';
      const invalidStates = stateList.filter(s => s.length !== 2);
      if (invalidStates.length > 0) {
        return `Invalid state codes: ${invalidStates.join(', ')}`;
      }
    },
  });

  if (p.isCancel(states)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const stateList = states.toUpperCase().split(/[\s,]+/).filter(Boolean);
  const results: { state: string; success: boolean; message: string }[] = [];

  for (const state of stateList) {
    try {
      const data = RecommendationSchema.parse({
        state,
        carrier,
      });

      // Check if recommendation already exists
      const existing = await db.fetchOne(
        'SELECT 1 FROM guaranteed_issue_recommendations WHERE state = ? AND carrier = ?',
        [data.state, data.carrier]
      );

      if (existing) {
        results.push({
          state: data.state,
          success: false,
          message: 'Already exists'
        });
        continue;
      }

      await db.execute(
        'INSERT INTO guaranteed_issue_recommendations (state, carrier) VALUES (?, ?)',
        [data.state, data.carrier]
      );

      results.push({
        state: data.state,
        success: true,
        message: 'Added successfully'
      });

    } catch (error) {
      results.push({
        state,
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Unknown error'
      });
    }
  }

  // Display results summary
  const successful = results.filter(r => r.success);
  const failed = results.filter(r => !r.success);

  if (successful.length > 0) {
    p.note(
      chalk.green(
        `Successfully added GI recommendations for ${carrier}:\n` +
        successful.map(r => `  ${r.state}`).join('\n')
      ),
      'Success'
    );
  }

  if (failed.length > 0) {
    p.note(
      chalk.yellow(
        `Failed to add some recommendations for ${carrier}:\n` +
        failed.map(r => `  ${r.state}: ${r.message}`).join('\n')
      ),
      'Warnings'
    );
  }
}

async function removeRecommendation(db: Database) {
  const recommendations = await db.fetchAll<{ id: number; state: string; carrier: string }>(
    'SELECT id, state, carrier FROM guaranteed_issue_recommendations ORDER BY carrier, state'
  );

  if (recommendations.length === 0) {
    p.note(chalk.yellow('No recommendations to remove'));
    return;
  }

  const selections = await p.multiselect({
    message: 'Select recommendations to remove (space to select/deselect):',
    options: recommendations
      .sort((a, b) => a.carrier.localeCompare(b.carrier) || a.state.localeCompare(b.state))
      .map(rec => ({
        value: rec.id.toString(),
        label: `${rec.carrier} - ${rec.state}`,
      })),
    required: true,
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const idsToRemove = (selections as string[]).map(Number);

  if (idsToRemove.length === 0) {
    p.note(chalk.yellow('No recommendations selected for removal'));
    return;
  }

  await db.execute(
    `DELETE FROM guaranteed_issue_recommendations WHERE id IN (${idsToRemove.join(',')})`,
  );

  const removedItems = recommendations
    .filter(r => idsToRemove.includes(r.id))
    .reduce((acc, curr) => {
      if (!acc[curr.carrier]) {
        acc[curr.carrier] = [];
      }
      acc[curr.carrier].push(curr.state);
      return acc;
    }, {} as Record<string, string[]>);

  p.note(
    chalk.green(
      'Successfully removed recommendations:\n\n' +
      Object.entries(removedItems)
        .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
        .join('\n\n')
    ),
    'Success'
  );
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: scripts/manage-turso.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';
import { TURSO_CONFIG } from '../src/config/turso';
import fetch from 'node-fetch';

interface Organization {
  id: number;
  name: string;
  turso_db_url: string | null;
}

class TursoManager {
  private headers = {
    'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
    'Content-Type': 'application/json'
  };

  async listLocations(): Promise<string[]> {
    const response = await fetch(`${TURSO_CONFIG.API_URL}/locations`, {
      headers: this.headers
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch locations: ${await response.text()}`);
    }

    const data = await response.json() as { locations: Array<{ name: string }> };
    return data.locations.map(l => l.name);
  }

  async listDatabases(): Promise<Array<{name: string, hostname: string}>> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`,
      { headers: this.headers }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch databases: ${await response.text()}`);
    }

    const data = await response.json() as { databases: Array<{Name: string, Hostname: string}> };
    return data.databases.map(db => ({
      name: db.Name,
      hostname: db.Hostname
    }));
  }

  async updateGroup(name: string, location: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/groups/${TURSO_CONFIG.GROUP_NAME}`,
      {
        method: 'PATCH',
        headers: this.headers,
        body: JSON.stringify({ name, location })
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to update group: ${await response.text()}`);
    }
  }

  async deleteDatabase(name: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${name}`,
      {
        method: 'DELETE',
        headers: this.headers
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete database: ${await response.text()}`);
    }
  }
}

async function main() {
  p.intro(chalk.green('âœ¨ Turso Database Manager âœ¨'));

  const db = new Database();
  const turso = new TursoManager();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all databases and organizations' },
        { value: 'update-group', label: 'Update group configuration' },
        { value: 'delete-db', label: 'Delete a customer database' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listDatabasesAndOrgs(db, turso);
          break;
        case 'update-group':
          await updateGroupConfig(turso);
          break;
        case 'delete-db':
          await deleteCustomerDatabase(db, turso);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listDatabasesAndOrgs(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  const mappedDatabases = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      name: database.name,
      hostname: database.hostname,
      organization: org ? org[1] : 'Not associated with any organization'
    };
  });

  if (mappedDatabases.length === 0) {
    p.note('No databases found', 'Empty');
    return;
  }

  p.note(
    mappedDatabases
      .map(db => `${db.name}:\n  URL: ${db.hostname}\n  Organization: ${db.organization}`)
      .join('\n\n'),
    'Current Databases'
  );
}

async function updateGroupConfig(turso: TursoManager) {
  // Get available locations
  const locations = await turso.listLocations();

  p.note(
    `Current Configuration:\n` +
    `  Group Name: ${TURSO_CONFIG.GROUP_NAME}\n` +
    `  Location: ${TURSO_CONFIG.LOCATION}`,
    'Current Settings'
  );

  const newGroupName = await p.text({
    message: 'Enter new group name (or press enter to keep current):',
    initial: TURSO_CONFIG.GROUP_NAME,
  });

  if (p.isCancel(newGroupName)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const newLocation = await p.select({
    message: 'Select new location:',
    options: locations.map(loc => ({
      value: loc,
      label: loc,
    })),
    initialValue: TURSO_CONFIG.LOCATION,
  });

  if (p.isCancel(newLocation)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const confirm = await p.confirm({
    message: `Update group "${TURSO_CONFIG.GROUP_NAME}" to:\n` +
             `  Name: ${newGroupName}\n` +
             `  Location: ${newLocation}\n` +
             `Are you sure?`,
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  await turso.updateGroup(newGroupName, newLocation as string);
  
  p.note(
    chalk.green(
      `Successfully updated group configuration.\n` +
      `Remember to update TURSO_CONFIG in your code!`
    ),
    'Success'
  );
}

async function deleteCustomerDatabase(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  if (databases.length === 0) {
    p.note('No databases found to delete', 'Empty');
    return;
  }

  const options = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      value: database.name,
      label: `${database.name} (${org ? org[1] : 'Unassociated'})`,
    };
  });

  const selections = await p.multiselect({
    message: 'Select databases to delete (space to select, enter to confirm):',
    options,
    required: true
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const selectedDbs = selections as string[];
  if (selectedDbs.length === 0) {
    p.note(chalk.yellow('No databases selected'));
    return;
  }

  const confirm = await p.confirm({
    message: chalk.red(
      `Are you sure you want to delete the following databases?\n` +
      selectedDbs.map(db => `  - ${db}`).join('\n') +
      `\nThis action cannot be undone!`
    ),
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  for (const dbName of selectedDbs) {
    try {
      await turso.deleteDatabase(dbName);

      // Update organization record
      const org = orgs.find((o: any) => 
        o[2] && 
        o[2].toString().includes(
          databases.find(d => d.name === dbName)?.hostname || ''
        )
      );

      if (org) {
        await db.execute(
          'UPDATE organizations SET turso_db_url = NULL, turso_auth_token = NULL WHERE id = ?',
          [org[0]]
        );
      }

      p.note(
        chalk.green(`Successfully deleted database "${dbName}"`),
        'Success'
      );
    } catch (error) {
      p.note(
        chalk.red(`Failed to delete database "${dbName}": ${error}`),
        'Error'
      );
    }
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: src/config/turso.ts
================
export const TURSO_CONFIG = {
  API_URL: 'https://api.turso.tech/v1',
  API_TOKEN: process.env.TURSO_API_TOKEN, // Add this to your .env
  ORG_SLUG: 'pyrex41',
  GROUP_NAME: 'medicare-portal',
  LOCATION: 'aws-us-east-1' // We can update this to your preferred location
}

================
File: src/middleware/auth.ts
================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { Database } from '../database';

interface AuthenticatedRequest extends Request {
  user?: {
    id: number;
    email: string;
    organization_id: number;
    role: string;
    turso_db_url?: string;
    turso_auth_token?: string;
  };
}

export async function authMiddleware(
  req: AuthenticatedRequest, 
  res: Response, 
  next: NextFunction
) {
  try {
    // Verify JWT token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      res.status(401).json({ error: 'No token provided' });
      return;
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
      userId: number;
    };

    const db = new Database();

    // Get user with organization info from central DB
    const user = await db.execute(
      `SELECT u.*, o.turso_db_url, o.turso_auth_token
       FROM users u
       JOIN organizations o ON u.organization_id = o.id
       WHERE u.id = ?`,
      [decoded.userId]
    );

    if (!user) {
      res.status(401).json({ error: 'User not found' });
      return;
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Unauthorized' });
  }
}

================
File: src/middleware/error.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'

export const errorHandler = new Elysia()
  .onError(({ code, error, set }) => {
    logger.error(`âŒ Error: ${code} - ${error.message}`);
    
    switch (code) {
      case 'NOT_FOUND':
        set.status = 404;
        return {
          success: false,
          message: 'Resource not found'
        };
      
      case 'VALIDATION':
        set.status = 400;
        return {
          success: false,
          message: error.message
        };
      
      default:
        set.status = 500;
        return {
          success: false,
          message: 'Internal server error'
        };
    }
  });

================
File: src/routes/admin-portal.ts
================
import { Elysia } from 'elysia'
import { spawn } from 'child_process'
import path from 'path'
import { logger } from '../logger'
import { requireAuth, requireAdmin } from '../middleware/auth'

// Create admin portal routes
export const createAdminPortalRoutes = () => {
  const adminPortal = new Elysia({ prefix: '/api/admin' })
    .use(requireAuth)
    .use(requireAdmin)

    // Get available admin scripts
    .get('/scripts', () => {
      const availableScripts = [
        {
          id: 'add-agent',
          name: 'Add Agent',
          description: 'Interactive tool to add new agents',
          script: 'add-agent.ts'
        },
        {
          id: 'manage-recommendations',
          name: 'Manage GI Recommendations', 
          description: 'Manage guaranteed issue recommendations',
          script: 'manage-recommendations.ts'
        }
      ]
      
      return { scripts: availableScripts }
    })

    // Execute script endpoint
    .post('/execute/:scriptId', ({ params, set, server }) => {
      const { scriptId } = params
      const scriptPath = path.join(__dirname, '../../scripts', `${scriptId}.ts`)

      logger.info(`Executing admin script: ${scriptId}`)

      // Spawn script process
      const process = spawn('bun', ['run', scriptPath], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      // Get WebSocket server instance
      const wss = server.webSocket

      // Handle new WebSocket connections
      wss.on('connection', (ws) => {
        logger.info('Admin terminal WebSocket connected')

        // Handle input from client
        ws.on('message', (data: string) => {
          const parsed = JSON.parse(data)
          if (parsed.type === 'input') {
            process.stdin.write(parsed.data)
          }
        })

        // Send output to client
        process.stdout.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'output', 
            data: data.toString() 
          }))
        })

        process.stderr.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'error', 
            data: data.toString() 
          }))
        })

        // Handle process exit
        process.on('exit', (code) => {
          ws.send(JSON.stringify({ type: 'exit', code }))
          logger.info(`Admin script ${scriptId} exited with code ${code}`)
        })

        // Handle WebSocket close
        ws.on('close', () => {
          logger.info('Admin terminal WebSocket disconnected')
          process.kill()
        })
      })

      set.status = 200
      return { 
        success: true, 
        message: 'Script execution started' 
      }
    })

  return adminPortal
}

================
File: src/routes/admin.ts
================
import { Elysia } from 'elysia'
import { staticPlugin } from '@elysiajs/static'
import { spawn } from 'child_process'
import path from 'path'
import { TursoService } from '../services/turso'

const tursoService = new TursoService()

export const adminRoutes = new Elysia()
  // Protect admin routes
  .guard({
    beforeHandle: ({ request, set }) => {
      // Add your admin authentication logic here
      const isAdmin = true // Replace with actual admin check
      if (!isAdmin) {
        set.status = 401
        return 'Unauthorized'
      }
    }
  })
  // Serve admin portal static files
  .use(staticPlugin({
    assets: '../admin-portal/dist',
    prefix: '/admin'
  }))
  // Terminal WebSocket endpoint
  .ws('/admin/terminal', {
    open(ws) {
      ws.send('Connected to admin terminal')
    },
    message(ws, message) {
      const { command, args } = JSON.parse(message as string)
      
      const scripts = {
        'add-agent': '../scripts/add-agent.ts',
        'manage-recommendations': '../scripts/manage-recommendations.ts'
      }

      if (!scripts[command]) {
        ws.send(JSON.stringify({ error: 'Invalid command' }))
        return
      }

      const script = spawn('bun', [path.resolve(__dirname, scripts[command]), ...args], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      script.stdout.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'output', data: data.toString() }))
      })

      script.stderr.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'error', data: data.toString() }))
      })

      script.on('close', (code) => {
        ws.send(JSON.stringify({ type: 'exit', code }))
      })
    }
  })

// In your create organization endpoint:
app.post('/api/organizations', async (req, res) => {
  const { name, /* other org fields */ } = req.body
  
  try {
    // Create org in central DB
    const org = await db.one(`
      INSERT INTO organizations (name) 
      VALUES ($1) 
      RETURNING id`, 
      [name]
    )

    // Create Turso DB for org
    const { url, token } = await tursoService.createOrganizationDatabase(org.id)

    // Update org with Turso credentials
    await db.none(`
      UPDATE organizations 
      SET turso_db_url = $1, turso_auth_token = $2
      WHERE id = $3`,
      [url, token, org.id]
    )

    res.json({ success: true, organization: org })
  } catch (err) {
    res.status(500).json({ success: false, error: err.message })
  }
})

================
File: src/routes/auth.ts
================
import { Elysia } from 'elysia';
import { cookie } from '@elysiajs/cookie';
import { AuthService } from '../services/auth';
import { EmailService } from '../services/email';
import { logger } from '../logger';
import { randomBytes } from 'crypto';
import { config } from '../config';
import crypto from 'crypto';
import { db } from '../database';
import { Database } from '../database';
import { getUserFromSession } from '../services/auth';
import type { User } from '../types';

const dbInstance = new Database();

export function createAuthRoutes() {
  const auth = new AuthService();
  const emailService = new EmailService();

  return new Elysia()
    .use(cookie())
    .post('/api/auth/login', async ({ body, set }) => {
      try {
        const { email } = body as { email: string };
        logger.info(`Login request for email: ${email}`);

        // Check if user exists
        const client = dbInstance.getClient();
        const userResult = await client.execute({
          sql: 'SELECT id, email FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        if (userResult.rows.length === 0) {
          // Don't reveal if user exists or not
          logger.info(`No active user found for email: ${email}`);
          return { success: true };
        }

        // Generate and send magic link
        const magicLink = await auth.createMagicLink(
          email,
          'default', // Default organization for now
          { redirectUrl: '/dashboard' }
        );

        // Always send the email, but also log in development
        if (process.env.NODE_ENV === 'development') {
          logger.info(`Development mode - Magic link: ${magicLink}`);
        }
        
        // Send the email
        await emailService.sendMagicLink(email, magicLink, 'default');

        return { success: true };

      } catch (e) {
        logger.error(`Login error: ${e}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Internal server error'
        };
      }
    })

    .get('/api/auth/verify/:organizationSlug/:token', async ({ params, cookie, setCookie }) => {
      const { token, organizationSlug } = params;
      
      logger.info(`Starting verification for org ${organizationSlug}`);

      try {
        logger.info('Verifying magic link');
        const result = await auth.verifyMagicLink(token, organizationSlug);
        logger.info(`Magic link verification result: ${JSON.stringify(result)}`);
        
        if (!result.valid) {
          logger.error('Magic link validation failed');
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        // Create session ID
        const sessionId = crypto.randomBytes(32).toString('hex');
        logger.info(`Created session ID: ${sessionId}`);

        // First find user by email
        const user = await db.fetchOne<User>(
          `SELECT u.*, o.slug as organization_slug 
           FROM users u 
           JOIN organizations o ON u.organization_id = o.id 
           WHERE LOWER(u.email) = LOWER(?) AND u.is_active = 1`,
          [result.email]
        );

        if (!user) {
          logger.error(`No active user found for email: ${result.email}`);
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        logger.info(`Found user: ${JSON.stringify(user)}`);

        // Create session in database
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

        await db.execute(
          'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
          [sessionId, user.id, expiresAt.toISOString()]
        );

        logger.info(`Created session in database for user ${user.id}`);

        // Set session cookie
        setCookie('session', sessionId, {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7 // 7 days
        });

        const verificationResult = {
          success: true,
          redirectUrl: result.redirectUrl || '/dashboard',
          session: sessionId,
          email: result.email,
          orgSlug: user.organization_slug
        };
        logger.info(`Sending verification response: ${JSON.stringify(verificationResult)}`);
        return verificationResult;

      } catch (error) {
        logger.error(`Verification error: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return {
          success: false,
          redirectUrl: "/login",
          session: "",
          email: ""
        };
      }
    })

    .get('/api/auth/session', async ({ cookie }) => {
      const sessionId = cookie.session;
      logger.info(`Session check - Cookie session ID: ${sessionId}`);
      
      if (!sessionId) {
        logger.info('No session cookie found');
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: ""
        };
      }

      try {
        // Get user and organization info from session
        logger.info(`Looking up session in database: ${sessionId}`);
        const sessionUser = await db.fetchOne<{
          id: number;
          email: string;
          first_name: string;
          last_name: string;
          organization_slug: string;
        }>(
          `SELECT u.id, u.email, u.first_name, u.last_name, o.slug as organization_slug
           FROM sessions s
           JOIN users u ON s.user_id = u.id
           JOIN organizations o ON u.organization_id = o.id
           WHERE s.id = ?`,
          [sessionId]
        );

        if (!sessionUser) {
          logger.info(`No session found in database for ID: ${sessionId}`);
          return { 
            valid: false,
            session: "",
            email: "",
            organizationSlug: "",
            first_name: "",
            last_name: "",
            id: ""
          };
        }

        logger.info(`Found valid session for user: ${sessionUser.email}`);
        logger.info(`Session details: ${JSON.stringify(sessionUser, null, 2)}`);

        return { 
          valid: true,
          session: sessionId,
          email: sessionUser.email,
          organizationSlug: sessionUser.organization_slug,
          first_name: sessionUser.first_name,
          last_name: sessionUser.last_name,
          id: sessionUser.id
        };
      } catch (error) {
        logger.error(`Error getting session info: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: ""
        };
      }
    })

    .post('/api/auth/logout', async ({ set }) => {
      set.headers['Set-Cookie'] = 'session=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT';
      return { success: true };
    });
}

================
File: src/routes/brand.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';

const db = new Database();

interface Organization {
  id: number;
}

interface BrandSettings {
  brand_name: string;
  primary_color: string;
  secondary_color: string;
  logo_data: string | null;
}

export function createBrandRoutes() {
  return new Elysia()
    .get('/api/organizations/:orgSlug/brand', async ({ params }) => {
      try {
        const { orgSlug } = params;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Get brand settings
        const settings = await db.fetchOne<BrandSettings>(
          'SELECT brand_name, primary_color, secondary_color, logo_data FROM brand_settings WHERE organization_id = ?',
          [org.id]
        );

        if (!settings) {
          // Return defaults if no settings exist
          return {
            brand_name: '',
            primary_color: '#6B46C1',
            secondary_color: '#9F7AEA',
            logo: null
          };
        }

        return {
          brand_name: settings.brand_name,
          primary_color: settings.primary_color,
          secondary_color: settings.secondary_color,
          logo: settings.logo_data
        };
      } catch (error) {
        logger.error('Error fetching brand settings', error);
        return {
          success: false,
          error: 'Failed to fetch brand settings'
        };
      }
    })
    .put('/api/organizations/:orgSlug/brand', async ({ params, body }) => {
      try {
        const { orgSlug } = params;
        const { brand_name, primary_color, secondary_color, logo } = body as any;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Upsert brand settings
        await db.execute(`
          INSERT INTO brand_settings 
            (organization_id, brand_name, primary_color, secondary_color, logo_data)
          VALUES (?, ?, ?, ?, ?)
          ON CONFLICT(organization_id) DO UPDATE SET
            brand_name = excluded.brand_name,
            primary_color = excluded.primary_color,
            secondary_color = excluded.secondary_color,
            logo_data = excluded.logo_data
        `, [org.id, brand_name, primary_color, secondary_color, logo]);

        return {
          success: true
        };
      } catch (error) {
        logger.error('Error saving brand settings', error);
        return {
          success: false,
          error: 'Failed to save brand settings'
        };
      }
    });
}

================
File: src/routes/contacts.ts
================
import { createClient } from '@libsql/client';

// Get Turso client for organization
async function getOrgTursoClient(orgId: string) {
  const org = await db.one(`
    SELECT turso_db_url, turso_auth_token 
    FROM organizations 
    WHERE id = $1`,
    [orgId]
  );

  return createClient({
    url: org.turso_db_url,
    authToken: org.turso_auth_token
  });
}

// Update contacts endpoints to use org's Turso DB
app.post('/api/contacts/upload', async (req, res) => {
  const orgId = req.user.organizationId;
  const tursoClient = await getOrgTursoClient(orgId);

  try {
    // Process CSV file
    const contacts = parseCSV(req.file);
    
    // Insert into org's Turso DB
    for (const contact of contacts) {
      await tursoClient.execute(`
        INSERT INTO contacts (
          first_name, last_name, email, /* other fields */
        ) VALUES (?, ?, ?, /* other values */)`,
        [contact.firstName, contact.lastName, contact.email /* other values */]
      );
    }

    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ 
      success: false,
      message: err.message,
      // Include other error details as needed
    });
  }
});

// Similar updates needed for other contact endpoints

================
File: src/routes/organizations.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { TursoService } from '../services/turso';
import { z } from 'zod';
import { sendMagicLink } from '../services/email';
import { generateToken, getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { AuthService } from '../services/auth';
import { config } from '../config';

// Update the validation schema to include slug rules
const signupSchema = z.object({
  organizationName: z.string()
    .min(1, "Organization name is required")
    .max(100, "Organization name must be less than 100 characters")
    .regex(/^[a-zA-Z0-9\s\-_.]+$/, "Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores"),
  adminFirstName: z.string().min(1, "First name is required"),
  adminLastName: z.string().min(1, "Last name is required"),
  adminEmail: z.string().email("Invalid email address"),
});

// Enhanced slug generation with uniqueness check
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

export const organizationRoutes = new Elysia({ prefix: '/api' })
  .post('/organizations/signup', async ({ body, set }) => {
    const db = new Database();
    const turso = new TursoService();
    const auth = new AuthService();

    try {
      logger.info(`Attempting to create organization with data: ${JSON.stringify(body)}`);
      const data = signupSchema.parse(body);
      
      // Generate unique slug
      const slug = await generateUniqueSlug(db, data.organizationName);
      logger.info(`Generated unique slug: ${slug}`);
      
      // Check if email is already registered in any organization
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE email = ?',
        [data.adminEmail]
      );

      logger.info(`Existing user check result: ${JSON.stringify(existingUser)}`);

      if (existingUser[0]?.count > 0) {
        logger.warn(`Email ${data.adminEmail} is already registered`);
        set.status = 400;
        return {
          success: false,
          message: 'This email address is already registered. Please use a different email or contact support.'
        };
      }

      // Check if organization name or slug is taken
      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [data.organizationName, slug]
      );

      logger.info(`Existing org check result: ${JSON.stringify(existingOrg)}`);

      if (existingOrg[0]?.count > 0) {
        logger.warn(`Organization name ${data.organizationName} or slug ${slug} is already taken`);
        set.status = 400;
        return {
          success: false,
          message: 'Organization name is already taken'
        };
      }

      // Wrap all database operations in a transaction
      const orgId = await db.transaction('write', async (transactionDb) => {
        // Create organization
        logger.info('Creating organization');
        const org = await transactionDb.execute(
          `INSERT INTO organizations (
            name,
            slug,
            subscription_tier,
            agent_limit,
            contact_limit
          ) VALUES (?, ?, 'basic', 5, 100) RETURNING id`,
          [data.organizationName, slug]
        );

        const orgId = org.rows?.[0]?.id;
        if (!orgId) {
          throw new Error('Failed to create organization');
        }

        logger.info(`Organization created with ID: ${orgId}`);

        // Create inactive admin user
        logger.info('Creating admin user');
        await transactionDb.execute(
          `INSERT INTO users (
            email,
            organization_id,
            is_admin,
            is_agent,
            is_active,
            first_name,
            last_name,
            created_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            data.adminEmail,
            orgId,
            1, // is_admin
            1, // is_agent - Set to 1 for basic tier since admin is also an agent
            1, // is_active
            data.adminFirstName,
            data.adminLastName,
            new Date().toISOString()
          ]
        );

        return orgId;
      });

      // Generate and send magic link outside the transaction
      logger.info('Generating magic link');
      const magicLink = await auth.createMagicLink(
        data.adminEmail, 
        slug,
        {
          redirectUrl: '/choose-plan',
          orgId,
          name: `${data.adminFirstName} ${data.adminLastName}`
        }
      );

      logger.info(`Magic link generated successfully: ${magicLink}`);
      await sendMagicLink({
        email: data.adminEmail,
        magicLink,
        name: `${data.adminFirstName} ${data.adminLastName}`
      });

      logger.info('Magic link email sent successfully');
      set.status = 201;
      return { 
        success: true,
        message: 'Please check your email to verify your account'
      };

    } catch (error) {
      logger.error(`Organization creation error: ${error}`);
      set.status = 400;
      return {
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Failed to create organization. Please try again.'
      };
    }
  })
  .get('/organizations/check-name/:name', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedName = decodeURIComponent(params.name);
      const potentialSlug = decodedName
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');

      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [decodedName, potentialSlug]
      );

      const count = existingOrg[0]?.count || 0;

      if (count > 0) {
        return {
          available: false,
          message: 'Organization name is already taken'
        };
      }

      // Validate name format
      if (!/^[a-zA-Z0-9\s\-_.]+$/.test(decodedName)) {
        return {
          available: false,
          message: 'Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores'
        };
      }

      return {
        available: true,
        message: 'Organization name is available'
      };

    } catch (error) {
      logger.error(`Error checking organization name: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check organization name'
      };
    }
  })
  .get('/organizations/check-email/:email', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedEmail = decodeURIComponent(params.email);
      
      // Basic email format validation
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(decodedEmail)) {
        return {
          available: false,
          message: 'Invalid email format'
        };
      }

      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE email = ?',
        [decodedEmail]
      );

      const count = existingUser[0]?.count || 0;

      if (count > 0) {
        return {
          available: false,
          message: 'This email address is already registered'
        };
      }

      return {
        available: true,
        message: 'Email is available'
      };

    } catch (error) {
      logger.error(`Error checking email: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check email availability'
      };
    }
  })
  .get('/organizations/subscription-tiers', async ({ set }) => {
    const db = new Database();
    try {
      const tiersResult = await db.query<{
        id: string,
        name: string,
        agent_limit: number,
        contact_limit: number,
        price_monthly: number,
        features: string
      }>('SELECT id, name, agent_limit, contact_limit, price_monthly, features FROM subscription_tiers');

      const tiers = tiersResult.map(tier => ({
        id: tier.id,
        name: tier.name,
        price: `$${(tier.price_monthly / 100).toFixed(0)}/mo`,
        agentLimit: tier.agent_limit,
        contactLimit: tier.contact_limit,
        features: JSON.parse(tier.features)
      }));

      return { success: true, tiers };
    } catch (error) {
      logger.error(`Error fetching subscription tiers: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to fetch subscription tiers' };
    }
  })
  .post('/organizations/:orgSlug/subscription', async ({ params: { orgSlug }, body, request, set }) => {
    try {
      const db = new Database();

      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request)
      if (!currentUser) {
        set.status = 401
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        }
      }

      // Add more detailed logging
      logger.info(`Updating subscription - orgSlug: ${orgSlug}, userId: ${currentUser.organization_id}, body: ${JSON.stringify(body)}`);

      // First verify this user belongs to the organization they're trying to update
      const orgResult = await db.query<{ 
        id: number,
        stripe_customer_id: string | null,
        stripe_subscription_id: string | null,
        name: string
      }>(
        'SELECT id, stripe_customer_id, stripe_subscription_id, name FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404
        return {
          success: false,
          error: 'Organization not found'
        }
      }

      const organization = orgResult[0];

      // Verify user has permission for this org
      if (organization.id !== currentUser.organization_id) {
        logger.error(`User from org ${currentUser.organization_id} attempted to update org ${organization.id}`)
        set.status = 403
        return {
          success: false,
          error: 'You do not have permission to update this organization'
        }
      }

      // Parse the request body
      const { tierId, extraAgents = 0, extraContacts = 0 } = body as { 
        tierId: string, 
        extraAgents?: number, 
        extraContacts?: number 
      };
      
      // Import the Stripe service here to avoid circular dependencies
      const { createOrUpdateSubscription, PlanTier } = await import('../services/stripe');
      
      try {
        // Get user's email for Stripe customer
        const userResult = await db.query<{ email: string }>(
          'SELECT email FROM users WHERE id = ?',
          [currentUser.id]
        );
        
        if (!userResult || userResult.length === 0) {
          throw new Error('User not found');
        }
        
        // Create or update the Stripe subscription
        const stripeResult = await createOrUpdateSubscription({
          tierId: tierId as PlanTier,
          organizationId: organization.id,
          email: userResult[0].email,
          extraAgents,
          extraContacts,
          stripeCustomerId: organization.stripe_customer_id || undefined
        });
        
        // Update organization with Stripe IDs and subscription tier
        await db.execute(
          `UPDATE organizations 
           SET subscription_tier = ?, 
               stripe_customer_id = ?, 
               stripe_subscription_id = ?
           WHERE id = ?`,
          [tierId, stripeResult.customerId, stripeResult.subscriptionId, organization.id]
        );
        
        // Set up the Turso database after subscription is saved
        const baseUrl = process.env.PUBLIC_URL || 'http://localhost:5173';
        const setupDbResponse = await fetch(`${baseUrl}/api/organizations/${orgSlug}/setup-database`, {
          method: 'POST',
          headers: {
            'Cookie': request.headers.get('cookie') || ''
          }
        });

        if (!setupDbResponse.ok) {
          logger.error(`Failed to set up database for org ${organization.id}`);
        } else {
          logger.info(`Successfully set up database for org ${organization.id}`);
        }

        logger.info(`Successfully updated subscription for org ${organization.id} to tier ${tierId}`);

        // Return the client secret for frontend payment completion
        return {
          success: true,
          message: 'Subscription updated successfully',
          clientSecret: stripeResult.clientSecret,
          publishableKey: config.stripe.publishableKey
        };
        
      } catch (stripeError) {
        logger.error(`Stripe subscription error: ${stripeError}`);
        set.status = 400;
        return {
          success: false,
          error: 'Failed to process subscription payment'
        };
      }

    } catch (e) {
      logger.error(`Error updating subscription: ${e}`)
      set.status = 500
      return {
        success: false,
        error: String(e)
      }
    }
  })
  // Add new endpoint to create Turso database after plan selection
  .post('/organizations/:orgSlug/setup-database', async ({ params, set }) => {
    const db = new Database();
    const turso = new TursoService();

    try {
      const orgSlug = params.orgSlug;

      // Get organization ID from slug
      const orgResult = await db.query<{ id: number, has_db: number }>(
        'SELECT id, CASE WHEN turso_db_url IS NOT NULL THEN 1 ELSE 0 END as has_db FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        return {
          success: false,
          message: 'Organization not found'
        };
      }

      const orgId = orgResult[0].id;

      if (orgResult[0].has_db === 1) {
        set.status = 400;
        return {
          success: false,
          message: 'Organization already has a database'
        };
      }

      // Create Turso database for the organization
      const { url, token } = await turso.createOrganizationDatabase(orgId.toString());

      // Update organization with Turso database credentials
      await db.execute(
        'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ? WHERE id = ?',
        [url, token, orgId]
      );

      logger.info(`Successfully created Turso database for organization ${orgId}`);

      return {
        success: true,
        message: 'Database created successfully'
      };

    } catch (error) {
      logger.error(`Error creating database for organization ${params.orgSlug}: ${error}`);
      set.status = 500;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return {
        success: false,
        message: `Failed to create database: ${errorMessage}`
      };
    }
  })
  // Stripe webhook handler
  .post('/stripe-webhook', async ({ body, set, request }) => {
    try {
      const signature = request.headers.get('stripe-signature');
      
      if (!signature) {
        set.status = 400;
        return { success: false, error: 'Stripe signature missing' };
      }
      
      // Import Stripe to verify the webhook
      const Stripe = await import('stripe');
      const stripe = new Stripe.default(config.stripe.secretKey, {
        apiVersion: '2023-10-16',
      });
      
      const event = stripe.webhooks.constructEvent(
        JSON.stringify(body),
        signature,
        config.stripe.webhookSecret
      );
      
      // Import the Stripe service to handle the webhook
      const { handleStripeWebhook } = await import('../services/stripe');
      await handleStripeWebhook(event);
      
      logger.info(`Processed Stripe webhook: ${event.type}`);
      return { success: true };
      
    } catch (error) {
      logger.error(`Error processing Stripe webhook: ${error}`);
      set.status = 400;
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  });

================
File: src/routes/quotes.ts
================
import { Elysia } from 'elysia';
import axios from 'axios';
import { config } from '../config';
import { logger } from '../logger';
import { Database } from '../database';
import { generateQuoteId, decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';

interface Quote {
    age: number;
    gender: string;
    plan: string;
    tobacco: number;
    rate: number;
    discount_rate: number;
    discount_category: string;
}

interface QuoteResponse {
    naic: string;
    group: number;
    company_name: string;
    quotes: Quote[];
}

interface QuoteRequestBody {
    zip_code: string;
    state: string;
    age: string | number;
    tobacco: string | boolean;
    gender: string;
    county?: string;
}

interface QuoteRequest {
    zip_code: string;
    state: string;
    age: number;
    tobacco: boolean;
    gender: string;
    plans: string[];
    carriers: string;
    county?: string;
}

interface ContactQuoteInfo {
    zip_code: string;
    birth_date: string;
    tobacco_user: number;
    gender: string;
    email: string;
    first_name: string;
    last_name: string;
    current_carrier: string;
}

// Add new interface for org info response
interface OrgRedirectInfo {
    redirect_url: string | null;
    agent_name: string;
}

export const quotesRoutes = (app: Elysia) => {
    app
    .get('/api/quotes/generate/:contactId', async ({ params, request }) => {
        try {
            const user = await getUserFromSession(request);
            if (!user?.organization_id) {
                throw new Error('No organization ID found in session');
            }

            const contactId = parseInt(params.contactId);
            if (isNaN(contactId)) {
                throw new Error('Invalid contact ID');
            }

            // Get org-specific database
            const orgDb = await Database.getOrgDb(user.organization_id.toString());
            
            // Verify contact exists and belongs to this org
            const contact = await orgDb.fetchOne(
                'SELECT id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                throw new Error('Contact not found');
            }

            // Generate quote ID
            const quoteId = generateQuoteId(user.organization_id, contactId);

            return {
                success: true,
                quoteId,
                redirectUrl: `${process.env.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`
            };
        } catch (e) {
            logger.error(`Error generating quote ID: ${e}`);
            throw new Error(String(e));
        }
    })
    .get('/api/quotes/decode/:quoteId', async ({ params }) => {
        try {
            const decoded = decodeQuoteId(params.quoteId);
            if (!decoded) {
                throw new Error('Invalid quote ID');
            }

            // Get org-specific database
            const orgDb = await Database.getOrgDb(decoded.orgId.toString());
            
            // Fetch contact details
            const contact = await orgDb.fetchOne<ContactQuoteInfo>(
                'SELECT zip_code, birth_date, tobacco_user, gender, email, first_name, last_name, current_carrier FROM contacts WHERE id = ?',
                [decoded.contactId]
            );

            if (!contact) {
                throw new Error('Contact not found');
            }

            return {
                success: true,
                contact: {
                    zipCode: contact.zip_code,
                    dateOfBirth: contact.birth_date,
                    tobacco: Boolean(contact.tobacco_user),
                    gender: contact.gender,
                    email: contact.email,
                    firstName: contact.first_name,
                    lastName: contact.last_name,
                    currentCarrier: contact.current_carrier
                }
            };
        } catch (e) {
            logger.error(`Error decoding quote ID: ${e}`);
            throw new Error(String(e));
        }
    })
    .post('/api/quotes', async ({ body }: { body: QuoteRequestBody }) => {
        try {
            // Format request body
            const requestBody: QuoteRequest = {
                zip_code: body.zip_code,
                state: body.state,
                age: Number(body.age),
                tobacco: body.tobacco === 'true' || body.tobacco === true,
                gender: body.gender,
                plans: ['G', 'N'],
                carriers: 'supported',
                county: body.county
            };

            // Log incoming request details
            logger.info(`Incoming quote request body: ${JSON.stringify(requestBody, null, 2)}`);
            
            // Construct request config
            const quoteEngineUrl = 'https://quote-engine.replit.app/quotes/';
            const requestConfig = {
                url: quoteEngineUrl,
                method: 'POST' as const,
                headers: {
                    'X-API-Key': config.quoteApiKey,
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                data: requestBody
            };

            // Log complete request details
            logger.info(`Full request details: ${JSON.stringify({
                url: requestConfig.url,
                method: requestConfig.method,
                headers: requestConfig.headers,
                data: requestConfig.data
            }, null, 2)}`);
            
            const response = await axios.request<QuoteResponse[]>(requestConfig);
            
            // Log response summary without full data
            const quotes = response.data;
            const planTypes = new Set(quotes.flatMap(q => q.quotes.map(quote => quote.plan)));
            logger.info(`Quote response summary: ${JSON.stringify({
                total_quotes: quotes.length,
                plan_types: Array.from(planTypes),
                carriers: quotes.map(q => q.company_name)
            }, null, 2)}`);
            
            return response.data;
        } catch (error) {
            console.error('Error fetching quotes:', error);
            const message = error instanceof Error ? error.message : 'Unknown error';
            throw new Error(`Failed to fetch quotes: ${message}`);
        }
    })
    .get('/api/contact-request/org-info/:orgId', async ({ params }) => {
        try {
            const db = new Database();
            
            // Get organization info including redirect URL
            const orgResult = await db.fetchOne<{ redirect_url: string | null }>(
                'SELECT redirect_url FROM organizations WHERE id = ?',
                [params.orgId]
            );

            if (!orgResult) {
                throw new Error('Organization not found');
            }

            // Get org-specific database
            const orgDb = await Database.getOrgDb(params.orgId);

            // Try to get default agent (first admin or agent)
            const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                `SELECT first_name, last_name 
                FROM users 
                WHERE (is_admin = 1 OR is_agent = 1) 
                AND is_active = 1 
                ORDER BY is_admin DESC, id ASC 
                LIMIT 1`
            );

            if (!defaultAgent) {
                throw new Error('No active agents or admins found');
            }

            return {
                success: true,
                redirect_url: orgResult.redirect_url,
                agent_name: `${defaultAgent.first_name} ${defaultAgent.last_name}`
            };
        } catch (e) {
            logger.error(`Error getting org redirect info: ${e}`);
            throw new Error(String(e));
        }
    })
    .post('/api/contact-request', async ({ body }) => {
        try {
            const { name, email, type, quoteId } = body as { 
                name: string;
                email: string;
                type: 'accept' | 'decline' | 'generic';
                quoteId?: string;
            };

            // Get contact info from quoteId if available
            let orgId: number | undefined;
            let contactId: number | undefined;
            let agentName: string | undefined;

            if (!quoteId) {
                throw new Error('Quote ID is required');
            }

            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                throw new Error('Invalid quote ID');
            }

            orgId = decoded.orgId;
            contactId = decoded.contactId;

            // Get org-specific database
            const orgDb = await Database.getOrgDb(orgId.toString());

            // If we have a contact ID, try to get the assigned agent's name
            if (contactId) {
                const contact = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT u.first_name, u.last_name 
                    FROM contacts c
                    JOIN users u ON c.agent_id = u.id
                    WHERE c.id = ? AND u.is_active = 1`,
                    [contactId]
                );
                if (contact) {
                    agentName = `${contact.first_name} ${contact.last_name}`;
                }
            }

            // If no agent assigned to contact, get default agent
            if (!agentName) {
                const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT first_name, last_name 
                    FROM users 
                    WHERE (is_admin = 1 OR is_agent = 1) 
                    AND is_active = 1 
                    ORDER BY is_admin DESC, id ASC 
                    LIMIT 1`
                );
                if (defaultAgent) {
                    agentName = `${defaultAgent.first_name} ${defaultAgent.last_name}`;
                }
            }

            // Store request in org-specific database
            await orgDb.execute(
                `INSERT INTO contact_requests (
                    name, email, request_type, contact_id, status, agent_name, created_at
                ) VALUES (?, ?, ?, ?, 'new', ?, CURRENT_TIMESTAMP)`,
                [name, email, type, contactId || null, agentName || null]
            );

            // Get org redirect URL from central database
            const db = new Database();
            const orgResult = await db.fetchOne<{ redirect_url: string | null }>(
                'SELECT redirect_url FROM organizations WHERE id = ?',
                [orgId]
            );

            return { 
                success: true,
                redirect: orgResult?.redirect_url ? { redirect_url: orgResult.redirect_url } : null
            };
        } catch (e) {
            logger.error(`Error saving contact request: ${e}`);
            throw new Error(String(e));
        }
    });

    return app;
};

================
File: src/routes/settings.ts
================
import { Elysia } from 'elysia';
import { validateSession } from '../services/auth';
import { Database } from '../database';
import { type User } from '../types';
import { logger } from '../logger';
import { type Cookie } from '@elysiajs/cookie';
import { type BaseSettings } from '../types';

interface StateCarrierSetting {
  state: string;
  carrier: string;
  active: boolean;
  targetGI: boolean;
}

interface SettingsBody {
    settings?: BaseSettings;
    inheritOrgSettings?: boolean;
}

interface AgentSettingsResponse {
  orgSettings: BaseSettings;
  agentSettings: {
    inheritOrgSettings: boolean;
    settings: BaseSettings;
  } | null;
  canEditOrgSettings: boolean;
}

const defaultSettings: BaseSettings = {
  stateLicenses: [],
  carrierContracts: [],
  stateCarrierSettings: [],
  allowAgentSettings: true,
  emailSendBirthday: true,
  emailSendPolicyAnniversary: true,
  emailSendAep: true,
  smartSendEnabled: false
};

// Helper function to generate default state/carrier settings
function generateDefaultStateCarrierSettings(states: string[], carriers: string[]): StateCarrierSetting[] {
  return states.flatMap(state => 
    carriers.map(carrier => ({
      state,
      carrier,
      active: true,  // Default to active
      targetGI: false  // Default to no GI
    }))
  );
}

export const settingsRoutes = new Elysia()
  .get('/api/settings', async ({ cookie }) => {
    logger.info('GET /api/settings - Starting');
    
    const user = await validateSession(cookie.session);
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization settings
        const orgSettingsRow = await db.fetchOne<{ org_settings: string | null }>(
            'SELECT org_settings FROM organizations WHERE id = ?',
            [user.organization_id]
        );
        
        logger.info(`Retrieved org settings row`);

        // Parse the JSON string into an object
        let orgSettings: BaseSettings;
        try {
            orgSettings = orgSettingsRow?.org_settings 
                ? { ...defaultSettings, ...JSON.parse(orgSettingsRow.org_settings) }
                : { ...defaultSettings };

            // If we have states and carriers but no settings array, generate them
            if (orgSettings.stateLicenses.length > 0 && 
                orgSettings.carrierContracts.length > 0 && 
                !Array.isArray(orgSettings.stateCarrierSettings)) {
                
                logger.info('Generating default state/carrier settings');
                orgSettings.stateCarrierSettings = generateDefaultStateCarrierSettings(
                    orgSettings.stateLicenses,
                    orgSettings.carrierContracts
                );
            }
        } catch (parseError) {
            logger.error(`Error parsing org settings: ${parseError}`);
            orgSettings = { ...defaultSettings };
        }

        // Get agent settings if they exist
        const agentSettingsRow = await db.fetchOne<{ inherit_org_settings: boolean, settings: string | null }>(
            'SELECT inherit_org_settings, settings FROM agent_settings WHERE agent_id = ?',
            [user.id]
        );

        // Parse agent settings
        let agentSettings = null;
        if (agentSettingsRow) {
            try {
                const parsedSettings = agentSettingsRow.settings 
                    ? { ...defaultSettings, ...JSON.parse(agentSettingsRow.settings) }
                    : { ...defaultSettings };

                agentSettings = {
                    inheritOrgSettings: agentSettingsRow.inherit_org_settings,
                    settings: parsedSettings
                };
            } catch (parseError) {
                logger.error(`Error parsing agent settings: ${parseError}`);
            }
        }

        const canEditOrgSettings = user.is_admin;

        const response = {
            success: true,
            orgSettings,  // Now it's already an object, not a string
            agentSettings,
            canEditOrgSettings
        };

        logger.info(`Sending response`);
        return response;

    } catch (error) {
        logger.error(`Error fetching settings: ${error}`);
        return {
            success: false,
            error: 'Failed to load settings'
        };
    }
  })

  .put('/api/settings/:scope', async ({ cookie, body, params }) => {
    const { scope } = params;
    logger.info(`PUT /api/settings/${scope} - Starting`);
    
    const user = await validateSession(cookie?.session?.toString() || '');
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization's subscription tier
        const orgRow = await db.fetchOne<{ subscription_tier: string }>(
            'SELECT subscription_tier FROM organizations WHERE id = ?',
            [user.organization_id]
        );

        const isBasicTier = orgRow?.subscription_tier === 'basic';
        const typedBody = body as SettingsBody;

        if (scope === 'org') {
            logger.info('Updating organization settings');
            
            // Update organization settings
            await db.execute(
                'UPDATE organizations SET org_settings = ? WHERE id = ?',
                [JSON.stringify(typedBody), user.organization_id]
            );

            // For basic tier, also update the admin agent's settings
            if (isBasicTier) {
                logger.info('Basic tier detected - syncing settings to admin agent');
                
                // Get the admin agent's ID
                const adminAgentRow = await db.fetchOne<{ id: number }>(
                    'SELECT id FROM users WHERE organization_id = ? AND is_admin = 1 AND is_agent = 1 LIMIT 1',
                    [user.organization_id]
                );

                if (adminAgentRow) {
                    // Update agent settings with organization settings and set inherit_org_settings to true
                    await db.execute(
                        `INSERT INTO agent_settings (agent_id, inherit_org_settings, settings)
                         VALUES (?, true, ?)
                         ON CONFLICT (agent_id) DO UPDATE
                         SET inherit_org_settings = true, settings = ?`,
                        [adminAgentRow.id, JSON.stringify(typedBody), JSON.stringify(typedBody)]
                    );
                    logger.info('Successfully synced settings to admin agent');
                }
            }
        } else if (scope === 'agent') {
            // For basic tier, don't allow direct agent settings updates
            if (isBasicTier) {
                return {
                    success: false,
                    error: 'Agent settings cannot be modified directly in basic tier - update organization settings instead'
                };
            }

            logger.info('Updating agent settings');
            logger.info(`Agent settings body: ${JSON.stringify(typedBody, null, 2)}`);

            try {
                await db.execute(
                    `INSERT INTO agent_settings (agent_id, inherit_org_settings, settings)
                     VALUES (?, ?, ?)
                     ON CONFLICT (agent_id) DO UPDATE
                     SET inherit_org_settings = ?, settings = ?`,
                    [
                        user.id,
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings),
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings)
                    ]
                );
                logger.info('Agent settings updated successfully');
            } catch (dbError) {
                logger.error(`Database execute error details: ${JSON.stringify(dbError, null, 2)}`);
                throw dbError;
            }
        }

        return {
            success: true,
            settings: typedBody.settings || typedBody
        };
    } catch (error) {
        logger.error(`Error updating settings: ${error}`);
        logger.error(`Error stack: ${(error as Error).stack}`);
        return {
            success: false,
            error: 'Failed to update settings'
        };
    }
  })

  // Update the GI recommendations endpoint to use Elysia style
  .get('/api/settings/gi-recommendations', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const recommendations = await db.fetchAll<{ state: string; carrier: string }>(
        `SELECT state, carrier
         FROM guaranteed_issue_recommendations
         ORDER BY carrier, state`
      );

      // Transform the results to match the expected format
      const formattedRecommendations = recommendations.map(rec => ({
        state: rec.state,
        carrier: rec.carrier,
        active: true,
        targetGI: true
      }));

      return formattedRecommendations;

    } catch (error) {
      logger.error('Error fetching GI recommendations:', error);
      return { success: false, error: 'Failed to fetch GI recommendations' };
    }
  })

  // Update carriers endpoint to use Elysia style
  .get('/api/settings/carriers', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll<{ name: string }>(
        `SELECT name
         FROM carriers
         ORDER BY name`
      );

      return carriers;

    } catch (error) {
      logger.error('Error fetching carriers:', error);
      return { success: false, error: 'Failed to fetch carriers' };
    }
  })

  .get('/api/settings/carriers-with-aliases', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll<{ name: string, aliases: string | null }>(
        `SELECT name, aliases
         FROM carriers
         ORDER BY name`
      );

      return carriers.map(carrier => ({
        name: carrier.name,
        aliases: carrier.aliases ? JSON.parse(carrier.aliases) : []
      }));

    } catch (error) {
      logger.error('Error fetching carriers with aliases:', error);
      return { success: false, error: 'Failed to fetch carriers with aliases' };
    }
  });

================
File: src/services/agentSettings.ts
================
import { db } from '../database';
import { NotFoundError } from '../errors';
import { logger } from '../logger';

export interface StateCarrierSetting {
  active: boolean;
  targetGI: boolean;
}

export interface AgentSettings {
  id: number;
  agentId: number;
  stateLicenses: string[];
  carrierContracts: string[];
  stateCarrierSettings: {
    [state: string]: {
      [carrier: string]: StateCarrierSetting;
    };
  };
  emailSendBirthday: boolean;
  emailSendPolicyAnniversary: boolean;
  emailSendAep: boolean;
  smartSendEnabled: boolean;
}

export async function getAgentSettings(agentId: number): Promise<AgentSettings> {
  try {
    const result = await db.oneOrNone(
      'SELECT * FROM agent_settings WHERE agent_id = $1',
      [agentId]
    )

    if (!result) {
      // Return default settings instead of creating them
      return {
        id: 0,
        agentId: agentId,
        stateLicenses: [],
        carrierContracts: [],
        stateCarrierSettings: {},
        emailSendBirthday: false,
        emailSendPolicyAnniversary: false,
        emailSendAep: false,
        smartSendEnabled: false
      }
    }

    return {
      id: result.id,
      agentId: result.agent_id,
      stateLicenses: result.state_licenses || [],
      carrierContracts: result.carrier_contracts || [],
      stateCarrierSettings: result.state_carrier_settings || {},
      emailSendBirthday: result.email_send_birthday || false,
      emailSendPolicyAnniversary: result.email_send_policy_anniversary || false,
      emailSendAep: result.email_send_aep || false,
      smartSendEnabled: result.smart_send_enabled || false,
    }
  } catch (error) {
    logger.error(`Error fetching agent settings: ${error}`)
    // Return default settings on error
    return {
      id: 0,
      agentId: agentId,
      stateLicenses: [],
      carrierContracts: [],
      stateCarrierSettings: {},
      emailSendBirthday: false,
      emailSendPolicyAnniversary: false,
      emailSendAep: false,
      smartSendEnabled: false
    }
  }
}

async function createDefaultSettings(agentId: number): Promise<AgentSettings> {
  const result = await db.one(
    `INSERT INTO agent_settings 
     (agent_id, state_licenses, carrier_contracts, state_carrier_settings)
     VALUES ($1, $2, $3, $4)
     RETURNING *`,
    [agentId, [], [], {}]
  );

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

export async function updateAgentSettings(
  agentId: number,
  settings: Partial<AgentSettings>
): Promise<AgentSettings> {
  const result = await db.oneOrNone(
    `UPDATE agent_settings
     SET state_licenses = COALESCE($1, state_licenses),
         carrier_contracts = COALESCE($2, carrier_contracts),
         state_carrier_settings = COALESCE($3, state_carrier_settings),
         email_send_birthday = COALESCE($4, email_send_birthday),
         email_send_policy_anniversary = COALESCE($5, email_send_policy_anniversary),
         email_send_aep = COALESCE($6, email_send_aep),
         smart_send_enabled = COALESCE($7, smart_send_enabled)
     WHERE agent_id = $8
     RETURNING *`,
    [
      settings.stateLicenses,
      settings.carrierContracts,
      settings.stateCarrierSettings,
      settings.emailSendBirthday,
      settings.emailSendPolicyAnniversary,
      settings.emailSendAep,
      settings.smartSendEnabled,
      agentId,
    ]
  );

  if (!result) {
    throw new NotFoundError('Agent settings not found');
  }

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

================
File: src/services/auth.ts
================
import crypto from 'crypto';
import { logger } from '../logger';
import { db } from '../database';
import { Database } from '../database';
import type { User } from '../types';
import { config } from '../config';

const algorithm = "aes-256-gcm";
const IV_LENGTH = 12;
const UTF8 = "utf8";
const HEX = "hex";

// Initialize encryption key
let secret = process.env.MAGIC_LINK_SECRET;
if (!secret) {
  if (process.env.NODE_ENV === "production") {
    throw new Error("Must set MAGIC_LINK_SECRET in production");
  }
  secret = "dev-secret-key";
}

const ENCRYPTION_KEY = crypto.scryptSync(secret, "salt", 32);

interface MagicLinkPayload {
  email: string;
  organizationSlug: string;
  expiresAt: number;
  redirectUrl: string;
  orgId?: number;
  name?: string;
}

export class AuthService {
  constructor(private baseUrl?: string) {
    // If no baseUrl is provided, get it from config
    if (!baseUrl) {
      this.baseUrl = config.PUBLIC_URL;
    } else {
      // Ensure baseUrl doesn't end with a slash
      this.baseUrl = baseUrl.replace(/\/$/, '');
    }
    
    logger.info(`AuthService initialized with baseUrl: ${this.baseUrl}`);
  }

  async createMagicLink(
    email: string, 
    organizationSlug: string, 
    options?: { 
      redirectUrl?: string;
      orgId?: number;
      name?: string;
    }
  ): Promise<string> {
    const payload: MagicLinkPayload = {
      email,
      organizationSlug,
      expiresAt: Date.now() + (30 * 60 * 1000), // 30 minutes
      redirectUrl: options?.redirectUrl || '/dashboard',
      ...(options?.orgId && { orgId: options.orgId }),
      ...(options?.name && { name: options.name })
    };

    logger.info(`Creating magic link with payload: ${JSON.stringify(payload)}`);
    const token = this.encrypt(JSON.stringify(payload));
    // URL encode the entire token
    const encodedToken = encodeURIComponent(token);
    logger.info(`Generated magic link token: ${token}`);
    return `${this.baseUrl}/auth/verify/${organizationSlug}/${encodedToken}`;
  }

  async verifyMagicLink(token: string, organizationSlug: string): Promise<{
    valid: boolean;
    email?: string;
    redirectUrl?: string;
  }> {
    try {
      logger.info('Starting magic link verification');
      logger.info(`Organization slug: ${organizationSlug}`);

      const decodedToken = decodeURIComponent(token);
      const decrypted = this.decrypt(decodedToken);
      const payload: MagicLinkPayload = JSON.parse(decrypted);

      // Verify organization and expiration
      if (payload.organizationSlug !== organizationSlug) {
        logger.error(`Organization slug mismatch: ${payload.organizationSlug} !== ${organizationSlug}`);
        return { valid: false };
      }

      if (payload.expiresAt < Date.now()) {
        logger.error(`Token expired: ${new Date(payload.expiresAt)} < ${new Date()}`);
        return { valid: false };
      }

      // No need to check agent status here since we only send links to valid agents

      logger.info('Verification successful, returning payload');
      return {
        valid: true,
        email: payload.email,
        redirectUrl: payload.redirectUrl
      };

    } catch (error) {
      logger.error(`Magic link verification failed: ${error}`);
      return { valid: false };
    }
  }

  private encrypt(text: string): string {
    try {
      const iv = crypto.randomBytes(IV_LENGTH);
      const cipher = crypto.createCipheriv(algorithm, ENCRYPTION_KEY, iv);
      let encrypted = cipher.update(text, UTF8, HEX);
      encrypted += cipher.final(HEX);
      const authTag = cipher.getAuthTag();
      
      const token = `${iv.toString(HEX)}:${authTag.toString(HEX)}:${encrypted}`;
      return token;
    } catch (error) {
      logger.error(`Encryption failed: ${error}`);
      throw error;
    }
  }

  private decrypt(text: string): string {
    try {
      const [ivPart, authTagPart, encryptedText] = text.split(":");
      if (!ivPart || !authTagPart || !encryptedText) {
        throw new Error("Invalid token format - missing parts");
      }

      logger.info('Decrypting token parts:');
      logger.info(`IV length: ${ivPart.length}`);
      logger.info(`Auth tag length: ${authTagPart.length}`);
      logger.info(`Encrypted text length: ${encryptedText.length}`);

      const iv = Buffer.from(ivPart, HEX);
      const authTag = Buffer.from(authTagPart, HEX);
      const decipher = crypto.createDecipheriv(algorithm, ENCRYPTION_KEY, iv);
      decipher.setAuthTag(authTag);
      let decrypted = decipher.update(encryptedText, HEX, UTF8);
      decrypted += decipher.final(UTF8);
      return decrypted;
    } catch (error) {
      logger.error(`Decryption failed: ${error}`);
      throw error;
    }
  }
}

export async function validateSession(sessionId: string): Promise<User | null> {
  logger.info(`Validating session: ${sessionId}`);
  
  const db = new Database();

  // Get the session
  const session = await db.fetchOne<{
    id: string;
    user_id: number;
    expires_at: string;
  }>('SELECT * FROM sessions WHERE id = ?', [sessionId]);

  logger.info(`Session lookup result: ${session ? JSON.stringify(session) : 'not found'}`);

  if (!session) {
    logger.warn('No session found in database');
    return null;
  }

  // Check if session is expired
  const expiresAt = new Date(session.expires_at);
  const now = new Date();
  logger.info(`Session expires: ${expiresAt}, current time: ${now}`);

  if (expiresAt < now) {
    logger.warn('Session is expired');
    await db.execute('DELETE FROM sessions WHERE id = ?', [sessionId]);
    return null;
  }

  // Get the user associated with this session with updated columns
  const user = await db.fetchOne<User>(
    `SELECT 
      u.id,
      u.email,
      u.organization_id,
      u.is_admin,
      u.is_agent,
      u.first_name,
      u.last_name,
      u.is_active,
      u.phone,
      o.name as organization_name 
     FROM users u
     JOIN organizations o ON u.organization_id = o.id 
     WHERE u.id = ?`,
    [session.user_id]
  );

  logger.info(`User lookup result: ${user ? JSON.stringify(user) : 'not found'}`);

  return user;
}

export function generateToken(): string {
  return crypto.randomBytes(32).toString('hex');
}

export async function getUserFromSession(request: Request) {
  try {
    // Get session cookie
    const sessionId = request.headers.get('cookie')?.split('session=')[1]?.split(';')[0];
    
    if (!sessionId) {
      logger.warn('No session cookie found');
      return null;
    }

    // Initialize database
    const db = new Database();

    // Get session data
    const sessionResult = await db.fetchAll(
      'SELECT user_id FROM sessions WHERE id = ?',
      [sessionId]
    );

    if (!sessionResult || sessionResult.length === 0) {
      logger.warn(`No session found for ID: ${sessionId}`);
      return null;
    }

    const userId = sessionResult[0][0];

    // Updated query to use is_admin and is_agent
    const userResult = await db.fetchAll(
      `SELECT 
        u.id,
        u.email,
        u.organization_id,
        u.is_admin,
        u.is_agent,
        u.first_name,
        u.last_name,
        u.is_active,
        u.phone,
        o.name as organization_name
       FROM users u
       JOIN organizations o ON u.organization_id = o.id 
       WHERE u.id = ?`,
      [userId]
    );

    if (!userResult || userResult.length === 0) {
      logger.warn('No user found for session');
      return null;
    }

    const user = {
      id: userResult[0][0],
      email: userResult[0][1],
      organization_id: userResult[0][2],
      is_admin: Boolean(userResult[0][3]),
      is_agent: Boolean(userResult[0][4]),
      first_name: userResult[0][5],
      last_name: userResult[0][6],
      is_active: userResult[0][7],
      phone: userResult[0][8],
      organization_name: userResult[0][9]
    };

    return user;

  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

================
File: src/services/email.ts
================
import sgMail from '@sendgrid/mail';
import { logger } from '../logger';


interface MagicLinkEmailParams {
  email: string;
  token: string;
  orgId: number;
  name: string;
}

export class EmailService {
  constructor() {
    if (!process.env.SENDGRID_API_KEY) {
      throw new Error('Missing SENDGRID_API_KEY environment variable');
    }
    sgMail.setApiKey(process.env.SENDGRID_API_KEY);
  }

  async sendMagicLink(email: string, magicLink: string, organizationSlug: string) {
    try {
      const msg = {
        to: email,
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: 'Your Login Link',
        text: `Click this link to log in: ${magicLink}\n\nThis link will expire in 30 minutes.`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">Welcome to MedicareMax</h2>
            <p>Click the button below to log in to your account. This link will expire in 30 minutes.</p>
            <div style="margin: 30px 0;">
              <a href="${magicLink}" 
                 style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                        text-decoration: none; border-radius: 4px; display: inline-block;">
                Log In
              </a>
            </div>
            <p style="color: #666; font-size: 14px;">
              If the button doesn't work, copy and paste this link into your browser:
              <br>
              <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
            </p>
          </div>
        `
      };

      await sgMail.send(msg);
      logger.info(`Magic link email sent successfully to ${email}`);
    } catch (error) {
      logger.error(`Error sending magic link email: ${error}`);
      throw new Error('Failed to send magic link email');
    }
  }
}

// For the organization signup flow
export async function sendMagicLink({ email, magicLink, name }: {
  email: string;
  magicLink: string;
  name: string;
}) {
  try {
    const msg = {
      to: email,
      from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
      subject: 'Verify Your MedicareMax Account',
      text: `Hi ${name},\n\nClick this link to verify your account: ${magicLink}\n\nThis link will expire in 30 minutes.`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Welcome to MedicareMax</h2>
          <p>Hi ${name},</p>
          <p>Click the button below to verify your account and complete your organization setup. This link will expire in 30 minutes.</p>
          <div style="margin: 30px 0;">
            <a href="${magicLink}" 
               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 4px; display: inline-block;">
              Verify Account
            </a>
          </div>
          <p style="color: #666; font-size: 14px;">
            If the button doesn't work, copy and paste this link into your browser:
            <br>
            <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
          </p>
        </div>
      `
    };

    await sgMail.send(msg);
    logger.info('Magic link email sent successfully');
  } catch (error) {
    logger.error(`Failed to send magic link email: ${error}`);
    throw error;
  }
}

================
File: src/services/stripe.ts
================
import Stripe from 'stripe';
import { config } from '../config';
import { logger } from '../logger';

// Initialize Stripe with the secret key from environment variables
const stripe = new Stripe(config.stripe.secretKey, {
  apiVersion: '2023-10-16',
});

export type PlanTier = 'basic' | 'pro' | 'enterprise';

// Map subscription tier IDs to Stripe price IDs
const PRICE_MAP: Record<PlanTier, string> = {
  basic: config.stripe.prices.basic,
  pro: config.stripe.prices.pro,
  enterprise: config.stripe.prices.enterprise,
};

// Extra resource price IDs
const EXTRA_AGENT_PRICE = config.stripe.prices.extraAgent;
const EXTRA_CONTACT_PRICE = config.stripe.prices.extraContact;

interface CreateSubscriptionOptions {
  tierId: PlanTier;
  organizationId: number;
  email: string;
  extraAgents: number;
  extraContacts: number;
  stripeCustomerId?: string;
}

export interface SubscriptionResult {
  customerId: string;
  subscriptionId: string;
  clientSecret?: string;
}

/**
 * Creates or updates a Stripe subscription for an organization
 */
export async function createOrUpdateSubscription({
  tierId,
  organizationId,
  email,
  extraAgents,
  extraContacts,
  stripeCustomerId,
}: CreateSubscriptionOptions): Promise<SubscriptionResult> {
  try {
    // Get or create a customer
    let customerId = stripeCustomerId;
    
    if (!customerId) {
      const customer = await stripe.customers.create({
        email,
        metadata: {
          organizationId: organizationId.toString(),
        },
      });
      customerId = customer.id;
      logger.info(`Created Stripe customer for organization ${organizationId}: ${customerId}`);
    }

    // Create subscription line items
    const items = [
      {
        price: PRICE_MAP[tierId],
        quantity: 1,
      },
    ];

    // Add extra agents if needed
    if (extraAgents > 0 && EXTRA_AGENT_PRICE) {
      items.push({
        price: EXTRA_AGENT_PRICE,
        quantity: extraAgents,
      });
    }

    // Add extra contacts (subscription is based on 100s of contacts)
    if (extraContacts > 0 && EXTRA_CONTACT_PRICE) {
      items.push({
        price: EXTRA_CONTACT_PRICE,
        // Calculate how many 100s of contacts
        quantity: Math.ceil(extraContacts / 100),
      });
    }

    // Create the subscription
    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items,
      payment_behavior: 'default_incomplete',
      payment_settings: {
        save_default_payment_method: 'on_subscription',
        payment_method_types: ['card'],
      },
      expand: ['latest_invoice.payment_intent'],
      metadata: {
        organizationId: organizationId.toString(),
        tierId,
        extraAgents: extraAgents.toString(),
        extraContacts: extraContacts.toString(),
      },
    });

    // Get the client secret from the subscription
    const invoice = subscription.latest_invoice as Stripe.Invoice;
    const paymentIntent = invoice.payment_intent as Stripe.PaymentIntent;
    const clientSecret = paymentIntent?.client_secret || undefined;

    logger.info(`Created Stripe subscription for organization ${organizationId}: ${subscription.id}`);

    return {
      customerId,
      subscriptionId: subscription.id,
      clientSecret,
    };
  } catch (error) {
    logger.error('Error creating Stripe subscription:', error);
    throw error;
  }
}

/**
 * Webhook handler for Stripe events
 */
export async function handleStripeWebhook(event: Stripe.Event): Promise<void> {
  logger.info(`Processing Stripe webhook: ${event.type}`);

  try {
    switch (event.type) {
      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription;
        // Handle subscription updates (e.g., when a payment succeeds)
        // You would typically update your database here
        logger.info(`Subscription updated: ${subscription.id}, status: ${subscription.status}`);
        break;
      }
      
      case 'invoice.payment_failed': {
        const invoice = event.data.object as Stripe.Invoice;
        // Handle failed payments
        logger.warn(`Payment failed for invoice: ${invoice.id}`);
        break;
      }
      
      // Add other event types as needed
    }
  } catch (error) {
    logger.error('Error handling Stripe webhook:', error);
    throw error;
  }
}

================
File: src/services/turso.ts
================
import { createClient } from '@libsql/client';
import { TURSO_CONFIG } from '../config/turso';

export class TursoService {
  private headers = {
    'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
    'Content-Type': 'application/json'
  };

  async createOrganizationDatabase(orgId: string): Promise<{url: string, token: string}> {
    const dbName = `org-${orgId}`;

    // Create database using Turso API
    const createDbResponse = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, 
      {
        method: 'POST',
        headers: this.headers,
        body: JSON.stringify({
          name: dbName,
          group: TURSO_CONFIG.GROUP_NAME
        })
      }
    );

    if (!createDbResponse.ok) {
      throw new Error(`Failed to create database: ${await createDbResponse.text()}`);
    }

    const dbData = await createDbResponse.json();
    
    // Generate auth token for the database
    const tokenResponse = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}/auth/tokens`,
      {
        method: 'POST',
        headers: this.headers
      }
    );

    if (!tokenResponse.ok) {
      throw new Error(`Failed to create auth token: ${await tokenResponse.text()}`);
    }

    const tokenData = await tokenResponse.json();

    // Initialize database client and create schema
    const client = createClient({
      url: `https://${dbData.database.Hostname}`,
      authToken: tokenData.jwt
    });

    // Execute SQL statements one at a time
    const statements = [
      `CREATE TABLE contacts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        first_name TEXT NOT NULL,
        last_name TEXT NOT NULL,
        email TEXT NOT NULL,
        current_carrier TEXT NOT NULL,
        plan_type TEXT NOT NULL,
        effective_date TEXT NOT NULL,
        birth_date TEXT NOT NULL,
        tobacco_user BOOLEAN NOT NULL,
        gender TEXT NOT NULL,
        state TEXT NOT NULL,
        zip_code TEXT NOT NULL,
        agent_id INTEGER,
        last_emailed TEXT,
        phone_number TEXT NOT NULL DEFAULT '',
        status TEXT NOT NULL DEFAULT '',
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
      )`,
      `CREATE TABLE leads (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'new',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        converted_contact_id INTEGER,
        FOREIGN KEY (converted_contact_id) REFERENCES contacts(id)
      )`,
      `CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email)`,
      `CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status)`,
      `CREATE TABLE contact_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        contact_id INTEGER,
        lead_id INTEGER,
        event_type TEXT NOT NULL,
        metadata TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (contact_id) REFERENCES contacts(id),
        FOREIGN KEY (lead_id) REFERENCES leads(id),
        CHECK ((contact_id IS NOT NULL AND lead_id IS NULL) OR (contact_id IS NULL AND lead_id IS NOT NULL))
      )`,
      `CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id)`,
      `CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id)`,
      `CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type)`,
      `CREATE TABLE contact_requests (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT NOT NULL,
        request_type TEXT NOT NULL CHECK(request_type IN ('accept', 'decline', 'generic')),
        contact_id INTEGER,
        status TEXT NOT NULL DEFAULT 'new',
        agent_name TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (contact_id) REFERENCES contacts(id)
      )`
    ];

    // Execute each statement
    for (const statement of statements) {
      await client.execute(statement);
    }

    return {
      url: `https://${dbData.database.Hostname}`,
      token: tokenData.jwt
    };
  }

  async deleteOrganizationDatabase(dbName: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}`,
      {
        method: 'DELETE',
        headers: this.headers
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete database: ${await response.text()}`);
    }
  }
}

================
File: src/utils/quoteId.ts
================
import { createHash } from 'crypto';

// Function to generate a unique quote ID from org ID and contact ID
export function generateQuoteId(orgId: number, contactId: number): string {
  // Create a string combining org ID and contact ID
  const data = `${orgId}-${contactId}-${process.env.QUOTE_ID_SECRET || 'default-secret'}`;
  
  // Generate a hash of the data
  const hash = createHash('sha256').update(data).digest('base64');
  
  // Take first 12 characters and make URL safe
  const urlSafeHash = hash
    .slice(0, 12)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
  
  // Encode org ID and contact ID in base36 for shorter strings
  const encodedOrgId = orgId.toString(36);
  const encodedContactId = contactId.toString(36);
  
  // Combine everything with a separator
  return `${encodedOrgId}-${encodedContactId}-${urlSafeHash}`;
}

// Function to decode a quote ID back to org ID and contact ID
export function decodeQuoteId(quoteId: string): { orgId: number; contactId: number } | null {
  try {
    // Split the quote ID into its components
    const [encodedOrgId, encodedContactId] = quoteId.split('-');
    
    // Decode the IDs from base36 back to numbers
    const orgId = parseInt(encodedOrgId, 36);
    const contactId = parseInt(encodedContactId, 36);
    
    if (isNaN(orgId) || isNaN(contactId)) {
      return null;
    }
    
    return { orgId, contactId };
  } catch (e) {
    return null;
  }
}

================
File: src/config.ts
================
import { config as dotenvConfig } from 'dotenv'
import { resolve } from 'path'
import { logger } from './logger'
import { existsSync } from 'fs'

// Get absolute path to .env file
const envPath = resolve(__dirname, '../.env')

// Check if .env file exists - but don't exit if using Replit Secrets
const envFileExists = existsSync(envPath)
if (!envFileExists) {
  console.log(`âš ï¸ .env file not found at: ${envPath}, will attempt to use Replit Secrets instead`)
} else {
  // Load .env file with override option only if it exists
  const result = dotenvConfig({ 
    path: envPath,
    override: true // This tells dotenv to override existing env vars
  })

  if (result.error) {
    console.warn('âš ï¸ Error loading .env file:', result.error)
  } else {
    console.log('ðŸ“ Loading .env from:', envPath)
  }
}

// Log environment variables (safely)
console.log('ðŸ“ Environment variables available:', {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL ? '[PRESENT]' : '[MISSING]',
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN ? '[PRESENT]' : '[MISSING]',
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH ? '[PRESENT]' : '[MISSING]'
})

export const config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  quoteApiKey: process.env.QUOTE_API_KEY,
  PUBLIC_URL: process.env.PUBLIC_URL || (process.env.NODE_ENV === 'development' 
    ? 'http://localhost:5173'
    : 'http://localhost:3000'),
  stripe: {
    secretKey: process.env.STRIPE_SECRET_KEY || '',
    publishableKey: process.env.STRIPE_PUBLISHABLE_KEY || '',
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET || '',
    prices: {
      basic: process.env.STRIPE_PRICE_BASIC || '',
      pro: process.env.STRIPE_PRICE_PRO || '',
      enterprise: process.env.STRIPE_PRICE_ENTERPRISE || '',
      extraAgent: process.env.STRIPE_PRICE_EXTRA_AGENT || '',
      extraContact: process.env.STRIPE_PRICE_EXTRA_CONTACT || '',
    }
  }
}

// Log loaded config (safely)
logger.info(`Config loaded ${envFileExists ? `from ${envPath}` : 'from environment'}`)

================
File: src/database.ts
================
import { createClient } from '@libsql/client'
import { config } from './config'
import { logger } from './logger'

export class Database {
  private client: any
  private url: string

  constructor(dbUrl?: string, authToken?: string) {
    const url = dbUrl || config.TURSO_DATABASE_URL
    const token = authToken || config.TURSO_AUTH_TOKEN

    if (!url || !token) {
      logger.error('Missing database credentials')
      throw new Error('Missing database credentials')
    }

    this.url = url
    this.client = createClient({
      url: url,
      authToken: token,
    })
    
    logger.info(`Database connected to: ${this.url}`)
  }

  static async getOrgDb(orgId: string): Promise<Database> {
    try {
      // Use main DB to get org's Turso credentials
      const mainDb = new Database()
      const org = await mainDb.fetchOne<{turso_db_url: string, turso_auth_token: string}>(
        'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
        [orgId]
      )

      if (!org?.turso_db_url || !org?.turso_auth_token) {
        logger.error(`No Turso credentials found for org ${orgId}`)
        throw new Error('Organization database not configured')
      }

      logger.info(`Creating client for org ${orgId} database: ${org.turso_db_url}`)
      return new Database(org.turso_db_url, org.turso_auth_token)
    } catch (error) {
      logger.error(`Failed to get org database: ${error}`)
      throw error
    }
  }

  getClient() {
    return this.client
  }

  async execute(sql: string, args: any[] = []) {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result
    } catch (error) {
      logger.error(`Database execute error: ${error}`)
      throw error
    }
  }

  async fetchAll(sql: string, args: any[] = []) {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result.rows || []
    } catch (error) {
      logger.error(`Database fetchAll error: ${error}`)
      throw error
    }
  }

  async fetchOne<T>(sql: string, args: any[] = []): Promise<T | null> {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      if (!result.rows || result.rows.length === 0) {
        return null
      }
      // Convert array row to object using column names
      const row = result.rows[0]
      const columns = result.columns || []
      const obj: any = {}
      columns.forEach((col: string, i: number) => {
        obj[col] = row[i]
      })
      return obj as T
    } catch (error) {
      logger.error(`Database fetchOne error: ${error}`)
      throw error
    }
  }

  // Compatibility method for old query interface
  async query<T = any>(sql: string, args: any[] = []): Promise<T[]> {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result.rows || []
    } catch (error) {
      logger.error(`Database query error: ${error}`)
      throw error
    }
  }

  // Transaction support with function overloads
  async transaction<T>(callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(mode: 'read' | 'write', callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(
    callbackOrMode: ((tx: Database) => Promise<T>) | 'read' | 'write',
    callback?: (tx: Database) => Promise<T>
  ): Promise<T> {
    let mode: 'read' | 'write' = 'write'
    let fn: ((tx: Database) => Promise<T>) | null = null

    if (typeof callbackOrMode === 'string') {
      mode = callbackOrMode
      fn = callback || null
    } else {
      fn = callbackOrMode
    }
    
    if (!fn) {
      throw new Error('Transaction callback is required')
    }

    const tx = await this.client.transaction(mode)
    try {
      // Create a Database-like wrapper around the transaction
      const txWrapper = new Database()
      // Override the client with the transaction
      txWrapper.client = tx
      
      const result = await fn(txWrapper)
      await tx.commit()
      return result
    } catch (error) {
      await tx.rollback()
      throw error
    }
  }
}

export const db = new Database()

================
File: src/errors.ts
================
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'NotFoundError'
  }
}

export class UnauthorizedError extends Error {
  constructor(message: string = 'Unauthorized') {
    super(message)
    this.name = 'UnauthorizedError'
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'ValidationError'
  }
}

export class DatabaseError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'DatabaseError'
  }
}

================
File: src/index.ts
================
import { Elysia, t } from 'elysia'
import { cors } from '@elysiajs/cors'
import { Database } from './database'
import { logger } from './logger'
import type { ContactCreate, AgentCreate } from './types'
import { readFileSync } from 'fs'
import { staticPlugin } from '@elysiajs/static'
import { parse as csvParse } from 'csv-parse/sync'
import { Readable } from 'stream'
import { Buffer } from 'buffer'
import { createAuthRoutes } from './routes/auth'
import { settingsRoutes } from './routes/settings'
import { organizationRoutes } from './routes/organizations'
import { createBrandRoutes } from './routes/brand'
import { quotesRoutes } from './routes/quotes'
import { errorHandler } from './middleware/error'
import { getUserFromSession } from './services/auth'
import { join } from 'path'
import { existsSync } from 'fs'

// At the top of the file, add interface for ZIP data
interface ZipInfo {
  state: string;
  // Add other ZIP info properties as needed
}

// Update ZIP_DATA declaration
let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'))
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}

// Add with the other type imports
type NewAgentRequest = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

type AgentUpdate = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

interface DbRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  phone: string | null;
  is_admin: number;
  is_agent: number;
  settings: string | null;
}

// Add at the top with other interfaces
interface ContactRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  current_carrier: string;
  plan_type: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: number;
  gender: string;
  state: string;
  zip_code: string;
  agent_id: number | null;
  last_emailed: string | null;
  phone_number: string;
}

interface CarrierRow {
  name: string;
  aliases: string | null;
}

// Add this helper function before startServer
function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
  const digits = phone.replace(/\D/g, '').slice(0, 10);
  return {
    isValid: digits.length === 10,
    standardized: digits
  };
}

// Add this helper function near the other validation functions
function validateEmail(email: string): boolean {
  // RFC 5322 compliant email regex
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  return emailRegex.test(email.trim());
}

// Add this helper function near the other validation functions
function validateISODate(dateStr: string): { isValid: boolean; isoDate: string | null } {
  try {
    const trimmed = dateStr.trim();
    
    // Try to parse the date - will throw if invalid
    const date = new Date(trimmed);
    
    // Check if date is invalid
    if (isNaN(date.getTime())) {
      return { isValid: false, isoDate: null };
    }
    
    // Convert to ISO format (YYYY-MM-DD)
    const isoDate = date.toISOString().split('T')[0];
    
    // Verify the date is not in the future
    if (date > new Date()) {
      return { isValid: false, isoDate: null };
    }
    
    return { isValid: true, isoDate };
  } catch (e) {
    return { isValid: false, isoDate: null };
  }
}

// Add this helper function near the other validation functions
async function validateCarrier(carrier: string, db: Database): Promise<{ isValid: boolean; standardizedName: string; wasConverted: boolean }> {
  try {
    // Trim and standardize input
    const trimmedCarrier = carrier.trim();
    logger.info(`Validating carrier: "${trimmedCarrier}"`);
    
    // Create a new instance of the central database
    const centralDb = new Database();
    
    // Get all carriers with their aliases from the central database
    const result = await centralDb.execute<CarrierRow>(
      'SELECT name, aliases FROM carriers'
    );
    
    logger.info(`Found ${result.rows.length} carriers in database`);
    
    // Check each carrier and its aliases
    for (const row of result.rows) {
      logger.info(`Checking against carrier: "${row.name}", aliases: ${row.aliases || '[]'}`);
      
      // Check exact name match (case insensitive)
      if (row.name.toLowerCase() === trimmedCarrier.toLowerCase()) {
        logger.info(`Found exact match with carrier: ${row.name}`);
        return { isValid: true, standardizedName: row.name, wasConverted: false };
      }
      
      // Check aliases if they exist
      if (row.aliases) {
        const aliases = JSON.parse(row.aliases);
        logger.info(`Checking aliases for ${row.name}: ${JSON.stringify(aliases)}`);
        if (Array.isArray(aliases) && aliases.some(alias => alias.toLowerCase() === trimmedCarrier.toLowerCase())) {
          logger.info(`Found match in aliases for carrier: ${row.name}`);
          return { isValid: true, standardizedName: row.name, wasConverted: false };
        }
      }
    }
    
    // If no match found, keep the original carrier name but mark as converted
    logger.info(`No matching carrier found for: "${trimmedCarrier}", keeping original name`);
    return { isValid: true, standardizedName: trimmedCarrier, wasConverted: true };
  } catch (e) {
    logger.error(`Error validating carrier: ${e}`);
    return { isValid: true, standardizedName: carrier.trim(), wasConverted: true };
  }
}

const startServer = async () => {
  try {
    // Log environment information at startup
    logger.info(`Environment: NODE_ENV = "${process.env.NODE_ENV}"`)
    logger.info(`Current working directory: ${process.cwd()}`)
    logger.info(`Is production mode: ${process.env.NODE_ENV === 'production'}`)
    
    // Log available environment variables (without values for security)
    logger.info(`Available environment variables: ${Object.keys(process.env).join(', ')}`)
    
    // Try loading directly from process.env
    if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
      logger.warn('Critical environment variables missing. Check Replit Secrets are properly set:')
      logger.warn('Required: TURSO_DATABASE_URL, TURSO_AUTH_TOKEN')
      logger.warn('Available env vars: ' + Object.keys(process.env).join(', '))
    } else {
      logger.info('Required environment variables found')
    }
    
    const db = new Database()
    logger.info('Database initialized successfully')

    const app = new Elysia()
      .use(cors({
        // In development, allow the Vite dev server origin
        origin: process.env.NODE_ENV === 'development' 
          ? 'http://localhost:5173'
          : false, // Disable CORS in production
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Cookie'],  // Add Cookie to allowed headers
        credentials: true,
        preflight: true
      }))
      // Add explicit OPTIONS handler for preflight
      .options('/api/contacts/:id', ({ set }) => {
        set.headers = {
          'Access-Control-Allow-Origin': 'http://localhost:5173',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Allow-Credentials': 'true'
        }
        return new Response(null, { status: 204 })
      })
      // Log all requests
      .onRequest(({ request: { method, url, headers } }) => {
        const path = new URL(url).pathname
        logger.info(`â®• ${method} ${path}`)
      })
      // Log all responses
      .onResponse((context) => {
        const { request: { method }, path, set } = context
        logger.info(`â¬… ${method} ${path} ${set.status}`)
      })
      // Enhanced error handling
      .onError(({ code, error, request }: {
        code: string;
        error: Error;
        request: { url: string; method: string };
      }) => {
        const path = new URL(request.url).pathname
        const errorMessage = `âŒ ${request.method} ${path} - ${error.message}`
        logger.error(errorMessage)

        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), { 
          status: code === 'NOT_FOUND' ? 404 : 500,
          headers: {
            'Content-Type': 'application/json'
          }
        })
      })
      // Add health check endpoint
      .get('/health', () => ({ status: 'OK' }))
      .get('/api/contacts', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts - Attempting to fetch contacts for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())
          
          // First get all unique carriers and states for filter options
          const [carrierResults, stateResults] = await Promise.all([
            orgDb.fetchAll('SELECT DISTINCT current_carrier FROM contacts WHERE current_carrier IS NOT NULL ORDER BY current_carrier'),
            orgDb.fetchAll('SELECT DISTINCT state FROM contacts WHERE state IS NOT NULL ORDER BY state')
          ])

          const allCarriers = carrierResults.map((row: any[]) => row[0])
          const allStates = stateResults.map((row: any[]) => row[0])
          
          // Get search query and filters from URL params
          const url = new URL(request.url)
          const searchQuery = url.searchParams.get('search') || ''
          const carriers = (url.searchParams.get('carriers') || '').split(',').filter(Boolean)
          const states = (url.searchParams.get('states') || '').split(',').filter(Boolean)
          const agents = (url.searchParams.get('agents') || '').split(',').filter(Boolean)
          
          // Build the SQL query with search and filter conditions
          let conditions = []
          let params = []

          // Add search condition if search query exists
          if (searchQuery) {
            conditions.push(`(
              LOWER(first_name) LIKE ? OR 
              LOWER(last_name) LIKE ? OR 
              LOWER(email) LIKE ? OR
              LOWER(current_carrier) LIKE ? OR
              LOWER(state) LIKE ?
            )`)
            const searchTerm = `%${searchQuery.toLowerCase()}%`
            params.push(searchTerm, searchTerm, searchTerm, searchTerm, searchTerm)
          }

          // Add carrier filter if carriers are specified
          if (carriers.length > 0) {
            conditions.push(`current_carrier IN (${carriers.map(() => '?').join(',')})`)
            params.push(...carriers)
          }

          // Add state filter if states are specified
          if (states.length > 0) {
            conditions.push(`state IN (${states.map(() => '?').join(',')})`)
            params.push(...states)
          }

          // Add agent filter if agents are specified
          if (agents.length > 0) {
            // Handle special case: if agent list includes '0', include NULL agent_id values too
            if (agents.includes('0')) {
              const nonZeroAgents = agents.filter(id => id !== '0')
              if (nonZeroAgents.length > 0) {
                conditions.push(`(agent_id IN (${nonZeroAgents.map(() => '?').join(',')}) OR agent_id IS NULL)`)
                params.push(...nonZeroAgents.map(Number))
              } else {
                conditions.push(`agent_id IS NULL`)
              }
            } else {
              conditions.push(`agent_id IN (${agents.map(() => '?').join(',')})`)
              params.push(...agents.map(Number))
            }
          }

          // Construct the final query
          const query = `
            SELECT * FROM contacts 
            ${conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : ''}
            ORDER BY id DESC
          `
          
          // Execute query with params
          const contacts = await orgDb.fetchAll(query, params)

          if (!contacts || !Array.isArray(contacts)) {
            logger.warn('GET /api/contacts - No contacts found or invalid response')
            return {
              contacts: [],
              filterOptions: {
                carriers: allCarriers,
                states: allStates
              }
            }
          }

          logger.info(`GET /api/contacts - Successfully fetched ${contacts.length} contacts from org database`)

          const mappedContacts = contacts.map(contact => ({
            id: contact[0],
            first_name: contact[1],
            last_name: contact[2],
            email: contact[3],
            current_carrier: contact[4],
            plan_type: contact[5],
            effective_date: contact[6],
            birth_date: contact[7],
            tobacco_user: Boolean(contact[8]),
            gender: contact[9],
            state: contact[10],
            zip_code: contact[11],
            agent_id: contact[12],
            last_emailed: contact[13],
            phone_number: contact[14] || ''
          }))

          logger.info(`GET /api/contacts - Returning ${mappedContacts.length} contacts with ${allCarriers.length} carriers and ${allStates.length} states`)
          return {
            contacts: mappedContacts,
            filterOptions: {
              carriers: allCarriers,
              states: allStates
            }
          }
        } catch (e) {
          logger.error(`Error in GET /api/contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/check-email/:email', async ({ params: { email }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const orgDb = await Database.getOrgDb(user.organization_id.toString())
          
          const result = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          return {
            exists: result !== null
          }
        } catch (e) {
          logger.error(`Error checking email existence: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/:id', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id} - Fetching contact for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())
          
          // Fetch the contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            throw new Error(`Contact ${id} not found`)
          }

          // Return the contact with mapped fields
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error fetching contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .post('/api/contacts', async ({ body, request }: { body: ContactCreate, request: Request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contact = body
          logger.info(`Attempting to create contact for org ${user.organization_id}: ${contact.first_name} ${contact.last_name}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          // Check for existing email
          const existingContact = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [contact.email]
          )

          if (existingContact) {
            throw new Error('A contact with this email already exists')
          }
          
          const query = `
            INSERT INTO contacts (
              first_name, last_name, email, current_carrier, plan_type,
              effective_date, birth_date, tobacco_user, gender,
              state, zip_code, agent_id, phone_number
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `
          
          const params = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            contact.state,
            contact.zip_code,
            contact.agent_id || null,
            contact.phone_number || ''
          ]

          logger.info(`Executing query with params: ${JSON.stringify(params)}`)
          await orgDb.execute(query, params)

          // Fetch the newly created contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE email = ? ORDER BY id DESC LIMIT 1',
            [contact.email]
          )

          if (!result) {
            throw new Error('Failed to fetch created contact')
          }

          // Match response format to schema
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error creating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .put('/api/contacts/:id', async ({ params: { id }, body, request }) => {
        try {
          // Get user and org info
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          const contact = body as ContactCreate
          logger.info(`PUT /api/contacts/${id} - Updating contact for org ${user.organization_id}`)

          // Get state from ZIP code
          const zipInfo = ZIP_DATA[contact.zip_code]
          if (!zipInfo) {
            throw new Error(`Invalid ZIP code: ${contact.zip_code}`)
          }

          // First update the contact
          const updateQuery = /* sql */ `
            UPDATE contacts SET 
              first_name = ?,
              last_name = ?,
              current_carrier = ?,
              plan_type = ?,
              effective_date = ?,
              birth_date = ?,
              tobacco_user = ?,
              gender = ?,
              state = ?,
              zip_code = ?,
              phone_number = ?
            WHERE LOWER(email) = ?
          `

          const updateParams = [
            contact.first_name,
            contact.last_name,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            zipInfo.state, // Use state from ZIP code
            contact.zip_code,
            contact.phone_number || '',
            contact.email.toLowerCase()
          ]

          // Execute the update
          await orgDb.execute(updateQuery, updateParams)

          // Then fetch the updated contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            throw new Error(`Contact ${id} not found after update`)
          }

          logger.info(`Successfully updated contact ${id} in org ${user.organization_id}`)

          // Return the updated contact
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number
          }
        } catch (e) {
          logger.error(`Error updating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add DELETE endpoint for contacts
      .delete('/api/contacts', async ({ body, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contactIds = body as number[]
          logger.info(`DELETE /api/contacts - Attempting to delete contacts with IDs: ${contactIds} for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contactIds.map(() => '?').join(',')
          
          const query = `
            DELETE FROM contacts 
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const result = await orgDb.execute(query, contactIds)
          const deletedIds = result.rows?.map(row => row.id) || []

          logger.info(`DELETE /api/contacts - Successfully deleted ${deletedIds.length} contacts from org ${user.organization_id}`)

          return {
            success: true,
            deleted_ids: deletedIds,
            message: `Successfully deleted ${deletedIds.length} contacts`
          }
        } catch (e) {
          logger.error(`Error deleting contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add endpoint for reassigning contacts to a different agent
      .put('/api/contacts/reassign', async ({ body, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Only admins can reassign contacts
          if (!user.is_admin) {
            throw new Error('Only administrators can reassign contacts')
          }

          // Parse the request body
          const { contact_ids, agent_id } = body as { contact_ids: number[], agent_id: number }
          logger.info(`PUT /api/contacts/reassign - Attempting to reassign contacts with IDs: ${contact_ids} to agent ${agent_id} for org ${user.organization_id}`)

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contact_ids.map(() => '?').join(',')
          
          const query = `
            UPDATE contacts 
            SET agent_id = ?
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const params = [agent_id, ...contact_ids]
          const result = await orgDb.execute(query, params)
          const updatedIds = result.rows?.map(row => row.id) || []

          logger.info(`PUT /api/contacts/reassign - Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`)

            return {
            success: true,
            updated_ids: updatedIds,
            message: `Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`
          }
        } catch (e) {
          logger.error(`Error reassigning contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add file upload endpoint
      .post('/api/contacts/upload', async ({ body, request }) => {
        try {
          // Get user and org info
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          // Extract file and overwrite flag from form data
          const formData = body as { file: File, overwrite_duplicates: boolean | string, duplicateStrategy: string, agent_id?: string }
          const file = formData.file
          
          // Get agent_id from form data or use current user's ID if they're an agent
          const agentId = formData.agent_id ? parseInt(formData.agent_id, 10) : (user.is_agent ? user.id : null)
          logger.info(`Using agent_id: ${agentId} for contact upload (from form: ${formData.agent_id}, user is agent: ${user.is_agent}, user id: ${user.id})`)
          
          // Support both naming conventions - overwrite_duplicates (old) and duplicateStrategy (new)
          let overwriteDuplicates = false
          if (formData.overwrite_duplicates !== undefined) {
            // Convert string 'false'/'true' to boolean
            overwriteDuplicates = formData.overwrite_duplicates === 'true' || formData.overwrite_duplicates === true
          } else if (formData.duplicateStrategy !== undefined) {
            // Support the new 'duplicateStrategy' parameter
            overwriteDuplicates = formData.duplicateStrategy === 'overwrite'
          }

          logger.info(`Initial overwriteDuplicates value: ${overwriteDuplicates}, type: ${typeof overwriteDuplicates}, raw overwrite_duplicates: ${formData.overwrite_duplicates}, raw duplicateStrategy: ${formData.duplicateStrategy}`)

          logger.info(`POST /api/contacts/upload - Processing CSV upload with overwriteDuplicates=${overwriteDuplicates}`)

          // Read file contents
          const fileContents = await file.text()
          
          // Parse CSV
          const records = csvParse(fileContents, {
            columns: true,
            skip_empty_lines: true
          })

          // Required fields in desired order
          const requiredFields = [
            'First Name',
            'Last Name',
            'Email',
            'Current Carrier',
            'Plan Type',
            'Effective Date',
            'Birth Date',
            'Tobacco User',
            'Gender',
            'ZIP Code',
            'Phone Number'
          ]

          // Validate headers
          const headers = Object.keys(records[0] || {})
          const missingFields = requiredFields.filter(field => !headers.includes(field))

          // Add this: Get the email column index from headers
          const emailColumnIndex = headers.indexOf('Email')

          if (missingFields.length > 0) {
            return {
              success: false,
              message: `Missing required columns: ${missingFields.join(', ')}`,
              error_csv: null,
              converted_carriers_csv: null,
              total_rows: 0,
              error_rows: 0,
              valid_rows: 0,
              converted_carrier_rows: 0,
              supported_carriers: []
            }
          }

          const validRows: any[] = []
          const errorRows: any[] = []
          const paramsList: any[] = []
          const convertedCarrierRows: any[] = []

          // Get existing emails for duplicate checking
          let existingEmails = new Set<string>()
          const emailResults = await orgDb.fetchAll("SELECT email FROM contacts")
          existingEmails = new Set(emailResults.map((row: any) => row[0]?.trim().toLowerCase()))

          logger.info(`Found ${existingEmails.size} existing emails in database`)

          // Validate each row
          for (const [index, row] of records.entries()) {
            const rowNum = index + 2 // Account for header row and 0-based index
            
            // Check for missing values
            const missingValues = requiredFields.filter(field => !row[field]?.trim())
            if (missingValues.length > 0) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Missing values for: ${missingValues.join(', ')}`
              })
              continue
            }

            // Validate email format
            const email = row['Email'].trim().toLowerCase()
            if (!validateEmail(email)) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid email format: ${row['Email']}`
              })
              continue
            }

            // Validate phone number
            const phoneResult = standardizePhoneNumber(row['Phone Number']);
            if (!phoneResult.isValid) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid phone number: ${row['Phone Number']}. Must be exactly 10 digits.`
              })
              continue
            }

            // Validate ZIP code
            const zipCode = row['ZIP Code'].trim()
            const zipInfo = ZIP_DATA[zipCode]
            if (!zipInfo) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid ZIP code: ${zipCode}`
              })
              continue
            }

            // Validate gender
            const gender = row['Gender'].trim().toUpperCase()
            if (!['M', 'F'].includes(gender)) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid gender: ${gender}. Must be 'M' or 'F'`
              })
              continue
            }

            // Check for duplicate email
            logger.info(`Checking row ${rowNum} email: ${email}`)
            logger.info(`Overwrite duplicates is set to: ${overwriteDuplicates}`)
            if (existingEmails.has(email)) {
              logger.info(`Found duplicate email: ${email}`)
              const notOverwrite = !overwriteDuplicates
              logger.info(`Debug - overwriteDuplicates: ${overwriteDuplicates}, !overwriteDuplicates: ${notOverwrite}`)
              if (!overwriteDuplicates) {
                logger.info(`Adding duplicate email to error rows since overwrite is disabled`)
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Email already exists: ${row['Email']}`
                })
                logger.info('Skipping duplicate email')
                continue
              }
              logger.info(`Allowing duplicate email since overwrite is enabled`)
            }

            // Add carrier validation
            const carrierResult = await validateCarrier(row['Current Carrier'], orgDb);
            let carrierNote = null;
            if (carrierResult.wasConverted) {
              carrierNote = {
                Row: rowNum,
                ...row,
                OriginalCarrier: row['Current Carrier']
              };
            }

            try {
              // Validate dates with better error messages
              const effectiveDateResult = validateISODate(row['Effective Date']);
              if (!effectiveDateResult.isValid) {
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Invalid effective date format: ${row['Effective Date']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
                });
                continue;
              }

              const birthDateResult = validateISODate(row['Birth Date']);
              if (!birthDateResult.isValid) {
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Invalid birth date format: ${row['Birth Date']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
                });
                continue;
              }

              const tobaccoUser = ['yes', 'true', '1', 'y'].includes(row['Tobacco User'].trim().toLowerCase())

              paramsList.push([
                row['First Name'].trim(),
                row['Last Name'].trim(),
                email,
                carrierResult.standardizedName,
                row['Plan Type'].trim(),
                effectiveDateResult.isoDate,
                birthDateResult.isoDate,
                tobaccoUser,
                gender,
                zipInfo.state,
                zipCode,
                phoneResult.standardized,
                agentId  // Add agentId parameter
              ])
              validRows.push(row)
              
              // If this row had a carrier conversion, track it
              if (carrierNote) {
                convertedCarrierRows.push(carrierNote)
              }
            } catch (e) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: 'Unexpected error processing dates. Please ensure dates are in YYYY-MM-DD format.'
              })
            }
          }

          // Insert valid rows
          let insertedCount = 0
          if (paramsList.length > 0) {
            logger.info(`Processing ${paramsList.length} valid rows with overwriteDuplicates=${overwriteDuplicates}`)
            logger.info(`Debug - overwriteDuplicates value type: ${typeof overwriteDuplicates}`)
            if (overwriteDuplicates) {
              logger.info('Using update/insert logic for duplicates')
              // First update existing records
              const updateQuery = /* sql */ `
                UPDATE contacts SET 
                  first_name = ?,
                  last_name = ?,
                  current_carrier = ?,
                  plan_type = ?,
                  effective_date = ?,
                  birth_date = ?,
                  tobacco_user = ?,
                  gender = ?,
                  state = ?,
                  zip_code = ?,
                  phone_number = ?,
                  agent_id = ?
                WHERE LOWER(email) = ?
              `
              
              for (const params of paramsList) {
                const email = params[2].toLowerCase()
                logger.info(`Processing row with email: ${email}`)
                
                // Check if email exists
                const existingContact = await orgDb.fetchAll(
                  'SELECT 1 FROM contacts WHERE LOWER(email) = ?',
                  [email]
                )
                
                if (existingContact.length > 0) {
                  logger.info(`Updating existing contact with email: ${email}`)
                  // Update existing contact
                  const updateParams = [
                    params[0], // first_name
                    params[1], // last_name
                    params[3], // current_carrier
                    params[4], // plan_type
                    params[5], // effective_date
                    params[6], // birth_date
                    params[7], // tobacco_user
                    params[8], // gender
                    params[9], // state
                    params[10], // zip_code
                    params[11], // phone_number
                    params[12], // agent_id
                    email     // for WHERE clause
                  ]
                  logger.info(`Update params: ${JSON.stringify(updateParams)}`)
                  await orgDb.execute(updateQuery, updateParams)
                  logger.info(`Successfully updated contact with email: ${email}`)
                } else {
                  logger.info(`Inserting new contact with email: ${email}`)
                  // Insert new contact
                  await orgDb.execute(
                    `INSERT INTO contacts (
                      first_name, last_name, email, current_carrier, plan_type,
                      effective_date, birth_date, tobacco_user, gender,
                      state, zip_code, phone_number, agent_id
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    params
                  )
                  logger.info(`Successfully inserted new contact with email: ${email}`)
                }
              }
              insertedCount = paramsList.length
            } else {
              logger.info('Using insert-only logic for non-duplicates')
              // If not overwriting duplicates, only insert non-duplicate rows
              for (const params of paramsList) {
                const email = params[2].toLowerCase()
                // Check if email exists
                const existingContact = await orgDb.fetchAll(
                  'SELECT 1 FROM contacts WHERE LOWER(email) = ?',
                  [email]
                )

                if (existingContact.length === 0) {
                  // Only insert if email doesn't exist
                  await orgDb.execute(
                    `INSERT INTO contacts (
                      first_name, last_name, email, current_carrier, plan_type,
                      effective_date, birth_date, tobacco_user, gender,
                      state, zip_code, phone_number, agent_id
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    params
                  )
                  insertedCount++
                }
              }
            }
          }

          // Generate error CSV if needed
          let errorCsv = null
          if (errorRows.length > 0) {
            errorCsv = [
              ['Row', ...requiredFields, 'Error'].join(','),
              ...errorRows.map(row => {
                return [
                  row.Row,
                  ...requiredFields.map(field => `"${row[field] || ''}"`),
                  `"${row.Error}"`
                ].join(',')
              })
            ].join('\n')
          }

          // Generate converted carriers CSV if needed
          let convertedCarriersCsv = null;
          if (convertedCarrierRows.length > 0) {
            convertedCarriersCsv = [
              ['Row', ...requiredFields, 'Original Carrier'].join(','),
              ...convertedCarrierRows.map((row: { Row: number; [key: string]: any }) => {
                return [
                  row.Row,
                  ...requiredFields.map(field => `"${row[field] || ''}"`),
                  `"${row.OriginalCarrier}"`
                ].join(',')
              })
            ].join('\n');
          }

          // Get list of supported carriers and their aliases
          const centralDb = new Database();
          const carriersResult = await centralDb.execute(
            'SELECT name, aliases FROM carriers ORDER BY name'
          );
          
          const supportedCarriers = carriersResult.rows.map((row: any) => ({
            name: row.name,
            aliases: row.aliases ? JSON.parse(row.aliases) : []
          }));

          // Create carrier info message
          const carrierInfoMessage = `Supported carriers: ${supportedCarriers.map((c: { name: string; aliases: string[] }) => 
            `${c.name}${c.aliases.length > 0 ? ` (also accepts: ${c.aliases.join(', ')})` : ''}`
          ).join(', ')}`;

          // Create messages array for different types of feedback
          const messages = [];
          
          // Add error message if there are errors
          if (errorRows.length > 0) {
            messages.push(`Found ${errorRows.length} rows with errors. Successfully imported ${insertedCount} rows.`);
          } else {
            messages.push(`Successfully imported ${insertedCount} rows.`);
          }

          // Add carrier conversion message if there were conversions
          if (convertedCarrierRows.length > 0) {
            messages.push(
              `${convertedCarrierRows.length} rows had unrecognized carriers and were marked as "Other". ` +
              `This is normal if these are carriers we don't support. However, please review the carrier conversion CSV ` +
              `to ensure there are no typos or misspellings of supported carriers.`
            );
          }

          // Add supported carriers message
          messages.push(carrierInfoMessage);

          return {
            success: true,
            message: messages.join('\n\n'),
            error_csv: errorCsv,
            converted_carriers_csv: convertedCarriersCsv,
            total_rows: validRows.length + errorRows.length,
            error_rows: errorRows.length,
            valid_rows: insertedCount,
            converted_carrier_rows: convertedCarrierRows.length,
            supported_carriers: supportedCarriers
          }

        } catch (e) {
          logger.error(`Error processing CSV upload: ${e.stack || e}`)
          return {
            success: false,
            message: String(e),
            error_csv: null,
            converted_carriers_csv: null,
            total_rows: 0,
            error_rows: 0,
            valid_rows: 0,
            converted_carrier_rows: 0,
            supported_carriers: []
          }
        }
      })
      // Add error handler
      .use(errorHandler)
      // Add explicit debug log for auth routes
      .use(app => {
        logger.info('Registering auth routes...')
        return app.use(createAuthRoutes())
      })
      // Add settings routes
      .use(settingsRoutes)
      // Add organization routes
      .use(organizationRoutes)
      // Add brand routes
      .use(createBrandRoutes())
      // Add quotes routes
      .use(quotesRoutes)
      // In production, serve the frontend static files
      .use(process.env.NODE_ENV === 'production' 
        ? async (app) => {
            logger.info(`[Static Files] Running in production mode: NODE_ENV = "${process.env.NODE_ENV}"`)
            const distPath = join(process.cwd(), '../dist');
            logger.info(`[Static Files] Serving from: ${distPath} (exists: ${existsSync(distPath)})`);
            
            // List directory contents for debugging
            try {
              const fs = require('fs');
              const distContents = fs.readdirSync(distPath);
              logger.info(`[Static Files] dist directory contents: ${JSON.stringify(distContents)}`);
              
              // Check if index.html exists
              const indexPath = join(distPath, 'index.html');
              logger.info(`[Static Files] index.html path: ${indexPath} (exists: ${existsSync(indexPath)})`);
              
              // If it exists, log its contents for debugging
              if (existsSync(indexPath)) {
                const indexContent = fs.readFileSync(indexPath, 'utf-8');
                logger.info(`[Static Files] index.html first 100 chars: ${indexContent.substring(0, 100)}...`);
              }
            } catch (error) {
              logger.error(`[Static Files] Error inspecting dist directory: ${error}`);
            }
            
            // Try different approach for static files
            app.get('/*', async ({ request }) => {
              const url = new URL(request.url);
              const path = url.pathname;
              
              logger.info(`[Static Route Handler] Handling request for: ${path}`);
              
              // Skip API routes
              if (path.startsWith('/api/')) {
                logger.info(`[Static Route Handler] Skipping API route: ${path}`);
                return;
              }
              
              // Try to serve the file directly from dist directory
              try {
                const filePath = join(distPath, path === '/' ? 'index.html' : path.slice(1));
                logger.info(`[Static Route Handler] Trying file path: ${filePath} (exists: ${existsSync(filePath)})`);
                
                if (existsSync(filePath)) {
                  logger.info(`[Static Route Handler] File exists, serving: ${filePath}`);
                  const ext = filePath.substring(filePath.lastIndexOf('.') + 1);
                  const mimeTypes: Record<string, string> = {
                    'html': 'text/html',
                    'js': 'application/javascript',
                    'css': 'text/css',
                    'json': 'application/json',
                    'png': 'image/png',
                    'jpg': 'image/jpeg',
                    'svg': 'image/svg+xml',
                    'ico': 'image/x-icon',
                    'csv': 'text/csv',
                  };
                  
                  return new Response(Bun.file(filePath), {
                    headers: { 'Content-Type': mimeTypes[ext] || 'application/octet-stream' }
                  });
                } else if (path !== '/' && !path.includes('.')) {
                  // This is likely a SPA route, serve index.html
                  logger.info(`[Static Route Handler] Likely SPA route, serving index.html for: ${path}`);
                  return new Response(Bun.file(join(distPath, 'index.html')), {
                    headers: { 'Content-Type': 'text/html' }
                  });
                } else if (path === '/') {
                  // Explicitly handle root path
                  logger.info(`[Static Route Handler] Handling root path, serving index.html`);
                  const indexPath = join(distPath, 'index.html');
                  
                  if (existsSync(indexPath)) {
                    logger.info(`[Static Route Handler] Root: index.html exists, serving it`);
                    return new Response(Bun.file(indexPath), {
                      headers: { 'Content-Type': 'text/html' }
                    });
                  } else {
                    logger.error(`[Static Route Handler] Root: index.html doesn't exist at ${indexPath}`);
                    return new Response('index.html not found', { status: 404 });
                  }
                }
                
                // If we get here, the file doesn't exist
                logger.warn(`[Static Route Handler] No matching file found for: ${path}`);
                return new Response('Not found', { status: 404 });
              } catch (error) {
                logger.error(`[Static Route Handler] Error serving file for ${path}: ${error}`);
                return new Response(`Server error: ${error}`, { status: 500 });
              }
            });

            return app;
          }
        : (app) => app
      )
      // Add this endpoint within the app definition
      .post('/api/agents', async ({ body, request, set }) => {
        try {
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent: ${newAgent.email} (org: ${currentUser.organization_id})`)

          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add an alias endpoint for POST /api/agents/create to match frontend expectations
      .post('/api/agents/create', async ({ body, request, set }) => {
        try {
          // Log the request to the alias endpoint
          logger.info(`POST /api/agents/create - Using the same implementation as /api/agents`)
          
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent via /api/agents/create: ${newAgent.email} (org: ${currentUser.organization_id})`)
          
          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent via /api/agents/create: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add this GET endpoint within the app definition, near the POST /api/agents endpoint
      .get('/api/agents', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Remove admin check - allow any authenticated user to fetch agents for their organization
          // All users should be able to see the agent list for assignment purposes
          logger.info(`GET /api/agents - Fetching agents for org ${currentUser.organization_id}`)

          // Get the libSQL client
          const client = db.getClient()

          // Fetch all agents (users) from the organization along with their settings
          const result = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.first_name,
                u.last_name,
                u.email,
                u.phone,
                u.is_admin,
                u.is_agent,
                a.settings
              FROM users u
              LEFT JOIN agent_settings a ON u.id = a.agent_id
              WHERE u.organization_id = ?
              AND u.is_active = 1
              ORDER BY u.first_name, u.last_name
            `,
            args: [currentUser.organization_id]
          })

          logger.info(`GET /api/agents - Found ${result.rows.length} agents`)

          // Map the database results to the expected format with camelCase field names
          const agents = result.rows.map((row: any) => {
            const settings = row.settings ? JSON.parse(row.settings) : {
              stateLicenses: [],
              carrierContracts: [],
              stateCarrierSettings: []
            }

            return {
              id: String(row.id),
              firstName: row.first_name,
              lastName: row.last_name,
              email: row.email,
              phone: row.phone || '',
              isAdmin: Boolean(row.is_admin),
              isAgent: Boolean(row.is_agent),
              carriers: settings.carrierContracts || [],
              stateLicenses: settings.stateLicenses || []
            }
          })

          logger.info(`GET /api/agents - Returning ${agents.length} agents`)
          return agents

        } catch (e) {
          logger.error(`Error fetching agents: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Update PUT endpoint for updating agent details - moved here to be with other agent endpoints
      .put('/api/agents/:id', async ({ params, body, request, set }: {
        params: { id: string },
        body: AgentUpdate,
        request: Request,
        set: any
      }) => {
        console.log('DEBUG: PUT handler hit', { params, path: request.url })
        logger.info(`Starting update for agent ${params.id}`)
        logger.info(`Request body: ${JSON.stringify(body, null, 2)}`)
        
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            logger.error('Authentication failed: No user in session')
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Allow users to update their own details or admins to update any agent
          if (!currentUser.is_admin && currentUser.id.toString() !== params.id) {
            logger.error(`Authorization failed: User ${currentUser.id} is not an admin and trying to update another user`)
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can update other agents'
            }
          }
          
          // Security protection: NEVER allow ANY user to remove their own admin status,
          // even if they are an admin themselves
          if (currentUser.id.toString() === params.id) {
            // If this is a self-update and user is trying to change admin status
            if (body.is_admin !== Boolean(currentUser.is_admin)) {
              // If they're trying to REMOVE admin status
              if (Boolean(currentUser.is_admin) && !body.is_admin) {
                logger.warn(`Security protection: Admin user ${currentUser.id} attempted to remove their own admin status`)
                // Prevent admin from removing their own admin status - keep it as is
                body.is_admin = true;
              }
              // Note: We still allow non-admins to be promoted by an admin
            }
          }

          const agent = body
          logger.info(`Updating agent ${params.id} - Name: ${agent.firstName} ${agent.lastName}, Phone: ${agent.phone}`)

          // Get the libSQL client
          const client = db.getClient()

          // Determine if this is a self-update by a non-admin
          const isSelfUpdate = currentUser.id.toString() === params.id && !currentUser.is_admin
          
          // Create dynamic SQL that excludes is_admin for self-updates
          let sql, args
          if (isSelfUpdate) {
            // For self-updates, exclude is_admin from the update
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
            logger.info(`Self-update detected: excluding admin status from update for user ${params.id}`)
          } else {
            // For admin updates or other users, include all fields
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      is_admin = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.is_admin ? 1 : 0,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
          }

          // Execute the update with the appropriate SQL and args
          const userUpdateResult = await client.execute({
            sql,
            args
          })

          logger.info(`User update result: ${JSON.stringify(userUpdateResult.rows, null, 2)}`)

          if (!userUpdateResult.rows || userUpdateResult.rows.length === 0) {
            logger.error('User update failed: No rows affected')
            throw new Error('User update failed - no rows affected')
          }

          logger.info('User details updated successfully')

          // Update agent settings
          const settings = {
            stateLicenses: agent.stateLicenses,
            carrierContracts: agent.carriers,
            stateCarrierSettings: [],
            emailSendBirthday: false,
            emailSendPolicyAnniversary: false,
            emailSendAep: false,
            smartSendEnabled: false
          }

          logger.info(`Agent settings to update: ${JSON.stringify(settings, null, 2)}`)

          const settingsUpdateResult = await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)
            ON CONFLICT (agent_id) 
            DO UPDATE SET settings = EXCLUDED.settings
            RETURNING *`,
            args: [
              params.id,
              JSON.stringify(settings)
            ]
          })

          logger.info(`Settings update result: ${JSON.stringify(settingsUpdateResult.rows, null, 2)}`)

          if (!settingsUpdateResult.rows || settingsUpdateResult.rows.length === 0) {
            logger.error('Settings update failed: No rows affected')
            throw new Error('Settings update failed - no rows affected')
          }

          logger.info('Settings updated successfully')

          const updatedUser = userUpdateResult.rows[0]
          const updatedSettings = JSON.parse(settingsUpdateResult.rows[0].settings)

          return {
            success: true,
            message: 'Agent updated successfully',
            agent: {
              id: updatedUser.id.toString(),
              firstName: updatedUser.first_name,
              lastName: updatedUser.last_name,
              email: updatedUser.email,
              phone: updatedUser.phone || '',
              is_admin: Boolean(updatedUser.is_admin),
              is_agent: Boolean(updatedUser.is_agent),
              carriers: updatedSettings.carrierContracts,
              stateLicenses: updatedSettings.stateLicenses
            }
          }

        } catch (error: unknown) {
          const dbError = error as Error
          logger.error(`Database error: ${dbError.message}`)
          set.status = 500
          return {
            success: false,
            error: dbError.message
          }
        }
      })
      // Add DELETE endpoint for agent deletion with contact reassignment
      .delete('/api/agents/:id', async ({ params, request, set, query }: {
        params: { id: string },
        request: Request,
        set: any,
        query: { reassignTo?: string }
      }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Only admins can delete agents
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can delete agents'
            }
          }

          const agentId = params.id
          
          // Prevent users from deleting themselves
          if (String(currentUser.id) === agentId) {
            set.status = 403
            return {
              success: false,
              error: 'You cannot delete your own account'
            }
          }
          
          const reassignToAgentId = query.reassignTo

          // Get the main database client for user/agent operations
          const client = db.getClient()

          // Also get the organization-specific database for contact operations
          const orgDb = await Database.getOrgDb(currentUser.organization_id.toString())

          // First handle contact operations in org database
          try {
            // Using the transaction method instead of direct SQL commands
            await orgDb.transaction(async (orgTx) => {
            // If reassignToAgentId is provided, reassign contacts to the new agent
            if (reassignToAgentId && reassignToAgentId !== agentId) {
              logger.info(`Reassigning contacts from agent ${agentId} to agent ${reassignToAgentId}`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = ?
                   WHERE agent_id = ?`,
                  [reassignToAgentId, agentId]
                )
            } else {
              // Set agent_id to NULL for contacts associated with this agent
              logger.info(`Setting contacts from agent ${agentId} to have no assigned agent`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = NULL
                   WHERE agent_id = ?`,
                  [agentId]
                )
              }
            })
            
            logger.info(`Successfully updated contacts for agent ${agentId}`)
            
            // Now handle agent operations in the main database
            await db.transaction(async (tx) => {
              // First, check if the user has any other related records that need to be deleted

            // Delete agent's settings
              await tx.execute(
                `DELETE FROM agent_settings
                 WHERE agent_id = ?`,
                [agentId]
              )
              
              // Check for any related records in other tables that might reference this user
              // For example, delete from sessions table if it exists
              await tx.execute(
                `DELETE FROM sessions
                 WHERE user_id = ?`,
                [agentId]
              )
              
              // IMPORTANT: Add any other related tables that might have foreign keys to users
              
              // Finally, completely delete the user record instead of just marking as inactive
              await tx.execute(
                `DELETE FROM users
                 WHERE id = ?`,
                [agentId]
              )
            })
            
            logger.info(`Successfully deleted agent ${agentId}`)

            return {
              success: true,
              message: 'Agent deleted successfully'
            }
          } catch (error) {
            logger.error(`Error in agent deletion: ${error}`)
            throw error;
          }
        } catch (e) {
          logger.error(`Error deleting agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: 'An error occurred while deleting the agent'
          }
        }
      })
      // Add this endpoint within the app definition
      .get('/api/me', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          logger.info(`GET /api/me - Current user from session: ${JSON.stringify(currentUser)}`)
          
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          // Get user details including agent settings if they exist
          const client = db.getClient()
          const userDetails = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.email,
                u.first_name as firstName,
                u.last_name as lastName,
                u.is_admin,
                u.is_agent,
                u.phone,
                u.organization_id,
                o.slug as organization_slug,
                o.subscription_tier,
                a.settings as agentSettings
              FROM users u
              JOIN organizations o ON u.organization_id = o.id
              LEFT JOIN agent_settings a ON a.agent_id = u.id
              WHERE u.id = ?
            `,
            args: [currentUser.id]
          })

          logger.info(`GET /api/me - Raw user details from DB: (omitted)`)

          if (!userDetails.rows[0]) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          const user = userDetails.rows[0]
          const response = {
            success: true,
            user: {
              id: user.id,
              email: user.email,
              firstName: user.firstName,
              lastName: user.lastName,
              is_admin: Boolean(user.is_admin),
              is_agent: Boolean(user.is_agent),
              phone: user.phone || '',
              organization_id: user.organization_id,
              organization_slug: user.organization_slug,
              subscription_tier: user.subscription_tier,
              agentSettings: user.agentSettings ? JSON.parse(user.agentSettings) : null
            }
          }
          logger.info(`GET /api/me - Sending response`)
          return response

        } catch (e) {
          logger.error(`Error fetching current user: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/:redirect', async ({ params, set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for redirect to: ${params.redirect}`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`

          // Handle redirect
          const redirectPath = params.redirect === 'add-agent' ? 'agents/add' : params.redirect
          set.redirect = `/${redirectPath}`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/login', async ({ set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for login page`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add ZIP lookup endpoint
      .get('/api/zip-lookup/:zipCode', ({ params: { zipCode } }) => {
        try {
          const zipInfo = ZIP_DATA[zipCode]
          if (!zipInfo) {
            return {
              success: false,
              error: `Invalid ZIP code: ${zipCode}`
            }
          }
          return {
            success: true,
            ...zipInfo
          }
        } catch (e) {
          logger.error(`Error looking up ZIP code ${zipCode}: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .post('/api/contact-request', async ({ body, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const { name, email, type, quoteId } = body
          logger.info(`Processing contact request for ${email} (type: ${type})`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          // Check for existing contact
          const existingContact = await orgDb.fetchOne<{ id: number }>(
            'SELECT id FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          let eventTargetId: number
          let isLead = false

          if (existingContact) {
            // Use existing contact
            logger.info(`Found existing contact with ID ${existingContact.id}`)
            eventTargetId = existingContact.id
          } else {
            // Create new lead
            logger.info(`No existing contact found, creating lead for ${email}`)
            const leadResult = await orgDb.execute(
              `INSERT INTO leads (name, email) VALUES (?, ?) RETURNING id`,
              [name, email]
            )
            
            if (!leadResult.rows?.[0]?.id) {
              throw new Error('Failed to create lead')
            }
            
            eventTargetId = leadResult.rows[0].id
            isLead = true
          }

          // Record the event
          const metadata = {
            quoteId,
            requestType: type
          }

          const eventQuery = isLead
            ? `INSERT INTO contact_events (lead_id, event_type, metadata) VALUES (?, 'followup_request', ?)`
            : `INSERT INTO contact_events (contact_id, event_type, metadata) VALUES (?, 'followup_request', ?)`

          await orgDb.execute(eventQuery, [eventTargetId, JSON.stringify(metadata)])
          logger.info(`Recorded followup request event for ${isLead ? 'lead' : 'contact'} ${eventTargetId}`)

          // Return success response
          return {
            success: true,
            message: 'Contact request recorded successfully'
          }

        } catch (e) {
          logger.error(`Error processing contact request: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/:id/eligibility', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/eligibility - Fetching eligibility results`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())
          
          // Get most recent eligibility answers for this contact
          const result = await orgDb.fetchOne(
            `SELECT answers 
             FROM eligibility_answers 
             WHERE contact_id = ? 
             ORDER BY created_at DESC 
             LIMIT 1`,
            [id]
          )

          if (!result) {
            return {
              status: "incomplete",
              answers: null
            }
          }

          // Parse answers JSON and determine status
          const answers = JSON.parse(result.answers)
          const allTrue = Object.values(answers).every(value => value === true)

          return {
            status: allTrue ? "pass" : "flagged",
            answers: answers
          }

        } catch (e) {
          logger.error(`Error fetching eligibility results: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add new endpoint to get follow-up requests
      .get('/api/contacts/:id/follow-ups', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/follow-ups - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())
          
          // Get follow-up requests from contact_events table
          const result = await orgDb.execute(
            `SELECT 
              event_type,
              metadata,
              created_at
             FROM contact_events 
             WHERE contact_id = ? 
               AND event_type = 'followup_request'
             ORDER BY created_at DESC`,
            [id]
          )

          // Map results to a more friendly format
          const followUps = result.rows.map(row => {
            const metadata = JSON.parse(row.metadata)
            return {
              type: metadata.requestType,
              quoteId: metadata.quoteId,
              createdAt: row.created_at
            }
          })

          return followUps

        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e}`)
          throw new Error(String(e))
        }
      })
      .post('/api/eligibility-answers', async ({ body, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          type EligibilityAnswers = {
            quote_id: string;
            answers: Record<string, boolean>;
          }
          const { quote_id, answers } = body as EligibilityAnswers
          logger.info(`POST /api/eligibility-answers - Recording answers for quote ${quote_id}`)

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          // Decode the quote ID - format is {orgId-base36}-{contactId-base36}-{hash}
          const [encodedOrgId, encodedContactId] = quote_id.split('-')
          if (!encodedOrgId || !encodedContactId) {
            throw new Error('Invalid quote ID format')
          }

          // Convert from base36 back to numbers
          const orgId = parseInt(encodedOrgId, 36)
          const contactId = parseInt(encodedContactId, 36)
          
          if (isNaN(orgId) || isNaN(contactId)) {
            throw new Error('Invalid quote ID format - could not decode IDs')
          }

          // Verify the contact exists
          const contactResult = await orgDb.fetchOne(
            'SELECT id FROM contacts WHERE id = ?',
            [contactId]
          )
            
          if (!contactResult) {
            throw new Error('Contact not found')
          }

          // Create eligibility_answers table if it doesn't exist
          await orgDb.execute(`
            CREATE TABLE IF NOT EXISTS eligibility_answers (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              contact_id INTEGER NOT NULL,
              answers TEXT NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id)
            )
          `)

          // Insert the answers
          await orgDb.execute(
            'INSERT INTO eligibility_answers (contact_id, answers) VALUES (?, ?)',
            [contactId, JSON.stringify(answers)]
          )

          return {
            success: true,
            message: 'Eligibility answers recorded successfully'
          }

        } catch (e) {
          logger.error(`Error recording eligibility answers: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add profile update endpoint
      .put('/api/profile', async ({ request, body, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          const { firstName, lastName, phone } = body as { 
            firstName: string;
            lastName: string;
            phone: string;
          }

          // Get the libSQL client
          const client = db.getClient()

          // Update only allowed profile fields
          const result = await client.execute({
            sql: `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      phone = ?
                  WHERE id = ?
                  RETURNING *`,
            args: [firstName, lastName, phone, currentUser.id]
          })

          if (!result.rows || result.rows.length === 0) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          return {
            success: true,
            message: 'Profile updated successfully'
          }

        } catch (error) {
          logger.error(`Error updating profile: ${error}`)
          set.status = 500
          return {
            success: false,
            error: String(error)
          }
        }
      })
      .listen(8000)

    logger.info('Server started on port 8000')
  } catch (error) {
    logger.error(`Error starting server: ${error}`)
    process.exit(1)
  }
}

startServer()

================
File: src/logger.ts
================
export const logger = {
  info: (message: string) => {
    const timestamp = new Date().toISOString()
    console.log(`[${timestamp}] [INFO] ${message}`)
  },
  error: (message: string) => {
    const timestamp = new Date().toISOString()
    console.error(`[${timestamp}] [ERROR] ${message}`)
  },
  warn: (message: string) => {
    const timestamp = new Date().toISOString()
    console.warn(`[${timestamp}] [WARN] ${message}`)
  }
}

================
File: src/types.ts
================
export interface ContactCreate {
  first_name: string
  last_name: string
  email: string
  current_carrier: string
  plan_type: string
  effective_date: string
  birth_date: string
  tobacco_user: boolean
  gender: string
  state: string
  zip_code: string
  agent_id?: number | null
  phone_number: string
}

export interface AgentCreate {
  first_name: string
  last_name: string
  email: string
  phone: string
}

export interface User {
  id: number;
  email: string;
  organization_id: number;
  is_admin: boolean;
  is_agent: boolean;
  is_active: boolean;
  first_name: string;
  last_name: string;
  phone: string;
  organization_name?: string;
}

================
File: package.json
================
{
  "name": "backend",
  "module": "index.ts",
  "type": "module",
  "scripts": {
    "dev": "bun run --watch --env-file .env src/index.ts",
    "add-agent": "bun run scripts/add-agent.ts",
    "manage-recommendations": "bun run scripts/manage-recommendations.ts",
    "manage-turso": "bun run scripts/manage-turso.ts",
    "start": "NODE_ENV=production bun run --no-env-file src/index.ts"
  },
  "dependencies": {
    "@clack/prompts": "^0.7.0",
    "@elysiajs/cookie": "^0.8.0",
    "@elysiajs/cors": "^0.8.0",
    "@elysiajs/static": "^1.2.0",
    "@libsql/client": "^0.15.0-pre.1",
    "@sendgrid/mail": "^8.1.4",
    "@types/bun": "latest",
    "chalk": "^5.4.1",
    "csv-parse": "^5.6.0",
    "dotenv": "^16.3.1",
    "elysia": "^0.8.9",
    "prompts": "^2.4.2",
    "stripe": "^17.7.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "bun-types": "latest"
  }
}



================================================================
End of Codebase
================================================================

This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.elm, **/*.ts
- Files matching these patterns are excluded: backend/node_modules/*, frontend/node_modules/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
backend/
  scripts/
    add-agent.ts
    manage-recommendations.ts
    manage-turso.ts
  src/
    config/
      turso.ts
    middleware/
      auth.ts
      error.ts
    routes/
      admin-portal.ts
      admin.ts
      auth.ts
      brand.ts
      contacts.ts
      organizations.ts
      settings.ts
    services/
      agentSettings.ts
      auth.ts
      email.ts
      turso.ts
    config.ts
    database.ts
    errors.ts
    index.ts
    logger.ts
    types.ts
frontend/
  src/
    Components/
      ProgressIndicator.elm
      SetupLayout.elm
    AddAgent.elm
    BrandSettings.elm
    ChoosePlan.elm
    Contact.elm
    Contacts.elm
    Home.elm
    Login.elm
    Main.elm
    main.ts
    Profile.elm
    Settings.elm
    Signup.elm
    StateRegions.elm
    TempLanding.elm
    vite-env.d.ts
  vite.config.ts

================================================================
Files
================================================================

================
File: backend/scripts/add-agent.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for agent data
const AgentSchema = z.object({
  first_name: z.string().min(1),
  last_name: z.string().min(1),
  email: z.string().email(),
  phone: z.string().min(1),
  organization_id: z.number(),
});

async function main() {
  p.intro(chalk.green('âœ¨ Interactive Agent Creation Tool âœ¨'));

  const db = new Database();

  // Get all organizations
  const orgs = await db.fetchAll<{ id: number; name: string }>('SELECT id, name FROM organizations');
  
  if (orgs.length === 0) {
    p.outro(chalk.red('No organizations found. Please create an organization first.'));
    exit(1);
  }

  // Gather information
  const firstName = await p.text({
    message: 'Enter agent first name:',
    validate: (value) => {
      if (value.length === 0) return 'First name cannot be empty';
    },
  });

  const lastName = await p.text({
    message: 'Enter agent last name:',
    validate: (value) => {
      if (value.length === 0) return 'Last name cannot be empty';
    },
  });

  const email = await p.text({
    message: 'Enter agent email:',
    validate: (value) => {
      if (!value.includes('@')) return 'Invalid email address';
    },
  });

  const phone = await p.text({
    message: 'Enter agent phone:',
    validate: (value) => {
      if (value.length === 0) return 'Phone cannot be empty';
    },
  });

  const organization = await p.select({
    message: 'Select organization:',
    options: orgs.map(org => ({
      value: org.id,
      label: org.name,
    })),
  });

  if (p.isCancel(firstName) || p.isCancel(lastName) || p.isCancel(email) || p.isCancel(phone) || p.isCancel(organization)) {
    p.outro(chalk.yellow('Operation cancelled'));
    exit(0);
  }

  try {
    // Validate data
    const agentData = AgentSchema.parse({
      first_name: firstName,
      last_name: lastName,
      email,
      phone,
      organization_id: organization,
    });

    // Start a transaction
    await db.execute('BEGIN TRANSACTION');

    try {
      // Insert into agents table
      await db.execute(
        `INSERT INTO agents (first_name, last_name, email, phone, organization_id)
         VALUES (?, ?, ?, ?, ?)`,
        [
          agentData.first_name,
          agentData.last_name,
          agentData.email,
          agentData.phone,
          agentData.organization_id
        ]
      );

      // Insert into users table
      await db.execute(
        `INSERT INTO users (email, organization_id, is_admin, is_agent, is_active)
         VALUES (?, ?, ?, ?, true)`,
        [agentData.email, agentData.organization_id, false, true]
      );

      // Commit the transaction
      await db.execute('COMMIT');

      p.outro(chalk.green('Agent created successfully! ðŸŽ‰'));

    } catch (error) {
      // Rollback on error
      await db.execute('ROLLBACK');
      throw error;
    }

  } catch (error) {
    if (error instanceof z.ZodError) {
      p.outro(chalk.red(`Validation error: ${error.errors.map(e => e.message).join(', ')}`));
    } else {
      p.outro(chalk.red(`Error creating agent: ${error}`));
    }
    exit(1);
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: backend/scripts/manage-recommendations.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for GI recommendation data
const RecommendationSchema = z.object({
  state: z.string().length(2),
  carrier: z.string().min(1),
});

async function main() {
  p.intro(chalk.green('âœ¨ Guaranteed Issue Recommendations Manager âœ¨'));

  const db = new Database();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all GI recommendations' },
        { value: 'add', label: 'Add new GI recommendation' },
        { value: 'remove', label: 'Remove GI recommendation' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listRecommendations(db);
          break;
        case 'add':
          await addRecommendation(db);
          break;
        case 'remove':
          await removeRecommendation(db);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listRecommendations(db: Database) {
  const results = await db.fetchAll<{ state: string; carrier: string; created_at: string }>(
    `SELECT state, carrier, created_at 
     FROM guaranteed_issue_recommendations 
     ORDER BY carrier, state`
  );

  if (results.length === 0) {
    p.note('No GI recommendations found', 'Empty');
    return;
  }

  const groupedByCarrier = results.reduce((acc, curr) => {
    if (!acc[curr.carrier]) {
      acc[curr.carrier] = [];
    }
    acc[curr.carrier].push(curr.state);
    return acc;
  }, {} as Record<string, string[]>);

  p.note(
    Object.entries(groupedByCarrier)
      .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
      .join('\n\n'),
    'Current GI Recommendations'
  );
}

async function addRecommendation(db: Database) {
  // Get available carriers first
  const carriers = await db.fetchAll<{ name: string }>(
    'SELECT name FROM carriers ORDER BY name'
  );

  if (carriers.length === 0) {
    p.note(chalk.red('No carriers found in database'));
    return;
  }

  const carrier = await p.select({
    message: 'Select carrier:',
    options: carriers.map(c => ({
      value: c.name,
      label: c.name,
    })),
  });

  if (p.isCancel(carrier)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const states = await p.text({
    message: 'Enter state codes (comma/space separated, e.g., TX CA FL):',
    validate: (value) => {
      const stateList = value.toUpperCase().split(/[\s,]+/).filter(Boolean);
      if (stateList.length === 0) return 'At least one state code is required';
      const invalidStates = stateList.filter(s => s.length !== 2);
      if (invalidStates.length > 0) {
        return `Invalid state codes: ${invalidStates.join(', ')}`;
      }
    },
  });

  if (p.isCancel(states)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const stateList = states.toUpperCase().split(/[\s,]+/).filter(Boolean);
  const results: { state: string; success: boolean; message: string }[] = [];

  for (const state of stateList) {
    try {
      const data = RecommendationSchema.parse({
        state,
        carrier,
      });

      // Check if recommendation already exists
      const existing = await db.fetchOne(
        'SELECT 1 FROM guaranteed_issue_recommendations WHERE state = ? AND carrier = ?',
        [data.state, data.carrier]
      );

      if (existing) {
        results.push({
          state: data.state,
          success: false,
          message: 'Already exists'
        });
        continue;
      }

      await db.execute(
        'INSERT INTO guaranteed_issue_recommendations (state, carrier) VALUES (?, ?)',
        [data.state, data.carrier]
      );

      results.push({
        state: data.state,
        success: true,
        message: 'Added successfully'
      });

    } catch (error) {
      results.push({
        state,
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Unknown error'
      });
    }
  }

  // Display results summary
  const successful = results.filter(r => r.success);
  const failed = results.filter(r => !r.success);

  if (successful.length > 0) {
    p.note(
      chalk.green(
        `Successfully added GI recommendations for ${carrier}:\n` +
        successful.map(r => `  ${r.state}`).join('\n')
      ),
      'Success'
    );
  }

  if (failed.length > 0) {
    p.note(
      chalk.yellow(
        `Failed to add some recommendations for ${carrier}:\n` +
        failed.map(r => `  ${r.state}: ${r.message}`).join('\n')
      ),
      'Warnings'
    );
  }
}

async function removeRecommendation(db: Database) {
  const recommendations = await db.fetchAll<{ id: number; state: string; carrier: string }>(
    'SELECT id, state, carrier FROM guaranteed_issue_recommendations ORDER BY carrier, state'
  );

  if (recommendations.length === 0) {
    p.note(chalk.yellow('No recommendations to remove'));
    return;
  }

  const selections = await p.multiselect({
    message: 'Select recommendations to remove (space to select/deselect):',
    options: recommendations
      .sort((a, b) => a.carrier.localeCompare(b.carrier) || a.state.localeCompare(b.state))
      .map(rec => ({
        value: rec.id.toString(),
        label: `${rec.carrier} - ${rec.state}`,
      })),
    required: true,
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const idsToRemove = (selections as string[]).map(Number);

  if (idsToRemove.length === 0) {
    p.note(chalk.yellow('No recommendations selected for removal'));
    return;
  }

  await db.execute(
    `DELETE FROM guaranteed_issue_recommendations WHERE id IN (${idsToRemove.join(',')})`,
  );

  const removedItems = recommendations
    .filter(r => idsToRemove.includes(r.id))
    .reduce((acc, curr) => {
      if (!acc[curr.carrier]) {
        acc[curr.carrier] = [];
      }
      acc[curr.carrier].push(curr.state);
      return acc;
    }, {} as Record<string, string[]>);

  p.note(
    chalk.green(
      'Successfully removed recommendations:\n\n' +
      Object.entries(removedItems)
        .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
        .join('\n\n')
    ),
    'Success'
  );
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: backend/scripts/manage-turso.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';
import { TURSO_CONFIG } from '../src/config/turso';
import fetch from 'node-fetch';

interface Organization {
  id: number;
  name: string;
  turso_db_url: string | null;
}

class TursoManager {
  private headers = {
    'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
    'Content-Type': 'application/json'
  };

  async listLocations(): Promise<string[]> {
    const response = await fetch(`${TURSO_CONFIG.API_URL}/locations`, {
      headers: this.headers
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch locations: ${await response.text()}`);
    }

    const data = await response.json() as { locations: Array<{ name: string }> };
    return data.locations.map(l => l.name);
  }

  async listDatabases(): Promise<Array<{name: string, hostname: string}>> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`,
      { headers: this.headers }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch databases: ${await response.text()}`);
    }

    const data = await response.json() as { databases: Array<{Name: string, Hostname: string}> };
    return data.databases.map(db => ({
      name: db.Name,
      hostname: db.Hostname
    }));
  }

  async updateGroup(name: string, location: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/groups/${TURSO_CONFIG.GROUP_NAME}`,
      {
        method: 'PATCH',
        headers: this.headers,
        body: JSON.stringify({ name, location })
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to update group: ${await response.text()}`);
    }
  }

  async deleteDatabase(name: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${name}`,
      {
        method: 'DELETE',
        headers: this.headers
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete database: ${await response.text()}`);
    }
  }
}

async function main() {
  p.intro(chalk.green('âœ¨ Turso Database Manager âœ¨'));

  const db = new Database();
  const turso = new TursoManager();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all databases and organizations' },
        { value: 'update-group', label: 'Update group configuration' },
        { value: 'delete-db', label: 'Delete a customer database' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listDatabasesAndOrgs(db, turso);
          break;
        case 'update-group':
          await updateGroupConfig(turso);
          break;
        case 'delete-db':
          await deleteCustomerDatabase(db, turso);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listDatabasesAndOrgs(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  const mappedDatabases = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      name: database.name,
      hostname: database.hostname,
      organization: org ? org[1] : 'Not associated with any organization'
    };
  });

  if (mappedDatabases.length === 0) {
    p.note('No databases found', 'Empty');
    return;
  }

  p.note(
    mappedDatabases
      .map(db => `${db.name}:\n  URL: ${db.hostname}\n  Organization: ${db.organization}`)
      .join('\n\n'),
    'Current Databases'
  );
}

async function updateGroupConfig(turso: TursoManager) {
  // Get available locations
  const locations = await turso.listLocations();

  p.note(
    `Current Configuration:\n` +
    `  Group Name: ${TURSO_CONFIG.GROUP_NAME}\n` +
    `  Location: ${TURSO_CONFIG.LOCATION}`,
    'Current Settings'
  );

  const newGroupName = await p.text({
    message: 'Enter new group name (or press enter to keep current):',
    initial: TURSO_CONFIG.GROUP_NAME,
  });

  if (p.isCancel(newGroupName)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const newLocation = await p.select({
    message: 'Select new location:',
    options: locations.map(loc => ({
      value: loc,
      label: loc,
    })),
    initialValue: TURSO_CONFIG.LOCATION,
  });

  if (p.isCancel(newLocation)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const confirm = await p.confirm({
    message: `Update group "${TURSO_CONFIG.GROUP_NAME}" to:\n` +
             `  Name: ${newGroupName}\n` +
             `  Location: ${newLocation}\n` +
             `Are you sure?`,
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  await turso.updateGroup(newGroupName, newLocation as string);
  
  p.note(
    chalk.green(
      `Successfully updated group configuration.\n` +
      `Remember to update TURSO_CONFIG in your code!`
    ),
    'Success'
  );
}

async function deleteCustomerDatabase(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  if (databases.length === 0) {
    p.note('No databases found to delete', 'Empty');
    return;
  }

  const options = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      value: database.name,
      label: `${database.name} (${org ? org[1] : 'Unassociated'})`,
    };
  });

  const selections = await p.multiselect({
    message: 'Select databases to delete (space to select, enter to confirm):',
    options,
    required: true
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const selectedDbs = selections as string[];
  if (selectedDbs.length === 0) {
    p.note(chalk.yellow('No databases selected'));
    return;
  }

  const confirm = await p.confirm({
    message: chalk.red(
      `Are you sure you want to delete the following databases?\n` +
      selectedDbs.map(db => `  - ${db}`).join('\n') +
      `\nThis action cannot be undone!`
    ),
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  for (const dbName of selectedDbs) {
    try {
      await turso.deleteDatabase(dbName);

      // Update organization record
      const org = orgs.find((o: any) => 
        o[2] && 
        o[2].toString().includes(
          databases.find(d => d.name === dbName)?.hostname || ''
        )
      );

      if (org) {
        await db.execute(
          'UPDATE organizations SET turso_db_url = NULL, turso_auth_token = NULL WHERE id = ?',
          [org[0]]
        );
      }

      p.note(
        chalk.green(`Successfully deleted database "${dbName}"`),
        'Success'
      );
    } catch (error) {
      p.note(
        chalk.red(`Failed to delete database "${dbName}": ${error}`),
        'Error'
      );
    }
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: backend/src/config/turso.ts
================
export const TURSO_CONFIG = {
  API_URL: 'https://api.turso.tech/v1',
  API_TOKEN: process.env.TURSO_API_TOKEN, // Add this to your .env
  ORG_SLUG: 'pyrex41',
  GROUP_NAME: 'medicare-portal',
  LOCATION: 'aws-us-east-1' // We can update this to your preferred location
}

================
File: backend/src/middleware/auth.ts
================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { Database } from '../database';

interface AuthenticatedRequest extends Request {
  user?: {
    id: number;
    email: string;
    organization_id: number;
    role: string;
    turso_db_url?: string;
    turso_auth_token?: string;
  };
}

export async function authMiddleware(
  req: AuthenticatedRequest, 
  res: Response, 
  next: NextFunction
) {
  try {
    // Verify JWT token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      res.status(401).json({ error: 'No token provided' });
      return;
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
      userId: number;
    };

    const db = new Database();

    // Get user with organization info from central DB
    const user = await db.execute(
      `SELECT u.*, o.turso_db_url, o.turso_auth_token
       FROM users u
       JOIN organizations o ON u.organization_id = o.id
       WHERE u.id = ?`,
      [decoded.userId]
    );

    if (!user) {
      res.status(401).json({ error: 'User not found' });
      return;
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Unauthorized' });
  }
}

================
File: backend/src/middleware/error.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'

export const errorHandler = new Elysia()
  .onError(({ code, error, set }) => {
    logger.error(`âŒ Error: ${code} - ${error.message}`);
    
    switch (code) {
      case 'NOT_FOUND':
        set.status = 404;
        return {
          success: false,
          message: 'Resource not found'
        };
      
      case 'VALIDATION':
        set.status = 400;
        return {
          success: false,
          message: error.message
        };
      
      default:
        set.status = 500;
        return {
          success: false,
          message: 'Internal server error'
        };
    }
  });

================
File: backend/src/routes/admin-portal.ts
================
import { Elysia } from 'elysia'
import { spawn } from 'child_process'
import path from 'path'
import { logger } from '../logger'
import { requireAuth, requireAdmin } from '../middleware/auth'

// Create admin portal routes
export const createAdminPortalRoutes = () => {
  const adminPortal = new Elysia({ prefix: '/api/admin' })
    .use(requireAuth)
    .use(requireAdmin)

    // Get available admin scripts
    .get('/scripts', () => {
      const availableScripts = [
        {
          id: 'add-agent',
          name: 'Add Agent',
          description: 'Interactive tool to add new agents',
          script: 'add-agent.ts'
        },
        {
          id: 'manage-recommendations',
          name: 'Manage GI Recommendations', 
          description: 'Manage guaranteed issue recommendations',
          script: 'manage-recommendations.ts'
        }
      ]
      
      return { scripts: availableScripts }
    })

    // Execute script endpoint
    .post('/execute/:scriptId', ({ params, set, server }) => {
      const { scriptId } = params
      const scriptPath = path.join(__dirname, '../../scripts', `${scriptId}.ts`)

      logger.info(`Executing admin script: ${scriptId}`)

      // Spawn script process
      const process = spawn('bun', ['run', scriptPath], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      // Get WebSocket server instance
      const wss = server.webSocket

      // Handle new WebSocket connections
      wss.on('connection', (ws) => {
        logger.info('Admin terminal WebSocket connected')

        // Handle input from client
        ws.on('message', (data: string) => {
          const parsed = JSON.parse(data)
          if (parsed.type === 'input') {
            process.stdin.write(parsed.data)
          }
        })

        // Send output to client
        process.stdout.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'output', 
            data: data.toString() 
          }))
        })

        process.stderr.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'error', 
            data: data.toString() 
          }))
        })

        // Handle process exit
        process.on('exit', (code) => {
          ws.send(JSON.stringify({ type: 'exit', code }))
          logger.info(`Admin script ${scriptId} exited with code ${code}`)
        })

        // Handle WebSocket close
        ws.on('close', () => {
          logger.info('Admin terminal WebSocket disconnected')
          process.kill()
        })
      })

      set.status = 200
      return { 
        success: true, 
        message: 'Script execution started' 
      }
    })

  return adminPortal
}

================
File: backend/src/routes/admin.ts
================
import { Elysia } from 'elysia'
import { staticPlugin } from '@elysiajs/static'
import { spawn } from 'child_process'
import path from 'path'
import { TursoService } from '../services/turso'

const tursoService = new TursoService()

export const adminRoutes = new Elysia()
  // Protect admin routes
  .guard({
    beforeHandle: ({ request, set }) => {
      // Add your admin authentication logic here
      const isAdmin = true // Replace with actual admin check
      if (!isAdmin) {
        set.status = 401
        return 'Unauthorized'
      }
    }
  })
  // Serve admin portal static files
  .use(staticPlugin({
    assets: '../admin-portal/dist',
    prefix: '/admin'
  }))
  // Terminal WebSocket endpoint
  .ws('/admin/terminal', {
    open(ws) {
      ws.send('Connected to admin terminal')
    },
    message(ws, message) {
      const { command, args } = JSON.parse(message as string)
      
      const scripts = {
        'add-agent': '../scripts/add-agent.ts',
        'manage-recommendations': '../scripts/manage-recommendations.ts'
      }

      if (!scripts[command]) {
        ws.send(JSON.stringify({ error: 'Invalid command' }))
        return
      }

      const script = spawn('bun', [path.resolve(__dirname, scripts[command]), ...args], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      script.stdout.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'output', data: data.toString() }))
      })

      script.stderr.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'error', data: data.toString() }))
      })

      script.on('close', (code) => {
        ws.send(JSON.stringify({ type: 'exit', code }))
      })
    }
  })

// In your create organization endpoint:
app.post('/api/organizations', async (req, res) => {
  const { name, /* other org fields */ } = req.body
  
  try {
    // Create org in central DB
    const org = await db.one(`
      INSERT INTO organizations (name) 
      VALUES ($1) 
      RETURNING id`, 
      [name]
    )

    // Create Turso DB for org
    const { url, token } = await tursoService.createOrganizationDatabase(org.id)

    // Update org with Turso credentials
    await db.none(`
      UPDATE organizations 
      SET turso_db_url = $1, turso_auth_token = $2
      WHERE id = $3`,
      [url, token, org.id]
    )

    res.json({ success: true, organization: org })
  } catch (err) {
    res.status(500).json({ success: false, error: err.message })
  }
})

================
File: backend/src/routes/auth.ts
================
import { Elysia } from 'elysia';
import { cookie } from '@elysiajs/cookie';
import { AuthService } from '../services/auth';
import { EmailService } from '../services/email';
import { logger } from '../logger';
import { randomBytes } from 'crypto';
import { config } from '../config';
import crypto from 'crypto';
import { db } from '../database';
import { Database } from '../database';
import { getUserFromSession } from '../services/auth';
import type { User } from '../types';

const dbInstance = new Database();

export function createAuthRoutes() {
  const auth = new AuthService(
    process.env.NODE_ENV === 'development' 
      ? 'http://localhost:5173'  // Frontend URL in development
      : (process.env.BASE_URL || 'http://localhost:3000')
  );
  const emailService = new EmailService();

  return new Elysia()
    .use(cookie())
    .post('/api/auth/login', async ({ body, set }) => {
      try {
        const { email } = body as { email: string };
        logger.info(`Login request for email: ${email}`);

        // Check if user exists
        const client = dbInstance.getClient();
        const userResult = await client.execute({
          sql: 'SELECT id, email FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        if (userResult.rows.length === 0) {
          // Don't reveal if user exists or not
          logger.info(`No active user found for email: ${email}`);
          return { success: true };
        }

        // Generate and send magic link
        const magicLink = await auth.createMagicLink(
          email,
          'default', // Default organization for now
          { redirectUrl: '/dashboard' }
        );

        if (process.env.NODE_ENV === 'development') {
          logger.info(`Development mode - Magic link: ${magicLink}`);
        } else {
          // In production, send email with magic link
          await emailService.sendLoginLink(email, magicLink);
        }

        return { success: true };

      } catch (e) {
        logger.error(`Login error: ${e}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Internal server error'
        };
      }
    })

    .get('/api/auth/verify/:organizationSlug/:token', async ({ params, cookie, setCookie }) => {
      const { token, organizationSlug } = params;
      
      logger.info(`Starting verification for org ${organizationSlug}`);

      try {
        logger.info('Verifying magic link');
        const result = await auth.verifyMagicLink(token, organizationSlug);
        logger.info(`Magic link verification result: ${JSON.stringify(result)}`);
        
        if (!result.valid) {
          logger.error('Magic link validation failed');
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        // Create session ID
        const sessionId = crypto.randomBytes(32).toString('hex');
        logger.info(`Created session ID: ${sessionId}`);

        // First find user by email
        const user = await db.fetchOne<User>(
          `SELECT u.*, o.slug as organization_slug 
           FROM users u 
           JOIN organizations o ON u.organization_id = o.id 
           WHERE LOWER(u.email) = LOWER(?) AND u.is_active = 1`,
          [result.email]
        );

        if (!user) {
          logger.error(`No active user found for email: ${result.email}`);
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        logger.info(`Found user: ${JSON.stringify(user)}`);

        // Create session in database
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

        await db.execute(
          'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
          [sessionId, user.id, expiresAt.toISOString()]
        );

        logger.info(`Created session in database for user ${user.id}`);

        // Set session cookie
        setCookie('session', sessionId, {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7 // 7 days
        });

        const verificationResult = {
          success: true,
          redirectUrl: result.redirectUrl || '/dashboard',
          session: sessionId,
          email: result.email,
          orgSlug: user.organization_slug
        };
        logger.info(`Sending verification response: ${JSON.stringify(verificationResult)}`);
        return verificationResult;

      } catch (error) {
        logger.error(`Verification error: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return {
          success: false,
          redirectUrl: "/login",
          session: "",
          email: ""
        };
      }
    })

    .get('/api/auth/session', async ({ cookie }) => {
      const sessionId = cookie.session;
      logger.info(`Session check - Cookie session ID: ${sessionId}`);
      
      if (!sessionId) {
        logger.info('No session cookie found');
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: ""
        };
      }

      try {
        // Get user and organization info from session
        logger.info(`Looking up session in database: ${sessionId}`);
        const sessionUser = await db.fetchOne<{
          id: number;
          email: string;
          first_name: string;
          last_name: string;
          organization_slug: string;
        }>(
          `SELECT u.id, u.email, u.first_name, u.last_name, o.slug as organization_slug
           FROM sessions s
           JOIN users u ON s.user_id = u.id
           JOIN organizations o ON u.organization_id = o.id
           WHERE s.id = ?`,
          [sessionId]
        );

        if (!sessionUser) {
          logger.info(`No session found in database for ID: ${sessionId}`);
          return { 
            valid: false,
            session: "",
            email: "",
            organizationSlug: "",
            first_name: "",
            last_name: "",
            id: ""
          };
        }

        logger.info(`Found valid session for user: ${sessionUser.email}`);
        logger.info(`Session details: ${JSON.stringify(sessionUser, null, 2)}`);

        return { 
          valid: true,
          session: sessionId,
          email: sessionUser.email,
          organizationSlug: sessionUser.organization_slug,
          first_name: sessionUser.first_name,
          last_name: sessionUser.last_name,
          id: sessionUser.id
        };
      } catch (error) {
        logger.error(`Error getting session info: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: ""
        };
      }
    })

    .post('/api/auth/logout', async ({ set }) => {
      set.headers['Set-Cookie'] = 'session=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT';
      return { success: true };
    });
}

================
File: backend/src/routes/brand.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';

const db = new Database();

interface Organization {
  id: number;
}

interface BrandSettings {
  brand_name: string;
  primary_color: string;
  secondary_color: string;
  logo_data: string | null;
}

export function createBrandRoutes() {
  return new Elysia()
    .get('/api/organizations/:orgSlug/brand', async ({ params }) => {
      try {
        const { orgSlug } = params;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Get brand settings
        const settings = await db.fetchOne<BrandSettings>(
          'SELECT brand_name, primary_color, secondary_color, logo_data FROM brand_settings WHERE organization_id = ?',
          [org.id]
        );

        if (!settings) {
          // Return defaults if no settings exist
          return {
            brand_name: '',
            primary_color: '#6B46C1',
            secondary_color: '#9F7AEA',
            logo: null
          };
        }

        return {
          brand_name: settings.brand_name,
          primary_color: settings.primary_color,
          secondary_color: settings.secondary_color,
          logo: settings.logo_data
        };
      } catch (error) {
        logger.error('Error fetching brand settings', error);
        return {
          success: false,
          error: 'Failed to fetch brand settings'
        };
      }
    })
    .put('/api/organizations/:orgSlug/brand', async ({ params, body }) => {
      try {
        const { orgSlug } = params;
        const { brand_name, primary_color, secondary_color, logo } = body as any;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Upsert brand settings
        await db.execute(`
          INSERT INTO brand_settings 
            (organization_id, brand_name, primary_color, secondary_color, logo_data)
          VALUES (?, ?, ?, ?, ?)
          ON CONFLICT(organization_id) DO UPDATE SET
            brand_name = excluded.brand_name,
            primary_color = excluded.primary_color,
            secondary_color = excluded.secondary_color,
            logo_data = excluded.logo_data
        `, [org.id, brand_name, primary_color, secondary_color, logo]);

        return {
          success: true
        };
      } catch (error) {
        logger.error('Error saving brand settings', error);
        return {
          success: false,
          error: 'Failed to save brand settings'
        };
      }
    });
}

================
File: backend/src/routes/contacts.ts
================
import { createClient } from '@libsql/client';

// Get Turso client for organization
async function getOrgTursoClient(orgId: string) {
  const org = await db.one(`
    SELECT turso_db_url, turso_auth_token 
    FROM organizations 
    WHERE id = $1`,
    [orgId]
  );

  return createClient({
    url: org.turso_db_url,
    authToken: org.turso_auth_token
  });
}

// Update contacts endpoints to use org's Turso DB
app.post('/api/contacts/upload', async (req, res) => {
  const orgId = req.user.organizationId;
  const tursoClient = await getOrgTursoClient(orgId);

  try {
    // Process CSV file
    const contacts = parseCSV(req.file);
    
    // Insert into org's Turso DB
    for (const contact of contacts) {
      await tursoClient.execute(`
        INSERT INTO contacts (
          first_name, last_name, email, /* other fields */
        ) VALUES (?, ?, ?, /* other values */)`,
        [contact.firstName, contact.lastName, contact.email /* other values */]
      );
    }

    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ 
      success: false,
      message: err.message,
      // Include other error details as needed
    });
  }
});

// Similar updates needed for other contact endpoints

================
File: backend/src/routes/organizations.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { TursoService } from '../services/turso';
import { z } from 'zod';
import { sendMagicLink } from '../services/email';
import { generateToken, getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { AuthService } from '../services/auth';

// Update the validation schema to include slug rules
const signupSchema = z.object({
  organizationName: z.string()
    .min(1, "Organization name is required")
    .max(100, "Organization name must be less than 100 characters")
    .regex(/^[a-zA-Z0-9\s\-_.]+$/, "Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores"),
  adminFirstName: z.string().min(1, "First name is required"),
  adminLastName: z.string().min(1, "Last name is required"),
  adminEmail: z.string().email("Invalid email address"),
});

// Enhanced slug generation with uniqueness check
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

export const organizationRoutes = new Elysia({ prefix: '/api' })
  .post('/organizations/signup', async ({ body, set }) => {
    const db = new Database();
    const turso = new TursoService();
    const auth = new AuthService(process.env.PUBLIC_URL || 'http://localhost:5173');

    try {
      logger.info(`Attempting to create organization with data: ${JSON.stringify(body)}`);
      const data = signupSchema.parse(body);
      
      // Generate unique slug
      const slug = await generateUniqueSlug(db, data.organizationName);
      logger.info(`Generated unique slug: ${slug}`);
      
      // Check if email is already registered in any organization
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE email = ?',
        [data.adminEmail]
      );

      logger.info(`Existing user check result: ${JSON.stringify(existingUser)}`);

      if (existingUser[0]?.count > 0) {
        logger.warn(`Email ${data.adminEmail} is already registered`);
        set.status = 400;
        return {
          success: false,
          message: 'This email address is already registered. Please use a different email or contact support.'
        };
      }

      // Check if organization name or slug is taken
      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [data.organizationName, slug]
      );

      logger.info(`Existing org check result: ${JSON.stringify(existingOrg)}`);

      if (existingOrg[0]?.count > 0) {
        logger.warn(`Organization name ${data.organizationName} or slug ${slug} is already taken`);
        set.status = 400;
        return {
          success: false,
          message: 'Organization name is already taken'
        };
      }

      // Wrap all database operations in a transaction
      const orgId = await db.transaction('write', async (transactionDb) => {
        // Create organization
        logger.info('Creating organization');
        const org = await transactionDb.execute(
          `INSERT INTO organizations (
            name,
            slug,
            subscription_tier,
            agent_limit,
            contact_limit
          ) VALUES (?, ?, 'basic', 5, 100) RETURNING id`,
          [data.organizationName, slug]
        );

        const orgId = org.rows?.[0]?.id;
        if (!orgId) {
          throw new Error('Failed to create organization');
        }

        logger.info(`Organization created with ID: ${orgId}`);

        // Create Turso database for organization
        logger.info('Creating Turso database');
        const { url, token } = await turso.createOrganizationDatabase(orgId.toString());

        logger.info('Turso database created');

        // Update organization with Turso credentials
        logger.info('Updating organization with Turso credentials');
        await transactionDb.execute(
          'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ? WHERE id = ?',
          [url, token, orgId]
        );

        // Create inactive admin user
        logger.info('Creating admin user');
        await transactionDb.execute(
          `INSERT INTO users (
            email,
            organization_id,
            is_admin,
            is_agent,
            is_active,
            first_name,
            last_name,
            created_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            data.adminEmail,
            orgId,
            1, // is_admin
            0, // is_agent
            1, // is_active
            data.adminFirstName,
            data.adminLastName,
            new Date().toISOString()
          ]
        );

        return orgId;
      });

      // Generate and send magic link outside the transaction
      logger.info('Generating magic link');
      const magicLink = await auth.createMagicLink(
        data.adminEmail, 
        slug,
        {
          redirectUrl: '/choose-plan',
          orgId,
          name: `${data.adminFirstName} ${data.adminLastName}`
        }
      );

      logger.info(`Magic link generated successfully: ${magicLink}`);
      await sendMagicLink({
        email: data.adminEmail,
        magicLink,
        name: `${data.adminFirstName} ${data.adminLastName}`
      });

      logger.info('Magic link email sent successfully');
      set.status = 201;
      return { 
        success: true,
        message: 'Please check your email to verify your account'
      };

    } catch (error) {
      logger.error(`Organization creation error: ${error}`);
      set.status = 400;
      return {
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Failed to create organization. Please try again.'
      };
    }
  })
  .get('/organizations/check-name/:name', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedName = decodeURIComponent(params.name);
      const potentialSlug = decodedName
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');

      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [decodedName, potentialSlug]
      );

      const count = existingOrg[0]?.count || 0;

      if (count > 0) {
        return {
          available: false,
          message: 'Organization name is already taken'
        };
      }

      // Validate name format
      if (!/^[a-zA-Z0-9\s\-_.]+$/.test(decodedName)) {
        return {
          available: false,
          message: 'Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores'
        };
      }

      return {
        available: true,
        message: 'Organization name is available'
      };

    } catch (error) {
      logger.error(`Error checking organization name: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check organization name'
      };
    }
  })
  .get('/organizations/check-email/:email', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedEmail = decodeURIComponent(params.email);
      
      // Basic email format validation
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(decodedEmail)) {
        return {
          available: false,
          message: 'Invalid email format'
        };
      }

      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE email = ?',
        [decodedEmail]
      );

      const count = existingUser[0]?.count || 0;

      if (count > 0) {
        return {
          available: false,
          message: 'This email address is already registered'
        };
      }

      return {
        available: true,
        message: 'Email is available'
      };

    } catch (error) {
      logger.error(`Error checking email: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check email availability'
      };
    }
  })
  .get('/organizations/subscription-tiers', async ({ set }) => {
    try {
      const tiers = [
        {
          id: "basic",
          name: "Basic",
          price: "$99/month",
          agentLimit: 5,
          contactLimit: 100,
          features: ["Basic CRM features", "Email integration", "Contact management"]
        },
        {
          id: "professional",
          name: "Professional",
          price: "$199/month",
          agentLimit: 15,
          contactLimit: 500,
          features: ["All Basic features", "Advanced analytics", "API access"]
        },
        {
          id: "enterprise",
          name: "Enterprise",
          price: "$499/month",
          agentLimit: 50,
          contactLimit: 2000,
          features: ["All Professional features", "Priority support", "Custom integrations"]
        }
      ];

      return { success: true, tiers };
    } catch (error) {
      logger.error(`Error fetching subscription tiers: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to fetch subscription tiers' };
    }
  })
  .post('/organizations/:orgSlug/subscription', async ({ params: { orgSlug }, body, request, set }) => {
    try {
      const db = new Database();

      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request)
      if (!currentUser) {
        set.status = 401
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        }
      }

      // Add more detailed logging
      logger.info('Updating subscription', {
        orgSlug,
        currentUser: currentUser.organization_id,
        requestBody: body
      })

      // First verify this user belongs to the organization they're trying to update
      const orgResult = await db.fetchAll(
        'SELECT id FROM organizations WHERE slug = ?',
        [orgSlug]
      )

      if (!orgResult || orgResult.length === 0) {
        set.status = 404
        return {
          success: false,
          error: 'Organization not found'
        }
      }

      const organizationId = orgResult[0][0]

      // Verify user has permission for this org
      if (organizationId !== currentUser.organization_id) {
        logger.error(`User from org ${currentUser.organization_id} attempted to update org ${organizationId}`)
        set.status = 403
        return {
          success: false,
          error: 'You do not have permission to update this organization'
        }
      }

      // Type assertion for body
      const { tierId } = body as { tierId: string }
      
      // Update subscription using the verified organization ID
      await db.execute(
        `UPDATE organizations 
         SET subscription_tier = ?
         WHERE id = ?`,
        [tierId, organizationId]
      )

      logger.info(`Successfully updated subscription for org ${organizationId} to tier ${tierId}`)

      return {
        success: true,
        message: 'Subscription updated successfully'
      }

    } catch (e) {
      logger.error(`Error updating subscription: ${e}`)
      set.status = 500
      return {
        success: false,
        error: String(e)
      }
    }
  });

================
File: backend/src/routes/settings.ts
================
import { Elysia } from 'elysia';
import { validateSession } from '../services/auth';
import { Database } from '../database';
import { User } from '../types';
import { logger } from '../logger';

interface StateCarrierSetting {
  state: string;
  carrier: string;
  active: boolean;
  targetGI: boolean;
}

interface BaseSettings {
  stateLicenses: string[];
  carrierContracts: string[];
  stateCarrierSettings: StateCarrierSetting[];
  allowAgentSettings: boolean;
  emailSendBirthday: boolean;
  emailSendPolicyAnniversary: boolean;
  emailSendAep: boolean;
  smartSendEnabled: boolean;
}

interface AgentSettingsResponse {
  orgSettings: BaseSettings;
  agentSettings: {
    inheritOrgSettings: boolean;
    settings: BaseSettings;
  } | null;
  canEditOrgSettings: boolean;
}

const defaultSettings: BaseSettings = {
  stateLicenses: [],
  carrierContracts: [],
  stateCarrierSettings: [],
  allowAgentSettings: true,
  emailSendBirthday: true,
  emailSendPolicyAnniversary: true,
  emailSendAep: true,
  smartSendEnabled: false
};

// Helper function to generate default state/carrier settings
function generateDefaultStateCarrierSettings(states: string[], carriers: string[]): StateCarrierSetting[] {
  return states.flatMap(state => 
    carriers.map(carrier => ({
      state,
      carrier,
      active: true,  // Default to active
      targetGI: false  // Default to no GI
    }))
  );
}

export const settingsRoutes = new Elysia()
  .get('/api/settings', async ({ cookie }) => {
    logger.info('GET /api/settings - Starting');
    
    const user = await validateSession(cookie.session);
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization settings
        const orgSettingsRow = await db.fetchOne<{ org_settings: string | null }>(
            'SELECT org_settings FROM organizations WHERE id = ?',
            [user.organization_id]
        );
        
        logger.info(`Retrieved org settings row`);

        // Parse the JSON string into an object
        let orgSettings: BaseSettings;
        try {
            orgSettings = orgSettingsRow?.org_settings 
                ? { ...defaultSettings, ...JSON.parse(orgSettingsRow.org_settings) }
                : { ...defaultSettings };

            // If we have states and carriers but no settings array, generate them
            if (orgSettings.stateLicenses.length > 0 && 
                orgSettings.carrierContracts.length > 0 && 
                !Array.isArray(orgSettings.stateCarrierSettings)) {
                
                logger.info('Generating default state/carrier settings');
                orgSettings.stateCarrierSettings = generateDefaultStateCarrierSettings(
                    orgSettings.stateLicenses,
                    orgSettings.carrierContracts
                );
            }
        } catch (parseError) {
            logger.error(`Error parsing org settings: ${parseError}`);
            orgSettings = { ...defaultSettings };
        }

        // Get agent settings if they exist
        const agentSettingsRow = await db.fetchOne<{ inherit_org_settings: boolean, settings: string | null }>(
            'SELECT inherit_org_settings, settings FROM agent_settings WHERE agent_id = ?',
            [user.id]
        );

        // Parse agent settings
        let agentSettings = null;
        if (agentSettingsRow) {
            try {
                const parsedSettings = agentSettingsRow.settings 
                    ? { ...defaultSettings, ...JSON.parse(agentSettingsRow.settings) }
                    : { ...defaultSettings };

                agentSettings = {
                    inheritOrgSettings: agentSettingsRow.inherit_org_settings,
                    settings: parsedSettings
                };
            } catch (parseError) {
                logger.error(`Error parsing agent settings: ${parseError}`);
            }
        }

        const canEditOrgSettings = user.is_admin;

        const response = {
            success: true,
            orgSettings,  // Now it's already an object, not a string
            agentSettings,
            canEditOrgSettings
        };

        logger.info(`Sending response`);
        return response;

    } catch (error) {
        logger.error(`Error fetching settings: ${error}`);
        return {
            success: false,
            error: 'Failed to load settings'
        };
    }
  })

  .put('/api/settings/:scope', async ({ cookie, body, params }) => {
    const { scope } = params;
    logger.info(`PUT /api/settings/${scope} called`);
    logger.info(`Body type: ${typeof body}`);
    logger.info(`Body content: ${JSON.stringify(body, null, 2)}`);
    
    if (body.settings) {
        logger.info(`Settings type: ${typeof body.settings}`);
        logger.info(`Settings content: ${JSON.stringify(body.settings, null, 2)}`);
    }

    const user = await validateSession(cookie.session);
    logger.info(`User validation result: ${user ? JSON.stringify(user) : 'no user found'}`);
    
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        if (scope === 'org') {
            // Verify admin role for org settings
            if (!user.is_admin) {
                logger.warn(`User ${user.id} attempted to modify org settings but is not an admin`);
                return { success: false, error: 'Only admins can modify organization settings' };
            }

            // If states or carriers changed, regenerate the settings array
            const settings = body.settings || body;
            if (settings.stateCarrierSettings.length === 0) {
                settings.stateCarrierSettings = generateDefaultStateCarrierSettings(
                    settings.stateLicenses,
                    settings.carrierContracts
                );
            }

            let settingsToSave;
            try {
                settingsToSave = JSON.stringify(settings);
                logger.info(`Settings to save (type): ${typeof settingsToSave}`);
                logger.info(`Settings to save (value): ${settingsToSave}`);
                
                // Verify it's valid JSON
                JSON.parse(settingsToSave);
                logger.info('Settings validated as valid JSON');
            } catch (jsonError) {
                logger.error(`JSON processing error: ${jsonError}`);
                throw jsonError;
            }

            try {
                logger.info(`Executing DB update for org ${user.organization_id}`);
                logger.info(`First parameter type: ${typeof settingsToSave}`);
                logger.info(`First parameter value: ${settingsToSave}`);
                logger.info(`Second parameter type: ${typeof user.organization_id}`);
                logger.info(`Second parameter value: ${user.organization_id}`);

                await db.execute(
                    'UPDATE organizations SET org_settings = ? WHERE id = ?',
                    [settingsToSave, user.organization_id]
                );
                logger.info('Organization settings updated successfully');
            } catch (dbError) {
                logger.error(`Database execute error details: ${JSON.stringify(dbError, null, 2)}`);
                logger.error(`Database error name: ${dbError.name}`);
                logger.error(`Database error message: ${dbError.message}`);
                if (dbError.stack) {
                    logger.error(`Database error stack: ${dbError.stack}`);
                }
                throw dbError;
            }
        } else if (scope === 'agent') {
            logger.info('Updating agent settings');
            logger.info(`Agent settings body: ${JSON.stringify(body, null, 2)}`);

            try {
                await db.execute(`
                    INSERT INTO agent_settings (agent_id, inherit_org_settings, settings)
                    VALUES (?, ?, ?)
                    ON CONFLICT (agent_id) DO UPDATE
                    SET inherit_org_settings = ?, settings = ?`,
                    [
                        user.id,
                        body.inheritOrgSettings,
                        JSON.stringify(body.settings),
                        body.inheritOrgSettings,
                        JSON.stringify(body.settings)
                    ]
                );
                logger.info('Agent settings updated successfully');
            } catch (dbError) {
                logger.error(`Database execute error details: ${JSON.stringify(dbError, null, 2)}`);
                throw dbError;
            }
        }

        return {
            success: true,
            settings: body.settings || body
        };
    } catch (error) {
        logger.error(`Error updating settings: ${error}`);
        logger.error(`Error stack: ${error.stack}`);
        return {
            success: false,
            error: 'Failed to update settings'
        };
    }
  })

  // Update the GI recommendations endpoint to use Elysia style
  .get('/api/settings/gi-recommendations', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const recommendations = await db.fetchAll<{ state: string; carrier: string }>(
        `SELECT state, carrier
         FROM guaranteed_issue_recommendations
         ORDER BY carrier, state`
      );

      // Transform the results to match the expected format
      const formattedRecommendations = recommendations.map(rec => ({
        state: rec.state,
        carrier: rec.carrier,
        active: true,
        targetGI: true
      }));

      return formattedRecommendations;

    } catch (error) {
      logger.error('Error fetching GI recommendations:', error);
      return { success: false, error: 'Failed to fetch GI recommendations' };
    }
  })

  // Update carriers endpoint to use Elysia style
  .get('/api/settings/carriers', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll<{ name: string }>(
        `SELECT name
         FROM carriers
         ORDER BY name`
      );

      return carriers;

    } catch (error) {
      logger.error('Error fetching carriers:', error);
      return { success: false, error: 'Failed to fetch carriers' };
    }
  })

  .get('/api/settings/carriers-with-aliases', async ({ cookie }) => {
    const user = await validateSession(cookie.session);
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll<{ name: string, aliases: string | null }>(
        `SELECT name, aliases
         FROM carriers
         ORDER BY name`
      );

      return carriers.map(carrier => ({
        name: carrier.name,
        aliases: carrier.aliases ? JSON.parse(carrier.aliases) : []
      }));

    } catch (error) {
      logger.error('Error fetching carriers with aliases:', error);
      return { success: false, error: 'Failed to fetch carriers with aliases' };
    }
  });

================
File: backend/src/services/agentSettings.ts
================
import { db } from '../database';
import { NotFoundError } from '../errors';
import { logger } from '../logger';

export interface StateCarrierSetting {
  active: boolean;
  targetGI: boolean;
}

export interface AgentSettings {
  id: number;
  agentId: number;
  stateLicenses: string[];
  carrierContracts: string[];
  stateCarrierSettings: {
    [state: string]: {
      [carrier: string]: StateCarrierSetting;
    };
  };
  emailSendBirthday: boolean;
  emailSendPolicyAnniversary: boolean;
  emailSendAep: boolean;
  smartSendEnabled: boolean;
}

export async function getAgentSettings(agentId: number): Promise<AgentSettings> {
  try {
    const result = await db.oneOrNone(
      'SELECT * FROM agent_settings WHERE agent_id = $1',
      [agentId]
    )

    if (!result) {
      // Return default settings instead of creating them
      return {
        id: 0,
        agentId: agentId,
        stateLicenses: [],
        carrierContracts: [],
        stateCarrierSettings: {},
        emailSendBirthday: false,
        emailSendPolicyAnniversary: false,
        emailSendAep: false,
        smartSendEnabled: false
      }
    }

    return {
      id: result.id,
      agentId: result.agent_id,
      stateLicenses: result.state_licenses || [],
      carrierContracts: result.carrier_contracts || [],
      stateCarrierSettings: result.state_carrier_settings || {},
      emailSendBirthday: result.email_send_birthday || false,
      emailSendPolicyAnniversary: result.email_send_policy_anniversary || false,
      emailSendAep: result.email_send_aep || false,
      smartSendEnabled: result.smart_send_enabled || false,
    }
  } catch (error) {
    logger.error(`Error fetching agent settings: ${error}`)
    // Return default settings on error
    return {
      id: 0,
      agentId: agentId,
      stateLicenses: [],
      carrierContracts: [],
      stateCarrierSettings: {},
      emailSendBirthday: false,
      emailSendPolicyAnniversary: false,
      emailSendAep: false,
      smartSendEnabled: false
    }
  }
}

async function createDefaultSettings(agentId: number): Promise<AgentSettings> {
  const result = await db.one(
    `INSERT INTO agent_settings 
     (agent_id, state_licenses, carrier_contracts, state_carrier_settings)
     VALUES ($1, $2, $3, $4)
     RETURNING *`,
    [agentId, [], [], {}]
  );

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

export async function updateAgentSettings(
  agentId: number,
  settings: Partial<AgentSettings>
): Promise<AgentSettings> {
  const result = await db.oneOrNone(
    `UPDATE agent_settings
     SET state_licenses = COALESCE($1, state_licenses),
         carrier_contracts = COALESCE($2, carrier_contracts),
         state_carrier_settings = COALESCE($3, state_carrier_settings),
         email_send_birthday = COALESCE($4, email_send_birthday),
         email_send_policy_anniversary = COALESCE($5, email_send_policy_anniversary),
         email_send_aep = COALESCE($6, email_send_aep),
         smart_send_enabled = COALESCE($7, smart_send_enabled)
     WHERE agent_id = $8
     RETURNING *`,
    [
      settings.stateLicenses,
      settings.carrierContracts,
      settings.stateCarrierSettings,
      settings.emailSendBirthday,
      settings.emailSendPolicyAnniversary,
      settings.emailSendAep,
      settings.smartSendEnabled,
      agentId,
    ]
  );

  if (!result) {
    throw new NotFoundError('Agent settings not found');
  }

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

================
File: backend/src/services/auth.ts
================
import crypto from 'crypto';
import { logger } from '../logger';
import { db } from '../database';
import { Database } from '../database';
import type { User } from '../types';

const algorithm = "aes-256-gcm";
const IV_LENGTH = 12;
const UTF8 = "utf8";
const HEX = "hex";

// Initialize encryption key
let secret = process.env.MAGIC_LINK_SECRET;
if (!secret) {
  if (process.env.NODE_ENV === "production") {
    throw new Error("Must set MAGIC_LINK_SECRET in production");
  }
  secret = "dev-secret-key";
}

const ENCRYPTION_KEY = crypto.scryptSync(secret, "salt", 32);

interface MagicLinkPayload {
  email: string;
  organizationSlug: string;
  expiresAt: number;
  redirectUrl: string;
  orgId?: number;
  name?: string;
}

export class AuthService {
  constructor(private baseUrl: string) {
    // Ensure baseUrl doesn't end with a slash
    this.baseUrl = baseUrl.replace(/\/$/, '');
  }

  async createMagicLink(
    email: string, 
    organizationSlug: string, 
    options?: { 
      redirectUrl?: string;
      orgId?: number;
      name?: string;
    }
  ): Promise<string> {
    const payload: MagicLinkPayload = {
      email,
      organizationSlug,
      expiresAt: Date.now() + (30 * 60 * 1000), // 30 minutes
      redirectUrl: options?.redirectUrl || '/dashboard',
      ...(options?.orgId && { orgId: options.orgId }),
      ...(options?.name && { name: options.name })
    };

    logger.info(`Creating magic link with payload: ${JSON.stringify(payload)}`);
    const token = this.encrypt(JSON.stringify(payload));
    // URL encode the entire token
    const encodedToken = encodeURIComponent(token);
    logger.info(`Generated magic link token: ${token}`);
    return `${this.baseUrl}/auth/verify/${organizationSlug}/${encodedToken}`;
  }

  async verifyMagicLink(token: string, organizationSlug: string): Promise<{
    valid: boolean;
    email?: string;
    redirectUrl?: string;
  }> {
    try {
      logger.info('Starting magic link verification');
      logger.info(`Organization slug: ${organizationSlug}`);

      const decodedToken = decodeURIComponent(token);
      const decrypted = this.decrypt(decodedToken);
      const payload: MagicLinkPayload = JSON.parse(decrypted);

      // Verify organization and expiration
      if (payload.organizationSlug !== organizationSlug) {
        logger.error(`Organization slug mismatch: ${payload.organizationSlug} !== ${organizationSlug}`);
        return { valid: false };
      }

      if (payload.expiresAt < Date.now()) {
        logger.error(`Token expired: ${new Date(payload.expiresAt)} < ${new Date()}`);
        return { valid: false };
      }

      // No need to check agent status here since we only send links to valid agents

      logger.info('Verification successful, returning payload');
      return {
        valid: true,
        email: payload.email,
        redirectUrl: payload.redirectUrl
      };

    } catch (error) {
      logger.error(`Magic link verification failed: ${error}`);
      return { valid: false };
    }
  }

  private encrypt(text: string): string {
    try {
      const iv = crypto.randomBytes(IV_LENGTH);
      const cipher = crypto.createCipheriv(algorithm, ENCRYPTION_KEY, iv);
      let encrypted = cipher.update(text, UTF8, HEX);
      encrypted += cipher.final(HEX);
      const authTag = cipher.getAuthTag();
      
      const token = `${iv.toString(HEX)}:${authTag.toString(HEX)}:${encrypted}`;
      return token;
    } catch (error) {
      logger.error(`Encryption failed: ${error}`);
      throw error;
    }
  }

  private decrypt(text: string): string {
    try {
      const [ivPart, authTagPart, encryptedText] = text.split(":");
      if (!ivPart || !authTagPart || !encryptedText) {
        throw new Error("Invalid token format - missing parts");
      }

      logger.info('Decrypting token parts:');
      logger.info(`IV length: ${ivPart.length}`);
      logger.info(`Auth tag length: ${authTagPart.length}`);
      logger.info(`Encrypted text length: ${encryptedText.length}`);

      const iv = Buffer.from(ivPart, HEX);
      const authTag = Buffer.from(authTagPart, HEX);
      const decipher = crypto.createDecipheriv(algorithm, ENCRYPTION_KEY, iv);
      decipher.setAuthTag(authTag);
      let decrypted = decipher.update(encryptedText, HEX, UTF8);
      decrypted += decipher.final(UTF8);
      return decrypted;
    } catch (error) {
      logger.error(`Decryption failed: ${error}`);
      throw error;
    }
  }
}

export async function validateSession(sessionId: string): Promise<User | null> {
  logger.info(`Validating session: ${sessionId}`);
  
  const db = new Database();

  // Get the session
  const session = await db.fetchOne<{
    id: string;
    user_id: number;
    expires_at: string;
  }>('SELECT * FROM sessions WHERE id = ?', [sessionId]);

  logger.info(`Session lookup result: ${session ? JSON.stringify(session) : 'not found'}`);

  if (!session) {
    logger.warn('No session found in database');
    return null;
  }

  // Check if session is expired
  const expiresAt = new Date(session.expires_at);
  const now = new Date();
  logger.info(`Session expires: ${expiresAt}, current time: ${now}`);

  if (expiresAt < now) {
    logger.warn('Session is expired');
    await db.execute('DELETE FROM sessions WHERE id = ?', [sessionId]);
    return null;
  }

  // Get the user associated with this session with updated columns
  const user = await db.fetchOne<User>(
    `SELECT 
      u.id,
      u.email,
      u.organization_id,
      u.is_admin,
      u.is_agent,
      u.first_name,
      u.last_name,
      u.is_active,
      u.phone,
      o.name as organization_name 
     FROM users u
     JOIN organizations o ON u.organization_id = o.id 
     WHERE u.id = ?`,
    [session.user_id]
  );

  logger.info(`User lookup result: ${user ? JSON.stringify(user) : 'not found'}`);

  return user;
}

export function generateToken(): string {
  return crypto.randomBytes(32).toString('hex');
}

export async function getUserFromSession(request: Request) {
  try {
    // Get session cookie
    const sessionId = request.headers.get('cookie')?.split('session=')[1]?.split(';')[0];
    
    if (!sessionId) {
      logger.warn('No session cookie found');
      return null;
    }

    // Initialize database
    const db = new Database();

    // Get session data
    const sessionResult = await db.fetchAll(
      'SELECT user_id FROM sessions WHERE id = ?',
      [sessionId]
    );

    if (!sessionResult || sessionResult.length === 0) {
      logger.warn(`No session found for ID: ${sessionId}`);
      return null;
    }

    const userId = sessionResult[0][0];

    // Updated query to use is_admin and is_agent
    const userResult = await db.fetchAll(
      `SELECT 
        u.id,
        u.email,
        u.organization_id,
        u.is_admin,
        u.is_agent,
        u.first_name,
        u.last_name,
        u.is_active,
        u.phone,
        o.name as organization_name
       FROM users u
       JOIN organizations o ON u.organization_id = o.id 
       WHERE u.id = ?`,
      [userId]
    );

    if (!userResult || userResult.length === 0) {
      logger.warn('No user found for session');
      return null;
    }

    const user = {
      id: userResult[0][0],
      email: userResult[0][1],
      organization_id: userResult[0][2],
      is_admin: Boolean(userResult[0][3]),
      is_agent: Boolean(userResult[0][4]),
      first_name: userResult[0][5],
      last_name: userResult[0][6],
      is_active: userResult[0][7],
      phone: userResult[0][8],
      organization_name: userResult[0][9]
    };

    return user;

  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

================
File: backend/src/services/email.ts
================
import sgMail from '@sendgrid/mail';
import { logger } from '../logger';

interface MagicLinkEmailParams {
  email: string;
  token: string;
  orgId: number;
  name: string;
}

export class EmailService {
  constructor() {
    if (!process.env.SENDGRID_API_KEY) {
      throw new Error('Missing SENDGRID_API_KEY environment variable');
    }
    sgMail.setApiKey(process.env.SENDGRID_API_KEY);
  }

  async sendMagicLink(email: string, magicLink: string, organizationSlug: string) {
    // In development, just log the magic link
    if (process.env.NODE_ENV === 'development') {
      logger.info('=======================================');
      logger.info('Magic Link Email would be sent to:', email);
      logger.info('Organization:', organizationSlug);
      logger.info('Link:', magicLink);
      logger.info('=======================================');
      return;
    }

    // TODO: Implement actual email sending in production
    // You would integrate with your email service here (SendGrid, AWS SES, etc.)
    throw new Error('Email sending not implemented in production');
  }
}

// For the organization signup flow
export async function sendMagicLink({ email, magicLink, name }: {
  email: string;
  magicLink: string;
  name: string;
}) {
  try {
    logger.info('Attempting to send magic link email', { email, name });
    
    if (process.env.NODE_ENV === 'development') {
      logger.info('=======================================');
      logger.info('Organization Verification Email');
      logger.info('To:', email);
      logger.info('Name:', name);
      logger.info('Magic Link:', magicLink);
      logger.info('=======================================');
      return;
    }

    // TODO: Add production email sending
    logger.info('Email sending would happen here in production');
    return;
  } catch (error) {
    logger.error('Failed to send magic link email:', error);
    if (error instanceof Error) {
      logger.error('Error details:', error.message);
    }
    throw error;
  }
}

================
File: backend/src/services/turso.ts
================
import { createClient } from '@libsql/client';
import { TURSO_CONFIG } from '../config/turso';

export class TursoService {
  private headers = {
    'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
    'Content-Type': 'application/json'
  };

  async createOrganizationDatabase(orgId: string): Promise<{url: string, token: string}> {
    const dbName = `org-${orgId}`;

    // Create database using Turso API
    const createDbResponse = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, 
      {
        method: 'POST',
        headers: this.headers,
        body: JSON.stringify({
          name: dbName,
          group: TURSO_CONFIG.GROUP_NAME
        })
      }
    );

    if (!createDbResponse.ok) {
      throw new Error(`Failed to create database: ${await createDbResponse.text()}`);
    }

    const dbData = await createDbResponse.json();
    
    // Generate auth token for the database
    const tokenResponse = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}/auth/tokens`,
      {
        method: 'POST',
        headers: this.headers
      }
    );

    if (!tokenResponse.ok) {
      throw new Error(`Failed to create auth token: ${await tokenResponse.text()}`);
    }

    const tokenData = await tokenResponse.json();

    // Initialize database client and create schema
    const client = createClient({
      url: `https://${dbData.database.Hostname}`,
      authToken: tokenData.jwt
    });

    await client.execute(`
      CREATE TABLE contacts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        first_name TEXT NOT NULL,
        last_name TEXT NOT NULL,
        email TEXT NOT NULL,
        current_carrier TEXT NOT NULL,
        plan_type TEXT NOT NULL,
        effective_date TEXT NOT NULL,
        birth_date TEXT NOT NULL,
        tobacco_user BOOLEAN NOT NULL,
        gender TEXT NOT NULL,
        state TEXT NOT NULL,
        zip_code TEXT NOT NULL,
        agent_id INTEGER,
        last_emailed TEXT,
        phone_number TEXT NOT NULL DEFAULT '',
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
      )
    `);

    return {
      url: `https://${dbData.database.Hostname}`,
      token: tokenData.jwt
    };
  }

  async deleteOrganizationDatabase(dbName: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}`,
      {
        method: 'DELETE',
        headers: this.headers
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete database: ${await response.text()}`);
    }
  }
}

================
File: backend/src/config.ts
================
import { config as dotenvConfig } from 'dotenv'
import { resolve } from 'path'
import { logger } from './logger'
import { existsSync } from 'fs'

// Get absolute path to .env file
const envPath = resolve(__dirname, '../.env')

// Check if .env file exists
if (!existsSync(envPath)) {
  console.error(`âŒ .env file not found at: ${envPath}`)
  process.exit(1)
}

// Load .env file with override option
const result = dotenvConfig({ 
  path: envPath,
  override: true // This tells dotenv to override existing env vars
})

if (result.error) {
  console.error('âŒ Error loading .env file:', result.error)
  process.exit(1)
}

// Debug: Print raw env file path and contents
console.log('ðŸ“ Loading .env from:', envPath)
console.log('ðŸ“ Environment variables loaded:', {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN ? '[PRESENT]' : '[MISSING]',
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH
})

export const config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  // Add other config values here
}

// Log loaded config (safely)
logger.info(`Config loaded from ${envPath}`)

================
File: backend/src/database.ts
================
import { createClient } from '@libsql/client'
import { config } from './config'
import { logger } from './logger'

export class Database {
  private client: any
  private url: string

  constructor(dbUrl?: string, authToken?: string) {
    const url = dbUrl || config.TURSO_DATABASE_URL
    const token = authToken || config.TURSO_AUTH_TOKEN

    if (!url || !token) {
      logger.error('Missing database credentials')
      throw new Error('Missing database credentials')
    }

    this.url = url
    this.client = createClient({
      url: url,
      authToken: token,
    })
    
    logger.info(`Database connected to: ${this.url}`)
  }

  static async getOrgDb(orgId: string): Promise<Database> {
    try {
      // Use main DB to get org's Turso credentials
      const mainDb = new Database()
      const org = await mainDb.fetchOne<{turso_db_url: string, turso_auth_token: string}>(
        'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
        [orgId]
      )

      if (!org?.turso_db_url || !org?.turso_auth_token) {
        logger.error(`No Turso credentials found for org ${orgId}`)
        throw new Error('Organization database not configured')
      }

      logger.info(`Creating client for org ${orgId} database: ${org.turso_db_url}`)
      return new Database(org.turso_db_url, org.turso_auth_token)
    } catch (error) {
      logger.error(`Failed to get org database: ${error}`)
      throw error
    }
  }

  getClient() {
    return this.client
  }

  async execute(sql: string, args: any[] = []) {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result
    } catch (error) {
      logger.error(`Database execute error: ${error}`)
      throw error
    }
  }

  async fetchAll(sql: string, args: any[] = []) {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result.rows || []
    } catch (error) {
      logger.error(`Database fetchAll error: ${error}`)
      throw error
    }
  }

  async fetchOne<T>(sql: string, args: any[] = []): Promise<T | null> {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      if (!result.rows || result.rows.length === 0) {
        return null
      }
      // Convert array row to object using column names
      const row = result.rows[0]
      const columns = result.columns || []
      const obj: any = {}
      columns.forEach((col: string, i: number) => {
        obj[col] = row[i]
      })
      return obj as T
    } catch (error) {
      logger.error(`Database fetchOne error: ${error}`)
      throw error
    }
  }

  // Compatibility method for old query interface
  async query<T = any>(sql: string, args: any[] = []): Promise<T[]> {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result.rows || []
    } catch (error) {
      logger.error(`Database query error: ${error}`)
      throw error
    }
  }

  // Transaction support with function overloads
  async transaction<T>(callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(mode: 'read' | 'write', callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(
    callbackOrMode: ((tx: Database) => Promise<T>) | 'read' | 'write',
    callback?: (tx: Database) => Promise<T>
  ): Promise<T> {
    let mode: 'read' | 'write' = 'write'
    let fn: ((tx: Database) => Promise<T>) | null = null

    if (typeof callbackOrMode === 'string') {
      mode = callbackOrMode
      fn = callback || null
    } else {
      fn = callbackOrMode
    }
    
    if (!fn) {
      throw new Error('Transaction callback is required')
    }

    const tx = await this.client.transaction(mode)
    try {
      // Create a Database-like wrapper around the transaction
      const txWrapper = new Database()
      // Override the client with the transaction
      txWrapper.client = tx
      
      const result = await fn(txWrapper)
      await tx.commit()
      return result
    } catch (error) {
      await tx.rollback()
      throw error
    }
  }
}

export const db = new Database()

================
File: backend/src/errors.ts
================
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'NotFoundError'
  }
}

export class UnauthorizedError extends Error {
  constructor(message: string = 'Unauthorized') {
    super(message)
    this.name = 'UnauthorizedError'
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'ValidationError'
  }
}

export class DatabaseError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'DatabaseError'
  }
}

================
File: backend/src/index.ts
================
import { Elysia, t } from 'elysia'
import { cors } from '@elysiajs/cors'
import { Database } from './database'
import { logger } from './logger'
import type { ContactCreate, AgentCreate } from './types'
import { readFileSync } from 'fs'
import { staticPlugin } from '@elysiajs/static'
import { parse as csvParse } from 'csv-parse/sync'
import { Readable } from 'stream'
import { Buffer } from 'buffer'
import { createAuthRoutes } from './routes/auth'
import { settingsRoutes } from './routes/settings'
import { organizationRoutes } from './routes/organizations'
import { createBrandRoutes } from './routes/brand'
import { errorHandler } from './middleware/error'
import { getUserFromSession } from './services/auth'

// At the top of the file, add interface for ZIP data
interface ZipInfo {
  state: string;
  // Add other ZIP info properties as needed
}

// Update ZIP_DATA declaration
let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'))
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}

// Add with the other type imports
type NewAgentRequest = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

type AgentUpdate = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

interface DbRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  phone: string | null;
  is_admin: number;
  is_agent: number;
  settings: string | null;
}

// Add at the top with other interfaces
interface ContactRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  current_carrier: string;
  plan_type: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: number;
  gender: string;
  state: string;
  zip_code: string;
  agent_id: number | null;
  last_emailed: string | null;
  phone_number: string;
}

interface CarrierRow {
  name: string;
  aliases: string | null;
}

// Add this helper function before startServer
function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
  const digits = phone.replace(/\D/g, '').slice(0, 10);
  return {
    isValid: digits.length === 10,
    standardized: digits
  };
}

// Add this helper function near the other validation functions
function validateEmail(email: string): boolean {
  // RFC 5322 compliant email regex
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  return emailRegex.test(email.trim());
}

// Add this helper function near the other validation functions
function validateISODate(dateStr: string): { isValid: boolean; isoDate: string | null } {
  try {
    const trimmed = dateStr.trim();
    
    // Try to parse the date - will throw if invalid
    const date = new Date(trimmed);
    
    // Check if date is invalid
    if (isNaN(date.getTime())) {
      return { isValid: false, isoDate: null };
    }
    
    // Convert to ISO format (YYYY-MM-DD)
    const isoDate = date.toISOString().split('T')[0];
    
    // Verify the date is not in the future
    if (date > new Date()) {
      return { isValid: false, isoDate: null };
    }
    
    return { isValid: true, isoDate };
  } catch (e) {
    return { isValid: false, isoDate: null };
  }
}

// Add this helper function near the other validation functions
async function validateCarrier(carrier: string, db: Database): Promise<{ isValid: boolean; standardizedName: string; wasConverted: boolean }> {
  try {
    // Trim and standardize input
    const trimmedCarrier = carrier.trim();
    logger.info(`Validating carrier: "${trimmedCarrier}"`);
    
    // Create a new instance of the central database
    const centralDb = new Database();
    
    // Get all carriers with their aliases from the central database
    const result = await centralDb.execute<CarrierRow>(
      'SELECT name, aliases FROM carriers'
    );
    
    logger.info(`Found ${result.rows.length} carriers in database`);
    
    // Check each carrier and its aliases
    for (const row of result.rows) {
      logger.info(`Checking against carrier: "${row.name}", aliases: ${row.aliases || '[]'}`);
      
      // Check exact name match (case insensitive)
      if (row.name.toLowerCase() === trimmedCarrier.toLowerCase()) {
        logger.info(`Found exact match with carrier: ${row.name}`);
        return { isValid: true, standardizedName: row.name, wasConverted: false };
      }
      
      // Check aliases if they exist
      if (row.aliases) {
        const aliases = JSON.parse(row.aliases);
        logger.info(`Checking aliases for ${row.name}: ${JSON.stringify(aliases)}`);
        if (Array.isArray(aliases) && aliases.some(alias => alias.toLowerCase() === trimmedCarrier.toLowerCase())) {
          logger.info(`Found match in aliases for carrier: ${row.name}`);
          return { isValid: true, standardizedName: row.name, wasConverted: false };
        }
      }
    }
    
    // If no match found, keep the original carrier name but mark as converted
    logger.info(`No matching carrier found for: "${trimmedCarrier}", keeping original name`);
    return { isValid: true, standardizedName: trimmedCarrier, wasConverted: true };
  } catch (e) {
    logger.error(`Error validating carrier: ${e}`);
    return { isValid: true, standardizedName: carrier.trim(), wasConverted: true };
  }
}

const startServer = async () => {
  try {
    const db = new Database()
    logger.info('Database initialized successfully')

    const app = new Elysia()
      .use(cors({
        // In development, allow the Vite dev server origin
        origin: process.env.NODE_ENV === 'development' 
          ? 'http://localhost:5173'
          : false, // Disable CORS in production
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Cookie'],  // Add Cookie to allowed headers
        credentials: true,
        preflight: true
      }))
      // Add explicit OPTIONS handler for preflight
      .options('/api/contacts/:id', ({ set }) => {
        set.headers = {
          'Access-Control-Allow-Origin': 'http://localhost:5173',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Allow-Credentials': 'true'
        }
        return new Response(null, { status: 204 })
      })
      // Log all requests
      .onRequest(({ request: { method, url, headers } }) => {
        const path = new URL(url).pathname
        logger.info(`â®• ${method} ${path}`)
      })
      // Log all responses
      .onResponse((context) => {
        const { request: { method }, path, set } = context
        logger.info(`â¬… ${method} ${path} ${set.status}`)
      })
      // Enhanced error handling
      .onError(({ code, error, request }: {
        code: string;
        error: Error;
        request: { url: string; method: string };
      }) => {
        const path = new URL(request.url).pathname
        const errorMessage = `âŒ ${request.method} ${path} - ${error.message}`
        logger.error(errorMessage)

        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), { 
          status: code === 'NOT_FOUND' ? 404 : 500,
          headers: {
            'Content-Type': 'application/json'
          }
        })
      })
      // Add health check endpoint
      .get('/health', () => ({ status: 'OK' }))
      .get('/api/contacts', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts - Attempting to fetch contacts for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())
          
          // First get all unique carriers and states for filter options
          const [carrierResults, stateResults] = await Promise.all([
            orgDb.fetchAll('SELECT DISTINCT current_carrier FROM contacts WHERE current_carrier IS NOT NULL ORDER BY current_carrier'),
            orgDb.fetchAll('SELECT DISTINCT state FROM contacts WHERE state IS NOT NULL ORDER BY state')
          ])

          const allCarriers = carrierResults.map((row: any[]) => row[0])
          const allStates = stateResults.map((row: any[]) => row[0])
          
          // Get search query and filters from URL params
          const url = new URL(request.url)
          const searchQuery = url.searchParams.get('search') || ''
          const carriers = (url.searchParams.get('carriers') || '').split(',').filter(Boolean)
          const states = (url.searchParams.get('states') || '').split(',').filter(Boolean)
          
          // Build the SQL query with search and filter conditions
          let conditions = []
          let params = []

          // Add search condition if search query exists
          if (searchQuery) {
            conditions.push(`(
              LOWER(first_name) LIKE ? OR 
              LOWER(last_name) LIKE ? OR 
              LOWER(email) LIKE ? OR
              LOWER(current_carrier) LIKE ? OR
              LOWER(state) LIKE ?
            )`)
            const searchTerm = `%${searchQuery.toLowerCase()}%`
            params.push(searchTerm, searchTerm, searchTerm, searchTerm, searchTerm)
          }

          // Add carrier filter if carriers are specified
          if (carriers.length > 0) {
            conditions.push(`current_carrier IN (${carriers.map(() => '?').join(',')})`)
            params.push(...carriers)
          }

          // Add state filter if states are specified
          if (states.length > 0) {
            conditions.push(`state IN (${states.map(() => '?').join(',')})`)
            params.push(...states)
          }

          // Construct the final query
          const query = `
            SELECT * FROM contacts 
            ${conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : ''}
            ORDER BY id DESC
          `
          
          // Execute query with params
          const contacts = await orgDb.fetchAll(query, params)

          if (!contacts || !Array.isArray(contacts)) {
            logger.warn('GET /api/contacts - No contacts found or invalid response')
            return {
              contacts: [],
              filterOptions: {
                carriers: allCarriers,
                states: allStates
              }
            }
          }

          logger.info(`GET /api/contacts - Successfully fetched ${contacts.length} contacts from org database`)

          const mappedContacts = contacts.map(contact => ({
            id: contact[0],
            first_name: contact[1],
            last_name: contact[2],
            email: contact[3],
            current_carrier: contact[4],
            plan_type: contact[5],
            effective_date: contact[6],
            birth_date: contact[7],
            tobacco_user: Boolean(contact[8]),
            gender: contact[9],
            state: contact[10],
            zip_code: contact[11],
            agent_id: contact[12],
            last_emailed: contact[13],
            phone_number: contact[14] || ''
          }))

          logger.info(`GET /api/contacts - Returning ${mappedContacts.length} contacts with ${allCarriers.length} carriers and ${allStates.length} states`)
          return {
            contacts: mappedContacts,
            filterOptions: {
              carriers: allCarriers,
              states: allStates
            }
          }
        } catch (e) {
          logger.error(`Error in GET /api/contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/check-email/:email', async ({ params: { email }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const orgDb = await Database.getOrgDb(user.organization_id.toString())
          
          const result = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          return {
            exists: result !== null
          }
        } catch (e) {
          logger.error(`Error checking email existence: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/:id', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id} - Fetching contact for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())
          
          // Fetch the contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            throw new Error(`Contact ${id} not found`)
          }

          // Return the contact with mapped fields
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error fetching contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .post('/api/contacts', async ({ body, request }: { body: ContactCreate, request: Request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contact = body
          logger.info(`Attempting to create contact for org ${user.organization_id}: ${contact.first_name} ${contact.last_name}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          // Check for existing email
          const existingContact = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [contact.email]
          )

          if (existingContact) {
            throw new Error('A contact with this email already exists')
          }
          
          const query = `
            INSERT INTO contacts (
              first_name, last_name, email, current_carrier, plan_type,
              effective_date, birth_date, tobacco_user, gender,
              state, zip_code, agent_id, phone_number
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `
          
          const params = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            contact.state,
            contact.zip_code,
            contact.agent_id || null,
            contact.phone_number || ''
          ]

          logger.info(`Executing query with params: ${JSON.stringify(params)}`)
          await orgDb.execute(query, params)

          // Fetch the newly created contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE email = ? ORDER BY id DESC LIMIT 1',
            [contact.email]
          )

          if (!result) {
            throw new Error('Failed to fetch created contact')
          }

          // Match response format to schema
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error creating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .put('/api/contacts/:id', async ({ params: { id }, body, request }) => {
        try {
          // Get user and org info
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          const contact = body as ContactCreate
          logger.info(`PUT /api/contacts/${id} - Updating contact for org ${user.organization_id}`)

          // Get state from ZIP code
          const zipInfo = ZIP_DATA[contact.zip_code]
          if (!zipInfo) {
            throw new Error(`Invalid ZIP code: ${contact.zip_code}`)
          }

          // First update the contact
          const updateQuery = /* sql */ `
            UPDATE contacts SET 
              first_name = ?,
              last_name = ?,
              email = ?,
              current_carrier = ?,
              plan_type = ?,
              effective_date = ?,
              birth_date = ?,
              tobacco_user = ?,
              gender = ?,
              state = ?,
              zip_code = ?,
              agent_id = ?,
              phone_number = ?
            WHERE id = ?
          `

          const updateParams = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            zipInfo.state, // Use state from ZIP code
            contact.zip_code,
            contact.agent_id || null,
            contact.phone_number || '',
            id
          ]

          // Execute the update
          await orgDb.execute(updateQuery, updateParams)

          // Then fetch the updated contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            throw new Error(`Contact ${id} not found after update`)
          }

          logger.info(`Successfully updated contact ${id} in org ${user.organization_id}`)

          // Return the updated contact
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number
          }
        } catch (e) {
          logger.error(`Error updating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add DELETE endpoint for contacts
      .delete('/api/contacts', async ({ body, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contactIds = body as number[]
          logger.info(`DELETE /api/contacts - Attempting to delete contacts with IDs: ${contactIds} for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contactIds.map(() => '?').join(',')
          
          const query = `
            DELETE FROM contacts 
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const result = await orgDb.execute(query, contactIds)
          const deletedIds = result.rows?.map(row => row.id) || []

          logger.info(`DELETE /api/contacts - Successfully deleted ${deletedIds.length} contacts from org ${user.organization_id}`)

          return {
            success: true,
            deleted_ids: deletedIds,
            message: `Successfully deleted ${deletedIds.length} contacts`
          }
        } catch (e) {
          logger.error(`Error deleting contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add file upload endpoint
      .post('/api/contacts/upload', async ({ body, request }) => {
        try {
          // Get user and org info
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString())

          // Extract file and overwrite flag from form data
          const formData = body as { file: File, overwrite_duplicates: boolean | string }
          const file = formData.file
          // Convert string 'false'/'true' to boolean
          const overwriteDuplicates = formData.overwrite_duplicates === 'true'

          logger.info(`Initial overwriteDuplicates value: ${overwriteDuplicates}, type: ${typeof overwriteDuplicates}, raw value: ${formData.overwrite_duplicates}`)

          logger.info(`POST /api/contacts/upload - Processing CSV upload with overwriteDuplicates=${overwriteDuplicates}`)

          // Read file contents
          const fileContents = await file.text()
          
          // Parse CSV
          const records = csvParse(fileContents, {
            columns: true,
            skip_empty_lines: true
          })

          // Required fields in desired order
          const requiredFields = [
            'First Name',
            'Last Name',
            'Email',
            'Current Carrier',
            'Plan Type',
            'Effective Date',
            'Birth Date',
            'Tobacco User',
            'Gender',
            'ZIP Code',
            'Phone Number'
          ]

          // Validate headers
          const headers = Object.keys(records[0] || {})
          const missingFields = requiredFields.filter(field => !headers.includes(field))

          // Add this: Get the email column index from headers
          const emailColumnIndex = headers.indexOf('Email')

          if (missingFields.length > 0) {
            return {
              success: false,
              message: `Missing required columns: ${missingFields.join(', ')}`,
              error_csv: null,
              total_rows: 0,
              error_rows: 0,
              valid_rows: 0
            }
          }

          const validRows: any[] = []
          const errorRows: any[] = []
          const paramsList: any[] = []
          const convertedCarrierRows: any[] = []

          // Get existing emails for duplicate checking
          let existingEmails = new Set<string>()
          const emailResults = await orgDb.fetchAll("SELECT email FROM contacts")
          existingEmails = new Set(emailResults.map((row: any[]) => row[0].trim().toLowerCase()))

          logger.info(`Found ${existingEmails.size} existing emails in database`)

          // Validate each row
          for (const [index, row] of records.entries()) {
            const rowNum = index + 2 // Account for header row and 0-based index
            
            // Check for missing values
            const missingValues = requiredFields.filter(field => !row[field]?.trim())
            if (missingValues.length > 0) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Missing values for: ${missingValues.join(', ')}`
              })
              continue
            }

            // Validate email format
            const email = row['Email'].trim().toLowerCase()
            if (!validateEmail(email)) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid email format: ${row['Email']}`
              })
              continue
            }

            // Validate phone number
            const phoneResult = standardizePhoneNumber(row['Phone Number']);
            if (!phoneResult.isValid) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid phone number: ${row['Phone Number']}. Must be exactly 10 digits.`
              })
              continue
            }

            // Validate ZIP code
            const zipCode = row['ZIP Code'].trim()
            const zipInfo = ZIP_DATA[zipCode]
            if (!zipInfo) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid ZIP code: ${zipCode}`
              })
              continue
            }

            // Validate gender
            const gender = row['Gender'].trim().toUpperCase()
            if (!['M', 'F'].includes(gender)) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid gender: ${gender}. Must be 'M' or 'F'`
              })
              continue
            }

            // Check for duplicate email
            logger.info(`Checking row ${rowNum} email: ${email}`)
            logger.info(`Overwrite duplicates is set to: ${overwriteDuplicates}`)
            if (existingEmails.has(email)) {
              logger.info(`Found duplicate email: ${email}`)
              const notOverwrite = !overwriteDuplicates
              logger.info(`Debug - overwriteDuplicates: ${overwriteDuplicates}, !overwriteDuplicates: ${notOverwrite}`)
              if (!overwriteDuplicates) {
                logger.info(`Adding duplicate email to error rows since overwrite is disabled`)
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Email already exists: ${row['Email']}`
                })
                logger.info('Skipping duplicate email')
                continue
              }
              logger.info(`Allowing duplicate email since overwrite is enabled`)
            }

            // Add carrier validation
            const carrierResult = await validateCarrier(row['Current Carrier'], orgDb);
            let carrierNote = null;
            if (carrierResult.wasConverted) {
              carrierNote = {
                Row: rowNum,
                ...row,
                OriginalCarrier: row['Current Carrier']
              };
            }

            try {
              // Validate dates with better error messages
              const effectiveDateResult = validateISODate(row['Effective Date']);
              if (!effectiveDateResult.isValid) {
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Invalid effective date format: ${row['Effective Date']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
                });
                continue;
              }

              const birthDateResult = validateISODate(row['Birth Date']);
              if (!birthDateResult.isValid) {
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Invalid birth date format: ${row['Birth Date']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
                });
                continue;
              }

              const tobaccoUser = ['yes', 'true', '1', 'y'].includes(row['Tobacco User'].trim().toLowerCase())

              paramsList.push([
                row['First Name'].trim(),
                row['Last Name'].trim(),
                email,
                carrierResult.standardizedName,
                row['Plan Type'].trim(),
                effectiveDateResult.isoDate,
                birthDateResult.isoDate,
                tobaccoUser,
                gender,
                zipInfo.state,
                zipCode,
                phoneResult.standardized
              ])
              validRows.push(row)
              
              // If this row had a carrier conversion, track it
              if (carrierNote) {
                convertedCarrierRows.push(carrierNote)
              }
            } catch (e) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: 'Unexpected error processing dates. Please ensure dates are in YYYY-MM-DD format.'
              })
            }
          }

          // Insert valid rows
          let insertedCount = 0
          if (paramsList.length > 0) {
            logger.info(`Processing ${paramsList.length} valid rows with overwriteDuplicates=${overwriteDuplicates}`)
            logger.info(`Debug - overwriteDuplicates value type: ${typeof overwriteDuplicates}`)
            if (overwriteDuplicates) {
              logger.info('Using update/insert logic for duplicates')
              // First update existing records
              const updateQuery = /* sql */ `
                UPDATE contacts SET 
                  first_name = ?,
                  last_name = ?,
                  current_carrier = ?,
                  plan_type = ?,
                  effective_date = ?,
                  birth_date = ?,
                  tobacco_user = ?,
                  gender = ?,
                  state = ?,
                  zip_code = ?
                WHERE LOWER(email) = ?
              `

              for (const params of paramsList) {
                const email = params[2].toLowerCase()
                // Check if email exists
                const existingContact = await orgDb.fetchAll(
                  'SELECT 1 FROM contacts WHERE LOWER(email) = ?',
                  [email]
                )

                if (existingContact.length > 0) {
                  // Update existing contact
                  const updateParams = [
                    params[0], // first_name
                    params[1], // last_name
                    params[3], // current_carrier
                    params[4], // plan_type
                    params[5], // effective_date
                    params[6], // birth_date
                    params[7], // tobacco_user
                    params[8], // gender
                    params[9], // state
                    params[10], // zip_code
                    email     // for WHERE clause
                  ]
                  await orgDb.execute(updateQuery, updateParams)
                } else {
                  // Insert new contact
                  await orgDb.execute(
                    `INSERT INTO contacts (
                      first_name, last_name, email, current_carrier, plan_type,
                      effective_date, birth_date, tobacco_user, gender,
                      state, zip_code, phone_number
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    params
                  )
                }
              }
              insertedCount = paramsList.length
            } else {
              logger.info('Using insert-only logic for non-duplicates')
              // If not overwriting duplicates, only insert non-duplicate rows
              for (const params of paramsList) {
                const email = params[2].toLowerCase()
                // Check if email exists
                const existingContact = await orgDb.fetchAll(
                  'SELECT 1 FROM contacts WHERE LOWER(email) = ?',
                  [email]
                )

                if (existingContact.length === 0) {
                  // Only insert if email doesn't exist
                  await orgDb.execute(
                    `INSERT INTO contacts (
                      first_name, last_name, email, current_carrier, plan_type,
                      effective_date, birth_date, tobacco_user, gender,
                      state, zip_code, phone_number
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    params
                  )
                  insertedCount++
                }
              }
            }
          }

          // Generate error CSV if needed
          let errorCsv = null
          if (errorRows.length > 0) {
            errorCsv = [
              ['Row', ...requiredFields, 'Error'].join(','),
              ...errorRows.map(row => {
                return [
                  row.Row,
                  ...requiredFields.map(field => `"${row[field] || ''}"`),
                  `"${row.Error}"`
                ].join(',')
              })
            ].join('\n')
          }

          // Generate converted carriers CSV if needed
          let convertedCarriersCsv = null;
          if (convertedCarrierRows.length > 0) {
            convertedCarriersCsv = [
              ['Row', ...requiredFields, 'Original Carrier'].join(','),
              ...convertedCarrierRows.map((row: { Row: number; [key: string]: any }) => {
                return [
                  row.Row,
                  ...requiredFields.map(field => `"${row[field] || ''}"`),
                  `"${row.OriginalCarrier}"`
                ].join(',')
              })
            ].join('\n');
          }

          // Get list of supported carriers and their aliases
          const centralDb = new Database();
          const carriersResult = await centralDb.execute(
            'SELECT name, aliases FROM carriers ORDER BY name'
          );
          
          const supportedCarriers = carriersResult.rows.map(row => ({
            name: row.name,
            aliases: row.aliases ? JSON.parse(row.aliases) : []
          }));

          // Create carrier info message
          const carrierInfoMessage = `Supported carriers: ${supportedCarriers.map((c: { name: string; aliases: string[] }) => 
            `${c.name}${c.aliases.length > 0 ? ` (also accepts: ${c.aliases.join(', ')})` : ''}`
          ).join(', ')}`;

          // Create messages array for different types of feedback
          const messages = [];
          
          // Add error message if there are errors
          if (errorRows.length > 0) {
            messages.push(`Found ${errorRows.length} rows with errors. Successfully imported ${insertedCount} rows.`);
          } else {
            messages.push(`Successfully imported ${insertedCount} rows.`);
          }

          // Add carrier conversion message if there were conversions
          if (convertedCarrierRows.length > 0) {
            messages.push(
              `${convertedCarrierRows.length} rows had unrecognized carriers and were marked as "Other". ` +
              `This is normal if these are carriers we don't support. However, please review the carrier conversion CSV ` +
              `to ensure there are no typos or misspellings of supported carriers.`
            );
          }

          // Add supported carriers message
          messages.push(carrierInfoMessage);

          return {
            success: true,
            message: messages.join('\n\n'),
            error_csv: errorCsv,
            converted_carriers_csv: convertedCarriersCsv,
            total_rows: validRows.length + errorRows.length,
            error_rows: errorRows.length,
            valid_rows: insertedCount,
            converted_carrier_rows: convertedCarrierRows.length,
            supported_carriers: supportedCarriers
          }

        } catch (e) {
          logger.error(`Error processing CSV upload: ${e}`)
          return {
            success: false,
            message: String(e),
            error_csv: null,
            converted_carriers_csv: null,
            total_rows: 0,
            error_rows: 0,
            valid_rows: 0,
            converted_carrier_rows: 0,
            supported_carriers: []
          }
        }
      })
      // Add error handler
      .use(errorHandler)
      // Add explicit debug log for auth routes
      .use(app => {
        logger.info('Registering auth routes...')
        return app.use(createAuthRoutes())
      })
      // Add settings routes
      .use(settingsRoutes)
      // Add organization routes
      .use(organizationRoutes)
      // Add brand routes
      .use(createBrandRoutes())
      // In production, serve the frontend static files
      .use(process.env.NODE_ENV === 'production' 
        ? async (app) => {
            const plugin = staticPlugin({
              assets: '../dist',
              prefix: '/'
            })
            return app.use(plugin)
          }
        : (app) => app
      )
      // Add this endpoint within the app definition
      .post('/api/agents', async ({ body, request, set }) => {
        try {
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent: ${newAgent.email} (org: ${currentUser.organization_id})`)

          // Get the libSQL client
          const client = db.getClient()

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: newAgent.stateLicenses,
                carrierContracts: newAgent.carriers,
                stateCarrierSettings: [],
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId}`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add this GET endpoint within the app definition, near the POST /api/agents endpoint
      .get('/api/agents', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Add admin check
          if (!currentUser.is_admin && !request.url.includes('/setup')) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can view agents'
            }
          }

          // Get the libSQL client
          const client = db.getClient()

          // Fetch all agents (users) from the organization along with their settings
          const result = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.first_name,
                u.last_name,
                u.email,
                u.phone,
                u.is_admin,
                u.is_agent,
                a.settings
              FROM users u
              LEFT JOIN agent_settings a ON u.id = a.agent_id
              WHERE u.organization_id = ?
              AND u.is_active = 1
              ORDER BY u.first_name, u.last_name
            `,
            args: [currentUser.organization_id]
          })

          // Map the database results to the expected format
          const agents = result.rows.map((row: DbRow) => {
            const settings = row.settings ? JSON.parse(row.settings) : {
              stateLicenses: [],
              carrierContracts: [],
              stateCarrierSettings: []
            }

            return {
              id: row.id,
              firstName: row.first_name,
              lastName: row.last_name,
              email: row.email,
              phone: row.phone || '',
              is_admin: Boolean(row.is_admin),
              is_agent: Boolean(row.is_agent),
              carriers: settings.carrierContracts || [],
              stateLicenses: settings.stateLicenses || []
            }
          })

          return agents

        } catch (e) {
          logger.error(`Error fetching agents: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Update PUT endpoint for updating agent details - moved here to be with other agent endpoints
      .put('/api/agents/:id', async ({ params, body, request, set }: { 
        params: { id: string }, 
        body: AgentUpdate,
        request: Request,
        set: { status: number }
      }) => {
        console.log('DEBUG: PUT handler hit', { params, path: request.url })
        logger.info(`Starting update for agent ${params.id}`)
        logger.info(`Request body: ${JSON.stringify(body, null, 2)}`)
        
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            logger.error('Authentication failed: No user in session')
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            logger.error(`Authorization failed: User ${currentUser.id} is not an admin`)
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can update agents'
            }
          }

          const agent = body
          logger.info(`Updating agent ${params.id} - Name: ${agent.firstName} ${agent.lastName}, Phone: ${agent.phone}`)

          // Get the libSQL client
          const client = db.getClient()

          // Update user details
          const userUpdateResult = await client.execute({
            sql: `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      is_admin = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`,
            args: [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.is_admin ? 1 : 0,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
          })

          logger.info(`User update result: ${JSON.stringify(userUpdateResult.rows, null, 2)}`)

          if (!userUpdateResult.rows || userUpdateResult.rows.length === 0) {
            logger.error('User update failed: No rows affected')
            throw new Error('User update failed - no rows affected')
          }

          logger.info('User details updated successfully')

          // Update agent settings
          const settings = {
            stateLicenses: agent.stateLicenses,
            carrierContracts: agent.carriers,
            stateCarrierSettings: [],
            emailSendBirthday: false,
            emailSendPolicyAnniversary: false,
            emailSendAep: false,
            smartSendEnabled: false
          }

          logger.info(`Agent settings to update: ${JSON.stringify(settings, null, 2)}`)

          const settingsUpdateResult = await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)
            ON CONFLICT (agent_id) 
            DO UPDATE SET settings = EXCLUDED.settings
            RETURNING *`,
            args: [
              params.id,
              JSON.stringify(settings)
            ]
          })

          logger.info(`Settings update result: ${JSON.stringify(settingsUpdateResult.rows, null, 2)}`)

          if (!settingsUpdateResult.rows || settingsUpdateResult.rows.length === 0) {
            logger.error('Settings update failed: No rows affected')
            throw new Error('Settings update failed - no rows affected')
          }

          logger.info('Settings updated successfully')

          const updatedUser = userUpdateResult.rows[0]
          const updatedSettings = JSON.parse(settingsUpdateResult.rows[0].settings)

          return {
            success: true,
            message: 'Agent updated successfully',
            agent: {
              id: updatedUser.id.toString(),
              firstName: updatedUser.first_name,
              lastName: updatedUser.last_name,
              email: updatedUser.email,
              phone: updatedUser.phone || '',
              is_admin: Boolean(updatedUser.is_admin),
              is_agent: Boolean(updatedUser.is_agent),
              carriers: updatedSettings.carrierContracts,
              stateLicenses: updatedSettings.stateLicenses
            }
          }

        } catch (error: unknown) {
          const dbError = error as Error
          logger.error(`Database error: ${dbError.message}`)
          set.status = 500
          return {
            success: false,
            error: dbError.message
          }
        }
      })
      // Add this endpoint within the app definition
      .get('/api/me', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          logger.info(`GET /api/me - Current user from session: ${JSON.stringify(currentUser)}`)
          
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          // Get user details including agent settings if they exist
          const client = db.getClient()
          const userDetails = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.email,
                u.first_name as firstName,
                u.last_name as lastName,
                u.is_admin,
                u.is_agent,
                u.phone,
                a.settings as agentSettings
              FROM users u
              LEFT JOIN agent_settings a ON a.agent_id = u.id
              WHERE u.id = ?
            `,
            args: [currentUser.id]
          })

          logger.info(`GET /api/me - Raw user details from DB: (omitted)`)

          if (!userDetails.rows[0]) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          const user = userDetails.rows[0]
          const response = {
            success: true,
            user: {
              id: user.id,
              email: user.email,
              firstName: user.firstName,
              lastName: user.lastName,
              is_admin: Boolean(user.is_admin),
              is_agent: Boolean(user.is_agent),
              phone: user.phone || '',
              agentSettings: user.agentSettings ? JSON.parse(user.agentSettings) : null
            }
          }
          logger.info(`GET /api/me - Sending response`)
          return response

        } catch (e) {
          logger.error(`Error fetching current user: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/:redirect', async ({ params, set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for redirect to: ${params.redirect}`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`

          // Handle redirect
          const redirectPath = params.redirect === 'add-agent' ? 'agents/add' : params.redirect
          set.redirect = `/${redirectPath}`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/login', async ({ set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for login page`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add ZIP lookup endpoint
      .get('/api/zip-lookup/:zipCode', ({ params: { zipCode } }) => {
        try {
          const zipInfo = ZIP_DATA[zipCode]
          if (!zipInfo) {
            return {
              success: false,
              error: `Invalid ZIP code: ${zipCode}`
            }
          }
          return {
            success: true,
            ...zipInfo
          }
        } catch (e) {
          logger.error(`Error looking up ZIP code ${zipCode}: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .listen(8000)

    logger.info('Server started on port 8000')
  } catch (error) {
    logger.error(`Error starting server: ${error}`)
    process.exit(1)
  }
}

startServer()

================
File: backend/src/logger.ts
================
export const logger = {
  info: (message: string) => {
    const timestamp = new Date().toISOString()
    console.log(`[${timestamp}] [INFO] ${message}`)
  },
  error: (message: string) => {
    const timestamp = new Date().toISOString()
    console.error(`[${timestamp}] [ERROR] ${message}`)
  },
  warn: (message: string) => {
    const timestamp = new Date().toISOString()
    console.warn(`[${timestamp}] [WARN] ${message}`)
  }
}

================
File: backend/src/types.ts
================
export interface ContactCreate {
  first_name: string
  last_name: string
  email: string
  current_carrier: string
  plan_type: string
  effective_date: string
  birth_date: string
  tobacco_user: boolean
  gender: string
  state: string
  zip_code: string
  agent_id?: number | null
  phone_number: string
}

export interface AgentCreate {
  first_name: string
  last_name: string
  email: string
  phone: string
}

export interface User {
  id: number;
  email: string;
  organization_id: number;
  is_admin: boolean;
  is_agent: boolean;
  is_active: boolean;
  first_name: string;
  last_name: string;
  phone: string;
  organization_name?: string;
}

================
File: frontend/src/Components/ProgressIndicator.elm
================
module Components.ProgressIndicator exposing (Step, view)

import Html exposing (..)
import Html.Attributes exposing (..)


type alias Step =
    { icon : String
    , title : String
    , description : String
    , isCompleted : Bool
    , isActive : Bool
    }


view : List Step -> Html msg
view steps =
    div [ class "fixed left-0 top-0 bottom-0 w-[280px] bg-white border-r border-[#eaecf0]" ]
        [ div [ class "flex flex-col h-full px-8 py-8" ]
            [ -- Logo
              div [ class "mb-14" ]
                [ div [ class "flex items-center" ]
                    [ img
                        [ src "/images/medicare-max-logo.png"
                        , class "h-8 w-auto"
                        , alt "Medicare Max logo"
                        ]
                        []
                    ]
                ]

            -- Steps
            , div [ class "flex-1" ]
                [ div [ class "space-y-7" ] (List.map viewStep steps)
                ]

            -- Help email
            , div [ class "text-sm text-[#667085] flex items-center mt-8" ]
                [ span [ class "mr-2" ] [ text "âœ‰ï¸" ]
                , text "help@medicaremax.com"
                ]
            ]
        ]


viewStep : Step -> Html msg
viewStep step =
    div
        [ class "flex items-start"
        , classList [ ( "opacity-60", not step.isActive && not step.isCompleted ) ]
        ]
        [ div
            [ class "shrink-0 w-8 h-8 rounded-full flex items-center justify-center mr-3 transition-all duration-300"
            , classList
                [ ( "bg-[#03045e] text-white", step.isActive )
                , ( "bg-[#03045e]/90 text-white", step.isCompleted )
                , ( "bg-[#f9fafb] text-[#667085] border border-[#eaecf0]", not step.isActive && not step.isCompleted )
                ]
            ]
            [ span [ class "text-base" ] [ text step.icon ]
            ]
        , div [ class "flex-1" ]
            [ h3
                [ class "text-sm font-medium transition-colors duration-300"
                , classList
                    [ ( "text-[#101828]", step.isActive )
                    , ( "text-[#101828]/90", step.isCompleted )
                    , ( "text-[#667085]", not step.isActive && not step.isCompleted )
                    ]
                ]
                [ text step.title ]
            , p [ class "text-sm text-[#667085] mt-1 leading-relaxed" ]
                [ text step.description ]
            ]
        ]

================
File: frontend/src/Components/SetupLayout.elm
================
module Components.SetupLayout exposing (SetupStep(..), view)

import Components.ProgressIndicator as ProgressIndicator
import Html exposing (..)
import Html.Attributes exposing (..)


type SetupStep
    = PlanSelection
    | OrganizationSetup
    | BrandSetup
    | AgentSetup


type alias StepInfo =
    { step : SetupStep
    , icon : String
    , title : String
    , description : String
    }


view : SetupStep -> List (Html msg) -> Html msg
view currentStep content =
    div [ class "min-h-screen bg-gray-50 flex" ]
        [ viewProgressIndicator currentStep
        , div [ class "flex-1 ml-[280px] pb-24" ]
            [ div [ class "max-w-3xl mx-auto py-6 px-4 sm:px-6 lg:px-8" ]
                content
            ]
        ]


viewProgressIndicator : SetupStep -> Html msg
viewProgressIndicator currentStep =
    let
        steps =
            [ { step = PlanSelection
              , icon = "1"
              , title = "Choose Plan"
              , description = "Select your subscription"
              }
            , { step = OrganizationSetup
              , icon = "2"
              , title = "Organization Settings"
              , description = "Configure your organization"
              }
            , { step = BrandSetup
              , icon = "3"
              , title = "Brand Settings"
              , description = "Style your platform"
              }
            , { step = AgentSetup
              , icon = "4"
              , title = "Add Team Members"
              , description = "Invite your team"
              }
            ]

        makeStep info =
            { icon = info.icon
            , title = info.title
            , description = info.description
            , isCompleted = isStepComplete currentStep info.step
            , isActive = info.step == currentStep
            }
    in
    ProgressIndicator.view (List.map makeStep steps)


isStepComplete : SetupStep -> SetupStep -> Bool
isStepComplete currentStep step =
    case ( currentStep, step ) of
        ( PlanSelection, _ ) ->
            False

        ( OrganizationSetup, PlanSelection ) ->
            True

        ( OrganizationSetup, _ ) ->
            False

        ( BrandSetup, AgentSetup ) ->
            False

        ( BrandSetup, _ ) ->
            True

        ( AgentSetup, _ ) ->
            True

================
File: frontend/src/AddAgent.elm
================
module AddAgent exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Components.ProgressIndicator
import Components.SetupLayout as SetupLayout
import Debug
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Parser exposing ((|.), (|=), Parser, chompIf, chompWhile, end, succeed, symbol)
import StateRegions exposing (Region(..), getRegionStates, regionToString)
import Svg exposing (path, svg)
import Svg.Attributes exposing (d, fill, viewBox)
import Time



-- Constants


allStates : List String
allStates =
    [ "AL"
    , "AK"
    , "AZ"
    , "AR"
    , "CA"
    , "CO"
    , "CT"
    , "DE"
    , "FL"
    , "GA"
    , "HI"
    , "ID"
    , "IL"
    , "IN"
    , "IA"
    , "KS"
    , "KY"
    , "LA"
    , "ME"
    , "MD"
    , "MA"
    , "MI"
    , "MN"
    , "MS"
    , "MO"
    , "MT"
    , "NE"
    , "NV"
    , "NH"
    , "NJ"
    , "NM"
    , "NY"
    , "NC"
    , "ND"
    , "OH"
    , "OK"
    , "OR"
    , "PA"
    , "RI"
    , "SC"
    , "SD"
    , "TN"
    , "TX"
    , "UT"
    , "VT"
    , "VA"
    , "WA"
    , "WV"
    , "WI"
    , "WY"
    , "DC"
    ]


allCarriers : List String
allCarriers =
    [ "Aetna"
    , "Humana"
    , "UnitedHealthcare"
    , "Cigna"
    , "Aflac"
    , "Allstate"
    , "Mutual of Omaha"
    , "Ace Chubb"
    ]


type alias Model =
    { email : String
    , firstName : String
    , lastName : String
    , rawPhone : String
    , displayPhone : String
    , isAdmin : Bool
    , isAgent : Bool
    , carriers : List String
    , stateLicenses : List String
    , error : Maybe String
    , isSetup : Bool
    , key : Nav.Key
    , isLoading : Bool
    , agents : List Agent
    , showAddForm : Bool
    , currentUser : Maybe User
    , isLoadingForAgent : Maybe String
    , orgSettings : Maybe Settings
    , pendingSave : Maybe String
    }


type alias User =
    { id : String
    , email : String
    , firstName : String
    , lastName : String
    , isAdmin : Bool
    , isAgent : Bool
    , phone : String
    }


type alias Agent =
    { id : String
    , firstName : String
    , lastName : String
    , email : String
    , phone : String
    , isAdmin : Bool
    , isAgent : Bool
    , carriers : List String
    , stateLicenses : List String
    , expanded : Bool
    }


type Msg
    = NoOp
    | UpdateEmail String
    | UpdateFirstName String
    | UpdateLastName String
    | UpdatePhone String
    | ToggleAdmin String
    | ToggleAgent String
    | UpdateField String String
    | SaveAgent
    | AgentSaved (Result Http.Error ())
    | NavigateTo String
    | CloseModal
    | ShowModal
    | ToggleCarrier String Bool
    | ToggleState String Bool
    | SelectAllCarriers Bool
    | SelectAllStates Bool
    | DeleteAgent String
    | AgentDeleted (Result Http.Error ())
    | FinishSetup
    | SelectCommonStates Region
    | LoadFromOrg
    | GotOrgSettings (Result Http.Error Settings)
    | AddAnotherAgent
    | CancelAddAgent
    | RemoveAgent String
    | FetchAgents
    | GotAgents (Result Http.Error (List Agent))
    | GotCurrentUser (Result Http.Error CurrentUserResponse)
    | ToggleAgentRole String String
    | UpdateAgentField String String String
    | ToggleAgentExpanded String
    | UpdateAgentCarrier String String Bool
    | UpdateAgentState String String Bool
    | SelectAllStatesForAgent String Bool
    | SelectCommonStatesForAgent String Region
    | LoadFromOrgForAgent String
    | GotOrgSettingsForAgent String (Result Http.Error Settings)
    | SelectAllCarriersForAgent String Bool
    | SaveAgentDetails String
    | AgentDetailsSaved String (Result Http.Error ())
    | DebounceSaveAgent String


type alias CurrentUserResponse =
    { success : Bool
    , user : Maybe User
    }


init : { isSetup : Bool, key : Nav.Key } -> ( Model, Cmd Msg )
init flags =
    ( { email = ""
      , firstName = ""
      , lastName = ""
      , rawPhone = ""
      , displayPhone = ""
      , isAdmin = False
      , isAgent = False
      , carriers = []
      , stateLicenses = []
      , error = Nothing
      , isSetup = flags.isSetup
      , key = flags.key
      , isLoading = False
      , agents = []
      , showAddForm = False
      , currentUser = Nothing
      , isLoadingForAgent = Nothing
      , orgSettings = Nothing
      , pendingSave = Nothing
      }
    , Cmd.batch
        [ fetchAgents
        , fetchCurrentUser
        , Http.get
            { url = "/api/settings"
            , expect = Http.expectJson GotOrgSettings (Decode.field "orgSettings" settingsObjectDecoder)
            }
        ]
    )


view : Model -> Browser.Document Msg
view model =
    { title =
        if model.isSetup then
            "Add Team Members"

        else
            "Manage Agents"
    , body =
        [ if model.isSetup then
            SetupLayout.view SetupLayout.AgentSetup
                [ div [ class "max-w-3xl mx-auto pb-24" ]
                    [ viewSetupHeader model
                    , viewAgentsList model
                    , if model.showAddForm then
                        div [ class "bg-white shadow rounded-lg p-6 space-y-6 mt-6" ]
                            [ viewBasicInfo model
                            , viewWritingNumbers model
                            , viewStateLicenses model
                            ]

                      else
                        viewAddAgentButton
                    ]
                , viewBottomBar model
                ]

          else
            div [ class "min-h-screen bg-gray-50" ]
                [ viewHeader
                , div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 pb-24" ]
                    [ viewAgentsList model
                    , if model.showAddForm then
                        div [ class "bg-white shadow rounded-lg p-6 space-y-6 mt-6" ]
                            [ viewBasicInfo model
                            , viewWritingNumbers model
                            , viewStateLicenses model
                            ]

                      else
                        viewAddAgentButton
                    ]
                , viewBottomBar model
                ]
        ]
    }


viewSetupHeader : Model -> Html Msg
viewSetupHeader model =
    div [ class "mb-8" ]
        [ h1 [ class "text-3xl font-bold text-gray-900" ]
            [ text "Add Your First Agent" ]
        , p [ class "mt-2 text-gray-600" ]
            [ text "Set up your first agent to get started" ]
        ]


viewNormalHeader : Html Msg
viewNormalHeader =
    h1 [ class "text-2xl font-semibold text-gray-900 mb-6" ]
        [ text "Add Agent" ]


viewHeader : Html msg
viewHeader =
    nav [ class "bg-white border-b border-gray-200" ]
        [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
            [ div [ class "flex justify-between h-16" ]
                [ div [ class "flex" ]
                    [ div [ class "flex-shrink-0 flex items-center" ]
                        [ h1 [ class "text-xl font-semibold text-purple-600" ]
                            [ text "Manage Agents" ]
                        ]
                    ]
                ]
            ]
        ]


viewBasicInfo : Model -> Html Msg
viewBasicInfo model =
    div [ class "space-y-6" ]
        [ div [ class "border-b border-gray-200 pb-4" ]
            [ h2 [ class "text-lg font-medium text-gray-900" ]
                [ text "Add New Agent" ]
            , p [ class "mt-1 text-sm text-gray-500" ]
                [ text "Fill in the agent's information below" ]
            ]
        , div [ class "space-y-4" ]
            [ div [ class "grid grid-cols-2 gap-4" ]
                [ div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "First Name" ]
                    , input
                        ([ type_ "text"
                         , class "mt-1 px-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
                         , value
                            (if isAdminBecomingAgent model then
                                case model.currentUser of
                                    Just user ->
                                        user.firstName

                                    Nothing ->
                                        model.firstName

                             else
                                model.firstName
                            )
                         , placeholder "Enter first name"
                         ]
                            ++ (if isAdminBecomingAgent model then
                                    [ disabled True ]

                                else
                                    [ onInput UpdateFirstName ]
                               )
                        )
                        []
                    ]
                , div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Last Name" ]
                    , input
                        ([ type_ "text"
                         , class "mt-1 px-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
                         , value
                            (if isAdminBecomingAgent model then
                                case model.currentUser of
                                    Just user ->
                                        user.lastName

                                    Nothing ->
                                        model.lastName

                             else
                                model.lastName
                            )
                         , placeholder "Enter last name"
                         ]
                            ++ (if isAdminBecomingAgent model then
                                    [ disabled True ]

                                else
                                    [ onInput UpdateLastName ]
                               )
                        )
                        []
                    ]
                ]
            , div [ class "grid grid-cols-2 gap-4" ]
                [ div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Email" ]
                    , input
                        ([ type_ "email"
                         , class "mt-1 px-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
                         , value
                            (if isAdminBecomingAgent model then
                                Maybe.map .email model.currentUser |> Maybe.withDefault ""

                             else
                                model.email
                            )
                         , placeholder "name@example.com"
                         ]
                            ++ (if isAdminBecomingAgent model then
                                    [ disabled True ]

                                else
                                    [ onInput UpdateEmail ]
                               )
                        )
                        []
                    ]
                , div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Phone" ]
                    , input
                        [ type_ "tel"
                        , class "mt-1 px-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
                        , value model.displayPhone
                        , onInput UpdatePhone
                        , placeholder "(555) 555-5555"
                        , disabled (not (isAdminBecomingAgent model))
                        ]
                        []
                    ]
                ]
            , div [ class "mt-4" ]
                [ label [ class "block text-sm font-medium text-gray-700 mb-2" ]
                    [ text "Role" ]
                , div [ class "flex items-center space-x-6" ]
                    [ label [ class "inline-flex items-center" ]
                        [ input
                            [ type_ "checkbox"
                            , class "rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                            , checked model.isAdmin
                            , onClick (ToggleAdmin "")
                            , disabled (not (isAdminBecomingAgent model))
                            ]
                            []
                        , span [ class "ml-2 text-sm text-gray-700" ]
                            [ text "Admin" ]
                        ]
                    , label [ class "inline-flex items-center" ]
                        [ input
                            [ type_ "checkbox"
                            , class "rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                            , checked
                                (if model.showAddForm then
                                    True

                                 else
                                    model.isAgent
                                )
                            , onClick (ToggleAgent "")
                            , disabled (not (isAdminBecomingAgent model))
                            ]
                            []
                        , span [ class "ml-2 text-sm text-gray-700" ]
                            [ text "Agent" ]
                        ]
                    ]
                ]
            ]
        ]


viewWritingNumbers : Model -> Html Msg
viewWritingNumbers model =
    let
        orgCarriers =
            model.orgSettings
                |> Maybe.map .carrierContracts
                |> Maybe.withDefault []
    in
    div [ class "space-y-4" ]
        [ h3 [ class "text-lg font-medium text-gray-900" ]
            [ text "Carriers" ]
        , div [ class "mb-4 space-y-2" ]
            [ div [ class "flex gap-4" ]
                [ div []
                    [ div [ class "text-sm font-medium text-gray-700 mb-2" ]
                        [ text "Batch Select" ]
                    , div [ class "flex gap-2" ]
                        [ button
                            [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50 min-w-[70px] disabled:opacity-50 disabled:cursor-not-allowed"
                            , onClick (SelectAllCarriers True)
                            , disabled (not (isAdminBecomingAgent model))
                            ]
                            [ text "Select All" ]
                        , button
                            [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50 min-w-[70px] disabled:opacity-50 disabled:cursor-not-allowed"
                            , onClick (SelectAllCarriers False)
                            , disabled (not (isAdminBecomingAgent model))
                            ]
                            [ text "Clear All" ]
                        ]
                    ]
                ]
            ]
        ]


viewStateLicenses : Model -> Html Msg
viewStateLicenses model =
    let
        orgStates =
            model.orgSettings
                |> Maybe.map .stateLicenses
                |> Maybe.withDefault []
    in
    div [ class "space-y-4" ]
        [ h3 [ class "text-lg font-medium text-gray-900" ]
            [ text "State Licenses" ]
        , div [ class "mb-4 space-y-2" ]
            [ div [ class "space-y-4" ]
                [ div []
                    [ div [ class "text-sm font-medium text-gray-700 mb-2" ]
                        [ text "Batch Select" ]
                    , div [ class "flex gap-2" ]
                        [ button
                            [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50 min-w-[70px] disabled:opacity-50 disabled:cursor-not-allowed"
                            , onClick (SelectAllStates True)
                            , disabled (not (isAdminBecomingAgent model))
                            ]
                            [ text "Select All" ]
                        , button
                            [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50 min-w-[70px] disabled:opacity-50 disabled:cursor-not-allowed"
                            , onClick (SelectAllStates False)
                            , disabled (not (isAdminBecomingAgent model))
                            ]
                            [ text "Clear All" ]
                        ]
                    ]
                , div []
                    [ div [ class "text-sm font-medium text-gray-700 mb-2" ]
                        [ text "By Region:" ]
                    , div [ class "flex gap-2" ]
                        (List.map
                            (\region ->
                                button
                                    [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                                    , onClick (SelectCommonStates region)
                                    , disabled (not (isAdminBecomingAgent model))
                                    ]
                                    [ text (regionToString region) ]
                            )
                            StateRegions.allRegions
                        )
                    ]
                ]
            ]
        , div [ class "grid grid-cols-6 gap-4" ]
            (List.map
                (\state ->
                    let
                        isEnabled =
                            List.member state orgStates
                    in
                    label
                        [ class "inline-flex items-center"
                        , classList [ ( "opacity-50 cursor-not-allowed", not isEnabled || not (isAdminBecomingAgent model) ) ]
                        ]
                        [ input
                            [ type_ "checkbox"
                            , class "rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                            , checked (List.member state model.stateLicenses)
                            , onCheck (\isChecked -> ToggleState state isChecked)
                            , disabled (not isEnabled || not (isAdminBecomingAgent model))
                            ]
                            []
                        , span [ class "ml-2 text-sm text-gray-700" ]
                            [ text state ]
                        ]
                )
                allStates
            )
        ]


viewAgentsList : Model -> Html Msg
viewAgentsList model =
    div [ class "space-y-8" ]
        [ div [ class "flow-root" ]
            [ if List.isEmpty model.agents && model.error /= Nothing then
                div [ class "text-center py-4" ]
                    [ p [ class "text-red-600" ]
                        [ text (Maybe.withDefault "Failed to load agents" model.error) ]
                    ]

              else
                ul [ class "-my-5 divide-y divide-gray-200" ]
                    (let
                        -- Show admin/admin_agent first, but only once
                        adminAgents =
                            List.filter
                                (\agent ->
                                    (agent.isAdmin || agent.isAgent)
                                        && not (List.any (\a -> a.id == agent.id && a /= agent) model.agents)
                                )
                                model.agents

                        -- Then show regular agents
                        regularAgents =
                            List.filter (\agent -> not agent.isAdmin && agent.isAgent) model.agents
                     in
                     List.map (viewAgentItem model) adminAgents ++ List.map (viewAgentItem model) regularAgents
                    )
            ]
        ]


viewAgentItem : Model -> Agent -> Html Msg
viewAgentItem model agent =
    let
        isCurrentUserAgent =
            case model.currentUser of
                Just user ->
                    user.id == agent.id

                Nothing ->
                    False

        isValid =
            not (String.isEmpty agent.phone)
                && not (String.isEmpty agent.firstName)
                && not (String.isEmpty agent.lastName)
                && not (String.isEmpty agent.email)
                && (agent.isAdmin || agent.isAgent)

        validationIndicator =
            if not isValid then
                span [ class "text-red-500 ml-2" ] [ text "*" ]

            else
                text ""

        formattedPhone =
            formatPhoneNumber (String.filter Char.isDigit agent.phone)
    in
    div [ class "mb-4" ]
        [ div [ class "bg-white border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow duration-200" ]
            [ div
                [ class "p-4"
                ]
                [ div
                    [ class "flex items-center justify-between cursor-pointer"
                    , onClick (ToggleAgentExpanded agent.id)
                    ]
                    [ div [ class "min-w-0" ]
                        [ div [ class "flex items-center" ]
                            [ p [ class "text-sm font-medium text-gray-900 truncate" ]
                                [ text (agent.firstName ++ " " ++ agent.lastName) ]
                            , validationIndicator
                            ]
                        , div [ class "flex flex-col space-y-1" ]
                            [ p [ class "text-sm text-gray-500 truncate" ]
                                [ text agent.email ]
                            , p [ class "text-sm text-gray-500" ]
                                [ text formattedPhone ]
                            ]
                        ]
                    ]
                ]
            , if agent.expanded then
                div [ class "border-t border-gray-200 p-4 bg-gray-50" ]
                    [ viewAgentDetails model agent ]

              else
                text ""
            ]
        ]


viewAgentDetails : Model -> Agent -> Html Msg
viewAgentDetails model agent =
    let
        orgCarriers =
            model.orgSettings
                |> Maybe.map .carrierContracts
                |> Maybe.withDefault []

        orgStates =
            model.orgSettings
                |> Maybe.map .stateLicenses
                |> Maybe.withDefault []

        fieldError field =
            case field of
                "phone" ->
                    String.isEmpty agent.phone

                "firstName" ->
                    String.isEmpty agent.firstName

                "lastName" ->
                    String.isEmpty agent.lastName

                "email" ->
                    String.isEmpty agent.email

                _ ->
                    False

        errorIndicator field =
            if fieldError field then
                span [ class "text-red-500 ml-1" ] [ text "*" ]

            else
                text ""

        isCurrentUserAgent =
            case model.currentUser of
                Just user ->
                    user.id == agent.id

                Nothing ->
                    False

        formattedPhone =
            formatPhoneNumber (String.filter Char.isDigit agent.phone)

        isLoading =
            model.isLoadingForAgent == Just agent.id

        canEdit =
            canModifySettings model agent.id

        hasChanges =
            model.pendingSave == Just agent.id

        isSaving =
            model.isLoadingForAgent == Just agent.id

        onFieldInput : String -> String -> Msg
        onFieldInput field value =
            UpdateAgentField agent.id field value

        onSelectAllCarriers : Bool -> Msg
        onSelectAllCarriers isSelected =
            SelectAllCarriersForAgent agent.id isSelected
    in
    div [ class "space-y-6" ]
        [ div [ class "space-y-4" ]
            [ div [ class "grid grid-cols-2 gap-4" ]
                [ div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "First Name"
                        , errorIndicator "firstName"
                        ]
                    , input
                        [ type_ "text"
                        , class "mt-1 px-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
                        , value agent.firstName
                        , onInput (onFieldInput "firstName")
                        , disabled (not canEdit)
                        ]
                        []
                    ]
                , div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Last Name"
                        , errorIndicator "lastName"
                        ]
                    , input
                        [ type_ "text"
                        , class "mt-1 px-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
                        , value agent.lastName
                        , onInput (onFieldInput "lastName")
                        , disabled (not canEdit)
                        ]
                        []
                    ]
                ]
            , div [ class "grid grid-cols-2 gap-4" ]
                [ div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Email"
                        , errorIndicator "email"
                        ]
                    , input
                        [ type_ "email"
                        , class "mt-1 px-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
                        , value agent.email
                        , onInput (onFieldInput "email")
                        , disabled (not canEdit)
                        ]
                        []
                    ]
                , div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Phone"
                        , errorIndicator "phone"
                        ]
                    , input
                        [ type_ "tel"
                        , class "mt-1 px-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
                        , value formattedPhone
                        , onInput (onFieldInput "phone")
                        , placeholder "(555) 555-5555"
                        , disabled (not canEdit)
                        ]
                        []
                    ]
                ]
            ]
        , if agent.isAgent then
            div [ class "space-y-6" ]
                [ div [ class "mt-6" ]
                    [ button
                        [ class "w-full inline-flex justify-center items-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                        , onClick (LoadFromOrgForAgent agent.id)
                        , disabled (not canEdit)
                        ]
                        [ if isLoading then
                            div [ class "flex items-center" ]
                                [ div [ class "animate-spin -ml-1 mr-3 h-5 w-5 text-gray-700" ]
                                    [ svg
                                        [ Svg.Attributes.class "h-5 w-5"
                                        , viewBox "0 0 24 24"
                                        ]
                                        [ path
                                            [ d "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                                            , fill "currentColor"
                                            ]
                                            []
                                        ]
                                    ]
                                , text "Loading..."
                                ]

                          else
                            text "Copy from Organization Settings"
                        ]
                    ]
                , div [ class "space-y-4" ]
                    [ h3 [ class "text-lg font-medium text-gray-900" ]
                        [ text "Carriers" ]
                    , div [ class "mb-4 space-y-2" ]
                        [ div [ class "flex gap-4" ]
                            [ div []
                                [ div [ class "text-sm font-medium text-gray-700 mb-2" ]
                                    [ text "Batch Select" ]
                                , div [ class "flex gap-2" ]
                                    [ button
                                        [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50 min-w-[70px] disabled:opacity-50 disabled:cursor-not-allowed"
                                        , onClick (onSelectAllCarriers True)
                                        , disabled (not canEdit)
                                        ]
                                        [ text "Select All" ]
                                    , button
                                        [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50 min-w-[70px] disabled:opacity-50 disabled:cursor-not-allowed"
                                        , onClick (onSelectAllCarriers False)
                                        , disabled (not canEdit)
                                        ]
                                        [ text "Clear All" ]
                                    ]
                                ]
                            ]
                        ]
                    ]
                ]

          else
            text ""
        ]


viewAddAgentButton : Html Msg
viewAddAgentButton =
    div [ class "text-center mt-8" ]
        [ button
            [ class "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
            , onClick AddAnotherAgent
            ]
            [ span [ class "mr-2" ] [ text "+" ]
            , text "Add Agent"
            ]
        ]


viewBottomBar : Model -> Html Msg
viewBottomBar model =
    let
        allAgentsValid =
            List.all
                (\agent ->
                    not (String.isEmpty agent.phone)
                        && not (String.isEmpty agent.firstName)
                        && not (String.isEmpty agent.lastName)
                        && not (String.isEmpty agent.email)
                        && (agent.isAdmin || agent.isAgent)
                )
                model.agents

        canAdd =
            not (String.isEmpty (String.trim model.firstName))
                && not (String.isEmpty (String.trim model.lastName))
                && isValidEmail model.email
                && isValidPhone model.displayPhone
                && (model.isAdmin || model.showAddForm)
    in
    div [ class "fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-4 sm:px-6 z-10" ]
        [ div [ class "max-w-3xl mx-auto" ]
            [ if model.error /= Nothing then
                div [ class "mb-4" ]
                    [ p [ class "text-red-600" ]
                        [ text (Maybe.withDefault "" model.error) ]
                    ]

              else
                text ""
            , if model.showAddForm then
                div [ class "flex items-center justify-end space-x-4" ]
                    [ button
                        [ class "px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
                        , onClick CancelAddAgent
                        ]
                        [ text "Cancel" ]
                    , button
                        [ class "px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                        , onClick SaveAgent
                        , disabled (not canAdd)
                        ]
                        [ text "Add Agent" ]
                    ]

              else if model.isSetup then
                div [ class "flex justify-end" ]
                    [ button
                        [ class "px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
                        , onClick FinishSetup
                        , disabled (not allAgentsValid || List.isEmpty model.agents)
                        ]
                        [ text "Continue to Dashboard" ]
                    ]

              else
                text ""
            ]
        ]


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        UpdateEmail email ->
            ( { model | email = email }, Cmd.none )

        UpdateFirstName name ->
            ( { model | firstName = name }, Cmd.none )

        UpdateLastName name ->
            ( { model | lastName = name }, Cmd.none )

        UpdatePhone input ->
            let
                rawDigits =
                    String.filter Char.isDigit input
                        |> String.left 10

                formattedPhone =
                    formatPhoneNumber rawDigits

                _ =
                    Debug.log "Phone number updated" { raw = rawDigits, formatted = formattedPhone }
            in
            ( { model
                | rawPhone = rawDigits
                , displayPhone = formattedPhone
                , pendingSave = Just "main" -- Add pending save for main agent
              }
            , Cmd.none
            )

        ToggleAdmin agentId ->
            let
                updatedAgents =
                    List.map
                        (\agent ->
                            if agent.id == agentId then
                                { agent | isAdmin = not agent.isAdmin }

                            else
                                agent
                        )
                        model.agents
            in
            ( { model | agents = updatedAgents }
            , case List.head (List.filter (\a -> a.id == agentId) updatedAgents) of
                Just agent ->
                    saveAgentDetails agent

                Nothing ->
                    Cmd.none
            )

        ToggleAgent agentId ->
            let
                updatedAgents =
                    List.map
                        (\agent ->
                            if agent.id == agentId then
                                { agent | isAgent = not agent.isAgent }

                            else
                                agent
                        )
                        model.agents
            in
            ( { model | agents = updatedAgents }
            , case List.head (List.filter (\a -> a.id == agentId) updatedAgents) of
                Just agent ->
                    saveAgentDetails agent

                Nothing ->
                    Cmd.none
            )

        UpdateField field value ->
            case model.currentUser of
                Just user ->
                    let
                        updatedUser =
                            case field of
                                "firstName" ->
                                    { user | firstName = value }

                                "lastName" ->
                                    { user | lastName = value }

                                "phone" ->
                                    { user | phone = String.filter Char.isDigit value }

                                _ ->
                                    user
                    in
                    ( { model | currentUser = Just updatedUser }
                    , Cmd.none
                    )

                Nothing ->
                    ( model, Cmd.none )

        SaveAgent ->
            ( model
            , case model.currentUser of
                Just user ->
                    let
                        agent =
                            { id = user.id
                            , firstName = user.firstName
                            , lastName = user.lastName
                            , email = user.email
                            , phone = user.phone
                            , isAdmin = user.isAdmin
                            , isAgent = user.isAgent
                            , carriers = []
                            , stateLicenses = []
                            , expanded = False
                            }
                    in
                    saveAgentDetails agent

                Nothing ->
                    Cmd.none
            )

        AgentSaved (Ok ()) ->
            if model.isSetup then
                ( { model
                    | showAddForm = False
                    , isAdmin = False
                    , firstName = ""
                    , lastName = ""
                    , email = ""
                    , rawPhone = ""
                    , displayPhone = ""
                    , carriers = []
                    , stateLicenses = []
                  }
                , Cmd.batch
                    [ fetchAgents -- Refresh the agents list
                    , fetchCurrentUser -- Refresh current user to get updated role
                    ]
                )

            else
                ( { model | error = Nothing }
                , Nav.pushUrl model.key "/agents"
                )

        AgentSaved (Err _) ->
            ( { model | error = Just "Failed to save agent" }
            , Cmd.none
            )

        FinishSetup ->
            ( model
            , Nav.pushUrl model.key "/dashboard"
            )

        LoadFromOrg ->
            ( { model | isLoading = True }
            , Http.get
                { url = "/api/settings"
                , expect = Http.expectJson GotOrgSettings (Decode.field "orgSettings" settingsObjectDecoder)
                }
            )

        GotOrgSettings (Ok settings) ->
            ( { model
                | carriers = settings.carrierContracts
                , stateLicenses = settings.stateLicenses
                , isLoading = False
                , orgSettings = Just settings
              }
            , Cmd.none
            )

        GotOrgSettings (Err _) ->
            ( { model
                | error = Just "Failed to load organization settings"
                , isLoading = False
              }
            , Cmd.none
            )

        AddAnotherAgent ->
            ( { model
                | showAddForm = True
                , firstName = ""
                , lastName = ""
                , email = ""
                , rawPhone = ""
                , displayPhone = ""
                , carriers = []
                , stateLicenses = []
                , isAdmin = False
                , isAgent = True
              }
            , Cmd.none
            )

        CancelAddAgent ->
            ( { model | showAddForm = False }, Cmd.none )

        RemoveAgent id ->
            ( { model | agents = List.filter (\agent -> agent.id /= id) model.agents }, Cmd.none )

        FetchAgents ->
            ( model, fetchAgents )

        GotAgents result ->
            case result of
                Ok agents ->
                    let
                        _ =
                            Debug.log "Successfully decoded agents" agents
                    in
                    ( { model | agents = agents }, Cmd.none )

                Err error ->
                    case error of
                        Http.BadStatus 403 ->
                            -- For 403, keep the current user in the agents list
                            -- Don't show an error since this is expected for non-admin users
                            ( model, Cmd.none )

                        _ ->
                            let
                                errorMessage =
                                    case error of
                                        Http.BadUrl url ->
                                            "Invalid URL: " ++ url

                                        Http.Timeout ->
                                            "Request timed out"

                                        Http.NetworkError ->
                                            "Network error occurred"

                                        Http.BadStatus status ->
                                            "Server error: " ++ String.fromInt status

                                        Http.BadBody message ->
                                            "Data error: " ++ message
                            in
                            ( { model | error = Just errorMessage }, Cmd.none )

        GotCurrentUser result ->
            case result of
                Ok response ->
                    case response.user of
                        Just user ->
                            let
                                isAdminAgent =
                                    user.isAdmin && user.isAgent

                                -- Always create an initial agent for the current user in non-setup mode
                                initialAgent =
                                    { id = user.id
                                    , firstName = user.firstName
                                    , lastName = user.lastName
                                    , email = user.email
                                    , phone = user.phone
                                    , isAdmin = isAdminAgent || user.isAdmin
                                    , isAgent = isAdminAgent || user.isAgent
                                    , carriers = []
                                    , stateLicenses = []
                                    , expanded = False
                                    }
                            in
                            ( { model
                                | currentUser = Just user
                                , agents =
                                    if model.isSetup then
                                        [ initialAgent ]

                                    else
                                        initialAgent :: model.agents
                                , error = Nothing -- Clear any previous errors
                              }
                            , Cmd.none
                            )

                        Nothing ->
                            ( { model | currentUser = Nothing }, Cmd.none )

                Err error ->
                    let
                        _ =
                            Debug.log "GotCurrentUser error" error
                    in
                    ( { model | error = Just "Failed to load current user" }
                    , Cmd.none
                    )

        ToggleAgentRole agentId role ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        case role of
                            "admin" ->
                                { agent | isAdmin = not agent.isAdmin }

                            "agent" ->
                                { agent | isAgent = not agent.isAgent }

                            _ ->
                                agent

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        UpdateAgentField agentId field value ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        case field of
                            "firstName" ->
                                { agent | firstName = value }

                            "lastName" ->
                                { agent | lastName = value }

                            "phone" ->
                                { agent | phone = formatPhoneNumber (String.filter Char.isDigit value) }

                            _ ->
                                agent

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        ToggleAgentExpanded agentId ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent | expanded = not agent.expanded }

                    else
                        agent
            in
            ( { model | agents = List.map updateAgent model.agents }, Cmd.none )

        UpdateAgentCarrier agentId carrier isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | carriers =
                                if isSelected then
                                    agent.carriers ++ [ carrier ]

                                else
                                    List.filter ((/=) carrier) agent.carriers
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        UpdateAgentState agentId state isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | stateLicenses =
                                if isSelected then
                                    agent.stateLicenses ++ [ state ]

                                else
                                    List.filter ((/=) state) agent.stateLicenses
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        SelectAllStatesForAgent agentId isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | stateLicenses =
                                if isSelected then
                                    allStates

                                else
                                    []
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        SelectCommonStatesForAgent agentId region ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | stateLicenses = agent.stateLicenses ++ getRegionStates region
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        LoadFromOrgForAgent agentId ->
            ( { model | isLoadingForAgent = Just agentId }
            , Http.get
                { url = "/api/settings"
                , expect = Http.expectJson (GotOrgSettingsForAgent agentId) (Decode.field "orgSettings" settingsObjectDecoder)
                }
            )

        GotOrgSettingsForAgent agentId (Ok settings) ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | carriers = settings.carrierContracts
                            , stateLicenses = settings.stateLicenses
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , isLoadingForAgent = Nothing -- Clear the Loading state
              }
            , Cmd.none
            )

        GotOrgSettingsForAgent agentId (Err _) ->
            ( { model
                | error = Just "Failed to load organization settings"
                , isLoadingForAgent = Nothing -- Clear the Loading state
              }
            , Cmd.none
            )

        SelectAllCarriers isSelected ->
            ( { model
                | carriers =
                    if isSelected then
                        allCarriers

                    else
                        []
              }
            , Cmd.none
            )

        SelectAllStates isSelected ->
            ( { model
                | stateLicenses =
                    if isSelected then
                        allStates

                    else
                        []
              }
            , Cmd.none
            )

        DeleteAgent agentId ->
            ( { model | agents = List.filter (\a -> a.id /= agentId) model.agents }
            , Cmd.none
            )

        AgentDeleted result ->
            case result of
                Ok _ ->
                    ( model, fetchAgents )

                Err _ ->
                    ( { model | error = Just "Failed to delete agent" }, Cmd.none )

        SelectCommonStates region ->
            ( { model | stateLicenses = model.stateLicenses ++ getRegionStates region }
            , Cmd.none
            )

        NavigateTo path ->
            ( model, Nav.pushUrl model.key path )

        ShowModal ->
            ( { model | showAddForm = True }, Cmd.none )

        CloseModal ->
            ( { model | showAddForm = False }, Cmd.none )

        ToggleCarrier agentId isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | carriers =
                                if isSelected then
                                    agent.carriers ++ [ agentId ]

                                else
                                    List.filter ((/=) agentId) agent.carriers
                        }

                    else
                        agent
            in
            ( { model | agents = List.map updateAgent model.agents }
            , Cmd.none
            )

        ToggleState agentId isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | stateLicenses =
                                if isSelected then
                                    agent.stateLicenses ++ [ agentId ]

                                else
                                    List.filter ((/=) agentId) agent.stateLicenses
                        }

                    else
                        agent
            in
            ( { model | agents = List.map updateAgent model.agents }
            , Cmd.none
            )

        SelectAllCarriersForAgent agentId isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | carriers =
                                if isSelected then
                                    allCarriers

                                else
                                    []
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        SaveAgentDetails agentId ->
            ( { model
                | pendingSave = Nothing
                , isLoadingForAgent = Just agentId
              }
            , case List.filter (\a -> a.id == agentId) model.agents of
                agent :: _ ->
                    saveAgentDetails agent

                [] ->
                    Cmd.none
            )

        AgentDetailsSaved agentId result ->
            case result of
                Ok _ ->
                    let
                        updateAgent agent =
                            if agent.id == agentId then
                                { agent | expanded = False }

                            else
                                agent
                    in
                    ( { model
                        | agents = List.map updateAgent model.agents
                        , isLoadingForAgent = Nothing
                        , error = Nothing
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model
                        | error = Just "Failed to save agent details"
                        , isLoadingForAgent = Nothing
                      }
                    , Cmd.none
                    )

        DebounceSaveAgent agentId ->
            if agentId == "main" then
                -- Handle main agent save
                case model.currentUser of
                    Just user ->
                        let
                            agent =
                                { id = user.id
                                , firstName = user.firstName
                                , lastName = user.lastName
                                , email = user.email
                                , phone = user.phone
                                , isAdmin = user.isAdmin
                                , isAgent = user.isAgent
                                , carriers = []
                                , stateLicenses = []
                                , expanded = False
                                }
                        in
                        ( { model | pendingSave = Nothing }
                        , saveAgentDetails agent
                        )

                    Nothing ->
                        ( model, Cmd.none )

            else
                -- Handle sub-agent save
                ( { model | pendingSave = Nothing }
                , case List.filter (\a -> a.id == agentId) model.agents of
                    agent :: _ ->
                        saveAgentDetails agent

                    [] ->
                        Cmd.none
                )



-- Helper functions


formatPhoneNumber : String -> String
formatPhoneNumber rawPhone =
    let
        digits =
            String.filter Char.isDigit rawPhone
                |> String.left 10

        len =
            String.length digits
    in
    if len == 0 then
        ""

    else if len <= 3 then
        "(" ++ digits

    else if len <= 6 then
        "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

    else
        "("
            ++ String.left 3 digits
            ++ ") "
            ++ String.slice 3 6 digits
            ++ "-"
            ++ String.dropLeft 6 digits


saveAgent : User -> Cmd Msg
saveAgent user =
    let
        agent =
            { id = user.id
            , firstName = user.firstName
            , lastName = user.lastName
            , email = user.email
            , phone = user.phone
            , isAdmin = user.isAdmin
            , isAgent = user.isAgent
            , carriers = []
            , stateLicenses = []
            , expanded = False
            }
    in
    Http.post
        { url = "/api/agents"
        , body = Http.jsonBody (encodeAgent agent)
        , expect = Http.expectWhatever AgentSaved
        }


settingsDecoder : Decoder SettingsResponse
settingsDecoder =
    Decode.map2 SettingsResponse
        (Decode.field "orgSettings" settingsObjectDecoder)
        (Decode.field "canEditOrgSettings" Decode.bool)


type alias SettingsResponse =
    { orgSettings : Settings
    , canEditOrgSettings : Bool
    }


type alias Settings =
    { stateLicenses : List String
    , carrierContracts : List String
    , stateCarrierSettings : List StateCarrierSetting
    , allowAgentSettings : Bool
    , emailSendBirthday : Bool
    , emailSendPolicyAnniversary : Bool
    , emailSendAep : Bool
    , smartSendEnabled : Bool
    }


type alias StateCarrierSetting =
    { state : String
    , carrier : String
    , active : Bool
    , targetGI : Bool
    }


settingsObjectDecoder : Decoder Settings
settingsObjectDecoder =
    Decode.map8 Settings
        (Decode.field "stateLicenses" (Decode.list Decode.string))
        (Decode.field "carrierContracts" (Decode.list Decode.string))
        (Decode.field "stateCarrierSettings" (Decode.list stateCarrierSettingDecoder))
        (Decode.field "allowAgentSettings" Decode.bool)
        (Decode.field "emailSendBirthday" Decode.bool)
        (Decode.field "emailSendPolicyAnniversary" Decode.bool)
        (Decode.field "emailSendAep" Decode.bool)
        (Decode.field "smartSendEnabled" Decode.bool)


stateCarrierSettingDecoder : Decoder StateCarrierSetting
stateCarrierSettingDecoder =
    Decode.map4 StateCarrierSetting
        (Decode.field "state" Decode.string)
        (Decode.field "carrier" Decode.string)
        (Decode.field "active" Decode.bool)
        (Decode.field "targetGI" Decode.bool)


subscriptions : Model -> Sub Msg
subscriptions model =
    case model.pendingSave of
        Just agentId ->
            Time.every 2000 (\_ -> DebounceSaveAgent agentId)

        Nothing ->
            Sub.none


isValidEmail : String -> Bool
isValidEmail email =
    case Parser.run emailParser email of
        Ok _ ->
            True

        Err _ ->
            False


emailParser : Parser ()
emailParser =
    let
        usernameChar c =
            Char.isAlphaNum c || List.member c [ '.', '_', '-', '+', '%' ]

        domainChar c =
            Char.isAlphaNum c || c == '-'
    in
    succeed ()
        |. chompIf usernameChar
        |. chompWhile usernameChar
        |. symbol "@"
        |. chompIf domainChar
        |. chompWhile domainChar
        |. symbol "."
        |. chompIf Char.isAlpha
        |. chompWhile Char.isAlpha
        |. end


isValidPhone : String -> Bool
isValidPhone phone =
    String.length (String.filter Char.isDigit phone) == 10


canSave : Model -> Bool
canSave model =
    let
        hasValidName =
            not (String.isEmpty (String.trim model.firstName))
                && not (String.isEmpty (String.trim model.lastName))

        hasValidEmail =
            isValidEmail model.email

        hasValidPhone =
            isValidPhone model.displayPhone

        hasValidRole =
            model.isAdmin || model.isAgent

        allAgentsValid =
            List.all
                (\agent ->
                    not (String.isEmpty agent.phone)
                        && not (String.isEmpty agent.firstName)
                        && not (String.isEmpty agent.lastName)
                        && not (String.isEmpty agent.email)
                        && (agent.isAdmin || agent.isAgent)
                )
                model.agents
    in
    if model.showAddForm then
        hasValidName && hasValidEmail && hasValidPhone && hasValidRole

    else
        allAgentsValid


fetchAgents : Cmd Msg
fetchAgents =
    Http.get
        { url = "/api/agents"
        , expect =
            Http.expectStringResponse GotAgents
                (\response ->
                    case response of
                        Http.BadUrl_ url ->
                            Err (Http.BadUrl url)

                        Http.Timeout_ ->
                            Err Http.Timeout

                        Http.NetworkError_ ->
                            Err Http.NetworkError

                        Http.BadStatus_ metadata body ->
                            Err (Http.BadStatus metadata.statusCode)

                        Http.GoodStatus_ metadata body ->
                            let
                                _ =
                                    Debug.log "Raw response body" body
                            in
                            case Decode.decodeString (Decode.list agentDecoder) body of
                                Ok value ->
                                    Ok value

                                Err err ->
                                    Err (Http.BadBody (Decode.errorToString err))
                )
        }


agentDecoder : Decoder Agent
agentDecoder =
    Decode.succeed Agent
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "firstName" Decode.string
        |> Pipeline.required "lastName" Decode.string
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "phone" Decode.string
        |> Pipeline.required "is_admin" Decode.bool
        |> Pipeline.required "is_agent" Decode.bool
        |> Pipeline.optional "carriers" (Decode.list Decode.string) []
        |> Pipeline.optional "stateLicenses" (Decode.list Decode.string) []
        |> Pipeline.hardcoded False



-- expanded field


encodeAgent : Agent -> Encode.Value
encodeAgent agent =
    Encode.object
        [ ( "firstName", Encode.string agent.firstName )
        , ( "lastName", Encode.string agent.lastName )
        , ( "email", Encode.string agent.email )
        , ( "phone", Encode.string agent.phone )
        , ( "is_admin", Encode.bool agent.isAdmin )
        , ( "is_agent", Encode.bool agent.isAgent )
        , ( "carriers", Encode.list Encode.string agent.carriers )
        , ( "stateLicenses", Encode.list Encode.string agent.stateLicenses )
        ]



-- isAgent


isAdminBecomingAgent : Model -> Bool
isAdminBecomingAgent model =
    case model.currentUser of
        Just user ->
            model.isAdmin && user.isAdmin

        Nothing ->
            False


fetchCurrentUser : Cmd Msg
fetchCurrentUser =
    Http.get
        { url = "/api/me"
        , expect = Http.expectJson GotCurrentUser currentUserResponseDecoder
        }


currentUserResponseDecoder : Decoder CurrentUserResponse
currentUserResponseDecoder =
    let
        _ =
            Debug.log "Running currentUserResponseDecoder" ()

        debugField fieldName decoder =
            Decode.field fieldName decoder
                |> Decode.map
                    (\value ->
                        let
                            _ =
                                Debug.log ("Decoded " ++ fieldName) value
                        in
                        value
                    )
    in
    Decode.map2 CurrentUserResponse
        (debugField "success" Decode.bool)
        (Decode.maybe (debugField "user" userDecoder))


userDecoder : Decoder User
userDecoder =
    let
        idDecoder =
            Decode.oneOf
                [ Decode.field "id" Decode.string
                , Decode.field "id" (Decode.map String.fromInt Decode.int)
                ]
    in
    Decode.map7 User
        idDecoder
        (Decode.field "email" (Debug.log "email field" Decode.string))
        (Decode.field "firstName" (Debug.log "firstName field" Decode.string))
        (Decode.field "lastName" (Debug.log "lastName field" Decode.string))
        (Decode.field "is_admin" (Debug.log "is_admin field" Decode.bool))
        (Decode.field "is_agent" (Debug.log "is_agent field" Decode.bool))
        (Decode.oneOf
            [ Decode.field "phone" Decode.string
            , Decode.succeed ""
            ]
        )


saveAgentDetails : Agent -> Cmd Msg
saveAgentDetails agent =
    Http.request
        { method = "PUT"
        , headers = []
        , url = "/api/agents/" ++ agent.id
        , body = Http.jsonBody (encodeAgent agent)
        , expect = Http.expectWhatever (AgentDetailsSaved agent.id)
        , timeout = Nothing
        , tracker = Nothing
        }


isCurrentUser : Maybe User -> String -> Bool
isCurrentUser maybeUser agentId =
    case maybeUser of
        Just user ->
            user.id == agentId

        Nothing ->
            False


canModifySettings : Model -> String -> Bool
canModifySettings model agentId =
    case ( model.currentUser, model.orgSettings ) of
        ( Just user, Just settings ) ->
            -- Admin and admin_agent can always modify settings
            user.isAdmin
                || user.isAgent
                || -- Regular agents can modify if allowed and it's their own settings
                   (settings.allowAgentSettings && user.id == agentId)

        _ ->
            False

================
File: frontend/src/BrandSettings.elm
================
module BrandSettings exposing
    ( Model
    , Msg(..)
    , init
    , subscriptions
    , update
    , view
    )

import Browser
import Browser.Navigation as Nav
import Components.SetupLayout as SetupLayout
import Debug
import File exposing (File)
import File.Select as Select
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Task



-- MODEL


type alias Model =
    { key : Nav.Key
    , session : String
    , orgSlug : String
    , isSetup : Bool
    , brandName : String
    , primaryColor : String
    , secondaryColor : String
    , logo : Maybe String
    , isLoading : Bool
    , error : Maybe String
    , isSaving : Bool
    }


type alias BrandSettings =
    { brandName : String
    , primaryColor : String
    , secondaryColor : String
    , logo : Maybe String
    }


init : { key : Nav.Key, session : String, orgSlug : String, isSetup : Bool } -> ( Model, Cmd Msg )
init flags =
    ( { key = flags.key
      , session = flags.session
      , orgSlug = flags.orgSlug
      , isSetup = flags.isSetup
      , brandName = ""
      , primaryColor = "#6B46C1" -- Default purple color
      , secondaryColor = "#9F7AEA"
      , logo = Nothing
      , isLoading = True
      , error = Nothing
      , isSaving = False
      }
    , fetchBrandSettings flags.orgSlug flags.session
    )



-- UPDATE


type Msg
    = GotBrandSettings (Result Http.Error BrandSettings)
    | UpdateBrandName String
    | UpdatePrimaryColor String
    | UpdateSecondaryColor String
    | UploadLogo
    | GotLogo File
    | GotLogoUrl String
    | LogoUploaded (Result Http.Error String)
    | SaveSettings
    | SettingsSaved (Result Http.Error ())
    | FinishSetup
    | NoOp


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GotBrandSettings (Ok settings) ->
            ( { model
                | brandName = settings.brandName
                , primaryColor = settings.primaryColor
                , secondaryColor = settings.secondaryColor
                , logo = settings.logo
                , isLoading = False
              }
            , Cmd.none
            )

        GotBrandSettings (Err _) ->
            ( { model
                | error = Just "Failed to load brand settings"
                , isLoading = False
              }
            , Cmd.none
            )

        UpdateBrandName name ->
            ( { model | brandName = name }
            , Cmd.none
            )

        UpdatePrimaryColor color ->
            ( { model | primaryColor = color }
            , Cmd.none
            )

        UpdateSecondaryColor color ->
            ( { model | secondaryColor = color }
            , Cmd.none
            )

        UploadLogo ->
            ( model
            , Select.file [ "image/png", "image/jpeg" ] GotLogo
            )

        GotLogo file ->
            ( model
            , Task.perform GotLogoUrl (File.toUrl file)
            )

        GotLogoUrl url ->
            ( { model | logo = Just url }
            , Cmd.none
            )

        LogoUploaded (Ok url) ->
            ( { model | logo = Just url }
            , Cmd.none
            )

        LogoUploaded (Err _) ->
            ( { model | error = Just "Failed to upload logo" }
            , Cmd.none
            )

        SaveSettings ->
            ( { model | isSaving = True }
            , saveBrandSettings model
            )

        SettingsSaved (Ok ()) ->
            if model.isSetup then
                ( { model | isSaving = False, error = Nothing }
                , Nav.pushUrl model.key
                    ("/setup/add-agents?plan=" ++ model.orgSlug ++ "&org=complete&brand=complete")
                )

            else
                ( { model | isSaving = False, error = Nothing }
                , Cmd.none
                )

        SettingsSaved (Err _) ->
            ( { model
                | isSaving = False
                , error = Just "Failed to save settings"
              }
            , Cmd.none
            )

        FinishSetup ->
            ( model
            , Nav.pushUrl model.key
                ("/setup/add-agents?plan=" ++ model.orgSlug ++ "&org=complete&brand=complete")
            )

        NoOp ->
            ( model, Cmd.none )



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Brand Settings"
    , body =
        [ if model.isSetup then
            SetupLayout.view SetupLayout.BrandSetup
                [ if model.isLoading then
                    viewLoading

                  else
                    viewSettings model
                ]

          else
            div [ class "min-h-screen bg-gray-50" ]
                [ viewHeader
                , div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
                    [ if model.isLoading then
                        viewLoading

                      else
                        viewSettings model
                    ]
                ]
        ]
    }


viewHeader : Html Msg
viewHeader =
    nav [ class "bg-white border-b border-gray-200" ]
        [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
            [ div [ class "flex justify-between h-16" ]
                [ div [ class "flex" ]
                    [ div [ class "flex-shrink-0 flex items-center" ]
                        [ h1 [ class "text-xl font-semibold text-purple-600" ]
                            [ text "Brand Settings" ]
                        ]
                    ]
                ]
            ]
        ]


viewLoading : Html Msg
viewLoading =
    div [ class "flex justify-center items-center h-64" ]
        [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent" ] []
        ]


viewSettings : Model -> Html Msg
viewSettings model =
    div [ class "bg-white shadow-sm rounded-lg p-6" ]
        [ div [ class "space-y-6" ]
            [ viewErrorMessage model.error
            , viewFormGroup "Brand Name"
                (input
                    [ type_ "text"
                    , class "w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500"
                    , value model.brandName
                    , onInput UpdateBrandName
                    ]
                    []
                )
            , viewFormGroup "Primary Color"
                (div [ class "flex items-center space-x-4" ]
                    [ input
                        [ type_ "color"
                        , class "w-16 h-10 p-1 border border-gray-300 rounded"
                        , value model.primaryColor
                        , onInput UpdatePrimaryColor
                        ]
                        []
                    , input
                        [ type_ "text"
                        , class "flex-1 px-4 py-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500"
                        , value model.primaryColor
                        , onInput UpdatePrimaryColor
                        ]
                        []
                    ]
                )
            , viewFormGroup "Secondary Color"
                (div [ class "flex items-center space-x-4" ]
                    [ input
                        [ type_ "color"
                        , class "w-16 h-10 p-1 border border-gray-300 rounded"
                        , value model.secondaryColor
                        , onInput UpdateSecondaryColor
                        ]
                        []
                    , input
                        [ type_ "text"
                        , class "flex-1 px-4 py-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500"
                        , value model.secondaryColor
                        , onInput UpdateSecondaryColor
                        ]
                        []
                    ]
                )
            , viewFormGroup "Logo"
                (div [ class "flex items-center space-x-4" ]
                    [ case model.logo of
                        Just logoUrl ->
                            div [ class "flex items-center space-x-4" ]
                                [ img
                                    [ src logoUrl
                                    , class "h-16 w-16 object-contain border border-gray-200 rounded"
                                    ]
                                    []
                                , button
                                    [ class "px-4 py-2 text-sm text-purple-600 hover:text-purple-800"
                                    , onClick UploadLogo
                                    ]
                                    [ text "Change Logo" ]
                                ]

                        Nothing ->
                            button
                                [ class "px-4 py-2 text-sm text-purple-600 hover:text-purple-800 border border-purple-200 rounded"
                                , onClick UploadLogo
                                ]
                                [ text "Upload Logo" ]
                    ]
                )
            , div [ class "flex justify-center mt-8" ]
                [ button
                    [ class "px-6 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 disabled:opacity-50"
                    , onClick SaveSettings
                    , disabled model.isSaving
                    ]
                    [ if model.isSaving then
                        text "Saving..."

                      else
                        text "Save Changes"
                    ]
                ]
            ]
        ]


viewFormGroup : String -> Html Msg -> Html Msg
viewFormGroup labelText content =
    div [ class "mb-4" ]
        [ label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text labelText ]
        , content
        ]


viewErrorMessage : Maybe String -> Html Msg
viewErrorMessage maybeError =
    case maybeError of
        Just error ->
            div [ class "bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded relative" ]
                [ text error ]

        Nothing ->
            text ""



-- HTTP


fetchBrandSettings : String -> String -> Cmd Msg
fetchBrandSettings orgSlug session =
    Http.request
        { method = "GET"
        , headers = [ Http.header "Authorization" ("Bearer " ++ session) ]
        , url = "/api/organizations/" ++ orgSlug ++ "/brand"
        , body = Http.emptyBody
        , expect = Http.expectJson GotBrandSettings brandSettingsDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


saveBrandSettings : Model -> Cmd Msg
saveBrandSettings model =
    Http.request
        { method = "PUT"
        , headers = [ Http.header "Authorization" ("Bearer " ++ model.session) ]
        , url = "/api/organizations/" ++ model.orgSlug ++ "/brand"
        , body = Http.jsonBody (encodeBrandSettings model)
        , expect = Http.expectWhatever SettingsSaved
        , timeout = Nothing
        , tracker = Nothing
        }



-- JSON


brandSettingsDecoder : Decoder BrandSettings
brandSettingsDecoder =
    Decode.succeed BrandSettings
        |> Pipeline.required "brand_name" Decode.string
        |> Pipeline.required "primary_color" Decode.string
        |> Pipeline.required "secondary_color" Decode.string
        |> Pipeline.optional "logo" (Decode.nullable Decode.string) Nothing


encodeBrandSettings : Model -> Encode.Value
encodeBrandSettings model =
    Encode.object
        [ ( "brand_name", Encode.string model.brandName )
        , ( "primary_color", Encode.string model.primaryColor )
        , ( "secondary_color", Encode.string model.secondaryColor )
        , ( "logo", Maybe.map Encode.string model.logo |> Maybe.withDefault Encode.null )
        ]



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/ChoosePlan.elm
================
module ChoosePlan exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser exposing (Document)
import Browser.Navigation as Nav
import Components.SetupLayout as SetupLayout
import Debug
import Html exposing (Html, button, div, h1, h2, h3, input, label, li, p, span, text, ul)
import Html.Attributes exposing (class, type_, value)
import Html.Events exposing (onClick, onInput)
import Http
import Json.Decode as Decode exposing (Decoder, field, int, list, string)
import Json.Encode as Encode


type SetupStep
    = PlanSelection
    | Payment
    | Complete


type alias SubscriptionTier =
    { id : String
    , name : String
    , price : String
    , agentLimit : Int
    , contactLimit : Int
    , features : List String
    }


type alias Model =
    { session : Maybe String
    , orgSlug : String
    , currentStep : SetupStep
    , selectedPlan : Maybe String
    , error : Maybe String
    , tiers : List SubscriptionTier
    , isLoading : Bool
    , key : Nav.Key
    }


type Msg
    = NextStep
    | SelectPlan String
    | SubmitPayment
    | CompleteSetup
    | GotTiers (Result Http.Error (List SubscriptionTier))
    | SubscriptionSaved (Result Http.Error ())
    | NavigateToTempLanding
    | GotSaveResponse (Result Http.Error ())


init : String -> String -> Nav.Key -> ( Model, Cmd Msg )
init orgSlug session key =
    let
        _ =
            Debug.log "Initializing ChoosePlan with orgSlug" orgSlug
    in
    ( { session = Just session
      , orgSlug = orgSlug
      , currentStep = PlanSelection
      , selectedPlan = Nothing
      , error = Nothing
      , tiers = []
      , isLoading = True
      , key = key
      }
    , fetchSubscriptionTiers
    )


fetchSubscriptionTiers : Cmd Msg
fetchSubscriptionTiers =
    Http.get
        { url = "/api/organizations/subscription-tiers"
        , expect = Http.expectJson GotTiers subscriptionTiersDecoder
        }


saveSubscription : String -> String -> Cmd Msg
saveSubscription orgSlug tierId =
    let
        url =
            "/api/organizations/" ++ orgSlug ++ "/subscription"

        _ =
            Debug.log "Making subscription request"
                { url = url
                , tierId = tierId
                , orgSlug = orgSlug
                }
    in
    Http.post
        { url = url
        , body = Http.jsonBody (encodeSubscriptionUpdate tierId)
        , expect = Http.expectWhatever SubscriptionSaved
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    let
        _ =
            Debug.log "VerifyOrganization update" msg
    in
    case msg of
        SubscriptionSaved result ->
            case result of
                Ok _ ->
                    ( { model | error = Nothing }
                    , case model.selectedPlan of
                        Just planId ->
                            Nav.pushUrl model.key ("/setup/settings?plan=" ++ planId)

                        Nothing ->
                            Nav.pushUrl model.key "/setup/settings"
                    )

                Err error ->
                    ( { model | error = Just "Failed to save subscription" }
                    , Cmd.none
                    )

        NextStep ->
            case model.currentStep of
                PlanSelection ->
                    case model.selectedPlan of
                        Just planId ->
                            let
                                _ =
                                    Debug.log "Saving subscription with orgSlug" model.orgSlug
                            in
                            ( { model | currentStep = Payment }
                            , saveSubscription model.orgSlug planId
                            )

                        Nothing ->
                            ( { model | error = Just "Please select a plan" }
                            , Cmd.none
                            )

                Payment ->
                    ( { model | currentStep = Complete }
                    , Nav.pushUrl model.key "/templanding"
                    )

                Complete ->
                    ( model
                    , Nav.pushUrl model.key "/templanding"
                    )

        SelectPlan plan ->
            ( { model | selectedPlan = Just plan }, Cmd.none )

        GotTiers result ->
            case result of
                Ok tiers ->
                    let
                        _ =
                            Debug.log "Got tiers" tiers
                    in
                    ( { model | tiers = tiers, isLoading = False }
                    , Cmd.none
                    )

                Err error ->
                    let
                        _ =
                            Debug.log "Failed to load tiers" error
                    in
                    ( { model | error = Just "Failed to load subscription tiers", isLoading = False }
                    , Cmd.none
                    )

        GotSaveResponse result ->
            case result of
                Ok _ ->
                    ( { model | error = Nothing }
                    , Nav.pushUrl model.key "/brand-settings"
                    )

                Err error ->
                    ( { model
                        | error = Just "Failed to save subscription. Please try again."
                        , isLoading = False
                      }
                    , Cmd.none
                    )

        _ ->
            ( model, Cmd.none )


view : Model -> Browser.Document Msg
view model =
    { title = "Choose Plan - Medicare Max"
    , body =
        [ SetupLayout.view SetupLayout.PlanSelection
            [ if model.isLoading then
                viewLoading

              else
                viewPlanSelection model
            ]
        ]
    }


viewLoading : Html Msg
viewLoading =
    div [ class "text-center" ]
        [ div [ class "animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500 mx-auto" ] []
        , p [ class "mt-4 text-gray-500" ]
            [ text "Loading subscription tiers..." ]
        ]


viewPlanSelection : Model -> Html Msg
viewPlanSelection model =
    div [ class "space-y-8" ]
        [ div [ class "mb-8" ]
            [ h1 [ class "text-2xl font-semibold text-gray-900" ]
                [ text "Choose your plan" ]
            , p [ class "text-gray-600 mt-2" ]
                [ text "Select a plan that best fits your organization's needs" ]
            ]
        , div [ class "grid grid-cols-1 md:grid-cols-3 gap-4" ]
            (List.map
                (\tier ->
                    viewPlanOption
                        tier.id
                        tier.name
                        tier.price
                        tier.features
                        tier.agentLimit
                        tier.contactLimit
                        model.selectedPlan
                )
                model.tiers
            )
        , if model.error /= Nothing then
            div [ class "mt-4 text-red-500" ]
                [ text (Maybe.withDefault "" model.error) ]

          else
            text ""
        , div [ class "mt-8 flex justify-center" ]
            [ button
                [ class
                    ("px-6 py-3 rounded-lg transition-colors duration-200 "
                        ++ (if model.selectedPlan == Nothing then
                                "bg-[#2563EB]/50 cursor-not-allowed text-white"

                            else
                                "bg-[#2563EB] hover:bg-[#1D4ED8] text-white"
                           )
                    )
                , onClick NextStep
                , Html.Attributes.disabled (model.selectedPlan == Nothing)
                ]
                [ text "Select" ]
            ]
        ]


viewPlanOption : String -> String -> String -> List String -> Int -> Int -> Maybe String -> Html Msg
viewPlanOption id name price features agentLimit contactLimit selectedPlan =
    div
        [ class
            ("p-6 rounded-lg cursor-pointer transition-all "
                ++ (if Just id == selectedPlan then
                        "bg-[#2563EB]/10 ring-2 ring-[#2563EB]"

                    else
                        "bg-gray-50 hover:bg-gray-100"
                   )
            )
        , onClick (SelectPlan id)
        ]
        [ div [ class "space-y-4" ]
            [ div []
                [ h3 [ class "text-xl font-semibold text-gray-900" ] [ text name ]
                , p [ class "text-3xl font-bold text-gray-900 mt-2" ] [ text price ]
                ]
            , div [ class "space-y-2 py-4 border-t border-b border-gray-200" ]
                [ div [ class "text-gray-600" ]
                    [ text ("Up to " ++ String.fromInt agentLimit ++ " agents") ]
                , div [ class "text-gray-600" ]
                    [ text ("Up to " ++ String.fromInt contactLimit ++ " contacts") ]
                ]
            , div [ class "mt-4" ]
                [ p [ class "text-sm font-medium text-gray-900 mb-2" ] [ text "Features:" ]
                , ul [ class "space-y-2" ]
                    (List.map
                        (\feature ->
                            li [ class "flex items-center text-sm text-gray-600" ]
                                [ span [ class "text-[#059669] mr-2" ] [ text "âœ“" ]
                                , text feature
                                ]
                        )
                        features
                    )
                ]
            ]
        ]


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none


subscriptionTiersDecoder : Decoder (List SubscriptionTier)
subscriptionTiersDecoder =
    let
        _ =
            Debug.log "Decoding subscription tiers" ()
    in
    field "tiers"
        (list
            (Decode.map6 SubscriptionTier
                (field "id" string)
                (field "name" string)
                (field "price" string)
                (field "agentLimit" int)
                (field "contactLimit" int)
                (field "features" (list string))
            )
        )


encodeSubscriptionUpdate : String -> Encode.Value
encodeSubscriptionUpdate tierId =
    Encode.object
        [ ( "tierId", Encode.string tierId )
        ]

================
File: frontend/src/Contact.elm
================
module Contact exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Browser.Events
import Browser.Navigation as Nav
import Debug
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onBlur, onClick, onInput, onSubmit)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Task
import Time



-- TYPES


type alias Contact =
    { id : Int
    , firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , state : String
    , contactOwnerId : Maybe Int
    , contactOwner : Maybe User
    , currentCarrier : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : Bool
    , gender : String
    , zipCode : String
    , planType : String
    , status : String
    , agentId : Maybe Int
    , lastEmailed : Maybe String
    }


type alias User =
    { id : Int
    , email : String
    , firstName : String
    , lastName : String
    , isAdmin : Bool
    , isAgent : Bool
    , organizationId : Int
    , isActive : Bool
    , phone : String
    }


type alias ContactForm =
    { id : Maybe Int
    , firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , state : String
    , contactOwnerId : Maybe Int
    , currentCarrier : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : Bool
    , gender : String
    , zipCode : String
    , planType : String
    }


emptyForm : ContactForm
emptyForm =
    { id = Nothing
    , firstName = ""
    , lastName = ""
    , email = ""
    , phoneNumber = ""
    , state = ""
    , contactOwnerId = Nothing
    , currentCarrier = ""
    , effectiveDate = ""
    , birthDate = ""
    , tobaccoUser = False
    , gender = "M"
    , zipCode = ""
    , planType = ""
    }



-- MODEL


type alias Activity =
    { submissionDate : String
    , status : ActivityStatus
    , carrierSelected : Maybe String
    , planSelected : Maybe String
    , quoteAmount : Maybe Float
    }


type ActivityStatus
    = QuoteCreated
    | EmailOpened
    | EmailSent Int -- Int represents which email number (1, 2, etc.)


type Modal
    = NoModal
    | EditModal
    | DeleteConfirmModal


type alias Model =
    { key : Nav.Key
    , contact : Maybe Contact
    , showModal : Modal
    , editForm : ContactForm
    , isSubmittingForm : Bool
    , error : Maybe String
    , activities : List Activity
    , isCheckingEmail : Bool
    , emailExists : Bool
    , isDeletingContact : Bool
    }



-- DECODERS


contactDecoder : Decoder Contact
contactDecoder =
    Decode.succeed Contact
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "first_name" Decode.string
        |> Pipeline.required "last_name" Decode.string
        |> Pipeline.required "email" Decode.string
        |> Pipeline.optional "phone_number" Decode.string ""
        |> Pipeline.required "state" Decode.string
        |> Pipeline.optional "contact_owner_id" (Decode.nullable Decode.int) Nothing
        |> Pipeline.optional "contact_owner" (Decode.nullable userDecoder) Nothing
        |> Pipeline.required "current_carrier" Decode.string
        |> Pipeline.required "effective_date" Decode.string
        |> Pipeline.required "birth_date" Decode.string
        |> Pipeline.required "tobacco_user" Decode.bool
        |> Pipeline.required "gender" Decode.string
        |> Pipeline.required "zip_code" Decode.string
        |> Pipeline.required "plan_type" Decode.string
        |> Pipeline.optional "status" Decode.string "New"
        |> Pipeline.required "agent_id" (Decode.nullable Decode.int)
        |> Pipeline.optional "last_emailed_date" (Decode.nullable Decode.string) Nothing


userDecoder : Decoder User
userDecoder =
    Decode.succeed User
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "first_name" Decode.string
        |> Pipeline.required "last_name" Decode.string
        |> Pipeline.required "is_admin" Decode.bool
        |> Pipeline.required "is_agent" Decode.bool
        |> Pipeline.required "organization_id" Decode.int
        |> Pipeline.required "is_active" Decode.bool
        |> Pipeline.required "phone" Decode.string



-- INIT


type alias ZipInfo =
    { state : String
    , counties : List String
    , cities : List String
    }


init : Nav.Key -> String -> ( Model, Cmd Msg )
init key contactId =
    let
        _ =
            Debug.log "Initializing Contact page with ID" contactId
    in
    ( { key = key
      , contact = Nothing
      , showModal = NoModal
      , editForm = emptyForm
      , isSubmittingForm = False
      , error = Nothing
      , activities =
            [ { submissionDate = "11-24-2024"
              , status = QuoteCreated
              , carrierSelected = Just "Allstate"
              , planSelected = Just "Silver Tsunami xJ5"
              , quoteAmount = Just 120.0
              }
            , { submissionDate = "11-24-2024"
              , status = EmailOpened
              , carrierSelected = Nothing
              , planSelected = Nothing
              , quoteAmount = Nothing
              }
            , { submissionDate = "11-24-2024"
              , status = EmailSent 1
              , carrierSelected = Nothing
              , planSelected = Nothing
              , quoteAmount = Nothing
              }
            ]
      , isCheckingEmail = False
      , emailExists = False
      , isDeletingContact = False
      }
    , Http.get
        { url = "/api/contacts/" ++ contactId
        , expect = Http.expectJson GotContact contactDecoder
        }
    )



-- UPDATE


type Msg
    = NoOp
    | GotContact (Result Http.Error Contact)
    | ShowEditModal
    | CloseModal
    | BackToContacts
    | UpdateEditForm ContactFormField String
    | SubmitEditForm
    | ContactUpdated (Result Http.Error Contact)
    | CheckEmail String
    | EmailChecked (Result Http.Error { exists : Bool })
    | LookupZipCode String
    | GotZipLookup (Result Http.Error ZipInfo)
    | ShowDeleteConfirmModal
    | DeleteContact
    | ContactDeleted (Result Http.Error DeleteResponse)


type ContactFormField
    = FirstName
    | LastName
    | Email
    | PhoneNumber
    | State
    | ContactOwnerId
    | CurrentCarrier
    | EffectiveDate
    | BirthDate
    | TobaccoUser
    | Gender
    | ZipCode
    | PlanType


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        GotContact (Ok contact) ->
            let
                _ =
                    Debug.log "Got contact" contact
            in
            ( { model | contact = Just contact }, Cmd.none )

        GotContact (Err error) ->
            let
                _ =
                    Debug.log "Error getting contact" error
            in
            ( { model | error = Just "Failed to load contact" }, Cmd.none )

        ShowEditModal ->
            case model.contact of
                Just contact ->
                    ( { model
                        | showModal = EditModal
                        , editForm =
                            { id = Just contact.id
                            , firstName = contact.firstName
                            , lastName = contact.lastName
                            , email = contact.email
                            , phoneNumber = contact.phoneNumber
                            , state = contact.state
                            , contactOwnerId = contact.contactOwnerId
                            , currentCarrier = contact.currentCarrier
                            , effectiveDate = contact.effectiveDate
                            , birthDate = contact.birthDate
                            , tobaccoUser = contact.tobaccoUser
                            , gender = contact.gender
                            , zipCode = contact.zipCode
                            , planType = contact.planType
                            }
                      }
                    , Cmd.none
                    )

                Nothing ->
                    ( model, Cmd.none )

        CloseModal ->
            ( { model | showModal = NoModal }, Cmd.none )

        BackToContacts ->
            ( model, Nav.pushUrl model.key "/contacts" )

        UpdateEditForm field value ->
            let
                form =
                    model.editForm

                updatedForm =
                    case field of
                        FirstName ->
                            { form | firstName = value }

                        LastName ->
                            { form | lastName = value }

                        Email ->
                            { form | email = value }

                        PhoneNumber ->
                            { form | phoneNumber = String.filter Char.isDigit value |> String.left 10 }

                        State ->
                            { form | state = value }

                        ContactOwnerId ->
                            { form | contactOwnerId = String.toInt value }

                        CurrentCarrier ->
                            { form | currentCarrier = value }

                        EffectiveDate ->
                            { form | effectiveDate = value }

                        BirthDate ->
                            { form | birthDate = value }

                        TobaccoUser ->
                            { form | tobaccoUser = value == "true" }

                        Gender ->
                            { form | gender = value }

                        ZipCode ->
                            { form | zipCode = value }

                        PlanType ->
                            { form | planType = value }

                cmd =
                    if field == ZipCode && String.length value == 5 then
                        LookupZipCode value
                            |> Task.succeed
                            |> Task.perform identity

                    else if field == Email && String.length value > 0 then
                        checkEmail value

                    else
                        Cmd.none
            in
            ( { model
                | editForm = updatedForm
                , isCheckingEmail = field == Email && String.length value > 0
                , emailExists = False
                , error = Nothing
              }
            , cmd
            )

        SubmitEditForm ->
            case model.editForm.id of
                Just id ->
                    ( { model | isSubmittingForm = True }
                    , Http.request
                        { method = "PUT"
                        , headers = []
                        , url = "/api/contacts/" ++ String.fromInt id
                        , body = Http.jsonBody (encodeContactForm model.editForm)
                        , expect = Http.expectJson ContactUpdated contactDecoder
                        , timeout = Nothing
                        , tracker = Nothing
                        }
                    )

                Nothing ->
                    ( model, Cmd.none )

        ContactUpdated (Ok contact) ->
            ( { model
                | contact = Just contact
                , showModal = NoModal
                , isSubmittingForm = False
                , error = Nothing
              }
            , Cmd.none
            )

        ContactUpdated (Err _) ->
            ( { model
                | isSubmittingForm = False
                , error = Just "Failed to update contact"
              }
            , Cmd.none
            )

        CheckEmail email ->
            ( { model | isCheckingEmail = True }
            , checkEmail email
            )

        EmailChecked (Ok response) ->
            ( { model
                | isCheckingEmail = False
                , emailExists = response.exists
                , error =
                    if response.exists then
                        Just "A contact with this email already exists"

                    else
                        Nothing
              }
            , Cmd.none
            )

        EmailChecked (Err _) ->
            ( { model
                | isCheckingEmail = False
                , error = Just "Failed to check email. Please try again."
              }
            , Cmd.none
            )

        LookupZipCode zipCode ->
            ( model
            , Http.get
                { url = "/api/zip-lookup/" ++ zipCode
                , expect = Http.expectJson GotZipLookup zipInfoDecoder
                }
            )

        GotZipLookup (Ok zipInfo) ->
            let
                form =
                    model.editForm

                updatedForm =
                    { form | state = zipInfo.state }
            in
            ( { model | editForm = updatedForm }
            , Cmd.none
            )

        GotZipLookup (Err _) ->
            ( model, Cmd.none )

        ShowDeleteConfirmModal ->
            ( { model | showModal = DeleteConfirmModal }, Cmd.none )

        DeleteContact ->
            case model.contact of
                Just contact ->
                    ( { model | isDeletingContact = True }
                    , deleteContact contact.id
                    )

                Nothing ->
                    ( model, Cmd.none )

        ContactDeleted (Ok response) ->
            if response.success then
                ( model, Nav.pushUrl model.key "/contacts" )

            else
                ( { model | isDeletingContact = False, error = Just "Failed to delete contact" }, Cmd.none )

        ContactDeleted (Err _) ->
            ( { model | isDeletingContact = False, error = Just "Failed to delete contact" }, Cmd.none )



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Contact Details"
    , body =
        [ div [ class "min-h-screen bg-white" ]
            [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
                [ viewBackButton
                , case model.contact of
                    Just contact ->
                        div []
                            [ viewHeader contact
                            , viewContactSummary contact
                            , viewActivity model.activities
                            ]

                    Nothing ->
                        viewLoading
                ]
            ]
        , viewModals model
        ]
    }


viewBackButton : Html Msg
viewBackButton =
    button
        [ class "mb-6 inline-flex items-center text-sm text-gray-600 hover:text-gray-900"
        , onClick BackToContacts
        ]
        [ span [ class "mr-2" ] [ text "â†" ]
        , text "Back to Contacts"
        ]


viewHeader : Contact -> Html Msg
viewHeader contact =
    div [ class "flex justify-between items-center mb-8" ]
        [ div [ class "flex items-center gap-4" ]
            [ h1 [ class "text-2xl font-semibold" ]
                [ text (contact.firstName ++ " " ++ contact.lastName) ]
            , viewStatus contact.status
            ]
        , div [ class "flex gap-2" ]
            [ button
                [ class "px-4 py-2 text-sm font-medium text-purple-600 hover:text-purple-700 bg-purple-50 hover:bg-purple-100 rounded-lg transition-colors duration-200 flex items-center gap-2"
                , onClick ShowEditModal
                ]
                [ text "Edit" ]
            , button
                [ class "px-4 py-2 text-sm font-medium text-red-600 hover:text-red-700 bg-red-50 hover:bg-red-100 rounded-lg transition-colors duration-200 flex items-center gap-2"
                , onClick ShowDeleteConfirmModal
                ]
                [ text "Delete" ]
            ]
        ]


viewContactSummary : Contact -> Html Msg
viewContactSummary contact =
    div [ class "bg-white rounded-lg border border-gray-200 p-6 mb-8" ]
        [ h2 [ class "text-lg font-medium mb-6" ] [ text "Contact Summary" ]
        , div [ class "grid grid-cols-2 gap-x-8 gap-y-6" ]
            [ viewField "Date of Birth" contact.birthDate
            , viewField "Contact Owner" (Maybe.map .firstName contact.contactOwner |> Maybe.withDefault "Default")
            , viewField "Phone Number" (formatPhoneNumber contact.phoneNumber)
            , viewField "Email" contact.email
            , viewField "Gender" contact.gender
            , viewField "Tobacco Use"
                (if contact.tobaccoUser then
                    "Yes"

                 else
                    "No"
                )
            , viewField "State" contact.state
            , viewField "Zip Code" contact.zipCode
            , viewField "Effective Date" contact.effectiveDate
            , viewField "Plan Type" contact.planType
            ]
        ]


viewField : String -> String -> Html Msg
viewField label value =
    div []
        [ div [ class "text-sm font-medium text-gray-500" ] [ text label ]
        , div [ class "mt-1 text-sm text-gray-900" ] [ text value ]
        ]


viewActivity : List Activity -> Html Msg
viewActivity activities =
    div [ class "bg-white rounded-lg border border-gray-200 p-6" ]
        [ h2 [ class "text-lg font-medium mb-6" ] [ text "Activity" ]
        , table [ class "min-w-full" ]
            [ thead [ class "bg-gray-50" ]
                [ tr []
                    [ th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase" ] [ text "Submission Date" ]
                    , th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase" ] [ text "Status" ]
                    , th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase" ] [ text "Carrier Selected" ]
                    , th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase" ] [ text "Plan Selected" ]
                    , th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase" ] [ text "Quote Amount" ]
                    ]
                ]
            , tbody [ class "divide-y divide-gray-200" ]
                (List.map viewActivityRow activities)
            ]
        ]


viewActivityRow : Activity -> Html Msg
viewActivityRow activity =
    tr [ class "hover:bg-gray-50" ]
        [ td [ class "px-3 py-2 text-sm text-gray-900" ] [ text activity.submissionDate ]
        , td [ class "px-3 py-2 text-sm" ] [ viewActivityStatus activity.status ]
        , td [ class "px-3 py-2 text-sm text-gray-900" ] [ text (Maybe.withDefault "-" activity.carrierSelected) ]
        , td [ class "px-3 py-2 text-sm text-gray-900" ] [ text (Maybe.withDefault "-" activity.planSelected) ]
        , td [ class "px-3 py-2 text-sm text-gray-900" ]
            [ text
                (activity.quoteAmount
                    |> Maybe.map (\amount -> "$" ++ String.fromFloat amount)
                    |> Maybe.withDefault "-"
                )
            ]
        ]


viewActivityStatus : ActivityStatus -> Html Msg
viewActivityStatus status =
    let
        ( bgColor, textColor, statusText ) =
            case status of
                QuoteCreated ->
                    ( "bg-green-50", "text-green-700", "Quote Created" )

                EmailOpened ->
                    ( "bg-red-50", "text-red-700", "Email Opened" )

                EmailSent n ->
                    ( "bg-blue-50", "text-blue-700", "Email #" ++ String.fromInt n ++ " Sent" )
    in
    div [ class ("inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium " ++ bgColor ++ " " ++ textColor) ]
        [ text statusText ]


viewStatus : String -> Html Msg
viewStatus status =
    let
        ( bgColor, textColor ) =
            case status of
                "Quote Created" ->
                    ( "bg-green-50", "text-green-700" )

                "Opened Email" ->
                    ( "bg-red-50", "text-red-700" )

                "Email #2 Sent" ->
                    ( "bg-blue-50", "text-blue-700" )

                "Email #1 Sent" ->
                    ( "bg-blue-50", "text-blue-700" )

                "In Queue" ->
                    ( "bg-orange-50", "text-orange-700" )

                _ ->
                    ( "bg-gray-50", "text-gray-700" )
    in
    div [ class ("inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium " ++ bgColor ++ " " ++ textColor) ]
        [ text status ]


viewModals : Model -> Html Msg
viewModals model =
    case model.showModal of
        NoModal ->
            text ""

        EditModal ->
            viewEditModal model

        DeleteConfirmModal ->
            viewDeleteConfirmModal model


viewEditModal : Model -> Html Msg
viewEditModal model =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-5xl w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ text "Ã—" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Edit Contact" ]
            , viewContactForm model.editForm model.isSubmittingForm model
            ]
        ]


viewContactForm : ContactForm -> Bool -> Model -> Html Msg
viewContactForm form isSubmitting model =
    Html.form [ onSubmit SubmitEditForm ]
        [ div [ class "grid grid-cols-2 gap-x-8 gap-y-6" ]
            [ viewFormInput "First Name" "text" form.firstName FirstName True model
            , viewFormInput "Last Name" "text" form.lastName LastName True model
            , viewFormInput "Email" "email" form.email Email True model
            , viewFormInput "Phone Number" "text" (formatPhoneNumber form.phoneNumber) PhoneNumber True model
            , viewFormInput "Current Carrier" "text" form.currentCarrier CurrentCarrier True model
            , viewFormInput "Plan Type" "text" form.planType PlanType True model
            , viewFormInput "Effective Date" "date" form.effectiveDate EffectiveDate True model
            , viewFormInput "Birth Date" "date" form.birthDate BirthDate True model
            , viewFormRadioGroup "Tobacco User"
                (if form.tobaccoUser then
                    "true"

                 else
                    "false"
                )
                TobaccoUser
                [ ( "true", "Yes" ), ( "false", "No" ) ]
            , viewFormRadioGroup "Gender" form.gender Gender [ ( "M", "Male" ), ( "F", "Female" ) ]
            , div [ class "col-span-2 grid grid-cols-2 gap-x-8" ]
                [ viewFormInput "ZIP Code" "text" form.zipCode ZipCode True model
                , viewFormInput "State" "text" form.state State True model
                ]
            ]
        , div [ class "mt-10 flex justify-end space-x-4" ]
            [ button
                [ type_ "button"
                , onClick CloseModal
                , class "px-6 py-3 bg-white text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200 focus:ring-4 focus:ring-purple-100"
                ]
                [ text "Cancel" ]
            , if isSubmitting then
                div [ class "px-6 py-3 flex items-center space-x-2" ] [ viewSpinner ]

              else
                button
                    [ type_ "submit"
                    , class "px-6 py-3 bg-purple-500 text-white text-sm font-medium rounded-lg hover:bg-purple-600 transition-colors duration-200 focus:ring-4 focus:ring-purple-200"
                    ]
                    [ text "Save Changes" ]
            ]
        ]


viewFormInput : String -> String -> String -> ContactFormField -> Bool -> Model -> Html Msg
viewFormInput labelText inputType inputValue field isRequired model =
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text labelText ]
        , if field == Email then
            div [ class "relative" ]
                [ Html.input
                    [ type_ inputType
                    , class
                        ("w-full px-4 py-3 bg-white border-[2.5px] rounded-lg text-gray-700 placeholder-gray-400 shadow-sm transition-all duration-200 "
                            ++ (if model.emailExists then
                                    "border-red-300 hover:border-red-400 focus:border-red-500 focus:ring-2 focus:ring-red-200"

                                else
                                    "border-purple-300 hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200"
                               )
                        )
                    , Html.Attributes.value inputValue
                    , onInput (UpdateEditForm field)
                    , onBlur (CheckEmail inputValue)
                    , required isRequired
                    ]
                    []
                , if model.isCheckingEmail then
                    div [ class "absolute right-3 top-3" ]
                        [ viewSpinner ]

                  else if model.emailExists then
                    div [ class "absolute right-3 top-3 text-red-500" ]
                        [ text "âœ•" ]

                  else if String.length inputValue > 0 then
                    div [ class "absolute right-3 top-3 text-green-500" ]
                        [ text "âœ“" ]

                  else
                    text ""
                ]

          else if field == State then
            Html.input
                [ type_ inputType
                , class "w-full px-4 py-3 bg-white border-[2.5px] border-gray-200 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200"
                , Html.Attributes.value inputValue
                , Html.Attributes.disabled True
                , required isRequired
                ]
                []

          else
            Html.input
                [ type_ inputType
                , class "w-full px-4 py-3 bg-white border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200"
                , Html.Attributes.value inputValue
                , onInput (UpdateEditForm field)
                , required isRequired
                ]
                []
        ]


viewFormRadioGroup : String -> String -> ContactFormField -> List ( String, String ) -> Html Msg
viewFormRadioGroup labelText selectedValue field options =
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text labelText ]
        , div [ class "flex gap-4" ]
            (List.map
                (\( val, txt ) ->
                    label
                        [ class
                            ("flex items-center px-4 py-2 rounded-lg border-2 cursor-pointer transition-all duration-200 "
                                ++ (if selectedValue == val then
                                        "border-purple-500 bg-purple-50 text-purple-700"

                                    else
                                        "border-gray-200 hover:border-purple-200"
                                   )
                            )
                        ]
                        [ input
                            [ type_ "radio"
                            , value val
                            , checked (selectedValue == val)
                            , onInput (UpdateEditForm field)
                            , class "sr-only"
                            ]
                            []
                        , text txt
                        ]
                )
                options
            )
        ]


encodeContactForm : ContactForm -> Encode.Value
encodeContactForm form =
    Encode.object
        [ ( "first_name", Encode.string form.firstName )
        , ( "last_name", Encode.string form.lastName )
        , ( "email", Encode.string form.email )
        , ( "phone_number", Encode.string (String.filter Char.isDigit form.phoneNumber |> String.left 10) )
        , ( "state", Encode.string form.state )
        , ( "contact_owner_id", Maybe.map Encode.int form.contactOwnerId |> Maybe.withDefault Encode.null )
        , ( "current_carrier", Encode.string form.currentCarrier )
        , ( "effective_date", Encode.string form.effectiveDate )
        , ( "birth_date", Encode.string form.birthDate )
        , ( "tobacco_user", Encode.bool form.tobaccoUser )
        , ( "gender", Encode.string form.gender )
        , ( "zip_code", Encode.string form.zipCode )
        , ( "plan_type", Encode.string form.planType )
        ]


viewLoading : Html Msg
viewLoading =
    div [ class "flex justify-center items-center h-64" ]
        [ div [ class "animate-spin rounded-full h-8 w-8 border-2 border-purple-500 border-t-transparent" ] [] ]


viewSpinner : Html msg
viewSpinner =
    div [ class "animate-spin rounded-full h-5 w-5 border-2 border-purple-500 border-t-transparent" ] []


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    if String.isEmpty phone then
        ""

    else
        let
            digits =
                String.filter Char.isDigit phone
                    |> String.left 10

            len =
                String.length digits
        in
        if len == 0 then
            ""

        else if len <= 3 then
            "(" ++ digits

        else if len <= 6 then
            "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

        else
            "(" ++ String.left 3 digits ++ ") " ++ String.slice 3 6 digits ++ "-" ++ String.dropLeft 6 digits



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    if model.showModal /= NoModal then
        Browser.Events.onKeyDown
            (Decode.map
                (\key ->
                    if key == "Escape" then
                        CloseModal

                    else
                        NoOp
                )
                (Decode.field "key" Decode.string)
            )

    else
        Sub.none


checkEmail : String -> Cmd Msg
checkEmail email =
    Http.get
        { url = "/api/contacts/check-email/" ++ email
        , expect = Http.expectJson EmailChecked (Decode.map (\exists -> { exists = exists }) (Decode.field "exists" Decode.bool))
        }


lookupZipCode : String -> Cmd Msg
lookupZipCode zipCode =
    Http.get
        { url = "/api/zip-lookup/" ++ zipCode
        , expect = Http.expectJson GotZipLookup zipInfoDecoder
        }


zipInfoDecoder : Decode.Decoder ZipInfo
zipInfoDecoder =
    Decode.succeed ZipInfo
        |> Pipeline.required "state" Decode.string
        |> Pipeline.required "counties" (Decode.list Decode.string)
        |> Pipeline.required "cities" (Decode.list Decode.string)


deleteContact : Int -> Cmd Msg
deleteContact contactId =
    Http.request
        { method = "DELETE"
        , headers = []
        , url = "/api/contacts"
        , body = Http.jsonBody (Encode.list Encode.int [ contactId ])
        , expect = Http.expectJson ContactDeleted deleteResponseDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


type alias DeleteResponse =
    { success : Bool
    , deletedIds : List Int
    , message : String
    }


deleteResponseDecoder : Decode.Decoder DeleteResponse
deleteResponseDecoder =
    Decode.map3 DeleteResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "deleted_ids" (Decode.list Decode.int))
        (Decode.field "message" Decode.string)


viewDeleteConfirmModal : Model -> Html Msg
viewDeleteConfirmModal model =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ text "Ã—" ]
            , h2 [ class "text-xl font-semibold text-gray-900 mb-4" ]
                [ text "Delete Contact" ]
            , p [ class "text-sm text-gray-600 mb-6" ]
                [ text "Are you sure you want to delete this contact? This action cannot be undone." ]
            , div [ class "flex justify-end space-x-4" ]
                [ button
                    [ class "px-4 py-2 text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200"
                    , onClick CloseModal
                    ]
                    [ text "Cancel" ]
                , if model.isDeletingContact then
                    div [ class "px-4 py-2 flex items-center" ]
                        [ viewSpinner ]

                  else
                    button
                        [ class "px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors duration-200"
                        , onClick DeleteContact
                        ]
                        [ text "Delete" ]
                ]
            ]
        ]

================
File: frontend/src/Contacts.elm
================
module Contacts exposing
    ( Model
    , Msg(..)
    , init
    , subscriptions
    , update
    , view
    )

import Browser
import Browser.Events
import Browser.Navigation as Nav
import File exposing (File)
import File.Download
import File.Select as Select
import Html exposing (Html, button, col, colgroup, details, div, h1, h2, h3, input, label, nav, option, p, select, span, summary, table, tbody, td, text, th, thead, tr)
import Html.Attributes exposing (attribute, checked, class, placeholder, required, title, type_, value)
import Html.Events exposing (on, onClick, onInput, onSubmit, preventDefaultOn, stopPropagationOn)
import Http
import Json.Decode as Decode exposing (Decoder, bool, int, nullable, string)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import List.Extra
import Svg exposing (path, svg)
import Svg.Attributes exposing (d, fill, stroke, viewBox)
import Task
import Time
import Url exposing (Url)
import Url.Builder as Url



-- MAIN


main : Program () Model Msg
main =
    Browser.application
        { init = \flags url key -> init key
        , view = \model -> { title = "Dashboard", body = [ view model ] }
        , update = update
        , subscriptions = subscriptions
        , onUrlChange = \_ -> NoOp
        , onUrlRequest = \_ -> NoOp
        }



-- MODEL


type alias Contact =
    { id : Int
    , firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , state : String
    , contactOwnerId : Maybe Int
    , contactOwner : Maybe User
    , currentCarrier : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : Bool
    , gender : String
    , zipCode : String
    , planType : String
    , status : String
    , agentId : Maybe Int
    , lastEmailed : Maybe String
    }


type Modal
    = NoModal
    | ContactChoiceModal
    | AddModal
    | EditModal Contact
    | CsvUploadModal UploadState
    | DeleteConfirmModal


type alias Model =
    { contacts : List Contact
    , selectedContacts : List Int
    , showModal : Modal
    , searchQuery : String
    , addForm : ContactForm
    , editForm : ContactForm
    , sortColumn : Maybe SortColumn
    , sortDirection : SortDirection
    , activeFilters : Filters
    , openFilter : Maybe FilterType
    , currentTime : Time.Posix
    , isLoadingContacts : Bool
    , isUploadingCsv : Bool
    , isDeletingContacts : Bool
    , isSubmittingForm : Bool
    , isCheckingEmail : Bool
    , emailExists : Bool
    , currentUser : Maybe User
    , showProfileMenu : Bool
    , error : Maybe String
    , saveOnUpdate : Bool
    , expandedContactId : Maybe Int
    , availableFilters : AvailableFilters
    , carriers : List String
    , agents : List User
    , key : Nav.Key
    }


type alias ContactForm =
    { id : Maybe Int
    , firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , state : String
    , contactOwnerId : Maybe Int
    , currentCarrier : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : Bool
    , gender : String
    , zipCode : String
    , planType : String
    }


type SortColumn
    = NameCol
    | StatusCol
    | EmailCol
    | PhoneNumberCol
    | StateCol
    | ContactOwnerCol
    | CurrentCarrierCol
    | EffectiveDateCol


type SortDirection
    = Ascending
    | Descending


type alias Filters =
    { carriers : List String
    , states : List String
    , ageRange : Maybe ( Int, Int )
    }


type alias ZipInfo =
    { state : String
    , counties : List String
    , cities : List String
    }


type alias UploadState =
    { dragOver : Bool
    , file : Maybe File
    , error : Maybe String
    , errorCsv : Maybe String
    , converted_carriers_csv : Maybe String
    , stats : Maybe UploadStats
    , overwriteDuplicates : Bool
    }


type alias UploadStats =
    { totalRows : Int
    , errorRows : Int
    , validRows : Int
    , converted_carrier_rows : Int
    , supported_carriers : List { name : String, aliases : List String }
    }


type alias DeleteResponse =
    { success : Bool
    , deletedIds : List Int
    , message : String
    }


type alias User =
    { id : Int
    , email : String
    , firstName : String
    , lastName : String
    , isAdmin : Bool
    , isAgent : Bool
    , organizationId : Int
    , isActive : Bool
    , phone : String
    }


type alias AvailableFilters =
    { carriers : List String
    , states : List String
    }


type alias ContactsResponse =
    { contacts : List Contact
    , filterOptions : AvailableFilters
    }


init : Nav.Key -> ( Model, Cmd Msg )
init key =
    let
        initialModel =
            { contacts = []
            , selectedContacts = []
            , showModal = NoModal
            , searchQuery = ""
            , addForm = emptyForm
            , editForm = emptyForm
            , sortColumn = Nothing
            , sortDirection = Ascending
            , activeFilters = emptyFilters
            , openFilter = Nothing
            , currentTime = Time.millisToPosix 0
            , isLoadingContacts = True
            , isUploadingCsv = False
            , isDeletingContacts = False
            , isSubmittingForm = False
            , isCheckingEmail = False
            , emailExists = False
            , currentUser = Nothing
            , showProfileMenu = False
            , error = Nothing
            , saveOnUpdate = False
            , expandedContactId = Nothing
            , availableFilters = { carriers = [], states = [] }
            , carriers = []
            , agents = []
            , key = key
            }
    in
    ( initialModel
    , Cmd.batch
        [ fetchContacts initialModel
        , fetchCurrentUser
        , Task.perform GotCurrentTime Time.now
        , fetchCarriers
        , fetchAgents
        ]
    )


emptyForm : ContactForm
emptyForm =
    { id = Nothing
    , firstName = ""
    , lastName = ""
    , email = ""
    , phoneNumber = ""
    , state = ""
    , contactOwnerId = Nothing
    , currentCarrier = ""
    , effectiveDate = ""
    , birthDate = ""
    , tobaccoUser = False
    , gender = "M"
    , zipCode = ""
    , planType = ""
    }


emptyFilters : Filters
emptyFilters =
    { carriers = []
    , states = []
    , ageRange = Nothing
    }


emptyUploadState : UploadState
emptyUploadState =
    { dragOver = False
    , file = Nothing
    , error = Nothing
    , errorCsv = Nothing
    , converted_carriers_csv = Nothing
    , stats = Nothing
    , overwriteDuplicates = True
    }



-- UPDATE


type Msg
    = NoOp
    | ShowContactChoiceModal
    | ChooseSingleContact
    | ChooseMultipleContacts
    | ShowAddModal
    | ShowEditModal Contact
    | CloseModal
    | UpdateSearchQuery String
    | UpdateAddForm ContactFormField String
    | UpdateEditForm ContactFormField String
    | SubmitAddForm
    | SubmitEditForm
    | CheckEmail String
    | EmailChecked (Result Http.Error { exists : Bool })
    | GotContacts (Result Http.Error ContactsResponse)
    | ContactAdded (Result Http.Error Contact)
    | ContactUpdated (Result Http.Error Contact)
    | HandleKeyDown String
    | SetSort SortColumn
    | ToggleFilter FilterType String
    | SetAgeFilter Int Int
    | ClearFilters
    | LookupZipCode String
    | GotZipLookup (Result Http.Error ZipInfo)
    | Batch (List Msg)
    | ToggleFilterDropdown FilterType
    | SelectAllFilter FilterType Bool
    | CloseFilterDropdown
    | GotCurrentTime Time.Posix
    | ToggleSelectContact Int
    | SelectAllContacts
    | DeselectAllContacts
    | EmailSelectedCarriers
    | EmailSelectedContacts
    | ShowCsvUploadModal
    | DragEnter
    | DragLeave
    | FileDrop File
    | FileSelected File
    | ClickedSelectFile
    | UploadCsv
    | CsvUploaded (Result Http.Error UploadResponse)
    | DownloadErrorCsv String
    | DownloadCarrierConversionsCsv String
    | ShowDeleteConfirmModal
    | DeleteSelectedContacts
    | ContactsDeleted (Result Http.Error DeleteResponse)
    | ToggleOverwriteDuplicates Bool
    | GotCurrentUser (Result Http.Error User)
    | NavigateToContact Int
    | GotCarriers (Result Http.Error (List String))
    | GotAgents (Result Http.Error (List User))


type ContactFormField
    = FirstName
    | LastName
    | Email
    | PhoneNumber
    | State
    | ContactOwnerId
    | CurrentCarrier
    | EffectiveDate
    | BirthDate
    | TobaccoUser
    | Gender
    | ZipCode
    | PlanType


type FilterType
    = CarrierFilter
    | StateFilter
    | AgeFilter


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        ShowContactChoiceModal ->
            ( { model | showModal = ContactChoiceModal }, Cmd.none )

        ChooseSingleContact ->
            ( { model | showModal = AddModal }, Cmd.none )

        ChooseMultipleContacts ->
            ( { model | showModal = CsvUploadModal emptyUploadState }, Cmd.none )

        ShowAddModal ->
            ( { model | showModal = AddModal }, Cmd.none )

        ShowEditModal contact ->
            ( { model
                | showModal = EditModal contact
                , editForm =
                    { id = Just contact.id
                    , firstName = contact.firstName
                    , lastName = contact.lastName
                    , email = contact.email
                    , phoneNumber = contact.phoneNumber
                    , state = contact.state
                    , contactOwnerId = contact.contactOwnerId
                    , currentCarrier = contact.currentCarrier
                    , effectiveDate = contact.effectiveDate
                    , birthDate = contact.birthDate
                    , tobaccoUser = contact.tobaccoUser
                    , gender = contact.gender
                    , zipCode = contact.zipCode
                    , planType = contact.planType
                    }
              }
            , Cmd.none
            )

        CloseModal ->
            ( { model
                | showModal = NoModal
                , addForm = emptyForm
                , editForm = emptyForm
                , isCheckingEmail = False
                , emailExists = False
                , error = Nothing
                , isSubmittingForm = False
              }
            , Cmd.none
            )

        UpdateSearchQuery query ->
            let
                updatedModel =
                    { model | searchQuery = query, isLoadingContacts = True }
            in
            ( updatedModel, fetchContacts updatedModel )

        UpdateAddForm field value ->
            let
                form =
                    model.addForm

                updatedForm =
                    case field of
                        FirstName ->
                            { form | firstName = value }

                        LastName ->
                            { form | lastName = value }

                        Email ->
                            { form | email = value }

                        PhoneNumber ->
                            { form | phoneNumber = String.filter Char.isDigit value |> String.left 10 }

                        State ->
                            { form | state = value }

                        ContactOwnerId ->
                            { form | contactOwnerId = String.toInt value }

                        CurrentCarrier ->
                            { form | currentCarrier = value }

                        EffectiveDate ->
                            { form | effectiveDate = value }

                        BirthDate ->
                            { form | birthDate = value }

                        TobaccoUser ->
                            { form | tobaccoUser = value == "true" }

                        Gender ->
                            { form | gender = value }

                        ZipCode ->
                            { form | zipCode = value }

                        PlanType ->
                            { form | planType = value }

                cmd =
                    if field == ZipCode && String.length value == 5 then
                        submitEditFormWithFlag updatedForm True

                    else if field == Email && String.length value > 0 then
                        checkEmail value

                    else
                        Cmd.none
            in
            case model.showModal of
                ContactChoiceModal ->
                    ( model, Cmd.none )

                AddModal ->
                    ( { model
                        | addForm = updatedForm
                        , isCheckingEmail = field == Email && String.length value > 0
                        , emailExists = False
                        , error = Nothing
                      }
                    , cmd
                    )

                EditModal _ ->
                    ( { model | editForm = updatedForm }, cmd )

                NoModal ->
                    ( model, Cmd.none )

                CsvUploadModal _ ->
                    ( model, Cmd.none )

                DeleteConfirmModal ->
                    ( model, Cmd.none )

        UpdateEditForm field value ->
            let
                form =
                    model.editForm

                updatedForm =
                    case field of
                        FirstName ->
                            { form | firstName = value }

                        LastName ->
                            { form | lastName = value }

                        Email ->
                            { form | email = value }

                        PhoneNumber ->
                            { form | phoneNumber = String.filter Char.isDigit value |> String.left 10 }

                        State ->
                            { form | state = value }

                        ContactOwnerId ->
                            { form | contactOwnerId = String.toInt value }

                        CurrentCarrier ->
                            { form | currentCarrier = value }

                        EffectiveDate ->
                            { form | effectiveDate = value }

                        BirthDate ->
                            { form | birthDate = value }

                        TobaccoUser ->
                            { form | tobaccoUser = value == "true" }

                        Gender ->
                            { form | gender = value }

                        ZipCode ->
                            { form | zipCode = value }

                        PlanType ->
                            { form | planType = value }

                cmd =
                    if field == ZipCode && String.length value == 5 then
                        LookupZipCode value
                            |> Task.succeed
                            |> Task.perform identity

                    else if field == Email && String.length value > 0 then
                        checkEmail value

                    else
                        Cmd.none
            in
            case model.showModal of
                ContactChoiceModal ->
                    ( model, Cmd.none )

                AddModal ->
                    ( { model | addForm = updatedForm }, cmd )

                EditModal _ ->
                    ( { model | editForm = updatedForm }, cmd )

                NoModal ->
                    ( model, Cmd.none )

                CsvUploadModal _ ->
                    ( model, Cmd.none )

                DeleteConfirmModal ->
                    ( model, Cmd.none )

        SubmitAddForm ->
            ( { model | isSubmittingForm = True }
            , submitAddForm model.addForm
            )

        SubmitEditForm ->
            ( { model
                | isSubmittingForm = True
                , saveOnUpdate = True
              }
            , submitEditFormWithFlag model.editForm False
            )

        CheckEmail email ->
            ( { model | isCheckingEmail = True }
            , checkEmail email
            )

        EmailChecked (Ok response) ->
            ( { model
                | isCheckingEmail = False
                , emailExists = response.exists
                , error =
                    if response.exists then
                        Just "A contact with this email already exists"

                    else
                        Nothing
              }
            , Cmd.none
            )

        EmailChecked (Err _) ->
            ( { model
                | isCheckingEmail = False
                , error = Just "Failed to check email. Please try again."
              }
            , Cmd.none
            )

        GotContacts (Ok response) ->
            ( { model
                | contacts = response.contacts
                , isLoadingContacts = False
                , availableFilters = response.filterOptions
              }
            , Cmd.none
            )

        GotContacts (Err error) ->
            let
                _ =
                    Debug.log "Error fetching contacts" error
            in
            ( model, Cmd.none )

        ContactAdded (Ok contact) ->
            ( { model
                | contacts = contact :: model.contacts
                , showModal = NoModal
                , addForm = emptyForm
                , isSubmittingForm = False
              }
            , Cmd.none
            )

        ContactAdded (Err _) ->
            ( { model | isSubmittingForm = False }
            , Cmd.none
            )

        ContactUpdated (Ok contact) ->
            let
                updatedContacts =
                    updateContact contact model.contacts

                updatedModel =
                    if model.saveOnUpdate then
                        -- Close the modal for a final save
                        { model
                            | contacts = updatedContacts
                            , showModal = NoModal
                            , editForm = emptyForm
                            , isSubmittingForm = False
                            , error = Nothing
                            , saveOnUpdate = False
                        }

                    else
                        -- Just update the state field in the form
                        { model
                            | contacts = updatedContacts
                            , editForm =
                                model.editForm
                                    |> (\form -> { form | state = contact.state })
                            , isSubmittingForm = False
                            , error = Nothing
                        }
            in
            ( updatedModel, Cmd.none )

        ContactUpdated (Err error) ->
            ( { model
                | isSubmittingForm = False
                , error = Just "Failed to update contact. Please check the ZIP code is valid."
              }
            , Cmd.none
            )

        HandleKeyDown key ->
            if key == "Escape" then
                ( { model | showModal = NoModal }, Cmd.none )

            else
                ( model, Cmd.none )

        SetSort column ->
            let
                ( newColumn, newDirection ) =
                    case ( model.sortColumn, model.sortDirection ) of
                        ( Just currentColumn, direction ) ->
                            if currentColumn == column then
                                -- Toggle direction if same column
                                ( Just column
                                , if direction == Ascending then
                                    Descending

                                  else
                                    Ascending
                                )

                            else
                                -- New column, start with ascending
                                ( Just column, Ascending )

                        ( Nothing, _ ) ->
                            -- First time sorting, start with ascending
                            ( Just column, Ascending )
            in
            ( { model
                | sortColumn = newColumn
                , sortDirection = newDirection
              }
            , Cmd.none
            )

        ToggleFilter filterType value ->
            let
                updatedModel =
                    { model
                        | activeFilters = toggleFilter model.activeFilters filterType value
                        , isLoadingContacts = True
                    }
            in
            ( updatedModel, fetchContacts updatedModel )

        SetAgeFilter min max ->
            ( { model | activeFilters = setAgeFilter min max model.activeFilters }, Cmd.none )

        ClearFilters ->
            ( { model | activeFilters = emptyFilters }, Cmd.none )

        LookupZipCode zipCode ->
            ( model
            , Http.get
                { url = "/api/zip-lookup/" ++ zipCode
                , expect = Http.expectJson GotZipLookup zipInfoDecoder
                }
            )

        GotZipLookup (Ok zipInfo) ->
            let
                updateForm form =
                    { form | state = zipInfo.state }
            in
            case model.showModal of
                ContactChoiceModal ->
                    ( model, Cmd.none )

                AddModal ->
                    ( { model | addForm = updateForm model.addForm }, Cmd.none )

                EditModal _ ->
                    ( { model | editForm = updateForm model.editForm }, Cmd.none )

                NoModal ->
                    ( model, Cmd.none )

                CsvUploadModal _ ->
                    ( model, Cmd.none )

        GotZipLookup (Err _) ->
            ( model, Cmd.none )

        Batch messages ->
            List.foldl
                (\msg_ ( model_, cmds ) ->
                    let
                        ( newModel, newCmd ) =
                            update msg_ model_
                    in
                    ( newModel, newCmd :: cmds )
                )
                ( model, [] )
                messages
                |> (\( m, cs ) -> ( m, Cmd.batch cs ))

        ToggleFilterDropdown filterType ->
            ( { model
                | openFilter =
                    if model.openFilter == Just filterType then
                        Nothing

                    else
                        Just filterType
              }
            , Cmd.none
            )

        SelectAllFilter filterType select ->
            let
                options =
                    case filterType of
                        CarrierFilter ->
                            model.availableFilters.carriers

                        StateFilter ->
                            model.availableFilters.states

                        _ ->
                            []

                updatedFilters =
                    case filterType of
                        CarrierFilter ->
                            { carriers =
                                if select then
                                    options

                                else
                                    []
                            , states = model.activeFilters.states
                            , ageRange = model.activeFilters.ageRange
                            }

                        StateFilter ->
                            { carriers = model.activeFilters.carriers
                            , states =
                                if select then
                                    options

                                else
                                    []
                            , ageRange = model.activeFilters.ageRange
                            }

                        _ ->
                            model.activeFilters

                updatedModel =
                    { model | activeFilters = updatedFilters }
            in
            ( updatedModel, fetchContacts updatedModel )

        CloseFilterDropdown ->
            ( { model | openFilter = Nothing }, Cmd.none )

        GotCurrentTime time ->
            ( { model | currentTime = time }, Cmd.none )

        ToggleSelectContact id ->
            ( { model
                | selectedContacts =
                    if List.member id model.selectedContacts then
                        List.filter (\x -> x /= id) model.selectedContacts

                    else
                        id :: model.selectedContacts
              }
            , Cmd.none
            )

        SelectAllContacts ->
            let
                visibleContacts =
                    model.contacts
                        |> filterContacts model.activeFilters model.searchQuery model.currentTime
                        |> List.map .id
            in
            ( { model | selectedContacts = visibleContacts }
            , Cmd.none
            )

        DeselectAllContacts ->
            ( { model | selectedContacts = [] }
            , Cmd.none
            )

        EmailSelectedCarriers ->
            -- For now, just a placeholder that does nothing
            ( model, Cmd.none )

        EmailSelectedContacts ->
            -- For now, just a placeholder that does nothing
            ( model, Cmd.none )

        ShowCsvUploadModal ->
            ( { model | showModal = CsvUploadModal emptyUploadState }, Cmd.none )

        DragEnter ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | dragOver = True } }, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        DragLeave ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | dragOver = False } }, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        FileDrop file ->
            let
                _ =
                    Debug.log "File dropped"
                        { fileName = File.name file
                        , fileSize = File.size file
                        }
            in
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | file = Just file, dragOver = False } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        FileSelected file ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | file = Just file } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        ClickedSelectFile ->
            ( model
            , Select.file [ "text/csv" ] FileSelected
            )

        UploadCsv ->
            case model.showModal of
                CsvUploadModal state ->
                    case state.file of
                        Just file ->
                            ( { model
                                | showModal = CsvUploadModal { state | error = Nothing, errorCsv = Nothing, stats = Nothing }
                                , isUploadingCsv = True
                              }
                            , uploadCsv file state.overwriteDuplicates
                            )

                        Nothing ->
                            ( model, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        CsvUploaded (Ok response) ->
            let
                _ =
                    Debug.log "CSV Upload Response" response

                errorMessage =
                    if String.startsWith "Missing required columns:" response.message then
                        let
                            missingColumns =
                                String.dropLeft (String.length "Missing required columns:") response.message
                                    |> String.trim
                                    |> String.split ","
                                    |> List.map String.trim
                                    |> String.join ", "
                        in
                        "Your CSV is missing the following required columns: " ++ missingColumns ++ ". Please add these columns and try again."

                    else
                        response.message

                currentModal =
                    case model.showModal of
                        CsvUploadModal state ->
                            if response.success && response.errorRows == 0 then
                                NoModal

                            else
                                CsvUploadModal
                                    { state
                                        | error = Just errorMessage
                                        , errorCsv = response.errorCsv
                                        , converted_carriers_csv = response.converted_carriers_csv
                                        , stats =
                                            Just
                                                { totalRows = response.totalRows
                                                , errorRows = response.errorRows
                                                , validRows = response.validRows
                                                , converted_carrier_rows = response.converted_carrier_rows
                                                , supported_carriers = response.supported_carriers
                                                }
                                    }

                        _ ->
                            model.showModal

                updatedModel =
                    { model
                        | showModal = currentModal
                        , isUploadingCsv = False
                    }
            in
            ( updatedModel
            , if response.success then
                fetchContacts updatedModel

              else
                Cmd.none
            )

        CsvUploaded (Err httpError) ->
            let
                _ =
                    Debug.log "CSV Upload Error" httpError

                errorMessage =
                    case httpError of
                        Http.BadStatus 400 ->
                            "The CSV format is invalid. Please check that all required columns are present and data is in the correct format."

                        Http.NetworkError ->
                            "Network error. Please check your connection and try again."

                        Http.Timeout ->
                            "The upload timed out. Please try again."

                        _ ->
                            "An unexpected error occurred while uploading the CSV. Please try again."
            in
            case model.showModal of
                CsvUploadModal state ->
                    ( { model
                        | showModal = CsvUploadModal { state | error = Just errorMessage }
                        , isUploadingCsv = False
                      }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        DownloadErrorCsv csvContent ->
            ( model
            , File.Download.string "upload_errors.csv" "text/csv" csvContent
            )

        DownloadCarrierConversionsCsv csvContent ->
            ( model
            , File.Download.string "carrier_conversions.csv" "text/csv" csvContent
            )

        ShowDeleteConfirmModal ->
            ( { model | showModal = DeleteConfirmModal }, Cmd.none )

        DeleteSelectedContacts ->
            ( { model | isDeletingContacts = True, showModal = NoModal }
            , if List.isEmpty model.selectedContacts then
                Cmd.none

              else
                deleteContacts model.selectedContacts
            )

        ContactsDeleted (Ok response) ->
            if response.success then
                let
                    updatedModel =
                        { model
                            | contacts = List.filter (\c -> not (List.member c.id response.deletedIds)) model.contacts
                            , selectedContacts = []
                            , isDeletingContacts = False
                        }
                in
                ( updatedModel
                , fetchContacts updatedModel
                )

            else
                ( { model | isDeletingContacts = False }, Cmd.none )

        ContactsDeleted (Err _) ->
            ( model, Cmd.none )

        ToggleOverwriteDuplicates value ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | overwriteDuplicates = value } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        GotCurrentUser (Ok user) ->
            ( { model | currentUser = Just user }, Cmd.none )

        GotCurrentUser (Err _) ->
            ( model, Cmd.none )

        NavigateToContact id ->
            ( model, Nav.pushUrl model.key ("/contact/" ++ String.fromInt id) )

        GotCarriers (Ok carriers) ->
            ( { model | carriers = carriers }
            , Cmd.none
            )

        GotCarriers (Err _) ->
            ( model, Cmd.none )

        GotAgents (Ok agents) ->
            ( { model | agents = agents }, Cmd.none )

        GotAgents (Err _) ->
            ( model, Cmd.none )



-- TODO: Handle error
-- Add other update cases here...
-- VIEW


view : Model -> Html Msg
view model =
    div [ class "min-h-screen bg-white" ]
        [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
            [ -- Stats Section
              div [ class "grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4 mb-8" ]
                [ statsCard "Total Contacts" (String.fromInt (List.length model.contacts))
                , statsCard "Emails Sent" "1824"
                , statsCard "Emails Clicked" "425"
                , statsCard "Quotes Created" "385"
                ]
            , -- Filters and Actions
              div [ class "flex justify-between items-center mb-6" ]
                [ div [ class "flex items-center gap-4" ]
                    [ h1 [ class "text-lg font-semibold" ] [ text "Contacts " ]
                    , span [ class "text-sm text-gray-500" ]
                        [ text ("(" ++ String.fromInt (List.length model.contacts) ++ ")") ]
                    ]
                , div [ class "flex items-center gap-3" ]
                    [ if not (List.isEmpty model.selectedContacts) then
                        button
                            [ class "px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors duration-200 flex items-center gap-2"
                            , onClick ShowDeleteConfirmModal
                            ]
                            [ if model.isDeletingContacts then
                                viewSpinner

                              else
                                text ("Delete " ++ String.fromInt (List.length model.selectedContacts) ++ " Selected")
                            ]

                      else
                        text ""
                    , div [ class "relative" ]
                        [ button
                            [ class "inline-flex items-center gap-2 px-3 py-2 border rounded-lg text-sm text-gray-700 hover:bg-gray-50"
                            , onClick (ToggleFilterDropdown CarrierFilter)
                            ]
                            [ text "Carrier"
                            , viewIcon "M19 9l-7 7-7-7"
                            ]
                        , if model.openFilter == Just CarrierFilter then
                            viewFilterDropdown model CarrierFilter

                          else
                            text ""
                        ]
                    , div [ class "relative" ]
                        [ button
                            [ class "inline-flex items-center gap-2 px-3 py-2 border rounded-lg text-sm text-gray-700 hover:bg-gray-50"
                            , onClick (ToggleFilterDropdown StateFilter)
                            ]
                            [ text "State"
                            , viewIcon "M19 9l-7 7-7-7"
                            ]
                        , if model.openFilter == Just StateFilter then
                            viewFilterDropdown model StateFilter

                          else
                            text ""
                        ]
                    , div [ class "relative" ]
                        [ input
                            [ class "w-64 px-4 py-2 border rounded-lg text-sm placeholder-gray-500 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                            , placeholder "Search contacts..."
                            , value model.searchQuery
                            , onInput UpdateSearchQuery
                            ]
                            []
                        ]
                    , button
                        [ class "px-4 py-2 bg-black text-white rounded-lg text-sm hover:bg-gray-800 transition-colors"
                        , onClick ShowContactChoiceModal
                        ]
                        [ text "+ Add Contact" ]
                    ]
                ]
            , -- Table Container with overflow handling
              div [ class "overflow-x-auto" ]
                [ table [ class "min-w-full border-separate border-spacing-0" ]
                    [ colgroup []
                        [ col [ class "w-12" ] [] -- Checkbox
                        , col [ class "w-48" ] [] -- Name
                        , col [ class "w-32" ] [] -- Contact Status
                        , col [ class "w-48" ] [] -- Email
                        , col [ class "w-32" ] [] -- Phone Number
                        , col [ class "w-16" ] [] -- State
                        , col [ class "w-32" ] [] -- Contact Owner (optional)
                        , col [ class "w-32" ] [] -- Current Carrier
                        , col [ class "w-28" ] [] -- Effective Date
                        , col [ class "w-20" ] [] -- Actions
                        ]
                    , thead [ class "bg-gray-50" ]
                        [ tr []
                            [ th [ class "sticky top-0 px-3 py-2 border-b border-gray-200 bg-gray-50" ]
                                [ input
                                    [ type_ "checkbox"
                                    , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                    , checked (not (List.isEmpty model.contacts) && List.length model.selectedContacts == List.length model.contacts)
                                    , onClick
                                        (if not (List.isEmpty model.contacts) && List.length model.selectedContacts == List.length model.contacts then
                                            DeselectAllContacts

                                         else
                                            SelectAllContacts
                                        )
                                    ]
                                    []
                                ]
                            , tableHeader "Name"
                            , tableHeader "Contact Status"
                            , tableHeader "Email"
                            , tableHeader "Phone Number"
                            , tableHeader "State"
                            , if isAdminOrAdminAgent model.currentUser then
                                tableHeader "Contact Owner"

                              else
                                text ""
                            , tableHeader "Current Carrier"
                            , tableHeader "Effective Date"
                            , tableHeader "Actions"
                            ]
                        ]
                    , tbody [ class "bg-white" ]
                        (if model.isLoadingContacts then
                            [ tr []
                                [ td
                                    [ class "px-3 py-8 text-sm text-gray-500 text-center border-t border-gray-200"
                                    , attribute "colspan" "9"
                                    ]
                                    [ div [ class "flex items-center justify-center gap-3" ]
                                        [ viewSpinner
                                        , text "Loading contacts..."
                                        ]
                                    ]
                                ]
                            ]

                         else if List.isEmpty model.contacts then
                            [ tr []
                                [ td
                                    [ class "px-3 py-2 text-sm text-gray-500 text-center border-t border-gray-200"
                                    , attribute "colspan" "9"
                                    ]
                                    [ text "No contacts found" ]
                                ]
                            ]

                         else
                            List.concatMap (viewTableRow model) model.contacts
                        )
                    ]
                ]
            ]
        , viewModals model
        , if not (List.isEmpty model.selectedContacts) then
            viewBulkActionBar model

          else
            text ""
        ]


viewBulkActionBar : Model -> Html Msg
viewBulkActionBar model =
    div
        [ class "fixed bottom-0 inset-x-0 bg-white border-t border-gray-200 shadow-lg transform transition-all duration-200" ]
        [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4" ]
            [ div [ class "flex justify-between items-center" ]
                [ div [ class "flex items-center gap-4" ]
                    [ span [ class "text-sm text-gray-600" ]
                        [ text (String.fromInt (List.length model.selectedContacts) ++ " contacts selected") ]
                    ]
                , div [ class "flex items-center gap-3" ]
                    [ button
                        [ class "px-4 py-2 text-sm font-medium text-gray-700 hover:text-gray-900"
                        , onClick DeselectAllContacts
                        ]
                        [ text "Cancel" ]
                    , button
                        [ class "px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors duration-200"
                        , onClick DeleteSelectedContacts
                        ]
                        [ if model.isDeletingContacts then
                            viewSpinner

                          else
                            text "Delete Selected"
                        ]
                    ]
                ]
            ]
        ]


statsCard : String -> String -> Html Msg
statsCard title value =
    div [ class "bg-white rounded-lg border p-6 hover:shadow-lg transition-shadow" ]
        [ div [ class "text-sm text-gray-600 mb-2" ] [ text title ]
        , div [ class "text-3xl font-semibold" ] [ text value ]
        ]


tableHeader : String -> Html Msg
tableHeader headerText =
    th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200 bg-gray-50" ]
        [ text headerText ]


viewTableRow : Model -> Contact -> List (Html Msg)
viewTableRow model contact =
    let
        cellClass =
            "px-3 py-2 text-sm border-t border-gray-200"

        initials =
            String.left 1 contact.firstName ++ String.left 1 contact.lastName
    in
    [ tr [ class "hover:bg-gray-50 transition-colors duration-200" ]
        [ td
            [ class (cellClass ++ " text-center")
            ]
            [ input
                [ type_ "checkbox"
                , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                , checked (List.member contact.id model.selectedContacts)
                , onClick (ToggleSelectContact contact.id)
                ]
                []
            ]
        , td [ class cellClass ]
            [ div [ class "flex items-center" ]
                [ div [ class "h-8 w-8 rounded-full bg-purple-100 flex items-center justify-center text-sm text-purple-700 font-medium uppercase" ]
                    [ text initials ]
                , div [ class "ml-3 text-sm text-gray-900" ]
                    [ text (contact.firstName ++ " " ++ contact.lastName) ]
                ]
            ]
        , td [ class cellClass ]
            [ viewStatus contact.status ]
        , td [ class cellClass ]
            [ text contact.email ]
        , td [ class cellClass ]
            [ text (formatPhoneNumber contact.phoneNumber) ]
        , td [ class cellClass ]
            [ text contact.state ]
        , if isAdminOrAdminAgent model.currentUser then
            td [ class cellClass ]
                [ text (Maybe.map .firstName contact.contactOwner |> Maybe.withDefault "Default") ]

          else
            text ""
        , td [ class cellClass ]
            [ text contact.currentCarrier ]
        , td [ class cellClass ]
            [ text contact.effectiveDate ]
        , td [ class cellClass ]
            [ button
                [ class "text-purple-600 hover:text-purple-800 transition-colors duration-200"
                , onClick (NavigateToContact contact.id)
                ]
                [ viewIcon "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" ]
            ]
        ]
    ]


viewStatus : String -> Html Msg
viewStatus status =
    let
        ( bgColor, textColor, statusText ) =
            case status of
                "Quote Created" ->
                    ( "bg-green-50", "text-green-700", "Quote Created" )

                "Opened Email" ->
                    ( "bg-red-50", "text-red-700", "Opened Email" )

                "Email #2 Sent" ->
                    ( "bg-blue-50", "text-blue-700", "Email #2 Sent" )

                "Email #1 Sent" ->
                    ( "bg-blue-50", "text-blue-700", "Email #1 Sent" )

                "In Queue" ->
                    ( "bg-orange-50", "text-orange-700", "In Queue" )

                _ ->
                    ( "bg-gray-50", "text-gray-700", status )
    in
    div [ class ("inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium " ++ bgColor ++ " " ++ textColor) ]
        [ text statusText ]



-- HELPERS


updateContact : Contact -> List Contact -> List Contact
updateContact updated contacts =
    List.map
        (\contact ->
            if contact.id == updated.id then
                updated

            else
                contact
        )
        contacts



-- HTTP


submitAddForm : ContactForm -> Cmd Msg
submitAddForm form =
    Http.post
        { url = "/api/contacts"
        , body = Http.jsonBody (encodeContactForm form)
        , expect = Http.expectJson ContactAdded contactDecoder
        }


submitEditFormWithFlag : ContactForm -> Bool -> Cmd Msg
submitEditFormWithFlag form isZipUpdate =
    case form.id of
        Just id ->
            let
                url =
                    if isZipUpdate then
                        "/api/contacts/" ++ String.fromInt id ++ "?zip_update=true"

                    else
                        "/api/contacts/" ++ String.fromInt id
            in
            Http.request
                { method = "PUT"
                , headers = []
                , url = url
                , body = Http.jsonBody (encodeContactForm form)
                , expect = Http.expectJson ContactUpdated contactDecoder
                , timeout = Nothing
                , tracker = Nothing
                }

        Nothing ->
            Cmd.none



-- JSON


contactDecoder : Decode.Decoder Contact
contactDecoder =
    let
        debugLog label value =
            let
                _ =
                    Debug.log ("Decoding " ++ label) value
            in
            value
    in
    Decode.succeed Contact
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "first_name" Decode.string
        |> Pipeline.required "last_name" Decode.string
        |> Pipeline.required "email" Decode.string
        |> Pipeline.optional "phone_number"
            (Decode.string
                |> Decode.andThen
                    (\val ->
                        let
                            _ =
                                Debug.log "Raw phone_number" val
                        in
                        Decode.succeed val
                    )
            )
            ""
        |> Pipeline.required "state" Decode.string
        |> Pipeline.optional "contact_owner_id" (Decode.nullable Decode.int) Nothing
        |> Pipeline.optional "contact_owner" (Decode.nullable userDecoder) Nothing
        |> Pipeline.required "current_carrier" Decode.string
        |> Pipeline.required "effective_date" Decode.string
        |> Pipeline.required "birth_date" Decode.string
        |> Pipeline.required "tobacco_user" Decode.bool
        |> Pipeline.required "gender" Decode.string
        |> Pipeline.required "zip_code" Decode.string
        |> Pipeline.required "plan_type" Decode.string
        |> Pipeline.optional "status" Decode.string "New"
        |> Pipeline.required "agent_id" (Decode.nullable Decode.int)
        |> Pipeline.required "last_emailed" (Decode.nullable Decode.string)


contactsDecoder : Decode.Decoder ContactsResponse
contactsDecoder =
    Decode.succeed ContactsResponse
        |> Pipeline.required "contacts" (Decode.list contactDecoder)
        |> Pipeline.required "filterOptions" filterOptionsDecoder


filterOptionsDecoder : Decode.Decoder AvailableFilters
filterOptionsDecoder =
    Decode.succeed AvailableFilters
        |> Pipeline.required "carriers" (Decode.list Decode.string)
        |> Pipeline.required "states" (Decode.list Decode.string)


encodeContactForm : ContactForm -> Encode.Value
encodeContactForm form =
    Encode.object
        [ ( "first_name", Encode.string form.firstName )
        , ( "last_name", Encode.string form.lastName )
        , ( "email", Encode.string form.email )
        , ( "phone_number", Encode.string (String.filter Char.isDigit form.phoneNumber |> String.left 10) )
        , ( "state", Encode.string form.state )
        , ( "contact_owner_id", Maybe.map Encode.int form.contactOwnerId |> Maybe.withDefault Encode.null )
        , ( "current_carrier", Encode.string form.currentCarrier )
        , ( "effective_date", Encode.string form.effectiveDate )
        , ( "birth_date", Encode.string form.birthDate )
        , ( "tobacco_user", Encode.bool form.tobaccoUser )
        , ( "gender", Encode.string form.gender )
        , ( "zip_code", Encode.string form.zipCode )
        , ( "plan_type", Encode.string form.planType )
        ]


viewModals : Model -> Html Msg
viewModals model =
    case model.showModal of
        NoModal ->
            text ""

        ContactChoiceModal ->
            viewContactChoiceModal

        AddModal ->
            viewAddModal model model.isSubmittingForm

        EditModal contact ->
            viewEditModal model model.isSubmittingForm

        CsvUploadModal state ->
            viewCsvUploadModal state model.isUploadingCsv

        DeleteConfirmModal ->
            viewDeleteConfirmModal model


viewContactChoiceModal : Html Msg
viewContactChoiceModal =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-2xl w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Add Contacts" ]
            , div [ class "text-sm text-gray-600 mb-8" ]
                [ text "Select how you want to add your new contacts." ]
            , div [ class "grid grid-cols-2 gap-6" ]
                [ div
                    [ class "p-6 border-2 border-gray-200 rounded-lg hover:border-purple-400 cursor-pointer transition-colors"
                    , onClick ChooseSingleContact
                    ]
                    [ div [ class "flex items-center mb-4" ]
                        [ div [ class "h-8 w-8 rounded-full bg-purple-100 flex items-center justify-center text-sm text-purple-700 font-medium" ]
                            [ viewIcon "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" ]
                        ]
                    , h3 [ class "text-lg font-medium text-gray-900 mb-2" ]
                        [ text "Single Contact" ]
                    , p [ class "text-sm text-gray-600" ]
                        [ text "Individual Form" ]
                    ]
                , div
                    [ class "p-6 border-2 border-gray-200 rounded-lg hover:border-purple-400 cursor-pointer transition-colors"
                    , onClick ChooseMultipleContacts
                    ]
                    [ div [ class "flex items-center mb-4" ]
                        [ div [ class "h-8 w-8 rounded-full bg-purple-100 flex items-center justify-center text-sm text-purple-700 font-medium" ]
                            [ viewIcon "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" ]
                        ]
                    , h3 [ class "text-lg font-medium text-gray-900 mb-2" ]
                        [ text "Multiple Contacts" ]
                    , p [ class "text-sm text-gray-600" ]
                        [ text "CSV Upload" ]
                    ]
                ]
            ]
        ]


viewAddModal : Model -> Bool -> Html Msg
viewAddModal model isSubmitting =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-5xl w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Add New Client" ]
            , viewContactForm model model.addForm UpdateAddForm SubmitAddForm "Add Client" isSubmitting
            ]
        ]


viewEditModal : Model -> Bool -> Html Msg
viewEditModal model isSubmitting =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-5xl w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Edit Client" ]
            , viewContactForm model model.editForm UpdateEditForm SubmitEditForm "Save Changes" isSubmitting
            ]
        ]


viewCsvUploadModal : UploadState -> Bool -> Html Msg
viewCsvUploadModal state isUploading =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-2xl w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Upload CSV" ]
            , div [ class "mb-6 text-sm text-gray-600" ]
                [ text "Need help formatting your CSV? "
                , Html.a
                    [ class "text-purple-600 hover:text-purple-800 hover:underline"
                    , Html.Attributes.href "/example.csv"
                    , Html.Attributes.download "example.csv"
                    ]
                    [ text "Download example CSV file" ]
                ]
            , if state.error /= Nothing then
                div [ class "mb-6" ]
                    [ if state.stats /= Nothing then
                        let
                            stats =
                                Maybe.withDefault
                                    { totalRows = 0
                                    , errorRows = 0
                                    , validRows = 0
                                    , converted_carrier_rows = 0
                                    , supported_carriers = []
                                    }
                                    state.stats
                        in
                        div []
                            [ if stats.errorRows > 0 then
                                div [ class "p-4 mb-4 bg-red-50 border border-red-200 rounded-lg" ]
                                    [ div [ class "flex items-start" ]
                                        [ div [ class "flex-shrink-0" ]
                                            [ viewIcon "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" ]
                                        , div [ class "ml-3" ]
                                            [ h3 [ class "text-sm font-medium text-red-800" ]
                                                [ text "Upload Errors" ]
                                            , div [ class "mt-2 text-sm text-red-700" ]
                                                [ text ("Found " ++ String.fromInt stats.errorRows ++ " rows with errors. Successfully imported " ++ String.fromInt stats.validRows ++ " rows.")
                                                , case state.errorCsv of
                                                    Just csvContent ->
                                                        div [ class "mt-2 font-medium" ]
                                                            [ button
                                                                [ class "text-purple-600 hover:text-purple-800 hover:underline"
                                                                , onClick (DownloadErrorCsv csvContent)
                                                                ]
                                                                [ text "Download and Fix Error Rows" ]
                                                            ]

                                                    Nothing ->
                                                        text ""
                                                ]
                                            ]
                                        ]
                                    ]

                              else
                                text ""
                            , if stats.converted_carrier_rows > 0 then
                                div [ class "p-4 bg-yellow-50 border border-yellow-200 rounded-lg" ]
                                    [ div [ class "flex items-start" ]
                                        [ div [ class "flex-shrink-0" ]
                                            [ viewIcon "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" ]
                                        , div [ class "ml-3" ]
                                            [ h3 [ class "text-sm font-medium text-yellow-800 mb-3" ]
                                                [ text "Carrier Conversions" ]
                                            , div [ class "space-y-4 text-sm text-yellow-700" ]
                                                [ p []
                                                    [ text (String.fromInt stats.converted_carrier_rows ++ " rows had carriers we do not currently recognize/support. This is normal and expected.") ]
                                                , p []
                                                    [ text "However, this can also happen if there is a misspelling of a supported carrier. Please review to ensure the data is correct." ]
                                                , case state.converted_carriers_csv of
                                                    Just csvContent ->
                                                        div [ class "pt-1" ]
                                                            [ button
                                                                [ class "text-purple-600 hover:text-purple-800 hover:underline font-medium"
                                                                , onClick (DownloadCarrierConversionsCsv csvContent)
                                                                ]
                                                                [ text "Download Unrecognized Carrier Rows" ]
                                                            ]

                                                    Nothing ->
                                                        text ""
                                                , div [ class "pt-2 border-t border-yellow-200" ]
                                                    [ details [ class "text-sm" ]
                                                        [ summary [ class "cursor-pointer text-purple-600 hover:text-purple-800 font-medium" ]
                                                            [ text "Click to see supported carriers" ]
                                                        , div [ class "mt-3 pl-4 space-y-2" ]
                                                            (List.map
                                                                (\carrier ->
                                                                    div [ class "flex items-baseline" ]
                                                                        [ span [ class "font-medium" ] [ text carrier.name ]
                                                                        , if not (List.isEmpty carrier.aliases) then
                                                                            span [ class "ml-4 text-yellow-800" ]
                                                                                [ text ("Also accepts: " ++ String.join ", " carrier.aliases) ]

                                                                          else
                                                                            text ""
                                                                        ]
                                                                )
                                                                stats.supported_carriers
                                                            )
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]

                              else
                                text ""
                            ]

                      else
                        div [ class "p-4 bg-red-50 border border-red-200 rounded-lg" ]
                            [ div [ class "flex items-start" ]
                                [ div [ class "flex-shrink-0" ]
                                    [ viewIcon "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" ]
                                , div [ class "ml-3" ]
                                    [ h3 [ class "text-sm font-medium text-red-800" ]
                                        [ text "Error uploading CSV" ]
                                    , div [ class "mt-2 text-sm text-red-700" ]
                                        [ text (Maybe.withDefault "" state.error) ]
                                    ]
                                ]
                            ]
                    ]

              else
                text ""
            , div [ class "mb-4 flex items-center space-x-2" ]
                [ input
                    [ type_ "checkbox"
                    , checked state.overwriteDuplicates
                    , onInput (\val -> ToggleOverwriteDuplicates (val == "true"))
                    , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                    ]
                    []
                , label [ class "text-sm text-gray-600" ]
                    [ text "Overwrite existing contacts (matched on email address)" ]
                ]
            , div
                [ class
                    ("w-full h-64 border-2 border-dashed rounded-lg flex flex-col items-center justify-center p-8 transition-colors "
                        ++ (if state.dragOver then
                                "border-purple-500 bg-purple-50"

                            else
                                "border-gray-300 hover:border-purple-400"
                           )
                    )
                , preventDefaultOn "dragenter" (Decode.succeed ( DragEnter, True ))
                , preventDefaultOn "dragover" (Decode.succeed ( NoOp, True ))
                , preventDefaultOn "dragleave" (Decode.succeed ( DragLeave, True ))
                , preventDefaultOn "drop" (dropDecoder FileDrop)
                ]
                [ viewIcon "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                , div [ class "mt-4 text-center" ]
                    [ text "Drag and drop your CSV file here, or "
                    , button
                        [ class "text-purple-500 hover:text-purple-700 hover:underline"
                        , onClick ClickedSelectFile
                        ]
                        [ text "browse" ]
                    ]
                , case state.file of
                    Just file ->
                        div [ class "mt-4 text-sm text-gray-600" ]
                            [ text ("Selected: " ++ File.name file) ]

                    Nothing ->
                        text ""
                ]
            , div [ class "mt-8 flex justify-end space-x-4" ]
                [ button
                    [ class "px-6 py-3 bg-white text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200 focus:ring-4 focus:ring-purple-100"
                    , onClick CloseModal
                    ]
                    [ text "Cancel" ]
                , if isUploading then
                    div [ class "px-6 py-3 flex items-center space-x-2" ]
                        [ viewSpinner ]

                  else
                    button
                        [ type_ "submit"
                        , class "px-6 py-3 bg-purple-500 text-white text-sm font-medium rounded-lg hover:bg-purple-600 transition-colors duration-200 focus:ring-4 focus:ring-purple-200"
                        , onClick UploadCsv
                        , Html.Attributes.disabled (state.file == Nothing)
                        ]
                        [ text "Upload" ]
                ]
            ]
        ]


dropDecoder : (File -> msg) -> Decoder ( msg, Bool )
dropDecoder toMsg =
    Decode.at [ "dataTransfer", "files" ] (Decode.index 0 File.decoder)
        |> Decode.map (\file -> ( toMsg file, True ))


uploadCsv : File -> Bool -> Cmd Msg
uploadCsv file overwriteDuplicates =
    let
        _ =
            Debug.log "Uploading CSV"
                { fileName = File.name file
                , fileSize = File.size file
                , overwriteDuplicates = overwriteDuplicates
                }

        body =
            Http.multipartBody
                [ Http.filePart "file" file
                , Http.stringPart "overwrite_duplicates"
                    (if overwriteDuplicates then
                        "true"

                     else
                        "false"
                    )
                ]
    in
    Http.post
        { url = "/api/contacts/upload"
        , body = body
        , expect = Http.expectJson CsvUploaded uploadResponseDecoder
        }


uploadResponseDecoder : Decode.Decoder UploadResponse
uploadResponseDecoder =
    let
        errorCsvDecoder =
            Decode.oneOf
                [ Decode.string |> Decode.map Just
                , Decode.null Nothing
                ]
    in
    Decode.succeed UploadResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "message" Decode.string
        |> Pipeline.required "error_csv" errorCsvDecoder
        |> Pipeline.required "converted_carriers_csv" errorCsvDecoder
        |> Pipeline.required "total_rows" Decode.int
        |> Pipeline.required "error_rows" Decode.int
        |> Pipeline.required "valid_rows" Decode.int
        |> Pipeline.required "converted_carrier_rows" Decode.int
        |> Pipeline.required "supported_carriers" (Decode.list carrierDecoder)


type alias UploadResponse =
    { success : Bool
    , message : String
    , errorCsv : Maybe String
    , converted_carriers_csv : Maybe String
    , totalRows : Int
    , errorRows : Int
    , validRows : Int
    , converted_carrier_rows : Int
    , supported_carriers : List { name : String, aliases : List String }
    }


formatUploadError : String -> String
formatUploadError message =
    if String.startsWith "Missing required columns:" message then
        let
            missingColumns =
                String.dropLeft (String.length "Missing required columns:") message
                    |> String.trim
                    |> String.split ","
                    |> List.map String.trim
                    |> String.join ", "
        in
        "Your CSV is missing the following required columns: " ++ missingColumns ++ ". Please add these columns and try again."

    else
        message



-- Add this new subscription function


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch
        [ case model.showModal of
            NoModal ->
                Sub.none

            ContactChoiceModal ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))

            AddModal ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))

            EditModal _ ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))

            CsvUploadModal _ ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))

            DeleteConfirmModal ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))
        , case model.openFilter of
            Just _ ->
                Browser.Events.onMouseDown (Decode.succeed CloseFilterDropdown)

            Nothing ->
                Sub.none
        ]


sortContacts : Maybe SortColumn -> SortDirection -> List Contact -> List Contact
sortContacts maybeColumn direction contacts =
    case maybeColumn of
        Nothing ->
            contacts

        Just column ->
            let
                comparator =
                    case column of
                        NameCol ->
                            \a b ->
                                compare
                                    (a.firstName ++ " " ++ a.lastName)
                                    (b.firstName ++ " " ++ b.lastName)

                        StatusCol ->
                            \a b -> compare a.status b.status

                        EmailCol ->
                            \a b -> compare a.email b.email

                        PhoneNumberCol ->
                            \a b -> compare a.phoneNumber b.phoneNumber

                        StateCol ->
                            \a b -> compare a.state b.state

                        ContactOwnerCol ->
                            \a b ->
                                compare
                                    (Maybe.map .firstName a.contactOwner |> Maybe.withDefault "Default")
                                    (Maybe.map .firstName b.contactOwner |> Maybe.withDefault "Default")

                        CurrentCarrierCol ->
                            \a b -> compare a.currentCarrier b.currentCarrier

                        EffectiveDateCol ->
                            \a b -> compare a.effectiveDate b.effectiveDate
            in
            List.sortWith
                (if direction == Ascending then
                    comparator

                 else
                    \a b -> comparator b a
                )
                contacts


filterContacts : Filters -> String -> Time.Posix -> List Contact -> List Contact
filterContacts filters searchQuery currentTime contacts =
    contacts
        |> filterBySearch searchQuery
        |> filterByList .currentCarrier filters.carriers
        |> filterByList .state filters.states
        |> filterByAge filters.ageRange


filterBySearch : String -> List Contact -> List Contact
filterBySearch query contacts =
    if String.isEmpty query then
        contacts

    else
        let
            loweredQuery =
                String.toLower query
        in
        List.filter
            (\contact ->
                String.contains loweredQuery (String.toLower contact.firstName)
                    || String.contains loweredQuery (String.toLower contact.lastName)
                    || String.contains loweredQuery (String.toLower contact.currentCarrier)
            )
            contacts


filterByAge : Maybe ( Int, Int ) -> List Contact -> List Contact
filterByAge maybeRange contacts =
    case maybeRange of
        Nothing ->
            contacts

        Just ( min, max ) ->
            List.filter
                (\contact ->
                    let
                        age =
                            calculateAge contact.birthDate
                    in
                    age >= min && age <= max
                )
                contacts


calculateAge : String -> Int
calculateAge birthDate =
    -- This is a simplified version. You might want to use a proper date library
    2024 - (String.left 4 birthDate |> String.toInt |> Maybe.withDefault 0)


toggleFilter : Filters -> FilterType -> String -> Filters
toggleFilter filters filterType value =
    case filterType of
        CarrierFilter ->
            { filters | carriers = toggleList filters.carriers value }

        StateFilter ->
            { filters | states = toggleList filters.states value }

        AgeFilter ->
            { filters | ageRange = toggleAgeRange filters.ageRange value }


toggleList : List String -> String -> List String
toggleList list value =
    if List.member value list then
        List.filter (\v -> v /= value) list

    else
        value :: list


toggleAgeRange : Maybe ( Int, Int ) -> String -> Maybe ( Int, Int )
toggleAgeRange maybeRange value =
    case maybeRange of
        Nothing ->
            Just ( String.toInt value |> Maybe.withDefault 0, String.toInt value |> Maybe.withDefault 0 )

        Just ( min, max ) ->
            if min == (String.toInt value |> Maybe.withDefault 0) then
                Just ( String.toInt value |> Maybe.withDefault 0, max )

            else if max == (String.toInt value |> Maybe.withDefault 0) then
                Just ( min, String.toInt value |> Maybe.withDefault 0 )

            else
                Just ( min, max )


setAgeFilter : Int -> Int -> Filters -> Filters
setAgeFilter min max filters =
    if max < 1 then
        { filters | ageRange = Nothing }
        -- Don't apply filter if max is 0 or negative

    else
        { filters | ageRange = Just ( min, max ) }



-- Helper function to get unique values from contacts


getUniqueValues : (Contact -> String) -> List Contact -> List String
getUniqueValues getter contacts =
    contacts
        |> List.map getter
        |> List.sort
        |> List.Extra.unique


zipInfoDecoder : Decode.Decoder ZipInfo
zipInfoDecoder =
    Decode.succeed ZipInfo
        |> Pipeline.required "state" Decode.string
        |> Pipeline.required "counties" (Decode.list Decode.string)
        |> Pipeline.required "cities" (Decode.list Decode.string)


filterByList : (Contact -> String) -> List String -> List Contact -> List Contact
filterByList getter selectedValues contacts =
    if List.isEmpty selectedValues then
        contacts

    else
        List.filter
            (\contact ->
                List.member (getter contact) selectedValues
            )
            contacts


viewContactForm : Model -> ContactForm -> (ContactFormField -> String -> Msg) -> Msg -> String -> Bool -> Html Msg
viewContactForm model form updateMsg submitMsg buttonText isSubmitting =
    let
        carrierOptions =
            ( "", "Select a carrier" ) :: List.map (\c -> ( c, c )) (model.carriers ++ [ "Other" ])

        planTypeOptions =
            [ ( "", "Select a plan type" ), ( "Plan N", "Plan N" ), ( "Plan G", "Plan G" ), ( "Other", "Other" ) ]

        agentOptions =
            ( "", "Default" ) :: List.map (\agent -> ( String.fromInt agent.id, agent.firstName ++ " " ++ agent.lastName )) model.agents

        emailField =
            div [ class "form-group relative" ]
                [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
                    [ text "Email" ]
                , div [ class "relative" ]
                    [ Html.input
                        [ type_ "email"
                        , class
                            ("w-full px-4 py-3 bg-white border-[2.5px] rounded-lg text-gray-700 placeholder-gray-400 shadow-sm transition-all duration-200 "
                                ++ (if model.emailExists then
                                        "border-red-300 hover:border-red-400 focus:border-red-500 focus:ring-2 focus:ring-red-200"

                                    else
                                        "border-purple-300 hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200"
                                   )
                            )
                        , value form.email
                        , onInput (updateMsg Email)
                        , required True
                        ]
                        []
                    , if model.isCheckingEmail then
                        div [ class "absolute right-3 top-3" ]
                            [ viewSpinner ]

                      else if model.emailExists then
                        div
                            [ class "absolute right-3 top-3 text-red-500" ]
                            [ viewIcon "M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" ]

                      else if String.length form.email > 0 then
                        div
                            [ class "absolute right-3 top-3 text-green-500" ]
                            [ viewIcon "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" ]

                      else
                        text ""
                    ]
                , if model.emailExists then
                    div [ class "mt-2 text-sm text-red-600" ]
                        [ text "A contact with this email already exists" ]

                  else
                    text ""
                ]
    in
    Html.form [ onSubmit submitMsg ]
        [ div [ class "grid grid-cols-2 gap-x-8 gap-y-6" ]
            [ viewFormInput "First Name" "text" form.firstName FirstName updateMsg True
            , viewFormInput "Last Name" "text" form.lastName LastName updateMsg True
            , emailField
            , viewFormInput "Phone Number" "text" form.phoneNumber PhoneNumber updateMsg True
            , viewFormSelect "Current Carrier" form.currentCarrier CurrentCarrier updateMsg carrierOptions
            , viewFormSelect "Plan Type" form.planType PlanType updateMsg planTypeOptions
            , viewFormSelect "Contact Owner" (Maybe.map String.fromInt form.contactOwnerId |> Maybe.withDefault "") ContactOwnerId updateMsg agentOptions
            , viewFormInput "Effective Date" "date" form.effectiveDate EffectiveDate updateMsg True
            , viewFormInput "Birth Date" "date" form.birthDate BirthDate updateMsg True
            , viewFormRadioGroup "Tobacco User"
                (if form.tobaccoUser then
                    "true"

                 else
                    "false"
                )
                TobaccoUser
                updateMsg
                [ ( "true", "Yes" ), ( "false", "No" ) ]
            , viewFormRadioGroup "Gender" form.gender Gender updateMsg [ ( "M", "Male" ), ( "F", "Female" ) ]
            , div [ class "col-span-2 grid grid-cols-2 gap-x-8" ]
                [ viewZipCodeField model form
                , viewStateField form
                ]
            ]
        , if model.error /= Nothing && not model.emailExists then
            div [ class "mt-4 text-red-600 text-sm" ] [ text (Maybe.withDefault "" model.error) ]

          else
            text ""
        , div [ class "mt-10 flex justify-end space-x-4" ]
            [ button
                [ type_ "button"
                , onClick CloseModal
                , class "px-6 py-3 bg-white text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200 focus:ring-4 focus:ring-purple-100"
                ]
                [ text "Cancel" ]
            , if isSubmitting then
                div [ class "px-6 py-3 flex items-center space-x-2" ] [ viewSpinner ]

              else
                let
                    isValid =
                        isContactFormValid form && not model.emailExists && not model.isCheckingEmail
                in
                button
                    [ type_ "submit"
                    , class
                        ("px-6 py-3 text-white text-sm font-medium rounded-lg transition-colors duration-200 focus:ring-4 focus:ring-purple-200 "
                            ++ (if isValid then
                                    "bg-purple-500 hover:bg-purple-600"

                                else
                                    "bg-gray-300 cursor-not-allowed"
                               )
                        )
                    , Html.Attributes.disabled (not isValid)
                    ]
                    [ text buttonText ]
            ]
        ]


viewFormInput : String -> String -> String -> ContactFormField -> (ContactFormField -> String -> Msg) -> Bool -> Html Msg
viewFormInput labelText inputType inputValue field updateMsg isRequired =
    let
        displayValue =
            if field == PhoneNumber then
                formatPhoneNumber inputValue

            else
                inputValue

        inputHandler =
            if field == PhoneNumber then
                \val ->
                    let
                        digits =
                            String.filter Char.isDigit val |> String.left 10
                    in
                    updateMsg field digits

            else
                updateMsg field

        placeholderText =
            if field == PhoneNumber then
                "(555) 555-5555"

            else
                ""
    in
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text labelText ]
        , Html.input
            [ type_ inputType
            , class "w-full px-4 py-3 bg-white border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , value displayValue
            , onInput inputHandler
            , required isRequired
            , placeholder placeholderText
            ]
            []
        ]


viewFormSelect : String -> String -> ContactFormField -> (ContactFormField -> String -> Msg) -> List ( String, String ) -> Html Msg
viewFormSelect labelText selectedValue field updateMsg options =
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text labelText ]
        , div [ class "relative" ]
            [ Html.select
                [ class "w-full px-4 py-3 bg-white border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200 appearance-none"
                , value selectedValue
                , onInput (updateMsg field)
                ]
                (List.map (\( val, txt ) -> option [ value val ] [ text txt ]) options)
            , div [ class "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none" ]
                [ viewIcon "M19 9l-7 7-7-7" ]
            ]
        ]


viewFormRadioGroup : String -> String -> ContactFormField -> (ContactFormField -> String -> Msg) -> List ( String, String ) -> Html Msg
viewFormRadioGroup labelText selectedValue field updateMsg options =
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text labelText ]
        , div [ class "flex gap-4" ]
            (List.map
                (\( val, txt ) ->
                    label
                        [ class
                            ("flex items-center px-4 py-2 rounded-lg border-2 cursor-pointer transition-all duration-200 "
                                ++ (if selectedValue == val then
                                        "border-purple-500 bg-purple-50 text-purple-700"

                                    else
                                        "border-gray-200 hover:border-purple-200"
                                   )
                            )
                        ]
                        [ input
                            [ type_ "radio"
                            , value val
                            , checked (selectedValue == val)
                            , onInput (\_ -> updateMsg field val)
                            , class "sr-only" -- Hide the actual radio button
                            ]
                            []
                        , text txt
                        ]
                )
                options
            )
        ]


viewZipCodeField : Model -> ContactForm -> Html Msg
viewZipCodeField model form =
    div []
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text "ZIP Code" ]
        , Html.input
            [ type_ "text"
            , class "w-full px-4 py-3 bg-white border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , value form.zipCode
            , onInput
                (\zip ->
                    Batch
                        [ case model.showModal of
                            AddModal ->
                                UpdateAddForm ZipCode zip

                            EditModal _ ->
                                UpdateEditForm ZipCode zip

                            _ ->
                                NoOp
                        , if String.length zip == 5 then
                            LookupZipCode zip

                          else
                            NoOp
                        ]
                )
            ]
            []
        ]


viewStateField : ContactForm -> Html Msg
viewStateField form =
    div []
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text "State" ]
        , Html.input
            [ type_ "text"
            , class "w-full px-4 py-3 bg-white border-[2.5px] border-gray-200 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , value form.state
            , Html.Attributes.disabled True
            ]
            []
        ]


viewSpinner : Html msg
viewSpinner =
    div [ class "animate-spin rounded-full h-5 w-5 border-2 border-purple-500 border-t-transparent" ] []


onClickOutside : msg -> Html.Attribute msg
onClickOutside msg =
    on "click" (Decode.succeed msg)


userDecoder : Decode.Decoder User
userDecoder =
    Decode.succeed User
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "first_name" Decode.string
        |> Pipeline.required "last_name" Decode.string
        |> Pipeline.required "is_admin" Decode.bool
        |> Pipeline.required "is_agent" Decode.bool
        |> Pipeline.required "organization_id" Decode.int
        |> Pipeline.required "is_active" Decode.bool
        |> Pipeline.required "phone" Decode.string


deleteContacts : List Int -> Cmd Msg
deleteContacts contactIds =
    Http.request
        { method = "DELETE"
        , headers = []
        , url = "/api/contacts"
        , body = Http.jsonBody (encodeContactIds contactIds)
        , expect = Http.expectJson ContactsDeleted deleteResponseDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


encodeContactIds : List Int -> Encode.Value
encodeContactIds ids =
    Encode.list Encode.int ids


deleteResponseDecoder : Decode.Decoder DeleteResponse
deleteResponseDecoder =
    Decode.map3 DeleteResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "deleted_ids" (Decode.list Decode.int))
        (Decode.field "message" Decode.string)



-- HELPER FUNCTIONS


isAdminOrAdminAgent : Maybe User -> Bool
isAdminOrAdminAgent maybeUser =
    case maybeUser of
        Just user ->
            user.isAdmin || (user.isAgent && user.isAdmin)

        Nothing ->
            False


viewExpandedContent : Contact -> Html Msg
viewExpandedContent contact =
    div
        [ class "grid grid-cols-5 gap-4 py-2 px-4 transition-all duration-200 ease-in-out" ]
        [ viewExpandedField "Birth Date" contact.birthDate
        , viewExpandedField "Tobacco User"
            (if contact.tobaccoUser then
                "Yes"

             else
                "No"
            )
        , viewExpandedField "Gender" contact.gender
        , viewExpandedField "ZIP Code" contact.zipCode
        , viewExpandedField "Plan Type" contact.planType
        ]


viewExpandedField : String -> String -> Html Msg
viewExpandedField label value =
    div [ class "text-sm" ]
        [ span [ class "font-medium text-gray-500" ] [ text label ]
        , div [ class "mt-1 text-gray-900" ] [ text value ]
        ]


viewIcon : String -> Html Msg
viewIcon path =
    svg
        [ Svg.Attributes.class "w-4 h-4"
        , Svg.Attributes.fill "none"
        , Svg.Attributes.stroke "currentColor"
        , Svg.Attributes.viewBox "0 0 24 24"
        ]
        [ Svg.path [ Svg.Attributes.d path ] [] ]



-- HTTP FUNCTIONS


fetchContacts : Model -> Cmd Msg
fetchContacts model =
    let
        queryParams =
            [ ( "search", model.searchQuery )
            , ( "states", String.join "," model.activeFilters.states )
            , ( "carriers", String.join "," model.activeFilters.carriers )
            ]
                |> List.filter (\( _, value ) -> not (String.isEmpty value))
                |> List.map (\( key, value ) -> Url.string key value)
    in
    Http.get
        { url = Url.absolute [ "api", "contacts" ] queryParams
        , expect = Http.expectJson GotContacts contactsDecoder
        }


fetchCurrentUser : Cmd Msg
fetchCurrentUser =
    Http.get
        { url = "/api/me"
        , expect = Http.expectJson GotCurrentUser userDecoder
        }


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    if String.isEmpty phone then
        ""

    else
        let
            digits =
                String.filter Char.isDigit phone
                    |> String.left 10

            len =
                String.length digits
        in
        if len == 0 then
            ""

        else if len <= 3 then
            "(" ++ digits

        else if len <= 6 then
            "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

        else
            "(" ++ String.left 3 digits ++ ") " ++ String.slice 3 6 digits ++ "-" ++ String.dropLeft 6 digits


viewFilterDropdown : Model -> FilterType -> Html Msg
viewFilterDropdown model filterType =
    let
        options =
            case filterType of
                CarrierFilter ->
                    model.availableFilters.carriers

                StateFilter ->
                    model.availableFilters.states

                _ ->
                    []

        activeFilters =
            case filterType of
                CarrierFilter ->
                    model.activeFilters.carriers

                StateFilter ->
                    model.activeFilters.states

                _ ->
                    []

        hasActiveFilters =
            not (List.isEmpty activeFilters)
    in
    div
        [ class "absolute left-0 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 z-10"
        , stopPropagationOn "mousedown" (Decode.succeed ( CloseFilterDropdown, True ))
        ]
        [ div [ class "py-1" ]
            [ div [ class "p-2 border-b border-gray-200" ]
                [ button
                    [ class
                        ("w-full text-left text-sm font-medium "
                            ++ (if hasActiveFilters then
                                    "text-purple-600 hover:text-purple-800 cursor-pointer"

                                else
                                    "text-gray-400 cursor-not-allowed"
                               )
                        )
                    , onClick (SelectAllFilter filterType False)
                    , Html.Attributes.disabled (not hasActiveFilters)
                    ]
                    [ text "Clear Filters" ]
                ]
            , div [ class "max-h-48 overflow-y-auto p-2" ]
                (List.map
                    (\option ->
                        label
                            [ class "flex items-center space-x-2 py-1" ]
                            [ input
                                [ type_ "checkbox"
                                , checked (List.member option activeFilters)
                                , onClick (ToggleFilter filterType option)
                                , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                ]
                                []
                            , span [ class "text-sm text-gray-600" ]
                                [ text option ]
                            ]
                    )
                    options
                )
            ]
        ]


isContactFormValid : ContactForm -> Bool
isContactFormValid form =
    String.length form.firstName
        > 0
        && String.length form.lastName
        > 0
        && String.length form.email
        > 0
        && String.length form.phoneNumber
        > 0
        && String.length form.state
        > 0
        && String.length form.currentCarrier
        > 0
        && String.length form.effectiveDate
        > 0
        && String.length form.birthDate
        > 0
        && String.length form.zipCode
        > 0
        && String.length form.planType
        > 0


fetchCarriers : Cmd Msg
fetchCarriers =
    Http.get
        { url = "/api/settings/carriers"
        , expect = Http.expectJson GotCarriers (Decode.list (Decode.field "name" Decode.string))
        }


fetchAgents : Cmd Msg
fetchAgents =
    Http.get
        { url = "/api/agents"
        , expect = Http.expectJson GotAgents (Decode.list userDecoder)
        }


checkEmail : String -> Cmd Msg
checkEmail email =
    Http.get
        { url = "/api/contacts/check-email/" ++ email
        , expect = Http.expectJson EmailChecked emailCheckDecoder
        }


emailCheckDecoder : Decode.Decoder { exists : Bool }
emailCheckDecoder =
    Decode.map (\exists -> { exists = exists })
        (Decode.field "exists" Decode.bool)


carrierDecoder : Decode.Decoder { name : String, aliases : List String }
carrierDecoder =
    Decode.succeed (\name aliases -> { name = name, aliases = aliases })
        |> Pipeline.required "name" Decode.string
        |> Pipeline.required "aliases" (Decode.list Decode.string)


viewDeleteConfirmModal : Model -> Html Msg
viewDeleteConfirmModal model =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ text "Ã—" ]
            , h2 [ class "text-xl font-semibold text-gray-900 mb-4" ]
                [ text "Delete Contacts" ]
            , p [ class "text-sm text-gray-600 mb-6" ]
                [ text ("Are you sure you want to delete " ++ String.fromInt (List.length model.selectedContacts) ++ " contacts? This action cannot be undone.") ]
            , div [ class "flex justify-end space-x-4" ]
                [ button
                    [ class "px-4 py-2 text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200"
                    , onClick CloseModal
                    ]
                    [ text "Cancel" ]
                , if model.isDeletingContacts then
                    div [ class "px-4 py-2 flex items-center" ]
                        [ viewSpinner ]

                  else
                    button
                        [ class "px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors duration-200"
                        , onClick DeleteSelectedContacts
                        ]
                        [ text "Delete" ]
                ]
            ]
        ]

================
File: frontend/src/Home.elm
================
module Home exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)



-- MODEL


type alias Model =
    {}


init : () -> ( Model, Cmd Msg )
init _ =
    ( {}, Cmd.none )



-- UPDATE


type Msg
    = NoOp


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Medicare Max - Automate Client Retention"
    , body =
        [ div [ class "min-h-screen bg-white" ]
            [ nav [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6" ]
                [ div [ class "flex justify-between items-center" ]
                    [ div [ class "flex items-center" ]
                        [ img
                            [ src "/images/medicare-max-logo.png"
                            , class "h-8 w-auto"
                            , alt "Medicare Max logo"
                            ]
                            []
                        ]
                    , div [ class "flex items-center space-x-4" ]
                        [ a
                            [ href "/login"
                            , class "text-gray-600 hover:text-gray-900 px-4 py-2 text-sm font-medium"
                            ]
                            [ text "Log in" ]
                        , a
                            [ href "/signup"
                            , class "bg-[#0A0F4F] text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-[#1a1f5f] transition-colors duration-200"
                            ]
                            [ text "Sign up" ]
                        ]
                    ]
                ]
            , div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-24 pb-32" ]
                [ div [ class "lg:grid lg:grid-cols-12 lg:gap-8" ]
                    [ div [ class "sm:text-center md:max-w-2xl md:mx-auto lg:col-span-6 lg:text-left" ]
                        [ div [ class "inline-flex items-center space-x-2 bg-[#F4F3FF] rounded-full px-4 py-1.5 mb-8" ]
                            [ span [ class "text-sm font-medium text-[#0A0F4F]" ] [ text "What's new?" ]
                            , span [ class "text-sm text-gray-600" ] [ text "Instantly issue virtual cards" ]
                            ]
                        , h1
                            [ class "text-5xl tracking-tight font-bold text-gray-900 sm:text-6xl md:text-7xl" ]
                            [ text "Automate client retention." ]
                        , p
                            [ class "mt-6 text-lg text-gray-600 leading-relaxed" ]
                            [ text "Automatically engage clients in key moments of their medigap journey, and sit back as they enroll" ]
                        , div [ class "mt-10" ]
                            [ a
                                [ href "/signup"
                                , class "inline-flex items-center px-6 py-3 rounded-lg text-base font-medium text-white bg-[#0A0F4F] hover:bg-[#1a1f5f] transition-colors duration-200"
                                ]
                                [ text "Sign up" ]
                            ]
                        ]
                    , div [ class "mt-16 relative sm:max-w-lg sm:mx-auto lg:mt-0 lg:max-w-none lg:mx-0 lg:col-span-6 lg:flex lg:items-center" ]
                        [ div [ class "relative mx-auto w-full rounded-2xl shadow-xl overflow-hidden bg-gray-100 aspect-[4/3]" ]
                            [ img
                                [ src "/dashboard-preview.png"
                                , class "w-full h-full object-cover"
                                , alt "Dashboard preview"
                                ]
                                []
                            ]
                        ]
                    ]
                ]
            , div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16" ]
                [ p [ class "text-center text-gray-600 mb-12" ]
                    [ text "Join 200+ companies retaining their clients" ]
                , div [ class "grid grid-cols-2 gap-8 md:grid-cols-5 items-center justify-items-center" ]
                    [ img [ src "/company-logos/bitshift.svg", class "h-8", alt "Bitshift logo" ] []
                    , img [ src "/company-logos/lightbox.svg", class "h-8", alt "Lightbox logo" ] []
                    , img [ src "/company-logos/greenway.svg", class "h-8", alt "Greenway logo" ] []
                    , img [ src "/company-logos/skyline.svg", class "h-8", alt "Skyline logo" ] []
                    , img [ src "/company-logos/clockwork.svg", class "h-8", alt "Clockwork logo" ] []
                    ]
                ]
            ]
        ]
    }



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/Login.elm
================
module Login exposing (Model, Msg, init, subscriptions, update, view)

import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput, onSubmit)
import Http
import Json.Decode as Decode
import Json.Encode as Encode


type alias Model =
    { email : String
    , status : Status
    , isLoggedIn : Bool
    , key : Nav.Key
    }


type Status
    = Idle
    | Submitting
    | Success
    | Failed String
    | LinkSent


type alias LoginResponse =
    { success : Bool
    }


type Msg
    = EmailChanged String
    | SubmitForm
    | GotLoginResponse (Result Http.Error LoginResponse)
    | LogOut
    | NoOp


init : Nav.Key -> Bool -> ( Model, Cmd Msg )
init key isLoggedIn =
    ( { email = ""
      , status = Idle
      , isLoggedIn = isLoggedIn
      , key = key
      }
    , Cmd.none
    )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        EmailChanged email ->
            ( { model | email = email, status = Idle }
            , Cmd.none
            )

        SubmitForm ->
            if String.isEmpty model.email then
                ( { model | status = Failed "Please enter your email address" }
                , Cmd.none
                )

            else
                ( { model | status = Submitting }
                , Http.post
                    { url = "/api/auth/login"
                    , body = Http.jsonBody (encodeLoginBody model.email)
                    , expect = Http.expectJson GotLoginResponse loginResponseDecoder
                    }
                )

        NoOp ->
            ( model, Cmd.none )

        LogOut ->
            ( { model
                | isLoggedIn = False
                , status = Idle
              }
            , Http.post
                { url = "/api/auth/logout"
                , body = Http.emptyBody
                , expect = Http.expectWhatever (\_ -> NoOp)
                }
            )

        GotLoginResponse result ->
            case result of
                Ok response ->
                    if response.success then
                        ( { model | status = LinkSent }
                        , Cmd.none
                        )

                    else
                        ( { model | status = Failed "Failed to send login link. Please try again." }
                        , Cmd.none
                        )

                Err _ ->
                    ( { model | status = Failed "Failed to send login link. Please try again." }
                    , Cmd.none
                    )


viewLoginForm : Model -> { title : String, body : List (Html Msg) }
viewLoginForm model =
    { title = "Login"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8" ]
            [ div [ class "sm:mx-auto sm:w-full sm:max-w-md" ]
                [ h2 [ class "mt-6 text-center text-3xl font-extrabold text-gray-900" ]
                    [ text "Sign in to your account" ]
                ]
            , div [ class "mt-8 sm:mx-auto sm:w-full sm:max-w-md" ]
                [ div [ class "bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10" ]
                    [ Html.form [ onSubmit SubmitForm ]
                        [ div []
                            [ label [ for "email", class "block text-sm font-medium text-gray-700" ]
                                [ text "Email address" ]
                            , div [ class "mt-1" ]
                                [ input
                                    [ type_ "email"
                                    , name "email"
                                    , id "email"
                                    , class "appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                                    , placeholder "you@example.com"
                                    , value model.email
                                    , onInput EmailChanged
                                    ]
                                    []
                                ]
                            ]
                        , div [ class "mt-6" ]
                            [ button
                                [ type_ "submit"
                                , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                ]
                                [ text "Send login link" ]
                            ]
                        ]
                    , viewStatus model.status
                    ]
                ]
            ]
        ]
    }


viewStatus : Status -> Html msg
viewStatus status =
    case status of
        LinkSent ->
            div [ class "mt-4 p-4 bg-green-50 rounded-md" ]
                [ p [ class "text-sm text-green-700 text-center space-y-2" ]
                    [ p [] [ text "You will receive an email if you are a registered agent." ]
                    , p [] [ text "Check your email for the login link!" ]
                    ]
                ]

        Failed error ->
            div [ class "mt-4 p-4 bg-red-50 rounded-md" ]
                [ p [ class "text-sm text-red-700" ]
                    [ text error ]
                ]

        Submitting ->
            div [ class "mt-4 text-center text-gray-600" ]
                [ text "Sending login link..." ]

        _ ->
            text ""


encodeLoginBody : String -> Encode.Value
encodeLoginBody email =
    Encode.object
        [ ( "email", Encode.string email )
        ]


loginResponseDecoder : Decode.Decoder LoginResponse
loginResponseDecoder =
    Decode.map LoginResponse
        (Decode.field "success" Decode.bool)


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none


view : Model -> { title : String, body : List (Html Msg) }
view model =
    if model.isLoggedIn then
        { title = "Already Logged In"
        , body =
            [ div [ class "min-h-screen bg-gray-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8" ]
                [ div [ class "sm:mx-auto sm:w-full sm:max-w-md" ]
                    [ h2 [ class "mt-6 text-center text-3xl font-extrabold text-gray-900" ]
                        [ text "Already Logged In" ]
                    , div [ class "mt-8 sm:mx-auto sm:w-full sm:max-w-md" ]
                        [ div [ class "bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10" ]
                            [ p [ class "text-center text-gray-600 mb-6" ]
                                [ text "You are already logged in." ]
                            , button
                                [ onClick LogOut
                                , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                                ]
                                [ text "Log Out" ]
                            ]
                        ]
                    ]
                ]
            ]
        }

    else
        viewLoginForm model

================
File: frontend/src/Main.elm
================
module Main exposing (main)

import AddAgent
import BrandSettings
import Browser exposing (Document)
import Browser.Navigation as Nav
import ChoosePlan
import Contact
import Contacts
import Debug
import Home
import Html exposing (Html, button, div, h1, img, nav, p, text)
import Html.Attributes exposing (alt, class, href, src)
import Html.Events exposing (onClick)
import Http
import Json.Decode as Decode exposing (Decoder)
import Login
import Profile
import Settings
import Signup
import TempLanding
import Url exposing (Url)
import Url.Parser as Parser exposing ((</>), (<?>), Parser, map, oneOf, s, string, top)
import Url.Parser.Query as Query


type alias VerificationResponse =
    { success : Bool
    , redirectUrl : String
    , session : String
    , email : String
    , orgSlug : String
    }


type alias SessionResponse =
    { valid : Bool
    , session : String
    , email : String
    , organizationSlug : String
    , firstName : String
    , lastName : String
    , id : String
    }


verificationDecoder : Decoder VerificationResponse
verificationDecoder =
    Decode.map5 VerificationResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "redirectUrl" Decode.string)
        (Decode.field "session" Decode.string)
        (Decode.field "email" Decode.string)
        (Decode.field "orgSlug" Decode.string)


sessionDecoder : Decoder SessionResponse
sessionDecoder =
    Decode.map7 SessionResponse
        (Decode.field "valid" Decode.bool)
        (Decode.field "session" Decode.string)
        (Decode.field "email" Decode.string)
        (Decode.field "organizationSlug" Decode.string)
        (Decode.field "first_name" Decode.string)
        (Decode.field "last_name" Decode.string)
        (Decode.field "id" (Decode.map String.fromInt Decode.int))


type Role
    = AdminOnly
    | AdminAgent
    | AgentOnly


type alias User =
    { id : String
    , email : String
    , isAdmin : Bool
    , isAgent : Bool
    , organizationSlug : String
    , firstName : String
    , lastName : String
    }


type alias Model =
    { key : Nav.Key
    , url : Url
    , page : Page
    , session : SessionState
    , currentUser : Maybe User
    , isSetup : Bool
    , intendedDestination : Maybe String
    }


type SessionState
    = Unknown -- Initial state
    | Verified String -- Has valid session
    | NoSession -- Definitely no valid session


type Page
    = NotFoundPage
    | LoginPage Login.Model
    | ContactsPage Contacts.Model
    | TempLandingPage TempLanding.Model
    | SettingsPage Settings.Model
    | Signup Signup.Model
    | ChoosePlanPage ChoosePlan.Model
    | BrandSettingsPage BrandSettings.Model
    | AddAgentsPage AddAgent.Model
    | ProfilePage Profile.Model
    | LoadingPage
    | HomePage Home.Model
    | ContactPage Contact.Model


type Msg
    = LinkClicked Browser.UrlRequest
    | InternalLinkClicked String
    | UrlChanged Url
    | LoginMsg Login.Msg
    | ContactsMsg Contacts.Msg
    | TempLandingMsg TempLanding.Msg
    | SettingsMsg Settings.Msg
    | SignupMsg Signup.Msg
    | ChoosePlanMsg ChoosePlan.Msg
    | BrandSettingsMsg BrandSettings.Msg
    | AddAgentsMsg AddAgent.Msg
    | GotVerification (Result Http.Error VerificationResponse)
    | GotSession (Result Http.Error SessionResponse)
    | ProfileMsg Profile.Msg
    | HomeMsg Home.Msg
    | ContactMsg Contact.Msg


type alias Flags =
    { initialSession : Maybe String }


main : Program Flags Model Msg
main =
    Browser.application
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        , onUrlChange = UrlChanged
        , onUrlRequest = LinkClicked
        }


init : Flags -> Url.Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url key =
    let
        _ =
            Debug.log "Init flags" flags

        initialSession =
            case flags.initialSession of
                Just session ->
                    let
                        _ =
                            Debug.log "Found initial session" session
                    in
                    Verified session

                Nothing ->
                    let
                        _ =
                            Debug.log "No initial session found" ()
                    in
                    Unknown

        model =
            { key = key
            , url = url
            , page = LoadingPage -- Start with loading page while we check session
            , session = initialSession
            , currentUser = Nothing
            , isSetup = False
            , intendedDestination = Nothing
            }

        _ =
            Debug.log "Checking session at URL" (Url.toString url)

        checkSession =
            Http.get
                { url = "/api/auth/session"
                , expect = Http.expectJson GotSession sessionDecoder
                }
    in
    ( model
      -- Don't call updatePage here, wait for session response
    , checkSession
    )


type Route
    = PublicRoute PublicPage
    | ProtectedRoute ProtectedPage
    | SetupRoute SetupPage
    | NotFound


type VerifyParams
    = VerifyParams String String


type PublicPage
    = HomeRoute
    | LoginRoute
    | SignupRoute
    | VerifyRoute VerifyParams


type ProtectedPage
    = ContactsRoute
    | SettingsRoute
    | ProfileRoute
    | BrandSettingsRoute
    | TempLandingRoute
    | AgentsRoute
    | ContactRoute String


type SetupPage
    = ChoosePlanRoute (Maybe SetupProgress)
    | SetupSettingsRoute (Maybe SetupProgress)
    | SetupBrandSettingsRoute (Maybe SetupProgress)
    | AddAgentsRoute (Maybe SetupProgress)


type alias SetupProgress =
    { plan : Maybe String
    , orgSettings : Bool
    , brandSettings : Bool
    }


type RouteAccess
    = Public -- No auth needed (login, home)
    | Protected -- Requires valid session
    | Setup -- Special setup flow routes


setupProgressDecoder : Query.Parser (Maybe SetupProgress)
setupProgressDecoder =
    Query.map2
        (\plan org ->
            case ( plan, org ) of
                ( Just p, Just o ) ->
                    Just
                        { plan = Just p
                        , orgSettings = o == "complete"
                        , brandSettings = False
                        }

                _ ->
                    Nothing
        )
        (Query.string "plan")
        (Query.string "org")


routeParser : Parser (Route -> a) a
routeParser =
    oneOf
        [ map (PublicRoute HomeRoute) top
        , map (PublicRoute LoginRoute) (s "login")
        , map (PublicRoute SignupRoute) (s "signup")
        , map (\orgSlug -> \token -> PublicRoute (VerifyRoute (VerifyParams orgSlug token)))
            (s "auth" </> s "verify" </> string </> string)
        , map (ProtectedRoute ContactsRoute) (s "contacts")
        , map (ProtectedRoute SettingsRoute) (s "settings")
        , map (ProtectedRoute ProfileRoute) (s "profile")
        , map (ProtectedRoute BrandSettingsRoute) (s "brand-settings")
        , map (ProtectedRoute TempLandingRoute) (s "templanding")
        , map (ProtectedRoute AgentsRoute) (s "add-agents")
        , map (\id -> ProtectedRoute (ContactRoute id)) (s "contact" </> string)
        , map (\progress -> SetupRoute (ChoosePlanRoute progress))
            (s "choose-plan" <?> setupProgressDecoder)
        , map (\progress -> SetupRoute (SetupSettingsRoute progress))
            (s "setup" </> s "settings" <?> setupProgressDecoder)
        , map (\progress -> SetupRoute (SetupBrandSettingsRoute progress))
            (s "setup" </> s "brand-settings" <?> setupProgressDecoder)
        , map (\progress -> SetupRoute (AddAgentsRoute progress))
            (s "setup" </> s "add-agents" <?> setupProgressDecoder)
        ]


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        LinkClicked urlRequest ->
            case urlRequest of
                Browser.Internal url ->
                    ( model
                    , Nav.pushUrl model.key (Url.toString url)
                    )

                Browser.External href ->
                    ( model
                    , Nav.load href
                    )

        InternalLinkClicked frag ->
            ( model, Nav.pushUrl model.key frag )

        UrlChanged url ->
            ( { model | url = url }
            , Cmd.none
            )
                |> updatePage url

        LoginMsg subMsg ->
            case model.page of
                LoginPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Login.update subMsg pageModel
                    in
                    ( { model | page = LoginPage newPageModel }
                    , Cmd.map LoginMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ContactsMsg subMsg ->
            case model.page of
                ContactsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Contacts.update subMsg pageModel
                    in
                    ( { model | page = ContactsPage newPageModel }
                    , Cmd.map ContactsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        TempLandingMsg subMsg ->
            case model.page of
                TempLandingPage pageModel ->
                    case subMsg of
                        TempLanding.NavigateTo path ->
                            ( model
                            , Nav.pushUrl model.key path
                            )

                _ ->
                    ( model, Cmd.none )

        SettingsMsg subMsg ->
            case model.page of
                SettingsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Settings.update subMsg pageModel
                    in
                    ( { model | page = SettingsPage newPageModel }
                    , Cmd.map SettingsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        SignupMsg subMsg ->
            case model.page of
                Signup signupModel ->
                    let
                        ( newSignupModel, newCmd ) =
                            Signup.update subMsg signupModel
                    in
                    ( { model | page = Signup newSignupModel }
                    , Cmd.map SignupMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ChoosePlanMsg subMsg ->
            case model.page of
                ChoosePlanPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            ChoosePlan.update subMsg pageModel
                    in
                    ( { model | page = ChoosePlanPage newPageModel }
                    , Cmd.map ChoosePlanMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        AddAgentsMsg subMsg ->
            case model.page of
                AddAgentsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            AddAgent.update subMsg pageModel
                    in
                    ( { model | page = AddAgentsPage newPageModel }
                    , Cmd.map AddAgentsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        GotVerification result ->
            case result of
                Ok response ->
                    if response.success then
                        let
                            _ =
                                Debug.log "Got verification response" response

                            ( choosePlanModel, choosePlanCmd ) =
                                ChoosePlan.init response.orgSlug response.session model.key

                            newModel =
                                { model
                                    | session = Verified response.session
                                    , currentUser =
                                        Just
                                            { id = ""
                                            , email = response.email
                                            , isAdmin = False
                                            , isAgent = False
                                            , organizationSlug = response.orgSlug
                                            , firstName = ""
                                            , lastName = ""
                                            }
                                    , isSetup = True
                                }
                        in
                        ( newModel
                        , case model.intendedDestination of
                            Just destination ->
                                Cmd.batch
                                    [ Nav.replaceUrl model.key destination
                                    , Cmd.map ChoosePlanMsg choosePlanCmd
                                    ]

                            Nothing ->
                                Cmd.batch
                                    [ Nav.replaceUrl model.key response.redirectUrl
                                    , Cmd.map ChoosePlanMsg choosePlanCmd
                                    ]
                        )

                    else
                        ( model, Nav.pushUrl model.key "/login" )

                Err error ->
                    ( model, Nav.pushUrl model.key "/login" )

        GotSession result ->
            let
                _ =
                    Debug.log "Got session response" result
            in
            case result of
                Ok response ->
                    let
                        _ =
                            Debug.log "Session response details" response
                    in
                    if response.valid then
                        let
                            _ =
                                Debug.log "Session is valid" response.session

                            -- Create the user first so we can check setup state
                            user =
                                { id = response.id
                                , email = response.email
                                , isAdmin = False
                                , isAgent = False
                                , organizationSlug = response.organizationSlug
                                , firstName = response.firstName
                                , lastName = response.lastName
                                }

                            -- Only set isSetup to True if we're in the middle of setup
                            isInSetup =
                                case Parser.parse routeParser model.url of
                                    Just (SetupRoute _) ->
                                        True

                                    _ ->
                                        False

                            newModel =
                                { model
                                    | session = Verified response.session
                                    , currentUser = Just user
                                    , isSetup = isInSetup
                                }
                        in
                        -- Now that we have session info, update the page
                        updatePage model.url ( newModel, Cmd.none )

                    else
                        let
                            _ =
                                Debug.log "Session is invalid" ()

                            newModel =
                                { model | session = NoSession }
                        in
                        -- For invalid session, update page which will handle redirects
                        updatePage model.url ( newModel, Cmd.none )

                Err error ->
                    let
                        _ =
                            Debug.log "Session check error" error

                        newModel =
                            { model | session = NoSession }
                    in
                    -- For session error, update page which will handle redirects
                    updatePage model.url ( newModel, Cmd.none )

        ProfileMsg subMsg ->
            case model.page of
                ProfilePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Profile.update subMsg pageModel
                    in
                    ( { model | page = ProfilePage newPageModel }
                    , case subMsg of
                        Profile.NavigateTo path ->
                            Nav.pushUrl model.key path

                        _ ->
                            Cmd.map ProfileMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        HomeMsg subMsg ->
            case model.page of
                HomePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Home.update subMsg pageModel
                    in
                    ( { model | page = HomePage newPageModel }
                    , Cmd.map HomeMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        BrandSettingsMsg subMsg ->
            case model.page of
                BrandSettingsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            BrandSettings.update subMsg pageModel
                    in
                    ( { model | page = BrandSettingsPage newPageModel }
                    , Cmd.map BrandSettingsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ContactMsg subMsg ->
            case model.page of
                ContactPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Contact.update subMsg pageModel
                    in
                    ( { model | page = ContactPage newPageModel }
                    , Cmd.map ContactMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )


view : Model -> Browser.Document Msg
view model =
    let
        viewPage =
            case model.page of
                NotFoundPage ->
                    viewNotFound

                LoginPage loginModel ->
                    let
                        loginView =
                            Login.view loginModel
                    in
                    { title = loginView.title
                    , body = List.map (Html.map LoginMsg) loginView.body
                    }

                ContactsPage contactsModel ->
                    { title = "Contacts"
                    , body = [ viewWithNav model (Html.map ContactsMsg (Contacts.view contactsModel)) ]
                    }

                TempLandingPage landingModel ->
                    let
                        landingView =
                            TempLanding.view landingModel
                    in
                    { title = landingView.title
                    , body = [ viewWithNav model (Html.map TempLandingMsg (div [] landingView.body)) ]
                    }

                SettingsPage settingsModel ->
                    let
                        settingsView =
                            Settings.view settingsModel
                    in
                    { title = settingsView.title
                    , body = [ viewWithNav model (Html.map SettingsMsg (div [] settingsView.body)) ]
                    }

                Signup signupModel ->
                    let
                        signupView =
                            Signup.view signupModel
                    in
                    { title = signupView.title
                    , body = List.map (Html.map SignupMsg) signupView.body
                    }

                ChoosePlanPage choosePlanModel ->
                    let
                        choosePlanView =
                            ChoosePlan.view choosePlanModel
                    in
                    { title = choosePlanView.title
                    , body = [ viewWithNav model (Html.map ChoosePlanMsg (div [] choosePlanView.body)) ]
                    }

                BrandSettingsPage brandSettingsModel ->
                    let
                        brandSettingsView =
                            BrandSettings.view brandSettingsModel
                    in
                    { title = brandSettingsView.title
                    , body = [ viewWithNav model (Html.map BrandSettingsMsg (div [] brandSettingsView.body)) ]
                    }

                AddAgentsPage addAgentModel ->
                    let
                        addAgentView =
                            AddAgent.view addAgentModel
                    in
                    { title = addAgentView.title
                    , body = [ viewWithNav model (Html.map AddAgentsMsg (div [] addAgentView.body)) ]
                    }

                ProfilePage profileModel ->
                    let
                        profileView =
                            Profile.view profileModel
                    in
                    { title = profileView.title
                    , body = [ viewWithNav model (Html.map ProfileMsg (div [] profileView.body)) ]
                    }

                LoadingPage ->
                    { title = "Loading..."
                    , body = [ viewLoading ]
                    }

                HomePage homeModel ->
                    let
                        homeView =
                            Home.view homeModel
                    in
                    { title = homeView.title
                    , body = List.map (Html.map HomeMsg) homeView.body
                    }

                ContactPage contactModel ->
                    let
                        contactView =
                            Contact.view contactModel
                    in
                    { title = contactView.title
                    , body = [ viewWithNav model (Html.map ContactMsg (div [] contactView.body)) ]
                    }
    in
    viewPage


viewWithNav : Model -> Html Msg -> Html Msg
viewWithNav model content =
    div []
        [ viewNavHeader model
        , content
        ]


viewNavHeader : Model -> Html Msg
viewNavHeader model =
    nav [ class "bg-white border-b border-gray-200" ]
        [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
            [ div [ class "flex justify-between h-16" ]
                [ div [ class "flex" ]
                    [ div [ class "shrink-0 flex items-center" ]
                        [ button
                            [ onClick (InternalLinkClicked "/") ]
                            [ img
                                [ src "/images/medicare-max-logo.png"
                                , class "h-8 w-auto"
                                , alt "Medicare Max logo"
                                ]
                                []
                            ]
                        ]
                    ]
                , div [ class "flex items-center space-x-4" ]
                    [ button
                        [ class "px-3 py-1.5 text-gray-700 text-sm font-medium hover:text-purple-600 transition-colors duration-200"
                        , onClick (InternalLinkClicked "/contacts")
                        ]
                        [ text "Contacts" ]
                    , button
                        [ class "px-3 py-1.5 text-gray-700 text-sm font-medium hover:text-purple-600 transition-colors duration-200"
                        , onClick (InternalLinkClicked "/brand-settings")
                        ]
                        [ text "Brand Settings" ]
                    , if isAdminOrAdminAgent model.currentUser then
                        button
                            [ class "px-3 py-1.5 text-gray-700 text-sm font-medium hover:text-purple-600 transition-colors duration-200"
                            , onClick (InternalLinkClicked "/add-agents")
                            ]
                            [ text "Manage Agents" ]

                      else
                        text ""
                    , button
                        [ class "px-3 py-1.5 text-gray-700 text-sm font-medium hover:text-purple-600 transition-colors duration-200"
                        , onClick (InternalLinkClicked "/profile")
                        ]
                        [ text "Profile" ]
                    , if isAdminOrAdminAgent model.currentUser then
                        button
                            [ class "px-3 py-1.5 text-gray-700 text-sm font-medium hover:text-purple-600 transition-colors duration-200"
                            , onClick (InternalLinkClicked "/settings")
                            ]
                            [ text "Organization Settings" ]

                      else
                        text ""
                    ]
                ]
            ]
        ]


isAdminOrAdminAgent : Maybe User -> Bool
isAdminOrAdminAgent maybeUser =
    case maybeUser of
        Just user ->
            user.isAdmin

        Nothing ->
            False


viewNotFound : Browser.Document msg
viewNotFound =
    { title = "Not Found"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex flex-col items-center justify-center" ]
            [ h1 [ class "text-4xl font-bold text-gray-900 mb-4" ]
                [ text "404 - Page Not Found" ]
            , p [ class "text-gray-600" ]
                [ text "The page you're looking for doesn't exist." ]
            ]
        ]
    }


viewLoading : Html msg
viewLoading =
    div [ class "min-h-screen bg-gray-50 flex items-center justify-center" ]
        [ div [ class "animate-spin rounded-full h-8 w-8 border-2 border-purple-500 border-t-transparent" ] []
        ]


subscriptions : Model -> Sub Msg
subscriptions model =
    case model.page of
        LoadingPage ->
            Sub.none

        LoginPage pageModel ->
            Sub.map LoginMsg (Login.subscriptions pageModel)

        ContactsPage pageModel ->
            Sub.map ContactsMsg (Contacts.subscriptions pageModel)

        TempLandingPage pageModel ->
            Sub.map TempLandingMsg (TempLanding.subscriptions pageModel)

        SettingsPage pageModel ->
            Sub.map SettingsMsg (Settings.subscriptions pageModel)

        Signup signupModel ->
            Sub.map SignupMsg (Signup.subscriptions signupModel)

        ChoosePlanPage pageModel ->
            Sub.map ChoosePlanMsg (ChoosePlan.subscriptions pageModel)

        AddAgentsPage pageModel ->
            Sub.map AddAgentsMsg (AddAgent.subscriptions pageModel)

        ProfilePage pageModel ->
            Sub.map ProfileMsg (Profile.subscriptions pageModel)

        HomePage pageModel ->
            Sub.map HomeMsg (Home.subscriptions pageModel)

        BrandSettingsPage pageModel ->
            Sub.map BrandSettingsMsg (BrandSettings.subscriptions pageModel)

        ContactPage pageModel ->
            Sub.map ContactMsg (Contact.subscriptions pageModel)

        NotFoundPage ->
            Sub.none


getRouteAccess : Route -> RouteAccess
getRouteAccess route =
    case route of
        PublicRoute _ ->
            Public

        ProtectedRoute _ ->
            Protected

        SetupRoute _ ->
            Setup

        NotFound ->
            Public


userDecoder : Decoder User
userDecoder =
    Decode.map7 User
        (Decode.field "id" (Decode.map String.fromInt Decode.int))
        (Decode.field "email" Decode.string)
        (Decode.field "is_admin" Decode.bool)
        (Decode.field "is_agent" Decode.bool)
        (Decode.field "organization_name" Decode.string)
        (Decode.field "first_name" Decode.string)
        (Decode.field "last_name" Decode.string)


type SetupStep
    = NotStarted
    | PlanSelection
    | OrganizationSetup
    | BrandSetup
    | AgentSetup
    | Complete


getSetupStep : Model -> SetupStep
getSetupStep model =
    case model.currentUser of
        Nothing ->
            NotStarted

        Just user ->
            if not model.isSetup then
                PlanSelection

            else if not (hasOrganizationSettings user) then
                OrganizationSetup

            else if not (hasBrandSettings user) then
                BrandSetup

            else if not (hasAgents user) then
                AgentSetup

            else
                Complete


hasOrganizationSettings : User -> Bool
hasOrganizationSettings user =
    -- TODO: Add actual check for organization settings
    True


hasBrandSettings : User -> Bool
hasBrandSettings user =
    -- TODO: Add actual check for brand settings
    True


hasAgents : User -> Bool
hasAgents user =
    -- TODO: Add actual check for agents
    True


redirectToSetupStep : Model -> ( Model, Cmd Msg )
redirectToSetupStep model =
    case getSetupStep model of
        NotStarted ->
            ( model, Nav.pushUrl model.key "/login" )

        PlanSelection ->
            ( model, Nav.pushUrl model.key "/choose-plan" )

        OrganizationSetup ->
            case model.currentUser of
                Just user ->
                    ( model
                    , Nav.pushUrl model.key
                        ("/setup/settings?plan=" ++ user.organizationSlug)
                    )

                Nothing ->
                    ( model, Nav.pushUrl model.key "/setup/settings" )

        BrandSetup ->
            case model.currentUser of
                Just user ->
                    ( model
                    , Nav.pushUrl model.key
                        ("/setup/brand-settings?plan=" ++ user.organizationSlug ++ "&org=complete")
                    )

                Nothing ->
                    ( model, Nav.pushUrl model.key "/setup/brand-settings" )

        AgentSetup ->
            case model.currentUser of
                Just user ->
                    ( model
                    , Nav.pushUrl model.key
                        ("/setup/add-agents?plan=" ++ user.organizationSlug ++ "&org=complete&brand=complete")
                    )

                Nothing ->
                    ( model, Nav.pushUrl model.key "/setup/add-agents" )

        Complete ->
            ( model, Nav.pushUrl model.key "/contacts" )


shouldRedirectToLogin : Route -> Model -> Bool
shouldRedirectToLogin route model =
    case route of
        PublicRoute _ ->
            False

        NotFound ->
            False

        _ ->
            case model.session of
                Verified _ ->
                    False

                _ ->
                    True


shouldRedirectToSetup : Route -> Model -> Bool
shouldRedirectToSetup route model =
    -- Only check setup state if we're in setup mode
    if model.isSetup then
        case route of
            SetupRoute _ ->
                False

            PublicRoute _ ->
                False

            NotFound ->
                False

            ProtectedRoute _ ->
                getSetupStep model /= Complete

    else
        False



-- Not in setup mode, no need to redirect


updatePage : Url -> ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
updatePage url ( model, cmd ) =
    case model.session of
        Unknown ->
            -- If we don't know session state yet, stay on loading page
            ( { model | page = LoadingPage }
            , cmd
            )

        _ ->
            -- Only process route after we know session state
            case Parser.parse routeParser url of
                Just route ->
                    if shouldRedirectToLogin route model then
                        ( { model
                            | intendedDestination = Just (Url.toString url)
                            , page = LoginPage (Login.init model.key False |> Tuple.first)
                          }
                        , Nav.pushUrl model.key "/login"
                        )

                    else if shouldRedirectToSetup route model then
                        redirectToSetupStep model

                    else
                        case route of
                            PublicRoute HomeRoute ->
                                let
                                    ( homeModel, homeCmd ) =
                                        Home.init ()
                                in
                                ( { model | page = HomePage homeModel }
                                , Cmd.batch [ cmd, Cmd.map HomeMsg homeCmd ]
                                )

                            PublicRoute LoginRoute ->
                                let
                                    ( loginModel, loginCmd ) =
                                        Login.init model.key False
                                in
                                ( { model | page = LoginPage loginModel }
                                , Cmd.batch [ cmd, Cmd.map LoginMsg loginCmd ]
                                )

                            PublicRoute (VerifyRoute (VerifyParams orgSlug token)) ->
                                let
                                    _ =
                                        Debug.log "Verifying magic link" ( orgSlug, token )

                                    verifyUrl =
                                        "/api/auth/verify/" ++ orgSlug ++ "/" ++ token

                                    verifyRequest =
                                        Http.get
                                            { url = verifyUrl
                                            , expect = Http.expectJson GotVerification verificationDecoder
                                            }
                                in
                                ( model
                                , Cmd.batch [ cmd, verifyRequest ]
                                )

                            PublicRoute SignupRoute ->
                                let
                                    ( signupModel, signupCmd ) =
                                        Signup.init
                                in
                                ( { model | page = Signup signupModel }
                                , Cmd.batch [ cmd, Cmd.map SignupMsg signupCmd ]
                                )

                            ProtectedRoute ContactsRoute ->
                                let
                                    ( contactsModel, contactsCmd ) =
                                        Contacts.init model.key
                                in
                                ( { model | page = ContactsPage contactsModel }
                                , Cmd.batch [ cmd, Cmd.map ContactsMsg contactsCmd ]
                                )

                            ProtectedRoute SettingsRoute ->
                                let
                                    ( settingsModel, settingsCmd ) =
                                        Settings.init
                                            { isSetup = True
                                            , key = model.key
                                            , currentUser =
                                                case model.currentUser of
                                                    Just user ->
                                                        Just
                                                            { id = user.id
                                                            , email = user.email
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            }

                                                    Nothing ->
                                                        Nothing
                                            }
                                in
                                ( { model | page = SettingsPage settingsModel }
                                , Cmd.batch [ cmd, Cmd.map SettingsMsg settingsCmd ]
                                )

                            ProtectedRoute ProfileRoute ->
                                let
                                    ( profileModel, profileCmd ) =
                                        Profile.init ()
                                in
                                ( { model | page = ProfilePage profileModel }
                                , Cmd.batch [ cmd, Cmd.map ProfileMsg profileCmd ]
                                )

                            ProtectedRoute BrandSettingsRoute ->
                                let
                                    ( brandSettingsModel, brandSettingsCmd ) =
                                        case model.currentUser of
                                            Just user ->
                                                BrandSettings.init
                                                    { key = model.key
                                                    , session =
                                                        case model.session of
                                                            Verified session ->
                                                                session

                                                            _ ->
                                                                ""
                                                    , orgSlug = user.organizationSlug
                                                    , isSetup = True
                                                    }

                                            Nothing ->
                                                BrandSettings.init
                                                    { key = model.key
                                                    , session = ""
                                                    , orgSlug = ""
                                                    , isSetup = True
                                                    }
                                in
                                ( { model | page = BrandSettingsPage brandSettingsModel }
                                , Cmd.batch [ cmd, Cmd.map BrandSettingsMsg brandSettingsCmd ]
                                )

                            ProtectedRoute TempLandingRoute ->
                                let
                                    ( tempLandingModel, tempLandingCmd ) =
                                        TempLanding.init ()
                                in
                                ( { model | page = TempLandingPage tempLandingModel }
                                , Cmd.batch [ cmd, Cmd.map TempLandingMsg tempLandingCmd ]
                                )

                            ProtectedRoute AgentsRoute ->
                                let
                                    ( addAgentsModel, addAgentsCmd ) =
                                        AddAgent.init
                                            { isSetup = False
                                            , key = model.key
                                            }
                                in
                                ( { model | page = AddAgentsPage addAgentsModel }
                                , Cmd.batch [ cmd, Cmd.map AddAgentsMsg addAgentsCmd ]
                                )

                            ProtectedRoute (ContactRoute id) ->
                                let
                                    _ =
                                        Debug.log "Handling contact route with ID" id

                                    ( contactModel, contactCmd ) =
                                        Contact.init model.key id
                                in
                                ( { model | page = ContactPage contactModel }
                                , Cmd.batch [ cmd, Cmd.map ContactMsg contactCmd ]
                                )

                            SetupRoute (ChoosePlanRoute progress) ->
                                let
                                    ( choosePlanModel, choosePlanCmd ) =
                                        case model.currentUser of
                                            Just user ->
                                                ChoosePlan.init
                                                    user.organizationSlug
                                                    (case model.session of
                                                        Verified s ->
                                                            s

                                                        _ ->
                                                            ""
                                                    )
                                                    model.key

                                            Nothing ->
                                                -- This case should not happen as we check for auth before
                                                ChoosePlan.init "" "" model.key
                                in
                                ( { model | page = ChoosePlanPage choosePlanModel }
                                , Cmd.batch [ cmd, Cmd.map ChoosePlanMsg choosePlanCmd ]
                                )

                            SetupRoute (SetupSettingsRoute progress) ->
                                let
                                    ( settingsModel, settingsCmd ) =
                                        Settings.init
                                            { isSetup = True
                                            , key = model.key
                                            , currentUser =
                                                case model.currentUser of
                                                    Just user ->
                                                        Just
                                                            { id = user.id
                                                            , email = user.email
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            }

                                                    Nothing ->
                                                        Nothing
                                            }
                                in
                                ( { model | page = SettingsPage settingsModel }
                                , Cmd.batch [ cmd, Cmd.map SettingsMsg settingsCmd ]
                                )

                            SetupRoute (SetupBrandSettingsRoute progress) ->
                                let
                                    ( brandSettingsModel, brandSettingsCmd ) =
                                        case model.currentUser of
                                            Just user ->
                                                BrandSettings.init
                                                    { key = model.key
                                                    , session =
                                                        case model.session of
                                                            Verified session ->
                                                                session

                                                            _ ->
                                                                ""
                                                    , orgSlug = user.organizationSlug
                                                    , isSetup = True
                                                    }

                                            Nothing ->
                                                BrandSettings.init
                                                    { key = model.key
                                                    , session = ""
                                                    , orgSlug = ""
                                                    , isSetup = True
                                                    }
                                in
                                ( { model | page = BrandSettingsPage brandSettingsModel }
                                , Cmd.batch [ cmd, Cmd.map BrandSettingsMsg brandSettingsCmd ]
                                )

                            SetupRoute (AddAgentsRoute progress) ->
                                let
                                    ( addAgentsModel, addAgentsCmd ) =
                                        AddAgent.init
                                            { isSetup = True
                                            , key = model.key
                                            }
                                in
                                ( { model | page = AddAgentsPage addAgentsModel }
                                , Cmd.batch [ cmd, Cmd.map AddAgentsMsg addAgentsCmd ]
                                )

                            NotFound ->
                                ( { model | page = NotFoundPage }
                                , cmd
                                )

                Nothing ->
                    ( { model | page = NotFoundPage }
                    , cmd
                    )

================
File: frontend/src/main.ts
================
import './styles.css'
import { Elm } from './Main.elm'

const root = document.querySelector('#app')
if (root) {
  // Get session cookie if it exists
  const getCookie = (name: string) => {
    const value = `; ${document.cookie}`
    const parts = value.split(`; ${name}=`)
    if (parts.length === 2) return parts.pop()?.split(';').shift()
    return null
  }

  const sessionCookie = getCookie('session')
  console.log('Found session cookie:', sessionCookie)

  const app = Elm.Main.init({
    node: root,
    flags: {
      apiUrl: 'http://localhost:3000',
      initialSession: sessionCookie || null
    }
  })

  // Add any ports here if needed
  // app.ports.sendToJs.subscribe((data) => {
  //   console.log('From Elm:', data)
  // })
}

================
File: frontend/src/Profile.elm
================
module Profile exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Debug
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Svg exposing (path, svg)
import Svg.Attributes as SvgAttr
import Time



-- MODEL


type alias Model =
    { currentUser : Maybe User
    , originalUser : Maybe User -- Store original user data for comparison
    , isLoading : Bool
    , error : Maybe String
    , pendingSave : Bool
    }


type alias User =
    { id : Int
    , email : String
    , firstName : String
    , lastName : String
    , phone : String
    , isAdmin : Bool
    , isAgent : Bool
    , carriers : List String
    , stateLicenses : List String
    }


init : () -> ( Model, Cmd Msg )
init _ =
    ( { currentUser = Nothing
      , originalUser = Nothing
      , isLoading = True
      , error = Nothing
      , pendingSave = False
      }
    , fetchCurrentUser
    )



-- UPDATE


type Msg
    = GotCurrentUser (Result Http.Error CurrentUserResponse)
    | UpdateField String String
    | SaveProfile
    | ProfileSaved (Result Http.Error ())
    | NavigateTo String


type alias CurrentUserResponse =
    { success : Bool
    , user : Maybe User
    }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GotCurrentUser (Ok response) ->
            let
                _ =
                    Debug.log "GotCurrentUser success" response
            in
            ( { model
                | currentUser = response.user
                , originalUser = response.user -- Store original user data
                , isLoading = False
              }
            , Cmd.none
            )

        GotCurrentUser (Err error) ->
            let
                _ =
                    Debug.log "GotCurrentUser error" error
            in
            ( { model
                | error = Just "Failed to load profile"
                , isLoading = False
              }
            , Cmd.none
            )

        UpdateField field value ->
            case model.currentUser of
                Just user ->
                    let
                        updatedUser =
                            case field of
                                "firstName" ->
                                    { user | firstName = value }

                                "lastName" ->
                                    { user | lastName = value }

                                "phone" ->
                                    { user | phone = String.filter Char.isDigit value }

                                _ ->
                                    user
                    in
                    ( { model | currentUser = Just updatedUser }
                    , Cmd.none
                    )

                Nothing ->
                    ( model, Cmd.none )

        SaveProfile ->
            ( { model | pendingSave = True }
            , case model.currentUser of
                Just user ->
                    saveProfile user

                Nothing ->
                    Cmd.none
            )

        ProfileSaved (Ok _) ->
            ( { model
                | pendingSave = False
                , originalUser = model.currentUser -- Update original user after successful save
              }
            , Cmd.none
            )

        ProfileSaved (Err _) ->
            ( { model
                | pendingSave = False
                , error = Just "Failed to save profile changes"
              }
            , Cmd.none
            )

        NavigateTo path ->
            ( model, Cmd.none )



-- Main.elm will handle the actual navigation
-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Profile"
    , body =
        [ div [ class "min-h-screen bg-gray-50" ]
            [ div [ class "max-w-3xl mx-auto py-12 px-4 sm:px-6 lg:px-8" ]
                [ h1 [ class "text-3xl font-bold text-gray-900 mb-8" ]
                    [ text "Profile" ]
                , viewContent model
                ]
            ]
        ]
    }


viewContent : Model -> Html Msg
viewContent model =
    if model.isLoading then
        div [ class "flex justify-center items-center h-64" ]
            [ viewSpinner ]

    else
        case model.currentUser of
            Just user ->
                div [ class "bg-white shadow rounded-lg p-6 space-y-6" ]
                    [ viewBasicInfo user
                    , if isAgent user then
                        div [ class "space-y-6" ]
                            [ viewCarriers user
                            , viewStateLicenses user
                            ]

                      else
                        text ""
                    , viewSaveButton model
                    ]

            Nothing ->
                div [ class "text-center text-gray-600" ]
                    [ text "Failed to load profile" ]


viewBasicInfo : User -> Html Msg
viewBasicInfo user =
    div [ class "space-y-6" ]
        [ div [ class "border-b border-gray-200 pb-4" ]
            [ h2 [ class "text-lg font-medium text-gray-900" ]
                [ text "Basic Information" ]
            ]
        , div [ class "grid grid-cols-2 gap-4" ]
            [ viewField "First Name" "text" user.firstName "firstName"
            , viewField "Last Name" "text" user.lastName "lastName"
            , viewField "Email" "email" user.email "email"
            , viewField "Phone" "tel" user.phone "phone"
            ]
        , viewRoleInfo user
        ]


viewField : String -> String -> String -> String -> Html Msg
viewField label inputType value field =
    div []
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text label ]
        , input
            [ type_ inputType
            , class "mt-1 px-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
            , Html.Attributes.value
                (if field == "phone" then
                    formatPhoneNumber value

                 else
                    value
                )
            , onInput (UpdateField field)
            , disabled (field == "email") -- Email cannot be changed
            ]
            []
        ]


viewRoleInfo : User -> Html Msg
viewRoleInfo user =
    div [ class "mb-6" ]
        [ label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text "Role" ]
        , div [ class "text-gray-900" ]
            [ text (formatRole user) ]
        , if user.isAdmin then
            div [ class "mt-2 text-sm text-gray-500" ]
                [ text "You have administrator privileges" ]

          else
            text ""
        ]


viewCarriers : User -> Html Msg
viewCarriers user =
    div [ class "space-y-4" ]
        [ div [ class "border-b border-gray-200 pb-4" ]
            [ h2 [ class "text-lg font-medium text-gray-900" ]
                [ text "Activated Carriers" ]
            ]
        , if List.isEmpty user.carriers then
            div [ class "text-sm text-gray-500 italic" ]
                [ text "No carriers activated" ]

          else
            div [ class "grid grid-cols-3 gap-4" ]
                (List.map
                    (\carrier ->
                        div [ class "flex items-center space-x-2 text-sm text-gray-600" ]
                            [ svg [ SvgAttr.class "h-5 w-5 text-green-500", SvgAttr.viewBox "0 0 20 20", SvgAttr.fill "currentColor" ]
                                [ path [ SvgAttr.d "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z", SvgAttr.fillRule "evenodd", SvgAttr.clipRule "evenodd" ] [] ]
                            , span [] [ text carrier ]
                            ]
                    )
                    user.carriers
                )
        ]


viewStateLicenses : User -> Html Msg
viewStateLicenses user =
    div [ class "space-y-4" ]
        [ div [ class "border-b border-gray-200 pb-4" ]
            [ h2 [ class "text-lg font-medium text-gray-900" ]
                [ text "Activated State Licenses" ]
            ]
        , if List.isEmpty user.stateLicenses then
            div [ class "text-sm text-gray-500 italic" ]
                [ text "No state licenses activated" ]

          else
            div [ class "grid grid-cols-6 gap-4" ]
                (List.map
                    (\state ->
                        div [ class "flex items-center space-x-2 text-sm text-gray-600" ]
                            [ svg [ SvgAttr.class "h-5 w-5 text-green-500", SvgAttr.viewBox "0 0 20 20", SvgAttr.fill "currentColor" ]
                                [ path [ SvgAttr.d "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z", SvgAttr.fillRule "evenodd", SvgAttr.clipRule "evenodd" ] [] ]
                            , span [] [ text state ]
                            ]
                    )
                    user.stateLicenses
                )
        ]


viewSaveButton : Model -> Html Msg
viewSaveButton model =
    div [ class "mt-8 flex justify-end" ]
        [ if model.pendingSave then
            div [ class "px-6 py-3 flex items-center space-x-2" ]
                [ viewSpinner ]

          else
            button
                [ class "px-6 py-3 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-blue-600"
                , onClick SaveProfile
                , disabled (not (hasChanges model))
                ]
                [ text "Save Changes" ]
        ]


viewSpinner : Html Msg
viewSpinner =
    div [ class "animate-spin rounded-full h-5 w-5 border-2 border-blue-500 border-t-transparent" ] []



-- HTTP


fetchCurrentUser : Cmd Msg
fetchCurrentUser =
    Http.get
        { url = "/api/me"
        , expect = Http.expectJson GotCurrentUser currentUserResponseDecoder
        }


saveProfile : User -> Cmd Msg
saveProfile user =
    Http.request
        { method = "PUT"
        , headers = []
        , url = "/api/agents/" ++ String.fromInt user.id
        , body = Http.jsonBody (encodeUser user)
        , expect = Http.expectWhatever ProfileSaved
        , timeout = Nothing
        , tracker = Nothing
        }



-- DECODERS


currentUserResponseDecoder : Decoder CurrentUserResponse
currentUserResponseDecoder =
    Decode.map2 CurrentUserResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "user" (Decode.nullable userDecoder))


userDecoder : Decoder User
userDecoder =
    Decode.succeed User
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "firstName" Decode.string
        |> Pipeline.required "lastName" Decode.string
        |> Pipeline.required "phone" Decode.string
        |> Pipeline.required "is_admin" Decode.bool
        |> Pipeline.required "is_agent" Decode.bool
        |> Pipeline.optional "carriers" (Decode.list Decode.string) []
        |> Pipeline.optional "stateLicenses" (Decode.list Decode.string) []



-- ENCODERS


encodeUser : User -> Encode.Value
encodeUser user =
    Encode.object
        [ ( "firstName", Encode.string user.firstName )
        , ( "lastName", Encode.string user.lastName )
        , ( "email", Encode.string user.email )
        , ( "phone", Encode.string user.phone )
        , ( "carriers", Encode.list Encode.string user.carriers )
        , ( "stateLicenses", Encode.list Encode.string user.stateLicenses )
        ]



-- HELPERS


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    let
        digits =
            String.filter Char.isDigit phone
                |> String.left 10

        len =
            String.length digits
    in
    if len == 0 then
        ""

    else if len <= 3 then
        "(" ++ digits

    else if len <= 6 then
        "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

    else
        "("
            ++ String.left 3 digits
            ++ ") "
            ++ String.slice 3 6 digits
            ++ "-"
            ++ String.dropLeft 6 digits


formatRole : User -> String
formatRole user =
    if user.isAdmin && user.isAgent then
        "Admin Agent"

    else if user.isAdmin then
        "Administrator"

    else if user.isAgent then
        "Agent"

    else
        "User"


isAgent : User -> Bool
isAgent user =
    user.isAgent



-- Add this helper function to check for changes


hasChanges : Model -> Bool
hasChanges model =
    case ( model.currentUser, model.originalUser ) of
        ( Just current, Just original ) ->
            current.firstName
                /= original.firstName
                || current.lastName
                /= original.lastName
                || current.phone
                /= original.phone

        _ ->
            False



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/Settings.elm
================
module Settings exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Components.ProgressIndicator
import Components.SetupLayout as SetupLayout
import Debug
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onCheck, onClick, onInput)
import Http exposing (expectJson, jsonBody)
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import StateRegions exposing (Region(..), getRegionStates, regionToString)
import Svg exposing (path, svg)
import Svg.Attributes exposing (clipRule, d, fill, fillRule, viewBox)



-- Constants


allStates : List String
allStates =
    [ "AL"
    , "AK"
    , "AZ"
    , "AR"
    , "CA"
    , "CO"
    , "CT"
    , "DE"
    , "FL"
    , "GA"
    , "HI"
    , "ID"
    , "IL"
    , "IN"
    , "IA"
    , "KS"
    , "KY"
    , "LA"
    , "ME"
    , "MD"
    , "MA"
    , "MI"
    , "MN"
    , "MS"
    , "MO"
    , "MT"
    , "NE"
    , "NV"
    , "NH"
    , "NJ"
    , "NM"
    , "NY"
    , "NC"
    , "ND"
    , "OH"
    , "OK"
    , "OR"
    , "PA"
    , "RI"
    , "SC"
    , "SD"
    , "TN"
    , "TX"
    , "UT"
    , "VT"
    , "VA"
    , "WA"
    , "WV"
    , "WI"
    , "WY"
    , "DC"
    ]


allCarriers : List String
allCarriers =
    [ "Aetna"
    , "Humana"
    , "UnitedHealthcare"
    , "Cigna"
    , "Aflac"
    , "Allstate"
    , "Mutual of Omaha"
    , "Ace Chubb"
    ]


type Carrier
    = Aetna
    | Humana
    | UnitedHealthcare
    | Cigna
    | Aflac
    | Allstate
    | MutualOfOmaha
    | AceChubb



-- Add new type for GI selection mode


type GISelectionMode
    = GIAll
    | GINone
    | GIRecommended


type alias InitFlags =
    { isSetup : Bool
    , key : Nav.Key
    , currentUser : Maybe CurrentUser
    }


type alias CurrentUser =
    { id : String
    , email : String
    , isAdmin : Bool
    , isAgent : Bool
    }


type alias Model =
    { orgSettings : Maybe Settings
    , status : Status
    , expandedSections : List String
    , recommendedGICombos : List StateCarrierSetting
    , isSetup : Bool
    , key : Nav.Key
    , currentUser : Maybe CurrentUser
    , isLoading : Bool
    }


type alias StateCarrierSetting =
    { state : String
    , carrier : String
    , active : Bool
    , targetGI : Bool
    }


type alias Settings =
    { stateLicenses : List String
    , carrierContracts : List String
    , stateCarrierSettings : List StateCarrierSetting
    , allowAgentSettings : Bool
    , emailSendBirthday : Bool
    , emailSendPolicyAnniversary : Bool
    , emailSendAep : Bool
    , smartSendEnabled : Bool
    }


type Status
    = Loading
    | Loaded
    | Saving
    | Error String


type Msg
    = GotSettings (Result Http.Error SettingsResponse)
    | SaveSettings
    | SettingsSaved (Result Http.Error Settings)
    | ToggleEmailBirthday Bool
    | ToggleEmailAnniversary Bool
    | ToggleEmailAep Bool
    | ToggleSmartSend Bool
    | AddStateLicense String
    | RemoveStateLicense String
    | AddCarrierContract String
    | RemoveCarrierContract String
    | UpdateStateCarrierSetting String String Bool Bool
    | ToggleSection String
    | ToggleAllStates Bool
    | ToggleAllCarriers Bool
    | ApplyGISelection GISelectionMode
    | GotRecommendedGICombos (Result Http.Error (List StateCarrierSetting))
    | ToggleAllowAgentSettings Bool
    | FinishSetup
    | SelectCommonStates Region


type alias SettingsResponse =
    { orgSettings : Settings
    , canEditOrgSettings : Bool
    }


init : InitFlags -> ( Model, Cmd Msg )
init flags =
    ( { orgSettings = Nothing
      , status = Loading
      , expandedSections = []
      , recommendedGICombos = []
      , isSetup = flags.isSetup
      , key = flags.key
      , currentUser = flags.currentUser
      , isLoading = True
      }
    , Cmd.batch
        [ fetchSettings
        , fetchRecommendedGICombos
        ]
    )


fetchSettings : Cmd Msg
fetchSettings =
    let
        _ =
            Debug.log "Fetching settings" ()
    in
    Http.get
        { url = "/api/settings"
        , expect = Http.expectJson GotSettings settingsDecoder
        }


fetchRecommendedGICombos : Cmd Msg
fetchRecommendedGICombos =
    let
        _ =
            Debug.log "Fetching GI recommendations" ()
    in
    Http.get
        { url = "/api/settings/gi-recommendations"
        , expect = Http.expectJson GotRecommendedGICombos recommendationsDecoder
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GotSettings result ->
            case result of
                Ok response ->
                    ( { model | orgSettings = Just response.orgSettings, status = Loaded, isLoading = False }
                    , Cmd.none
                    )

                Err error ->
                    let
                        errorMsg =
                            case error of
                                Http.BadUrl url ->
                                    "Bad URL: " ++ url

                                Http.Timeout ->
                                    "Request timed out"

                                Http.NetworkError ->
                                    "Network error"

                                Http.BadStatus status ->
                                    "Bad status: " ++ String.fromInt status

                                Http.BadBody message ->
                                    let
                                        _ =
                                            Debug.log "Decoder error" message
                                    in
                                    "Bad body: " ++ message
                    in
                    ( { model | status = Error errorMsg, isLoading = False }
                    , Cmd.none
                    )

        SaveSettings ->
            ( { model | status = Saving }
            , Cmd.none
            )

        SettingsSaved result ->
            case result of
                Ok settings ->
                    ( { model | orgSettings = Just settings, status = Loaded }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model | status = Error "Failed to save settings" }
                    , Cmd.none
                    )

        ToggleEmailBirthday value ->
            updateSettings model (\s -> { s | emailSendBirthday = value })

        ToggleEmailAnniversary value ->
            updateSettings model (\s -> { s | emailSendPolicyAnniversary = value })

        ToggleEmailAep value ->
            updateSettings model (\s -> { s | emailSendAep = value })

        ToggleSmartSend value ->
            updateSettings model (\s -> { s | smartSendEnabled = value })

        AddStateLicense state ->
            updateSettings model
                (\s ->
                    { s
                        | stateLicenses =
                            if List.member state s.stateLicenses then
                                s.stateLicenses

                            else
                                state :: s.stateLicenses
                    }
                )

        RemoveStateLicense state ->
            updateSettings model
                (\s ->
                    { s
                        | stateLicenses =
                            List.filter (\x -> x /= state) s.stateLicenses
                        , stateCarrierSettings =
                            List.filter (\setting -> setting.state /= state) s.stateCarrierSettings
                    }
                )

        AddCarrierContract carrier ->
            updateSettings model
                (\s ->
                    { s
                        | carrierContracts =
                            if List.member carrier s.carrierContracts then
                                s.carrierContracts

                            else
                                carrier :: s.carrierContracts
                    }
                )

        RemoveCarrierContract carrier ->
            updateSettings model
                (\s ->
                    { s
                        | carrierContracts =
                            List.filter (\x -> x /= carrier) s.carrierContracts
                        , stateCarrierSettings =
                            List.filter (\setting -> setting.carrier /= carrier) s.stateCarrierSettings
                    }
                )

        UpdateStateCarrierSetting state carrier active targetGI ->
            updateSettings model
                (\s ->
                    let
                        existingSetting =
                            List.filter
                                (\setting ->
                                    setting.state == state && setting.carrier == carrier
                                )
                                s.stateCarrierSettings
                                |> List.head

                        newSettings =
                            case existingSetting of
                                Just _ ->
                                    List.map
                                        (\setting ->
                                            if setting.state == state && setting.carrier == carrier then
                                                { setting | active = active, targetGI = targetGI }

                                            else
                                                setting
                                        )
                                        s.stateCarrierSettings

                                Nothing ->
                                    { state = state
                                    , carrier = carrier
                                    , active = active
                                    , targetGI = targetGI
                                    }
                                        :: s.stateCarrierSettings
                    in
                    { s | stateCarrierSettings = newSettings }
                )

        ToggleSection title ->
            ( { model
                | expandedSections =
                    if List.member title model.expandedSections then
                        List.filter ((/=) title) model.expandedSections

                    else
                        title :: model.expandedSections
              }
            , Cmd.none
            )

        ToggleAllStates checked ->
            case model.orgSettings of
                Just settings ->
                    let
                        newSettings =
                            { settings
                                | stateLicenses =
                                    if checked then
                                        allStates

                                    else
                                        []
                                , stateCarrierSettings =
                                    if checked then
                                        settings.stateCarrierSettings

                                    else
                                        []

                                -- Clear all state/carrier settings when deselecting all states
                            }
                    in
                    ( { model | orgSettings = Just newSettings }
                    , saveSettings newSettings
                    )

                Nothing ->
                    ( model, Cmd.none )

        ToggleAllCarriers checked ->
            case model.orgSettings of
                Just settings ->
                    let
                        newSettings =
                            { settings
                                | carrierContracts =
                                    if checked then
                                        allCarriers

                                    else
                                        []
                                , stateCarrierSettings =
                                    if checked then
                                        settings.stateCarrierSettings

                                    else
                                        []

                                -- Clear all state/carrier settings when deselecting all carriers
                            }
                    in
                    ( { model | orgSettings = Just newSettings }
                    , saveSettings newSettings
                    )

                Nothing ->
                    ( model, Cmd.none )

        ApplyGISelection mode ->
            case model.orgSettings of
                Just settings ->
                    let
                        newSettings =
                            case mode of
                                GIAll ->
                                    { settings
                                        | stateCarrierSettings =
                                            List.concatMap
                                                (\state ->
                                                    List.map
                                                        (\carrier ->
                                                            { state = state
                                                            , carrier = carrier
                                                            , active = True
                                                            , targetGI = True
                                                            }
                                                        )
                                                        settings.carrierContracts
                                                )
                                                settings.stateLicenses
                                    }

                                GINone ->
                                    { settings
                                        | stateCarrierSettings =
                                            List.concatMap
                                                (\state ->
                                                    List.map
                                                        (\carrier ->
                                                            { state = state
                                                            , carrier = carrier
                                                            , active = True
                                                            , targetGI = False
                                                            }
                                                        )
                                                        settings.carrierContracts
                                                )
                                                settings.stateLicenses
                                    }

                                GIRecommended ->
                                    { settings
                                        | stateCarrierSettings =
                                            List.concatMap
                                                (\state ->
                                                    List.map
                                                        (\carrier ->
                                                            { state = state
                                                            , carrier = carrier
                                                            , active = True
                                                            , targetGI =
                                                                List.any
                                                                    (\rec ->
                                                                        rec.state == state && rec.carrier == carrier
                                                                    )
                                                                    model.recommendedGICombos
                                                            }
                                                        )
                                                        settings.carrierContracts
                                                )
                                                settings.stateLicenses
                                    }
                    in
                    ( { model | orgSettings = Just newSettings }
                    , saveSettings newSettings
                    )

                Nothing ->
                    ( model, Cmd.none )

        GotRecommendedGICombos result ->
            case result of
                Ok combos ->
                    let
                        _ =
                            Debug.log "Received GI recommendations" combos
                    in
                    ( { model | recommendedGICombos = combos }
                    , Cmd.none
                    )

                Err error ->
                    let
                        _ =
                            Debug.log "Error getting GI recommendations" error
                    in
                    ( { model | status = Error "Failed to load GI recommendations" }
                    , Cmd.none
                    )

        ToggleAllowAgentSettings value ->
            updateSettings model (\s -> { s | allowAgentSettings = value })

        FinishSetup ->
            case model.currentUser of
                Just user ->
                    ( model
                    , Nav.pushUrl model.key
                        ("/setup/brand-settings?plan=" ++ user.id ++ "&org=complete")
                    )

                Nothing ->
                    ( model
                    , Nav.pushUrl model.key "/setup/brand-settings"
                    )

        SelectCommonStates region ->
            updateSettings model
                (\s ->
                    { s | stateLicenses = s.stateLicenses ++ getRegionStates region }
                )


updateSettings : Model -> (Settings -> Settings) -> ( Model, Cmd Msg )
updateSettings model updateFn =
    case model.orgSettings of
        Just settings ->
            let
                newSettings =
                    updateFn settings
            in
            ( { model | orgSettings = Just newSettings }
            , saveSettings newSettings
            )

        Nothing ->
            ( model, Cmd.none )


saveSettings : Settings -> Cmd Msg
saveSettings settings =
    Http.request
        { method = "PUT"
        , headers = []
        , url = "/api/settings/org"
        , body = jsonBody (encodeSettings (settings |> Debug.log "settings"))
        , expect = expectJson SettingsSaved settingsObjectDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


encodeSettings : Settings -> Encode.Value
encodeSettings settings =
    Encode.object
        [ ( "stateLicenses", Encode.list Encode.string settings.stateLicenses )
        , ( "carrierContracts", Encode.list Encode.string settings.carrierContracts )
        , ( "stateCarrierSettings", Encode.list stateCarrierSettingEncoder settings.stateCarrierSettings )
        , ( "allowAgentSettings", Encode.bool settings.allowAgentSettings )
        , ( "emailSendBirthday", Encode.bool settings.emailSendBirthday )
        , ( "emailSendPolicyAnniversary", Encode.bool settings.emailSendPolicyAnniversary )
        , ( "emailSendAep", Encode.bool settings.emailSendAep )
        , ( "smartSendEnabled", Encode.bool settings.smartSendEnabled )
        ]


stateCarrierSettingEncoder : StateCarrierSetting -> Encode.Value
stateCarrierSettingEncoder setting =
    Encode.object
        [ ( "state", Encode.string setting.state )
        , ( "carrier", Encode.string setting.carrier )
        , ( "active", Encode.bool setting.active )
        , ( "targetGI", Encode.bool setting.targetGI )
        ]


view : Model -> Browser.Document Msg
view model =
    { title =
        if model.isSetup then
            "Organization Setup - Settings"

        else
            "Settings"
    , body =
        [ if model.isSetup then
            SetupLayout.view SetupLayout.OrganizationSetup
                [ if model.isLoading then
                    viewLoading

                  else
                    viewSettings model
                ]

          else
            div [ class "min-h-screen bg-gray-50" ]
                [ viewHeader
                , div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
                    [ if model.isLoading then
                        viewLoading

                      else
                        viewSettings model
                    ]
                ]
        ]
    }


viewSetupHeader : Html Msg
viewSetupHeader =
    div [ class "mb-8" ]
        [ h1 [ class "text-3xl font-bold text-gray-900" ]
            [ text "Set Up Your Organization" ]
        , p [ class "mt-2 text-gray-600" ]
            [ text "Configure your organization's settings to get started" ]
        ]


viewNormalHeader : Html Msg
viewNormalHeader =
    h1 [ class "text-2xl font-semibold text-gray-900 mb-6" ]
        [ text "Organization Settings" ]


viewBottomBar : Model -> Html Msg
viewBottomBar model =
    div
        [ class """sticky bottom-0 left-0 right-0 bg-white border-t border-gray-200 
                  px-4 py-4 sm:px-6 lg:px-8 flex justify-between items-center
                  mt-8"""
        ]
        [ button
            [ class """px-4 py-2 text-sm font-medium text-gray-700 bg-white 
                      border border-gray-300 rounded-md hover:bg-gray-50"""
            , onClick SaveSettings
            ]
            [ text "Save Changes" ]
        , if model.isSetup then
            button
                [ class """px-4 py-2 text-sm font-medium text-white bg-blue-600 
                          rounded-md hover:bg-blue-700 ml-4"""
                , onClick FinishSetup
                ]
                [ text "Next: Add Agents" ]

          else
            text ""
        ]


viewSettingsContent : Maybe Settings -> Bool -> List String -> Html Msg
viewSettingsContent maybeSettings canEdit expandedSections =
    case maybeSettings of
        Just settings ->
            div [ class "space-y-6" ]
                [ div [ class "bg-white shadow rounded-lg p-6" ]
                    [ h2 [ class "text-lg font-medium mb-4" ] [ text "Organization Settings" ]
                    , div [ class "space-y-4" ]
                        [ checkbox "Allow agents to customize their own settings"
                            settings.allowAgentSettings
                            ToggleAllowAgentSettings
                        ]
                    ]
                , viewEmailSettings settings
                , viewExpandableSection "State Licenses"
                    (viewLicensesGrid settings)
                    expandedSections
                , viewExpandableSection "Carrier Contracts"
                    (viewCarriersGrid settings)
                    expandedSections
                , viewExpandableSection "State & Carrier Settings"
                    (viewStateCarrierGrid settings)
                    expandedSections
                ]

        Nothing ->
            div [ class "text-gray-500 italic" ]
                [ text "Using organization settings" ]


viewEmailSettings : Settings -> Html Msg
viewEmailSettings settings =
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ h2 [ class "text-lg font-medium mb-4" ] [ text "Email Settings" ]
        , div [ class "space-y-4" ]
            [ checkbox "Send birthday emails" settings.emailSendBirthday ToggleEmailBirthday
            , checkbox "Send policy anniversary emails" settings.emailSendPolicyAnniversary ToggleEmailAnniversary
            , checkbox "Send AEP emails" settings.emailSendAep ToggleEmailAep
            , checkbox "Enable smart send" settings.smartSendEnabled ToggleSmartSend
            ]
        ]


checkbox : String -> Bool -> (Bool -> msg) -> Html msg
checkbox labelText isChecked onToggle =
    Html.label [ class "flex items-center space-x-3" ]
        [ input
            [ type_ "checkbox"
            , checked isChecked
            , onCheck onToggle
            , class "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
            ]
            []
        , span [ class "text-gray-700" ] [ text labelText ]
        ]


viewExpandableSection : String -> Html Msg -> List String -> Html Msg
viewExpandableSection title content expandedSections =
    let
        isExpanded =
            List.member title expandedSections
    in
    div [ class "bg-white shadow rounded-lg overflow-hidden" ]
        [ button
            [ class "w-full px-6 py-4 text-left flex justify-between items-center hover:bg-gray-50"
            , onClick (ToggleSection title)
            ]
            [ h2 [ class "text-lg font-medium" ] [ text title ]
            , div
                [ class "transform transition-transform"
                , classList [ ( "rotate-180", isExpanded ) ]
                ]
                [ text "â–¼" ]
            ]
        , div
            [ class "px-6 pb-6"
            , classList [ ( "hidden", not isExpanded ) ]
            ]
            [ content ]
        ]


viewLicensesGrid : Settings -> Html Msg
viewLicensesGrid settings =
    div []
        [ div [ class "mb-4 space-y-2" ]
            [ div [ class "flex gap-4" ]
                -- Container for both label groups
                [ div []
                    -- Batch Select group
                    [ div [ class "text-sm font-medium text-gray-700 mb-2" ]
                        [ text "Batch Select" ]
                    , div [ class "flex gap-2" ]
                        [ button
                            [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50 min-w-[70px]"
                            , onClick (ToggleAllStates True)
                            ]
                            [ text "Select All" ]
                        , button
                            [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50 min-w-[70px]"
                            , onClick (ToggleAllStates False)
                            ]
                            [ text "Clear All" ]
                        ]
                    ]
                , div []
                    -- By Region: group
                    [ div [ class "text-sm font-medium text-gray-700 mb-2" ]
                        [ text "By Region:" ]
                    , div [ class "flex gap-2" ]
                        (List.map
                            (\region ->
                                button
                                    [ class "px-3 py-1 text-sm border rounded-md hover:bg-gray-50"
                                    , onClick (SelectCommonStates region)
                                    ]
                                    [ text (regionToString region) ]
                            )
                            StateRegions.allRegions
                        )
                    ]
                ]
            ]
        , div [ class "grid grid-cols-5 gap-4" ]
            (List.map
                (\state ->
                    checkbox state
                        (List.member state settings.stateLicenses)
                        (\checked ->
                            if checked then
                                AddStateLicense state

                            else
                                RemoveStateLicense state
                        )
                )
                allStates
            )
        ]


viewCarriersGrid : Settings -> Html Msg
viewCarriersGrid settings =
    div []
        [ div [ class "mb-4 flex items-center" ]
            [ checkbox "Select All Carriers"
                (List.length settings.carrierContracts == List.length allCarriers)
                ToggleAllCarriers
            ]
        , div [ class "grid grid-cols-3 gap-4" ]
            (List.map
                (\carrier ->
                    checkbox carrier
                        (List.member carrier settings.carrierContracts)
                        (\checked ->
                            if checked then
                                AddCarrierContract carrier

                            else
                                RemoveCarrierContract carrier
                        )
                )
                allCarriers
            )
        ]


viewStateCarrierGrid : Settings -> Html Msg
viewStateCarrierGrid settings =
    if List.isEmpty settings.stateLicenses || List.isEmpty settings.carrierContracts then
        div [ class "text-gray-500 italic p-4" ]
            [ text "Please select at least one state license and one carrier contract to configure their settings." ]

    else
        div []
            [ div [ class "mb-6" ]
                [ h3 [ class "text-sm font-medium text-gray-700 mb-2" ]
                    [ text "Guaranteed Issue Settings" ]
                , div [ class "flex space-x-2" ]
                    [ button
                        [ class "px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
                        , onClick (ApplyGISelection GIAll)
                        ]
                        [ text "Select All" ]
                    , button
                        [ class "px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
                        , onClick (ApplyGISelection GINone)
                        ]
                        [ text "Clear All" ]
                    , div [ class "relative group" ]
                        [ button
                            [ class "px-4 py-2 text-sm font-medium text-indigo-700 bg-white border border-indigo-300 rounded-md hover:bg-indigo-50 flex items-center"
                            , onClick (ApplyGISelection GIRecommended)
                            ]
                            [ text "Apply Recommended"
                            , div [ class "ml-2 w-5 h-5 rounded-full bg-indigo-50 flex items-center justify-center text-indigo-700" ]
                                [ text "i" ]
                            ]
                        , div
                            [ class """absolute bottom-full mb-2 p-4 bg-white text-indigo-700 text-sm rounded-lg shadow-lg 
                                      invisible group-hover:visible opacity-0 group-hover:opacity-100 transition-opacity
                                      -translate-x-1/2 left-1/2 w-96 border border-indigo-100 z-50"""
                            ]
                            [ text """Include state/carriers with full compensation for GI policies. Always verify with your own contracts and commission schedules.""" ]
                        ]
                    ]
                ]
            , div [ class "overflow-x-auto" ]
                [ table [ class "min-w-full divide-y divide-gray-200" ]
                    [ thead [ class "bg-gray-50" ]
                        [ tr []
                            (th [ class "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider sticky left-0 bg-gray-50 z-10 w-16" ]
                                [ text "State" ]
                                :: List.map
                                    (\carrier ->
                                        th [ class "px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-24" ]
                                            [ text carrier ]
                                    )
                                    settings.carrierContracts
                            )
                        ]
                    , tbody [ class "bg-white divide-y divide-gray-200" ]
                        (List.indexedMap
                            (\index state ->
                                tr [ classList [ ( "bg-gray-50", modBy 2 index == 0 ) ] ]
                                    (td [ class "px-3 py-4 whitespace-nowrap text-sm font-medium text-gray-900 sticky left-0 bg-inherit z-10" ]
                                        [ text state ]
                                        :: List.map
                                            (\carrier ->
                                                let
                                                    setting =
                                                        findStateCarrierSetting settings state carrier
                                                in
                                                td [ class "px-3 py-2 whitespace-nowrap text-sm text-center" ]
                                                    [ div [ class "flex flex-col items-start space-y-1 w-20 mx-auto" ]
                                                        [ div [ class "w-full" ]
                                                            [ label [ class "flex items-center cursor-pointer w-full" ]
                                                                [ div [ class "relative w-4 h-4 mr-1 shrink-0" ]
                                                                    [ input
                                                                        [ type_ "checkbox"
                                                                        , checked setting.active
                                                                        , onCheck
                                                                            (\active ->
                                                                                UpdateStateCarrierSetting state
                                                                                    carrier
                                                                                    active
                                                                                    (if active then
                                                                                        setting.targetGI

                                                                                     else
                                                                                        False
                                                                                    )
                                                                            )
                                                                        , class "absolute w-0 h-0 opacity-0"
                                                                        ]
                                                                        []
                                                                    , div
                                                                        [ class "w-4 h-4 border rounded transition-colors duration-200 flex items-center justify-center"
                                                                        , classList
                                                                            [ ( "bg-green-600 border-green-600", setting.active )
                                                                            , ( "border-gray-300", not setting.active )
                                                                            ]
                                                                        ]
                                                                        [ if setting.active then
                                                                            div [ class "text-white text-xs" ] [ text "âœ“" ]

                                                                          else
                                                                            text ""
                                                                        ]
                                                                    ]
                                                                , span [ class "text-xs ml-1" ] [ text "Active" ]
                                                                ]
                                                            ]
                                                        , div [ class "w-full" ]
                                                            [ label
                                                                [ class "flex items-center w-full"
                                                                , classList
                                                                    [ ( "cursor-pointer", setting.active )
                                                                    , ( "cursor-not-allowed opacity-50", not setting.active )
                                                                    ]
                                                                ]
                                                                [ div [ class "relative w-4 h-4 mr-1 shrink-0" ]
                                                                    [ input
                                                                        [ type_ "checkbox"
                                                                        , checked setting.targetGI
                                                                        , onCheck (\targetGI -> UpdateStateCarrierSetting state carrier setting.active targetGI)
                                                                        , class "absolute w-0 h-0 opacity-0"
                                                                        , disabled (not setting.active)
                                                                        ]
                                                                        []
                                                                    , div
                                                                        [ class "w-4 h-4 border rounded transition-colors duration-200 flex items-center justify-center"
                                                                        , classList
                                                                            [ ( "bg-blue-600 border-blue-600", setting.targetGI && setting.active )
                                                                            , ( "border-gray-300", not setting.targetGI || not setting.active )
                                                                            ]
                                                                        ]
                                                                        [ if setting.targetGI && setting.active then
                                                                            div [ class "text-white text-xs" ] [ text "âœ“" ]

                                                                          else
                                                                            text ""
                                                                        ]
                                                                    ]
                                                                , span [ class "text-xs ml-1" ] [ text "GI" ]
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                            )
                                            settings.carrierContracts
                                    )
                            )
                            settings.stateLicenses
                        )
                    ]
                ]
            ]



-- Helper functions for state/carrier grid


isStateCarrierActive : Settings -> String -> String -> Bool
isStateCarrierActive settings state carrier =
    settings.stateCarrierSettings
        |> List.filter (\s -> s.state == state && s.carrier == carrier)
        |> List.head
        |> Maybe.map .active
        |> Maybe.withDefault True


isStateCarrierTargetGI : Settings -> String -> String -> Bool
isStateCarrierTargetGI settings state carrier =
    settings.stateCarrierSettings
        |> List.filter (\s -> s.state == state && s.carrier == carrier)
        |> List.head
        |> Maybe.map .targetGI
        |> Maybe.withDefault False


hasDefaultSettings : Settings -> Bool
hasDefaultSettings settings =
    List.all
        (\setting -> setting.active && not setting.targetGI)
        settings.stateCarrierSettings


findStateCarrierSetting : Settings -> String -> String -> StateCarrierSetting
findStateCarrierSetting settings state carrier =
    settings.stateCarrierSettings
        |> List.filter (\s -> s.state == state && s.carrier == carrier)
        |> List.head
        |> Maybe.withDefault
            { state = state
            , carrier = carrier
            , active = True
            , targetGI = False
            }


viewStateCarrierCell : StateCarrierSetting -> Html Msg
viewStateCarrierCell setting =
    div [ class "flex flex-col items-center gap-1" ]
        [ label [ class "flex items-center gap-2 cursor-pointer" ]
            [ input
                [ type_ "checkbox"
                , checked setting.active
                , onCheck (\active -> UpdateStateCarrierSetting setting.state setting.carrier active setting.targetGI)
                , class "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
                ]
                []
            , span [ class "text-sm text-gray-600" ] [ text "Active" ]
            ]
        , label [ class "flex items-center gap-2 cursor-pointer" ]
            [ input
                [ type_ "checkbox"
                , checked setting.targetGI
                , onCheck (\targetGI -> UpdateStateCarrierSetting setting.state setting.carrier setting.active targetGI)
                , class "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
                ]
                []
            , span [ class "text-sm text-gray-600" ] [ text "GI" ]
            ]
        ]



-- Encoders and Decoders


settingsDecoder : Decoder SettingsResponse
settingsDecoder =
    let
        _ =
            Debug.log "Running settingsDecoder" ()
    in
    Decode.map2 SettingsResponse
        (Decode.field "orgSettings" settingsObjectDecoder)
        (Decode.field "canEditOrgSettings" Decode.bool)


settingsObjectDecoder : Decoder Settings
settingsObjectDecoder =
    let
        _ =
            Debug.log "Running settingsObjectDecoder" ()

        stateCarrierSettingsDecoder =
            Decode.field "stateCarrierSettings" <|
                Decode.oneOf
                    [ Decode.list stateCarrierSettingDecoder
                    , Decode.null []
                    ]
    in
    Decode.map8 Settings
        (Decode.field "stateLicenses" (Decode.list Decode.string))
        (Decode.field "carrierContracts" (Decode.list Decode.string))
        stateCarrierSettingsDecoder
        (Decode.field "allowAgentSettings" Decode.bool)
        (Decode.field "emailSendBirthday" Decode.bool)
        (Decode.field "emailSendPolicyAnniversary" Decode.bool)
        (Decode.field "emailSendAep" Decode.bool)
        (Decode.field "smartSendEnabled" Decode.bool)


stateCarrierSettingDecoder : Decoder StateCarrierSetting
stateCarrierSettingDecoder =
    Decode.map4 StateCarrierSetting
        (Decode.field "state" Decode.string)
        (Decode.field "carrier" Decode.string)
        (Decode.field "active" Decode.bool)
        (Decode.field "targetGI" Decode.bool)


recommendationsDecoder : Decoder (List StateCarrierSetting)
recommendationsDecoder =
    let
        _ =
            Debug.log "Running recommendationsDecoder" ()
    in
    Decode.list
        (Decode.map4 StateCarrierSetting
            (Decode.field "state" Decode.string)
            (Decode.field "carrier" Decode.string)
            (Decode.field "active" Decode.bool)
            (Decode.field "targetGI" Decode.bool)
        )


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none


tab : String -> Bool -> Bool -> msg -> Html msg
tab label isActive isDisabled msg =
    button
        [ class "px-3 py-2 font-medium text-sm rounded-md -mb-px"
        , classList
            [ ( "text-indigo-600 border-indigo-500 border-b-2", isActive )
            , ( "text-gray-500 hover:text-gray-700 hover:border-gray-300 border-transparent border-b-2"
              , not isActive && not isDisabled
              )
            , ( "text-gray-400 cursor-not-allowed", isDisabled )
            ]
        , onClick msg
        , disabled isDisabled
        ]
        [ text label ]


viewNavLink : String -> String -> Html Msg
viewNavLink label path =
    a
        [ class "text-gray-700 hover:text-gray-900 hover:bg-gray-50 group flex items-center px-3 py-2 text-sm font-medium rounded-md"
        , href path
        ]
        [ text label ]


viewNavigation : Model -> Html Msg
viewNavigation model =
    nav []
        [ case model.currentUser of
            Just user ->
                if user.isAdmin then
                    viewNavLink "Manage Agents" "/agents"

                else
                    text ""

            Nothing ->
                text ""
        ]


viewLoading : Html msg
viewLoading =
    div [ class "flex justify-center items-center h-64" ]
        [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent" ] []
        ]


viewHeader : Html msg
viewHeader =
    nav [ class "bg-white border-b border-gray-200" ]
        [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
            [ div [ class "flex justify-between h-16" ]
                [ div [ class "flex" ]
                    [ div [ class "flex-shrink-0 flex items-center" ]
                        [ h1 [ class "text-xl font-semibold text-purple-600" ]
                            [ text "Organization Settings" ]
                        ]
                    ]
                ]
            ]
        ]


viewSettings : Model -> Html Msg
viewSettings model =
    div [ class "space-y-8" ]
        [ viewSettingsContent model.orgSettings True model.expandedSections
        , viewBottomBar model
        ]

================
File: frontend/src/Signup.elm
================
module Signup exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Components.ProgressIndicator as ProgressIndicator exposing (Step)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onBlur, onInput, onSubmit)
import Http
import Json.Decode as Decode
import Json.Encode as Encode
import Svg exposing (path, svg)
import Svg.Attributes exposing (d, fill, stroke, strokeLinecap, strokeLinejoin, strokeWidth, viewBox)
import Url



-- MODEL


type alias Model =
    { organizationName : String
    , adminFirstName : String
    , adminLastName : String
    , adminEmail : String
    , error : Maybe String
    , isSubmitting : Bool
    , submitted : Bool
    , orgNameStatus : OrgNameStatus
    , emailStatus : EmailStatus
    , currentStep : SignupStep
    }


type OrgNameStatus
    = NotChecked
    | Checking
    | Valid
    | Invalid String


type EmailStatus
    = EmailNotChecked
    | EmailChecking
    | EmailValid
    | EmailInvalid String


type Msg
    = UpdateOrganizationName String
    | CheckOrganizationName
    | GotOrgNameResponse (Result Http.Error OrgNameResponse)
    | UpdateAdminFirstName String
    | UpdateAdminLastName String
    | UpdateAdminEmail String
    | CheckAdminEmail
    | GotEmailResponse (Result Http.Error EmailResponse)
    | SubmitForm
    | GotSignupResponse (Result Http.Error SignupResponse)


type alias SignupResponse =
    { success : Bool
    , message : String
    }


type alias OrgNameResponse =
    { available : Bool
    , message : String
    }


type alias EmailResponse =
    { available : Bool
    , message : String
    }


type SignupStep
    = AccountSetup
    | CompanyDetails
    | CompanyStyle
    | SetupPayment


init : ( Model, Cmd Msg )
init =
    ( { organizationName = ""
      , adminFirstName = ""
      , adminLastName = ""
      , adminEmail = ""
      , error = Nothing
      , isSubmitting = False
      , submitted = False
      , orgNameStatus = NotChecked
      , emailStatus = EmailNotChecked
      , currentStep = AccountSetup
      }
    , Cmd.none
    )



-- UPDATE


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateOrganizationName value ->
            ( { model
                | organizationName = value
                , orgNameStatus = NotChecked -- Clear status when typing
              }
            , Cmd.none
            )

        CheckOrganizationName ->
            if String.length model.organizationName >= 1 then
                ( { model | orgNameStatus = Checking }
                  -- Show loading state
                , checkOrgName model.organizationName
                )

            else
                ( { model | orgNameStatus = NotChecked }
                , Cmd.none
                )

        GotOrgNameResponse (Ok response) ->
            ( { model
                | orgNameStatus =
                    if response.available then
                        Valid

                    else
                        Invalid response.message
              }
            , Cmd.none
            )

        GotOrgNameResponse (Err _) ->
            ( { model
                | orgNameStatus = Invalid "Failed to check organization name"
              }
            , Cmd.none
            )

        UpdateAdminFirstName value ->
            ( { model | adminFirstName = value }, Cmd.none )

        UpdateAdminLastName value ->
            ( { model | adminLastName = value }, Cmd.none )

        UpdateAdminEmail value ->
            ( { model
                | adminEmail = value
                , emailStatus = EmailNotChecked
              }
            , Cmd.none
            )

        CheckAdminEmail ->
            if String.isEmpty (String.trim model.adminEmail) then
                ( { model | emailStatus = EmailNotChecked }
                , Cmd.none
                )

            else if model.emailStatus == EmailChecking then
                ( model, Cmd.none )

            else
                ( { model | emailStatus = EmailChecking }
                , checkEmail model.adminEmail
                )

        GotEmailResponse result ->
            case result of
                Ok response ->
                    ( { model
                        | emailStatus =
                            if response.available then
                                EmailValid

                            else
                                EmailInvalid response.message
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model
                        | emailStatus = EmailInvalid "Failed to check email availability"
                      }
                    , Cmd.none
                    )

        SubmitForm ->
            if isFormValid model then
                ( { model | isSubmitting = True }
                , submitForm model
                )

            else
                ( { model | error = Just "Please fill out all fields and ensure email and organization name are valid" }
                , Cmd.none
                )

        GotSignupResponse (Ok response) ->
            if response.success then
                ( { model
                    | isSubmitting = False
                    , submitted = True
                    , error = Nothing
                  }
                , Cmd.none
                )

            else
                ( { model
                    | error = Just response.message
                    , isSubmitting = False
                  }
                , Cmd.none
                )

        GotSignupResponse (Err _) ->
            ( { model
                | error = Just "Failed to create organization. Please try again."
                , isSubmitting = False
              }
            , Cmd.none
            )


validateForm : Model -> Bool
validateForm model =
    not (String.isEmpty model.organizationName)
        && not (String.isEmpty model.adminFirstName)
        && not (String.isEmpty model.adminLastName)
        && not (String.isEmpty model.adminEmail)


submitForm : Model -> Cmd Msg
submitForm model =
    Http.post
        { url = "/api/organizations/signup"
        , body =
            Http.jsonBody
                (Encode.object
                    [ ( "organizationName", Encode.string model.organizationName )
                    , ( "adminFirstName", Encode.string model.adminFirstName )
                    , ( "adminLastName", Encode.string model.adminLastName )
                    , ( "adminEmail", Encode.string model.adminEmail )
                    ]
                )
        , expect =
            Http.expectJson GotSignupResponse
                (Decode.map2 SignupResponse
                    (Decode.field "success" Decode.bool)
                    (Decode.field "message" Decode.string)
                )
        }



-- Add this function to check organization name


checkOrgName : String -> Cmd Msg
checkOrgName name =
    if String.isEmpty (String.trim name) then
        Cmd.none

    else
        Http.get
            { url = "/api/organizations/check-name/" ++ Url.percentEncode (String.trim name)
            , expect =
                Http.expectJson GotOrgNameResponse
                    (Decode.map2 OrgNameResponse
                        (Decode.field "available" Decode.bool)
                        (Decode.field "message" Decode.string)
                    )
            }



-- Add this function to check email


checkEmail : String -> Cmd Msg
checkEmail email =
    Http.get
        { url = "/api/organizations/check-email/" ++ Url.percentEncode email
        , expect = Http.expectJson GotEmailResponse emailResponseDecoder
        }


emailResponseDecoder : Decode.Decoder EmailResponse
emailResponseDecoder =
    Decode.map2 EmailResponse
        (Decode.field "available" Decode.bool)
        (Decode.field "message" Decode.string)



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Create Organization"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex" ]
            [ viewProgress model
            , div [ class "flex-1 ml-80" ]
                [ div [ class "max-w-2xl mx-auto py-12 px-8" ]
                    [ if model.submitted then
                        viewSuccess

                      else
                        viewForm model
                    ]
                ]
            ]
        ]
    }


viewSuccess : Html Msg
viewSuccess =
    div [ class "text-center" ]
        [ div [ class "mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-green-100" ]
            [ -- Checkmark icon
              svg
                [ Svg.Attributes.class "h-6 w-6 text-green-600"
                , fill "none"
                , viewBox "0 0 24 24"
                , stroke "currentColor"
                ]
                [ path
                    [ strokeLinecap "round"
                    , strokeLinejoin "round"
                    , strokeWidth "2"
                    , d "M5 13l4 4L19 7"
                    ]
                    []
                ]
            ]
        , h3 [ class "mt-3 text-lg font-medium text-gray-900" ]
            [ text "Check your email" ]
        , p [ class "mt-2 text-sm text-gray-500" ]
            [ text "We've sent you a magic link to verify your account and complete the setup." ]
        ]


viewForm : Model -> Html Msg
viewForm model =
    Html.form [ onSubmit SubmitForm, class "space-y-6 max-w-md" ]
        [ h1 [ class "text-2xl font-semibold text-[#101828] mb-2" ]
            [ text "Agent Details" ]
        , p [ class "text-[#667085] text-base mb-8" ]
            [ text "Let's get to know you" ]
        , -- Form fields
          div [ class "space-y-6" ]
            [ -- Email field first
              div []
                [ label [ for "admin-email", class "block text-sm font-medium text-[#344054] mb-1.5" ]
                    [ text "Email" ]
                , div [ class "mt-1" ]
                    [ input
                        [ type_ "email"
                        , id "admin-email"
                        , value model.adminEmail
                        , onInput UpdateAdminEmail
                        , onBlur CheckAdminEmail
                        , class "block w-full px-3.5 py-2.5 bg-white border border-[#d0d5dd] rounded-lg shadow-sm text-[#101828] focus:outline-none focus:ring-2 focus:ring-[#03045e] focus:border-[#03045e] sm:text-sm"
                        , placeholder "Enter your email"
                        ]
                        []
                    , viewEmailStatus model.emailStatus
                    ]
                ]

            -- Organization name field second
            , div []
                [ label [ for "organization-name", class "block text-sm font-medium text-[#344054] mb-1.5" ]
                    [ text "Organization name" ]
                , div [ class "mt-1" ]
                    [ input
                        [ type_ "text"
                        , id "organization-name"
                        , value model.organizationName
                        , onInput UpdateOrganizationName
                        , onBlur CheckOrganizationName
                        , class "block w-full px-3.5 py-2.5 bg-white border border-[#d0d5dd] rounded-lg shadow-sm text-[#101828] focus:outline-none focus:ring-2 focus:ring-[#03045e] focus:border-[#03045e] sm:text-sm"
                        , placeholder "Enter organization name"
                        ]
                        []
                    , viewOrgNameStatus model.orgNameStatus
                    ]
                ]

            -- First Name field third
            , div []
                [ label [ for "admin-first-name", class "block text-sm font-medium text-[#344054] mb-1.5" ]
                    [ text "First Name" ]
                , div [ class "mt-1" ]
                    [ input
                        [ type_ "text"
                        , id "admin-first-name"
                        , value model.adminFirstName
                        , onInput UpdateAdminFirstName
                        , class "block w-full px-3.5 py-2.5 bg-white border border-[#d0d5dd] rounded-lg shadow-sm text-[#101828] focus:outline-none focus:ring-2 focus:ring-[#03045e] focus:border-[#03045e] sm:text-sm"
                        , placeholder "Enter your first name"
                        ]
                        []
                    ]
                ]

            -- Last Name field fourth
            , div []
                [ label [ for "admin-last-name", class "block text-sm font-medium text-[#344054] mb-1.5" ]
                    [ text "Last Name" ]
                , div [ class "mt-1" ]
                    [ input
                        [ type_ "text"
                        , id "admin-last-name"
                        , value model.adminLastName
                        , onInput UpdateAdminLastName
                        , class "block w-full px-3.5 py-2.5 bg-white border border-[#d0d5dd] rounded-lg shadow-sm text-[#101828] focus:outline-none focus:ring-2 focus:ring-[#03045e] focus:border-[#03045e] sm:text-sm"
                        , placeholder "Enter your last name"
                        ]
                        []
                    ]
                ]
            ]
        , -- Submit button
          button
            [ type_ "submit"
            , class (submitButtonClass model)
            , disabled (not (isFormValid model) || model.isSubmitting)
            ]
            [ if model.isSubmitting then
                text "Creating Organization..."

              else
                text "Continue"
            ]
        ]


viewOrgNameStatus : OrgNameStatus -> Html Msg
viewOrgNameStatus status =
    div [ class "mt-1 transition-all duration-200" ]
        [ case status of
            NotChecked ->
                text ""

            Checking ->
                div [ class "text-blue-600 text-sm flex items-center" ]
                    [ -- Loading spinner
                      div [ class "animate-spin h-4 w-4 mr-2 border-2 border-blue-600 border-t-transparent rounded-full" ] []
                    , text "Checking availability..."
                    ]

            Valid ->
                div [ class "text-green-600 text-sm flex items-center" ]
                    [ -- Checkmark icon
                      svg
                        [ Svg.Attributes.class "h-4 w-4 mr-1"
                        , fill "none"
                        , viewBox "0 0 24 24"
                        , stroke "currentColor"
                        ]
                        [ path
                            [ strokeLinecap "round"
                            , strokeLinejoin "round"
                            , strokeWidth "2"
                            , d "M5 13l4 4L19 7"
                            ]
                            []
                        ]
                    , text "Organization name is available"
                    ]

            Invalid message ->
                div [ class "text-red-600 text-sm flex items-center" ]
                    [ -- X icon
                      svg
                        [ Svg.Attributes.class "h-4 w-4 mr-1"
                        , fill "none"
                        , viewBox "0 0 24 24"
                        , stroke "currentColor"
                        ]
                        [ path
                            [ strokeLinecap "round"
                            , strokeLinejoin "round"
                            , strokeWidth "2"
                            , d "M6 18L18 6M6 6l12 12"
                            ]
                            []
                        ]
                    , text message
                    ]
        ]


viewEmailStatus : EmailStatus -> Html Msg
viewEmailStatus status =
    div [ class "mt-1 transition-all duration-200" ]
        [ case status of
            EmailNotChecked ->
                text ""

            EmailChecking ->
                div [ class "text-blue-600 text-sm flex items-center" ]
                    [ div [ class "animate-spin h-4 w-4 mr-2 border-2 border-blue-600 border-t-transparent rounded-full" ] []
                    , text "Checking availability..."
                    ]

            EmailValid ->
                div [ class "text-green-600 text-sm flex items-center" ]
                    [ -- Checkmark icon
                      svg
                        [ Svg.Attributes.class "h-4 w-4 mr-1"
                        , fill "none"
                        , viewBox "0 0 24 24"
                        , stroke "currentColor"
                        ]
                        [ path
                            [ strokeLinecap "round"
                            , strokeLinejoin "round"
                            , strokeWidth "2"
                            , d "M5 13l4 4L19 7"
                            ]
                            []
                        ]
                    , text "Email is available"
                    ]

            EmailInvalid message ->
                div [ class "text-red-600 text-sm flex items-center" ]
                    [ -- X icon
                      svg
                        [ Svg.Attributes.class "h-4 w-4 mr-1"
                        , fill "none"
                        , viewBox "0 0 24 24"
                        , stroke "currentColor"
                        ]
                        [ path
                            [ strokeLinecap "round"
                            , strokeLinejoin "round"
                            , strokeWidth "2"
                            , d "M6 18L18 6M6 6l12 12"
                            ]
                            []
                        ]
                    , text message
                    ]
        ]


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none



-- Add this helper function


isFormValid : Model -> Bool
isFormValid model =
    let
        isEmailValid =
            not (String.isEmpty (String.trim model.adminEmail))
                && String.contains "@" model.adminEmail
                && String.contains "." model.adminEmail
                && model.emailStatus
                == EmailValid

        isOrgValid =
            not (String.isEmpty (String.trim model.organizationName))
                && model.orgNameStatus
                == Valid

        areNamesValid =
            not (String.isEmpty (String.trim model.adminFirstName))
                && not (String.isEmpty (String.trim model.adminLastName))
    in
    isEmailValid && isOrgValid && areNamesValid



-- Add helper function for submit button classes


submitButtonClass : Model -> String
submitButtonClass model =
    "w-full flex justify-center py-2.5 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium transition-colors "
        ++ (if isFormValid model then
                "text-white bg-[#03045e] hover:bg-[#03045e]/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#03045e]"

            else
                "text-white bg-[#03045e]/60 cursor-not-allowed"
           )


viewProgress : Model -> Html Msg
viewProgress model =
    let
        currentStep =
            case model.currentStep of
                AccountSetup ->
                    1

                CompanyDetails ->
                    2

                CompanyStyle ->
                    3

                SetupPayment ->
                    4

        makeStep : Int -> String -> String -> String -> Step
        makeStep stepNum icon title description =
            { icon = icon
            , title = title
            , description = description
            , isCompleted = stepNum < currentStep
            , isActive = stepNum == currentStep
            }
    in
    ProgressIndicator.view
        [ makeStep 1 "ðŸ‘¤" "Your Details" "Please provide your name and email"
        , makeStep 2 "ðŸ¢" "Company Details" "General info for your Company"
        , makeStep 3 "âš™ï¸" "Company Style" "Style your platform"
        , makeStep 4 "ðŸ’³" "Setup Payment" "The final step to get started"
        ]

================
File: frontend/src/StateRegions.elm
================
module StateRegions exposing (Region(..), allRegions, getRegionStates, regionToString, stringToRegion)


type Region
    = WestCoast
    | EastCoast
    | South
    | Midwest


allRegions : List Region
allRegions =
    [ WestCoast, EastCoast, South, Midwest ]


regionToString : Region -> String
regionToString region =
    case region of
        WestCoast ->
            "West Coast"

        EastCoast ->
            "East Coast"

        South ->
            "South"

        Midwest ->
            "Midwest"


stringToRegion : String -> Maybe Region
stringToRegion str =
    case str of
        "west" ->
            Just WestCoast

        "east" ->
            Just EastCoast

        "south" ->
            Just South

        "midwest" ->
            Just Midwest

        _ ->
            Nothing


getRegionStates : Region -> List String
getRegionStates region =
    case region of
        WestCoast ->
            [ "CA", "OR", "WA", "AK", "HI" ]

        EastCoast ->
            [ "ME", "NH", "VT", "MA", "RI", "CT", "NY", "NJ", "PA", "DE", "MD", "DC" ]

        South ->
            [ "VA", "NC", "SC", "GA", "FL", "AL", "MS", "LA", "AR", "TN", "KY", "WV", "TX", "OK" ]

        Midwest ->
            [ "OH", "MI", "IN", "IL", "WI", "MN", "IA", "MO", "ND", "SD", "NE", "KS", "MT", "WY", "CO", "ID", "NV", "NM", "AZ", "UT" ]

================
File: frontend/src/TempLanding.elm
================
module TempLanding exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick)


type alias Model =
    {}


type Msg
    = NavigateTo String


init : () -> ( Model, Cmd Msg )
init _ =
    ( {}, Cmd.none )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NavigateTo _ ->
            ( model, Cmd.none )


view : Model -> Browser.Document Msg
view model =
    { title = "Welcome"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex flex-col justify-center" ]
            [ div [ class "text-center space-y-8" ]
                [ h1 [ class "text-4xl font-bold text-gray-900" ]
                    [ text "Welcome! You're logged in!" ]
                , div [ class "flex justify-center space-x-4" ]
                    [ button
                        [ class "inline-flex items-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                        , onClick (NavigateTo "/dashboard")
                        ]
                        [ text "Go to Dashboard" ]
                    , button
                        [ class "inline-flex items-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                        , onClick (NavigateTo "/settings")
                        ]
                        [ text "Go to Settings" ]
                    ]
                ]
            ]
        ]
    }


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: frontend/vite.config.ts
================
import { defineConfig } from 'vite'
import elmPlugin from 'vite-plugin-elm'
import path from 'path'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [
    elmPlugin(),
    tailwindcss(),
  ],
  resolve: {
    extensions: ['.ts', '.js', '.elm']
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
        secure: false,
        configure: (proxy, _options) => {
          proxy.on('error', (err) => {
            console.log('proxy error', err);
          });
          proxy.on('proxyReq', (proxyReq) => {
            console.log('Sending Request:', proxyReq.method, proxyReq.path);
          });
          proxy.on('proxyRes', (proxyRes) => {
            console.log('Received Response:', proxyRes.statusCode);
          });
        }
      }
    }
  },
  build: {
    outDir: '../dist',
    emptyOutDir: true,
    assetsDir: 'assets',
    rollupOptions: {
      input: {
        main: path.resolve(__dirname, 'index.html')
      }
    }
  }
})



================================================================
End of Codebase
================================================================

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-04T21:46:28.415Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
backend/
  src/
    config.ts
    database.ts
    index.ts
    logger.ts
    types.ts
  .gitignore
  medicare-portal.db-info
  README.md
frontend/
  src/
    Main.elm
    main.ts
    style.css
    styles.css
    vite-env.d.ts
  .gitignore
  tailwind.config.js
  vite.config.ts
migrations/
  001_initial.sql
  002_add_email_and_agents.sql
scripts/
  setup_db.py
static/
  css/
    main.css
.gitignore
.python-version
example.env
hello.py

================================================================
Files
================================================================

================
File: backend/src/config.ts
================
import { config as dotenvConfig } from 'dotenv'
import { resolve } from 'path'
import { logger } from './logger'
import { existsSync } from 'fs'

// Get absolute path to .env file
const envPath = resolve(__dirname, '../.env')

// Check if .env file exists
if (!existsSync(envPath)) {
  console.error(`❌ .env file not found at: ${envPath}`)
  process.exit(1)
}

// Load .env file with override option
const result = dotenvConfig({ 
  path: envPath,
  override: true // This tells dotenv to override existing env vars
})

if (result.error) {
  console.error('❌ Error loading .env file:', result.error)
  process.exit(1)
}

// Debug: Print raw env file path and contents
console.log('📁 Loading .env from:', envPath)
console.log('📝 Environment variables loaded:', {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN ? '[PRESENT]' : '[MISSING]',
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH
})

export const config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  // Add other config values here
}

// Log loaded config (safely)
logger.info(`Config loaded from ${envPath}`)

================
File: backend/src/database.ts
================
import { createClient, type Client } from '@libsql/client'
import { config } from './config'
import { logger } from './logger'

export class Database {
  private client: Client

  constructor() {
    if (!config.TURSO_DATABASE_URL || !config.TURSO_AUTH_TOKEN) {
      console.error('Config values:', config)
      throw new Error('Missing database credentials in .env file')
    }

    // Use template literals to ensure values are included in the string
    logger.info(`Initializing database with URL: ${config.TURSO_DATABASE_URL}`)
    logger.info(`Using auth token: ${config.TURSO_AUTH_TOKEN}`)

    try {
      this.client = createClient({
        url: "file:" + config.TURSO_DATABASE_PATH,
        syncUrl: config.TURSO_DATABASE_URL,
        authToken: config.TURSO_AUTH_TOKEN,
        offline: true,
      })
      logger.info('Database client created successfully')
    } catch (error) {
      logger.error(`Failed to create database client: ${error}`)
      throw error
    }
  }

  // Initialize separately since constructor can't be async
  async init() {
    try {
      await this.initTables()
      logger.info('Database tables initialized successfully')
      await this.client.sync();
      logger.info('Database synced successfully')

      // Check contact count
      const countResult = await this.client.execute('SELECT COUNT(*) as count FROM contacts')
      const count = countResult.rows[0].count
      logger.info(`Current number of contacts in database: ${count}`)

      // If count is 0, log a message
      if (count === 0) {
        logger.info('Database is empty - ready for new contacts')
      }

    } catch (error) {
      logger.error(`Failed to initialize database tables: ${error}`)
      throw error
    }
  }

  private async initTables() {
    // Create agents table
    await this.client.execute(`
      CREATE TABLE IF NOT EXISTS agents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        first_name TEXT NOT NULL,
        last_name TEXT NOT NULL,
        email TEXT NOT NULL UNIQUE,
        phone TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `)

    // Create contacts table
    await this.client.execute(`
      CREATE TABLE IF NOT EXISTS contacts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        first_name TEXT NOT NULL,
        last_name TEXT NOT NULL,
        email TEXT NOT NULL,
        current_carrier TEXT,
        plan_type TEXT,
        effective_date DATE,
        birth_date DATE,
        tobacco_user BOOLEAN DEFAULT FALSE,
        gender TEXT,
        state TEXT,
        zip_code TEXT,
        agent_id INTEGER,
        last_emailed DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (agent_id) REFERENCES agents(id)
      )
    `)
  }

  async execute(sql: string, args: any[] = []) {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      await this.client.sync();
      return result.rows
    } catch (error) {
      logger.error(`Database execute error: ${error}`)
      throw error
    }
  }

  async executeMany(statements: (string | { sql: string, args?: any[] })[]) {
    try {
      const results = await this.client.batch(statements, "write");
      await this.client.sync();
      return results.map(result => result.rows);
    } catch (error) {
      logger.error(`Database executeMany error: ${error}`);
      throw error;
    }
  }

  async fetchAll(sql: string, args: any[] = []) {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result.rows || []
    } catch (error) {
      logger.error(`Database fetchAll error: ${error}`)
      throw error
    }
  }

  async fetchOne(sql: string, args: any[] = []) {
    try {
      const result = await this.client.execute({
        sql,
        args
      })
      return result.rows[0] || null
    } catch (error) {
      logger.error(`Database fetchOne error: ${error}`)
      throw error
    }
  }
}

================
File: backend/src/index.ts
================
import { Elysia, t } from 'elysia'
import { cors } from '@elysiajs/cors'
import { Database } from './database'
import { logger } from './logger'
import type { ContactCreate, AgentCreate } from './types'
import { readFileSync } from 'fs'
import { staticPlugin } from '@elysiajs/static'
import { parse as csvParse } from 'csv-parse/sync'
import { Readable } from 'stream'
import { Buffer } from 'buffer'

// Load ZIP code data
let ZIP_DATA = {}
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'))
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}

const startServer = async () => {
  try {
    const db = new Database()
    await db.init()
    logger.info('Database initialized successfully')

    const app = new Elysia()
      .use(cors({
        // In development, allow the Vite dev server origin
        origin: process.env.NODE_ENV === 'development' 
          ? 'http://localhost:5173'
          : false, // Disable CORS in production
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type'],
        credentials: true,
        preflight: true
      }))
      // Add explicit OPTIONS handler for preflight
      .options('/api/contacts/:id', ({ set }) => {
        set.headers = {
          'Access-Control-Allow-Origin': 'http://localhost:5173',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Allow-Credentials': 'true'
        }
        return new Response(null, { status: 204 })
      })
      // Log all requests
      .onRequest(({ request: { method, url, headers } }) => {
        const path = new URL(url).pathname
        console.log(`⮕ ${method} ${path}`) 
        logger.info(`⮕ ${method} ${path}`)
      })
      // Log all responses
      .onResponse((context) => {
        const { request: { method }, path, set } = context
        console.log(`⬅ ${method} ${path} ${set.status}`)
        logger.info(`⬅ ${method} ${path} ${set.status}`)
      })
      // Enhanced error handling
      .onError(({ code, error, request }: {
        code: string;
        error: Error;
        request: { url: string; method: string };
      }) => {
        const path = new URL(request.url).pathname
        const errorMessage = `❌ ${request.method} ${path} - ${error.message}`
        console.error(errorMessage)
        logger.error(errorMessage)

        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), { 
          status: code === 'NOT_FOUND' ? 404 : 500,
          headers: {
            'Content-Type': 'application/json'
          }
        })
      })
      // Add health check endpoint
      .get('/health', () => ({ status: 'OK' }))
      .get('/api/contacts', async () => {
        try {
          logger.info('GET /api/contacts - Attempting to fetch contacts')
          const contacts = await db.fetchAll(
            'SELECT * FROM contacts ORDER BY created_at DESC'
          )

          if (!contacts || !Array.isArray(contacts)) {
            logger.warn('GET /api/contacts - No contacts found or invalid response')
            return []
          }

          logger.info(`GET /api/contacts - Successfully fetched ${contacts.length} contacts`)

          const mappedContacts = contacts.map(contact => ({
            id: contact[0],
            first_name: contact[1],
            last_name: contact[2],
            email: contact[3],
            current_carrier: contact[4],
            plan_type: contact[5],
            effective_date: contact[6],
            birth_date: contact[7],
            tobacco_user: Boolean(contact[8]),
            gender: contact[9],
            state: contact[10],
            zip_code: contact[11],
            last_emailed: contact[12],
            created_at: contact[13],
          }))

          logger.info(`GET /api/contacts - Returning ${mappedContacts.length} contacts`)
          return mappedContacts
        } catch (e) {
          logger.error(`Error in GET /api/contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      .post('/api/contacts', async ({ body }: { body: ContactCreate }) => {
        try {
          const contact = body
          logger.info(`Attempting to create contact: ${contact.first_name} ${contact.last_name}`)
          
          const query = `
            INSERT INTO contacts (
              first_name, last_name, email, current_carrier, plan_type,
              effective_date, birth_date, tobacco_user, gender,
              state, zip_code, agent_id
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            RETURNING *
          `
          
          const params = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user ? 1 : 0,
            contact.gender,
            contact.state,
            contact.zip_code,
            contact.agent_id
          ]

          const result = await db.execute(query, params)
          const row = result[0]

          // Match Python response format
          return {
            id: row[0],
            first_name: row[1],
            last_name: row[2],
            email: row[3],
            current_carrier: row[4],
            plan_type: row[5],
            effective_date: row[6],
            birth_date: row[7],
            tobacco_user: Boolean(row[8]),
            gender: row[9],
            state: row[10],
            zip_code: row[11],
            agent_id: row[12],
            last_emailed_date: row[13],
            created_at: row[14],
          }
        } catch (e) {
          logger.error(`Error creating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .put('/api/contacts/:id', async ({ params: { id }, body }) => {
        try {
          const contact = body as ContactCreate
          logger.info(`PUT /api/contacts/${id} - Updating contact`)

          // Match Python's conditional query based on agent_id
          const query = contact.agent_id === null ? `
            UPDATE contacts SET 
              first_name = ?,
              last_name = ?,
              email = ?,
              current_carrier = ?,
              plan_type = ?,
              effective_date = ?,
              birth_date = ?,
              tobacco_user = ?,
              gender = ?,
              state = ?,
              zip_code = ?,
            WHERE id = ?
            RETURNING *
          ` : `
            UPDATE contacts SET 
              first_name = ?,
              last_name = ?,
              email = ?,
              current_carrier = ?,
              plan_type = ?,
              effective_date = ?,
              birth_date = ?,
              tobacco_user = ?,
              gender = ?,
              state = ?,
              zip_code = ?,
              agent_id = ?,
            WHERE id = ?
            RETURNING *
          `

          const queryParams = contact.agent_id === null ? [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user ? 1 : 0,
            contact.gender,
            contact.state,
            contact.zip_code,
            id
          ] : [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user ? 1 : 0,
            contact.gender,
            contact.state,
            contact.zip_code,
            contact.agent_id,
            id
          ]

          const result = await db.execute(query, queryParams)
          const row = result[0]

          return {
            id: row[0],
            first_name: row[1],
            last_name: row[2],
            email: row[3],
            current_carrier: row[4],
            plan_type: row[5],
            effective_date: row[6],
            birth_date: row[7],
            tobacco_user: Boolean(row[8]),
            gender: row[9],
            state: row[10],
            zip_code: row[11],
            agent_id: row[12],
            last_emailed_date: row[13],
            created_at: row[14],
          }
        } catch (e) {
          logger.error(`Error updating contact: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add DELETE endpoint for contacts
      .delete('/api/contacts', async ({ body }) => {
        try {
          const contactIds = body as number[]
          logger.info(`DELETE /api/contacts - Attempting to delete contacts with IDs: ${contactIds}`)

          // Create placeholders for SQL IN clause
          const placeholders = contactIds.map(() => '?').join(',')
          
          const query = `
            DELETE FROM contacts 
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const result = await db.execute(query, contactIds)
          const deletedIds = result.map(row => row[0])

          logger.info(`DELETE /api/contacts - Successfully deleted ${deletedIds.length} contacts`)

          return {
            success: true,
            deleted_ids: deletedIds,
            message: `Successfully deleted ${deletedIds.length} contacts`
          }
        } catch (e) {
          logger.error(`Error deleting contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add file upload endpoint
      .post('/api/contacts/upload', async ({ body }) => {
        try {
          // Extract file and overwrite flag from form data
          const formData = body as { file: File, overwrite_duplicates: boolean | string }
          const file = formData.file
          // Convert string 'false'/'true' to boolean
          const overwriteDuplicates = formData.overwrite_duplicates === 'true'

          logger.info(`Initial overwriteDuplicates value: ${overwriteDuplicates}, type: ${typeof overwriteDuplicates}, raw value: ${formData.overwrite_duplicates}`)

          logger.info(`POST /api/contacts/upload - Processing CSV upload with overwriteDuplicates=${overwriteDuplicates}`)

          // Read file contents
          const fileContents = await file.text()
          
          // Parse CSV
          const records = csvParse(fileContents, {
            columns: true,
            skip_empty_lines: true
          })

          // Required fields in desired order
          const requiredFields = [
            'First Name',
            'Last Name',
            'Email',
            'Current Carrier',
            'Plan Type',
            'Effective Date',
            'Birth Date',
            'Tobacco User',
            'Gender',
            'ZIP Code'
          ]

          // Validate headers
          const headers = Object.keys(records[0] || {})
          const missingFields = requiredFields.filter(field => !headers.includes(field))

          // Add this: Get the email column index from headers
          const emailColumnIndex = headers.indexOf('Email')

          if (missingFields.length > 0) {
            return {
              success: false,
              message: `Missing required columns: ${missingFields.join(', ')}`,
              error_csv: null,
              total_rows: 0,
              error_rows: 0,
              valid_rows: 0
            }
          }

          const validRows: any[] = []
          const errorRows: any[] = []
          const paramsList: any[] = []

          // Get existing emails for duplicate checking
          let existingEmails = new Set<string>()
          const emailResults = await db.fetchAll("SELECT email FROM contacts")
          existingEmails = new Set(emailResults.map(row => row[0].toLowerCase()))

          logger.info(`Found ${existingEmails.size} existing emails in database`)

          // Validate each row
          for (const [index, row] of records.entries()) {
            const rowNum = index + 2 // Account for header row and 0-based index
            
            // Check for missing values
            const missingValues = requiredFields.filter(field => !row[field]?.trim())
            if (missingValues.length > 0) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Missing values for: ${missingValues.join(', ')}`
              })
              continue
            }

            // Validate ZIP code
            const zipCode = row['ZIP Code'].trim()
            const zipInfo = ZIP_DATA[zipCode]
            if (!zipInfo) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid ZIP code: ${zipCode}`
              })
              continue
            }

            // Validate gender
            const gender = row['Gender'].trim().toUpperCase()
            if (!['M', 'F'].includes(gender)) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: `Invalid gender: ${gender}. Must be 'M' or 'F'`
              })
              continue
            }

            // Check for duplicate email
            const email = row['Email'].trim().toLowerCase()
            logger.info(`Checking row ${rowNum} email: ${email}`)
            logger.info(`Overwrite duplicates is set to: ${overwriteDuplicates}`)
            if (existingEmails.has(email)) {
              logger.info(`Found duplicate email: ${email}`)
              const notOverwrite = !overwriteDuplicates
              logger.info(`Debug - overwriteDuplicates: ${overwriteDuplicates}, !overwriteDuplicates: ${notOverwrite}`)
              if (!overwriteDuplicates) {
                logger.info(`Adding duplicate email to error rows since overwrite is disabled`)
                errorRows.push({
                  Row: rowNum,
                  ...row,
                  Error: `Email already exists: ${row['Email']}`
                })
                logger.info('Skipping duplicate email')
                continue
              }
              logger.info(`Allowing duplicate email since overwrite is enabled`)
            }

            try {
              // Validate dates
              const effectiveDate = new Date(row['Effective Date'].trim())
              const birthDate = new Date(row['Birth Date'].trim())
              const tobaccoUser = ['yes', 'true', '1', 'y'].includes(row['Tobacco User'].trim().toLowerCase())

              paramsList.push([
                row['First Name'].trim(),
                row['Last Name'].trim(),
                email,
                row['Current Carrier'].trim(),
                row['Plan Type'].trim(),
                effectiveDate.toISOString().split('T')[0],
                birthDate.toISOString().split('T')[0],
                tobaccoUser ? 1 : 0,
                gender,
                zipInfo.state,
                zipCode
              ])
              validRows.push(row)
            } catch (e) {
              errorRows.push({
                Row: rowNum,
                ...row,
                Error: 'Invalid date format. Dates should be YYYY-MM-DD'
              })
            }
          }

          // Insert valid rows
          let insertedCount = 0
          if (paramsList.length > 0) {
            logger.info(`Processing ${paramsList.length} valid rows with overwriteDuplicates=${overwriteDuplicates}`)
            logger.info(`Debug - overwriteDuplicates value type: ${typeof overwriteDuplicates}`)
            if (overwriteDuplicates) {
              logger.info('Using update/insert logic for duplicates')
              // First update existing records
              const updateQuery = `
                UPDATE contacts SET 
                  first_name = ?,
                  last_name = ?,
                  current_carrier = ?,
                  plan_type = ?,
                  effective_date = ?,
                  birth_date = ?,
                  tobacco_user = ?,
                  gender = ?,
                  state = ?,
                  zip_code = ?
                WHERE LOWER(email) = ?
              `

              for (const params of paramsList) {
                const email = params[2].toLowerCase()
                // Check if email exists
                const existingContact = await db.fetchAll(
                  'SELECT 1 FROM contacts WHERE LOWER(email) = ?',
                  [email]
                )

                if (existingContact.length > 0) {
                  // Update existing contact
                  const updateParams = [
                    params[0], // first_name
                    params[1], // last_name
                    params[3], // current_carrier
                    params[4], // plan_type
                    params[5], // effective_date
                    params[6], // birth_date
                    params[7], // tobacco_user
                    params[8], // gender
                    params[9], // state
                    params[10], // zip_code
                    email     // for WHERE clause
                  ]
                  await db.execute(updateQuery, updateParams)
                } else {
                  // Insert new contact
                  await db.execute(
                    `INSERT INTO contacts (
                      first_name, last_name, email, current_carrier, plan_type,
                      effective_date, birth_date, tobacco_user, gender,
                      state, zip_code
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    params
                  )
                }
              }
              insertedCount = paramsList.length
            } else {
              logger.info('Using insert-only logic for non-duplicates')
              // If not overwriting duplicates, only insert non-duplicate rows
              for (const params of paramsList) {
                const email = params[2].toLowerCase()
                // Check if email exists
                const existingContact = await db.fetchAll(
                  'SELECT 1 FROM contacts WHERE LOWER(email) = ?',
                  [email]
                )

                if (existingContact.length === 0) {
                  // Only insert if email doesn't exist
                  await db.execute(
                    `INSERT INTO contacts (
                      first_name, last_name, email, current_carrier, plan_type,
                      effective_date, birth_date, tobacco_user, gender,
                      state, zip_code
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    params
                  )
                  insertedCount++
                }
              }
            }
          }

          // Generate error CSV if needed
          let errorCsv = null
          if (errorRows.length > 0) {
            errorCsv = [
              ['Row', ...requiredFields, 'Error'].join(','),
              ...errorRows.map(row => {
                return [
                  row.Row,
                  ...requiredFields.map(field => `"${row[field] || ''}"`),
                  `"${row.Error}"`
                ].join(',')
              })
            ].join('\n')
          }

          return {
            success: true,
            message: errorRows.length > 0
              ? `Found ${errorRows.length} rows with errors. Successfully imported ${insertedCount} rows.`
              : `Successfully imported ${insertedCount} rows`,
            error_csv: errorCsv,
            total_rows: validRows.length + errorRows.length,
            error_rows: errorRows.length,
            valid_rows: insertedCount
          }

        } catch (e) {
          logger.error(`Error processing CSV upload: ${e}`)
          return {
            success: false,
            message: String(e),
            error_csv: null,
            total_rows: 0,
            error_rows: 0,
            valid_rows: 0
          }
        }
      })
      // In production, serve the frontend static files
      .use(process.env.NODE_ENV === 'production' 
        ? staticPlugin({
            assets: '../dist', // Where your built frontend files are
            prefix: '/' // Serve at root path
          })
        : (app) => app
      )
      .listen(8000)

    logger.info('Server started on port 8000')
  } catch (error) {
    logger.error(`Error starting server: ${error}`)
    process.exit(1)
  }
}

startServer()

================
File: backend/src/logger.ts
================
export const logger = {
  info: (message: string) => {
    const timestamp = new Date().toISOString()
    console.log(`[${timestamp}] [INFO] ${message}`)
  },
  error: (message: string) => {
    const timestamp = new Date().toISOString()
    console.error(`[${timestamp}] [ERROR] ${message}`)
  }
}

================
File: backend/src/types.ts
================
export interface ContactCreate {
  first_name: string
  last_name: string
  email: string
  current_carrier: string
  plan_type: string
  effective_date: string
  birth_date: string
  tobacco_user: boolean
  gender: string
  state: string
  zip_code: string
  agent_id?: number | null
}

export interface AgentCreate {
  first_name: string
  last_name: string
  email: string
  phone: string
}

================
File: backend/.gitignore
================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

================
File: backend/medicare-portal.db-info
================
{"hash":2042468774,"version":0,"durable_frame_num":22,"generation":1}

================
File: backend/README.md
================
# backend

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.1.45. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.

================
File: frontend/src/Main.elm
================
module Main exposing (main)

import Browser
import Browser.Events
import File exposing (File)
import File.Download
import File.Select as Select
import Html exposing (Html, button, div, h1, h2, h3, input, label, nav, option, select, span, table, tbody, td, text, th, thead, tr)
import Html.Attributes exposing (attribute, checked, class, placeholder, required, title, type_, value)
import Html.Events exposing (onClick, onInput, onSubmit, preventDefaultOn, stopPropagationOn)
import Http
import Json.Decode as Decode exposing (Decoder, bool, int, nullable, string)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import List.Extra
import Svg exposing (svg)
import Svg.Attributes exposing (d, fill, stroke, viewBox)
import Task
import Time
import Url.Builder as Url



-- MAIN


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , update = update
        , view = view
        , subscriptions = subscriptions
        }



-- MODEL


type alias Contact =
    { id : Int
    , firstName : String
    , lastName : String
    , email : String
    , currentCarrier : String
    , planType : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : Bool
    , gender : String
    , state : String
    , zipCode : String
    , agentId : Maybe Int
    , lastEmailed : Maybe String
    }


type Modal
    = NoModal
    | AddModal
    | EditModal Contact
    | CsvUploadModal UploadState


type alias Model =
    { contacts : List Contact
    , selectedContacts : List Int
    , showModal : Modal
    , searchQuery : String
    , addForm : ContactForm
    , editForm : ContactForm
    , sortColumn : Maybe SortColumn
    , sortDirection : SortDirection
    , activeFilters : Filters
    , openFilter : Maybe FilterType
    , currentTime : Time.Posix
    , isLoadingContacts : Bool
    , isUploadingCsv : Bool
    , isDeletingContacts : Bool
    , isSubmittingForm : Bool
    }


type alias ContactForm =
    { id : Maybe Int
    , firstName : String
    , lastName : String
    , email : String
    , currentCarrier : String
    , planType : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : Bool
    , gender : String
    , state : String
    , zipCode : String
    , agentId : Maybe Int
    }


type SortColumn
    = FirstNameCol
    | LastNameCol
    | EmailCol
    | CarrierCol
    | PlanTypeCol
    | EffectiveDateCol
    | BirthDateCol
    | TobaccoCol
    | GenderCol
    | StateCol
    | ZipCodeCol


type SortDirection
    = Ascending
    | Descending


type alias Filters =
    { carriers : List String
    , states : List String
    , ageRange : Maybe ( Int, Int )
    }


type alias ZipInfo =
    { state : String
    , counties : List String
    , cities : List String
    }


type alias UploadState =
    { dragOver : Bool
    , file : Maybe File
    , error : Maybe String
    , errorCsv : Maybe String
    , stats : Maybe UploadStats
    , overwriteDuplicates : Bool
    }


type alias UploadStats =
    { totalRows : Int
    , errorRows : Int
    , validRows : Int
    }


type alias DeleteResponse =
    { success : Bool
    , deletedIds : List Int
    , message : String
    }


init : () -> ( Model, Cmd Msg )
init _ =
    ( { contacts = []
      , selectedContacts = []
      , showModal = NoModal
      , searchQuery = ""
      , addForm = emptyForm
      , editForm = emptyForm
      , sortColumn = Nothing
      , sortDirection = Ascending
      , activeFilters = emptyFilters
      , openFilter = Nothing
      , currentTime = Time.millisToPosix 0
      , isLoadingContacts = True
      , isUploadingCsv = False
      , isDeletingContacts = False
      , isSubmittingForm = False
      }
    , Cmd.batch
        [ fetchContacts
        , Task.perform GotCurrentTime Time.now
        ]
    )


emptyForm : ContactForm
emptyForm =
    { id = Nothing
    , firstName = ""
    , lastName = ""
    , email = ""
    , currentCarrier = ""
    , planType = ""
    , effectiveDate = ""
    , birthDate = ""
    , tobaccoUser = False
    , gender = "M"
    , state = ""
    , zipCode = ""
    , agentId = Nothing
    }


emptyFilters : Filters
emptyFilters =
    { carriers = []
    , states = []
    , ageRange = Nothing
    }


emptyUploadState : UploadState
emptyUploadState =
    { dragOver = False
    , file = Nothing
    , error = Nothing
    , errorCsv = Nothing
    , stats = Nothing
    , overwriteDuplicates = True
    }



-- UPDATE


type Msg
    = NoOp
    | ShowAddModal
    | ShowEditModal Contact
    | CloseModal
    | UpdateSearchQuery String
    | UpdateAddForm ContactFormField String
    | UpdateEditForm ContactFormField String
    | SubmitAddForm
    | SubmitEditForm
    | GotContacts (Result Http.Error (List Contact))
    | ContactAdded (Result Http.Error Contact)
    | ContactUpdated (Result Http.Error Contact)
    | HandleKeyDown String
    | SetSort SortColumn
    | ToggleFilter FilterType String
    | SetAgeFilter Int Int -- (min, max)
    | ClearFilters
    | LookupZipCode String
    | GotZipLookup (Result Http.Error ZipInfo)
    | Batch (List Msg)
    | ToggleFilterDropdown FilterType
    | SelectAllFilter FilterType Bool
    | CloseFilterDropdown
    | GotCurrentTime Time.Posix
    | ToggleSelectContact Int
    | SelectAllContacts
    | DeselectAllContacts
    | EmailSelectedCarriers
    | EmailSelectedContacts
    | ShowCsvUploadModal
    | DragEnter
    | DragLeave
    | FileDrop File
    | FileSelected File
    | ClickedSelectFile
    | UploadCsv
    | CsvUploaded (Result Http.Error UploadResponse)
    | DownloadErrorCsv String
    | DeleteSelectedContacts
    | ContactsDeleted (Result Http.Error DeleteResponse)
    | ToggleOverwriteDuplicates Bool


type ContactFormField
    = FirstName
    | LastName
    | Email
    | CurrentCarrier
    | PlanType
    | EffectiveDate
    | BirthDate
    | TobaccoUser
    | Gender
    | State
    | ZipCode


type FilterType
    = CarrierFilter
    | StateFilter
    | AgeFilter


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        ShowAddModal ->
            ( { model | showModal = AddModal }, Cmd.none )

        ShowEditModal contact ->
            ( { model
                | showModal = EditModal contact
                , editForm =
                    { id = Just contact.id
                    , firstName = contact.firstName
                    , lastName = contact.lastName
                    , email = contact.email
                    , currentCarrier = contact.currentCarrier
                    , planType = contact.planType
                    , effectiveDate = contact.effectiveDate
                    , birthDate = contact.birthDate
                    , tobaccoUser = contact.tobaccoUser
                    , gender = contact.gender
                    , state = contact.state
                    , zipCode = contact.zipCode
                    , agentId = contact.agentId
                    }
              }
            , Cmd.none
            )

        CloseModal ->
            ( { model | showModal = NoModal }, Cmd.none )

        UpdateSearchQuery query ->
            ( { model | searchQuery = query }, Cmd.none )

        UpdateAddForm field value ->
            let
                form =
                    model.addForm

                updatedForm =
                    case field of
                        FirstName ->
                            { form | firstName = value }

                        LastName ->
                            { form | lastName = value }

                        Email ->
                            { form | email = value }

                        CurrentCarrier ->
                            { form | currentCarrier = value }

                        PlanType ->
                            { form | planType = value }

                        EffectiveDate ->
                            { form | effectiveDate = value }

                        BirthDate ->
                            { form | birthDate = value }

                        TobaccoUser ->
                            { form | tobaccoUser = value == "true" }

                        Gender ->
                            { form | gender = value }

                        State ->
                            { form | state = value }

                        ZipCode ->
                            { form | zipCode = value }
            in
            ( { model | addForm = updatedForm }, Cmd.none )

        UpdateEditForm field value ->
            let
                form =
                    model.editForm

                updatedForm =
                    case field of
                        FirstName ->
                            { form | firstName = value }

                        LastName ->
                            { form | lastName = value }

                        Email ->
                            { form | email = value }

                        CurrentCarrier ->
                            { form | currentCarrier = value }

                        PlanType ->
                            { form | planType = value }

                        EffectiveDate ->
                            { form | effectiveDate = value }

                        BirthDate ->
                            { form | birthDate = value }

                        TobaccoUser ->
                            { form | tobaccoUser = value == "true" }

                        Gender ->
                            { form | gender = value }

                        State ->
                            { form | state = value }

                        ZipCode ->
                            { form | zipCode = value }
            in
            ( { model | editForm = updatedForm }, Cmd.none )

        SubmitAddForm ->
            ( { model | isSubmittingForm = True }
            , submitAddForm model.addForm
            )

        SubmitEditForm ->
            ( { model | isSubmittingForm = True }
            , submitEditForm model.editForm
            )

        GotContacts (Ok contacts) ->
            ( { model | contacts = contacts, isLoadingContacts = False }, Cmd.none )

        GotContacts (Err error) ->
            let
                _ =
                    Debug.log "Error fetching contacts" error
            in
            ( model, Cmd.none )

        ContactAdded (Ok contact) ->
            ( { model
                | contacts = contact :: model.contacts
                , showModal = NoModal
                , addForm = emptyForm
                , isSubmittingForm = False
              }
            , Cmd.none
            )

        ContactAdded (Err _) ->
            ( { model | isSubmittingForm = False }
            , Cmd.none
            )

        ContactUpdated (Ok contact) ->
            ( { model
                | contacts = updateContact contact model.contacts
                , showModal = NoModal
                , editForm = emptyForm
                , isSubmittingForm = False
              }
            , Cmd.none
            )

        ContactUpdated (Err _) ->
            ( { model | isSubmittingForm = False }
            , Cmd.none
            )

        HandleKeyDown key ->
            if key == "Escape" then
                ( { model | showModal = NoModal }, Cmd.none )

            else
                ( model, Cmd.none )

        SetSort column ->
            let
                ( newColumn, newDirection ) =
                    case ( model.sortColumn, model.sortDirection ) of
                        ( Just currentColumn, direction ) ->
                            if currentColumn == column then
                                -- Toggle direction if same column
                                ( Just column
                                , if direction == Ascending then
                                    Descending

                                  else
                                    Ascending
                                )

                            else
                                -- New column, start with ascending
                                ( Just column, Ascending )

                        ( Nothing, _ ) ->
                            -- First time sorting, start with ascending
                            ( Just column, Ascending )
            in
            ( { model
                | sortColumn = newColumn
                , sortDirection = newDirection
              }
            , Cmd.none
            )

        ToggleFilter filterType value ->
            ( { model | activeFilters = toggleFilter model.activeFilters filterType value }, Cmd.none )

        SetAgeFilter min max ->
            ( { model | activeFilters = setAgeFilter min max model.activeFilters }, Cmd.none )

        ClearFilters ->
            ( { model | activeFilters = emptyFilters }, Cmd.none )

        LookupZipCode zipCode ->
            ( model
            , Http.get
                { url = "/api/zip-lookup/" ++ zipCode
                , expect = Http.expectJson GotZipLookup zipInfoDecoder
                }
            )

        GotZipLookup (Ok zipInfo) ->
            let
                updateForm form =
                    { form | state = zipInfo.state }
            in
            case model.showModal of
                AddModal ->
                    ( { model | addForm = updateForm model.addForm }, Cmd.none )

                EditModal _ ->
                    ( { model | editForm = updateForm model.editForm }, Cmd.none )

                NoModal ->
                    ( model, Cmd.none )

                CsvUploadModal _ ->
                    ( model, Cmd.none )

        GotZipLookup (Err _) ->
            ( model, Cmd.none )

        Batch messages ->
            List.foldl
                (\msg_ ( model_, cmds ) ->
                    let
                        ( newModel, newCmd ) =
                            update msg_ model_
                    in
                    ( newModel, newCmd :: cmds )
                )
                ( model, [] )
                messages
                |> (\( m, cs ) -> ( m, Cmd.batch cs ))

        ToggleFilterDropdown filterType ->
            ( { model
                | openFilter =
                    if model.openFilter == Just filterType then
                        Nothing

                    else
                        Just filterType
              }
            , Cmd.none
            )

        SelectAllFilter filterType select ->
            let
                options =
                    case filterType of
                        CarrierFilter ->
                            getUniqueValues .currentCarrier model.contacts

                        StateFilter ->
                            getUniqueValues .state model.contacts

                        _ ->
                            []

                updatedFilters =
                    case filterType of
                        CarrierFilter ->
                            { activeFilters
                                | carriers =
                                    if select then
                                        options

                                    else
                                        []
                            }

                        StateFilter ->
                            { activeFilters
                                | states =
                                    if select then
                                        options

                                    else
                                        []
                            }

                        _ ->
                            model.activeFilters

                activeFilters =
                    model.activeFilters
            in
            ( { model | activeFilters = updatedFilters }, Cmd.none )

        CloseFilterDropdown ->
            ( { model | openFilter = Nothing }, Cmd.none )

        GotCurrentTime time ->
            ( { model | currentTime = time }, Cmd.none )

        ToggleSelectContact id ->
            ( { model
                | selectedContacts =
                    if List.member id model.selectedContacts then
                        List.filter (\x -> x /= id) model.selectedContacts

                    else
                        id :: model.selectedContacts
              }
            , Cmd.none
            )

        SelectAllContacts ->
            let
                visibleContacts =
                    model.contacts
                        |> filterContacts model.activeFilters model.searchQuery model.currentTime
                        |> List.map .id
            in
            ( { model | selectedContacts = visibleContacts }
            , Cmd.none
            )

        DeselectAllContacts ->
            ( { model | selectedContacts = [] }
            , Cmd.none
            )

        EmailSelectedCarriers ->
            -- For now, just a placeholder that does nothing
            ( model, Cmd.none )

        EmailSelectedContacts ->
            -- For now, just a placeholder that does nothing
            ( model, Cmd.none )

        ShowCsvUploadModal ->
            ( { model | showModal = CsvUploadModal emptyUploadState }, Cmd.none )

        DragEnter ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | dragOver = True } }, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        DragLeave ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | dragOver = False } }, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        FileDrop file ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | file = Just file, dragOver = False } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        FileSelected file ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | file = Just file } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        ClickedSelectFile ->
            ( model
            , Select.file [ "text/csv" ] FileSelected
            )

        UploadCsv ->
            case model.showModal of
                CsvUploadModal state ->
                    case state.file of
                        Just file ->
                            ( { model
                                | showModal = CsvUploadModal { state | error = Nothing, errorCsv = Nothing, stats = Nothing }
                                , isUploadingCsv = True
                              }
                            , uploadCsv file state.overwriteDuplicates
                            )

                        Nothing ->
                            ( model, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        CsvUploaded (Ok response) ->
            let
                currentModal =
                    case model.showModal of
                        CsvUploadModal state ->
                            if response.success && response.errorRows == 0 then
                                NoModal

                            else
                                CsvUploadModal
                                    { state
                                        | error = Just response.message
                                        , errorCsv = response.errorCsv
                                        , stats =
                                            Just
                                                { totalRows = response.totalRows
                                                , errorRows = response.errorRows
                                                , validRows = response.validRows
                                                }
                                    }

                        _ ->
                            model.showModal
            in
            ( { model
                | showModal = currentModal
                , isUploadingCsv = False
              }
            , if response.success then
                fetchContacts

              else
                Cmd.none
            )

        CsvUploaded (Err httpError) ->
            case model.showModal of
                CsvUploadModal state ->
                    let
                        errorMessage =
                            case httpError |> Debug.log "HTTP Error" of
                                Http.BadStatus 400 ->
                                    "Invalid CSV format. Please check the required columns and data."

                                _ ->
                                    "Failed to upload CSV. Please try again."
                    in
                    ( { model | showModal = CsvUploadModal { state | error = Just errorMessage } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        DownloadErrorCsv csvContent ->
            ( model
            , File.Download.string "upload_errors.csv" "text/csv" csvContent
            )

        DeleteSelectedContacts ->
            ( { model | isDeletingContacts = True }
            , if List.isEmpty model.selectedContacts then
                Cmd.none

              else
                deleteContacts model.selectedContacts
            )

        ContactsDeleted (Ok response) ->
            if response.success then
                ( { model
                    | contacts = List.filter (\c -> not (List.member c.id response.deletedIds)) model.contacts
                    , selectedContacts = []
                    , isDeletingContacts = False
                  }
                , fetchContacts
                )

            else
                ( { model | isDeletingContacts = False }, Cmd.none )

        ContactsDeleted (Err _) ->
            ( model, Cmd.none )

        ToggleOverwriteDuplicates value ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | overwriteDuplicates = value } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )



-- TODO: Handle error
-- Add other update cases here...
-- VIEW


view : Model -> Html Msg
view model =
    div [ class "min-h-screen bg-gray-50" ]
        [ viewNavHeader
        , div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
            [ viewActionBar model
            , viewContactsTable model
            , viewModals model
            ]
        ]


viewNavHeader : Html Msg
viewNavHeader =
    nav [ class "bg-white border-b border-gray-200" ]
        [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
            [ div [ class "flex justify-between h-16" ]
                [ div [ class "flex" ]
                    [ div [ class "flex-shrink-0 flex items-center" ]
                        [ h1 [ class "text-xl font-semibold text-purple-600" ]
                            [ text "Medicare Max" ]
                        ]
                    ]
                , div [ class "flex items-center" ]
                    [ button
                        [ class "px-3 py-1.5 bg-purple-500 text-white text-sm font-medium rounded-md hover:bg-purple-600 transition-colors duration-200" ]
                        [ text "Profile" ]
                    ]
                ]
            ]
        ]



-- Add other view helper functions here...
-- HTTP


fetchContacts : Cmd Msg
fetchContacts =
    Http.get
        { url = "/api/contacts"
        , expect = Http.expectJson GotContacts contactsDecoder
        }



-- Add other HTTP functions and JSON decoders/encoders here...
-- VIEW HELPERS


viewActionBar : Model -> Html Msg
viewActionBar model =
    div [ class "space-y-4 mb-6" ]
        [ div [ class "flex justify-between items-center" ]
            [ div [ class "flex space-x-3" ]
                [ button
                    [ class "px-3 py-1.5 bg-purple-500 text-white text-sm font-medium rounded-md hover:bg-purple-600 transition-colors duration-200"
                    , onClick ShowAddModal
                    ]
                    [ viewIcon "M12 4v16m8-8H4"
                    , text "Add Client"
                    ]
                , button
                    [ class "px-3 py-1.5 bg-white text-gray-700 text-sm font-medium rounded-md border border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200"
                    , onClick ShowCsvUploadModal
                    ]
                    [ viewIcon "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                    , text "Upload CSV"
                    ]
                , button
                    [ class "px-3 py-1.5 bg-white text-gray-700 text-sm font-medium rounded-md border border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200" ]
                    [ viewIcon "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
                    , text "Export"
                    ]
                ]
            , div [ class "flex space-x-3" ]
                [ input
                    [ class "px-3 py-1.5 w-64 bg-white border border-gray-200 rounded-md text-sm placeholder-gray-400 focus:border-purple-400 focus:ring-2 focus:ring-purple-400/20 transition-colors duration-200"
                    , placeholder "Search contacts..."
                    , onInput UpdateSearchQuery
                    , value model.searchQuery
                    ]
                    []
                ]
            ]
        , viewFilters model
        ]


viewFilters : Model -> Html Msg
viewFilters model =
    div [ class "space-y-4" ]
        [ h3 [ class "text-lg font-medium text-gray-700" ] [ text "Filters" ]
        , div [ class "flex space-x-4" ]
            [ viewFilterDropdown model
                "Carriers"
                CarrierFilter
                (getUniqueValues .currentCarrier model.contacts)
                model.activeFilters.carriers
            , viewFilterDropdown model
                "States"
                StateFilter
                (getUniqueValues .state model.contacts)
                model.activeFilters.states
            , viewAgeFilter model.activeFilters.ageRange
            ]
        ]


viewFilterDropdown : Model -> String -> FilterType -> List String -> List String -> Html Msg
viewFilterDropdown model label_ filterType options selectedValues =
    let
        isOpen =
            model.openFilter == Just filterType

        allSelected =
            List.length selectedValues == List.length options

        chevronIcon =
            if isOpen then
                "M19 9l-7 7-7-7"

            else
                "M9 5l7 7-7 7"

        selectionDisplay =
            if List.isEmpty selectedValues then
                [ span [ class "text-sm text-gray-600" ] [ text "Select..." ] ]

            else if List.length selectedValues == 1 then
                [ span [ class "text-sm text-gray-600" ] [ text (List.head selectedValues |> Maybe.withDefault "") ] ]

            else
                [ span [ class "text-sm text-gray-600" ]
                    [ text (String.fromInt (List.length selectedValues) ++ " selected") ]
                , if filterType == CarrierFilter && not (List.isEmpty selectedValues) then
                    button
                        [ class "ml-2 px-2 py-1 text-xs text-purple-600 hover:text-purple-800 hover:underline"
                        , onClick EmailSelectedCarriers
                        ]
                        [ text "Email" ]

                  else
                    text ""
                ]
    in
    div [ class "relative w-48" ]
        [ label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text label_ ]
        , div
            [ class "flex items-center justify-between w-full px-4 py-2 bg-white border border-gray-200 rounded-md cursor-pointer hover:bg-gray-50"
            , onClick (ToggleFilterDropdown filterType)
            ]
            [ div [ class "flex items-center space-x-2" ] selectionDisplay
            , svg
                [ Svg.Attributes.class "w-5 h-5 text-gray-400"
                , viewBox "0 0 24 24"
                , fill "none"
                , stroke "currentColor"
                ]
                [ Svg.path
                    [ d chevronIcon
                    , Svg.Attributes.strokeLinecap "round"
                    , Svg.Attributes.strokeLinejoin "round"
                    , Svg.Attributes.strokeWidth "2"
                    ]
                    []
                ]
            ]
        , if isOpen then
            div
                [ class "absolute z-10 w-full mt-1 bg-white border border-gray-200 rounded-md shadow-lg"
                , stopPropagationOn "mousedown" (Decode.succeed ( NoOp, True ))
                ]
                [ div [ class "p-2 border-b border-gray-200" ]
                    [ label [ class "flex items-center space-x-2" ]
                        [ input
                            [ type_ "checkbox"
                            , checked allSelected
                            , onClick (SelectAllFilter filterType (not allSelected))
                            , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                            ]
                            []
                        , span [ class "text-sm text-gray-600" ]
                            [ text "Select All" ]
                        ]
                    ]
                , div [ class "max-h-48 overflow-y-auto p-2" ]
                    (List.map
                        (\option ->
                            label
                                [ class "flex items-center space-x-2 py-1" ]
                                [ input
                                    [ type_ "checkbox"
                                    , checked (List.member option selectedValues)
                                    , onClick (ToggleFilter filterType option)
                                    , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                    ]
                                    []
                                , span [ class "text-sm text-gray-600" ]
                                    [ text option ]
                                ]
                        )
                        options
                    )
                ]

          else
            text ""
        ]


viewAgeFilter : Maybe ( Int, Int ) -> Html Msg
viewAgeFilter maybeRange =
    div [ class "w-48" ]
        [ label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text "Age Range (years)" ]
        , div [ class "flex items-center space-x-2" ]
            [ div [ class "flex items-center space-x-1" ]
                [ span [ class "text-sm text-gray-600" ] [ text "Min:" ]
                , input
                    [ type_ "number"
                    , class "w-16 px-4 py-2 border border-gray-200 rounded-md text-sm"
                    , value (Maybe.map (Tuple.first >> String.fromInt) maybeRange |> Maybe.withDefault "")
                    , onInput
                        (\val ->
                            if String.isEmpty val then
                                SetAgeFilter 0 0

                            else
                                SetAgeFilter (String.toInt val |> Maybe.withDefault 0) (Maybe.map Tuple.second maybeRange |> Maybe.withDefault 0)
                        )
                    ]
                    []
                ]
            , div [ class "flex items-center space-x-1" ]
                [ span [ class "text-sm text-gray-600" ] [ text "Max:" ]
                , input
                    [ type_ "number"
                    , class "w-16 px-4 py-2 border border-gray-200 rounded-md text-sm"
                    , value (Maybe.map (Tuple.second >> String.fromInt) maybeRange |> Maybe.withDefault "")
                    , onInput
                        (\val ->
                            if String.isEmpty val then
                                SetAgeFilter (Maybe.map Tuple.first maybeRange |> Maybe.withDefault 0) 0

                            else
                                SetAgeFilter (Maybe.map Tuple.first maybeRange |> Maybe.withDefault 0) (String.toInt val |> Maybe.withDefault 0)
                        )
                    ]
                    []
                ]
            , case maybeRange of
                Just _ ->
                    button
                        [ class "px-2 py-1 text-xs text-gray-600 hover:text-gray-800 border border-gray-200 rounded-md hover:border-gray-300 bg-white hover:bg-gray-50 transition-colors duration-200"
                        , onClick (SetAgeFilter 0 0)
                        ]
                        [ text "Reset" ]

                Nothing ->
                    text ""
            ]
        ]


viewContactsTable : Model -> Html Msg
viewContactsTable model =
    if model.isLoadingContacts then
        div [ class "flex justify-center items-center h-64" ]
            [ viewSpinner
            , span [ class "ml-2 text-gray-600" ] [ text "Loading contacts..." ]
            ]

    else
        let
            filteredAndSortedContacts =
                model.contacts
                    |> filterContacts model.activeFilters model.searchQuery model.currentTime
                    |> sortContacts model.sortColumn model.sortDirection

            selectionCount =
                List.length model.selectedContacts

            selectionText =
                case selectionCount of
                    0 ->
                        "No contacts selected"

                    1 ->
                        "1 contact selected"

                    n ->
                        String.fromInt n ++ " contacts selected"
        in
        div []
            [ div [ class "mb-4 flex items-center space-x-2" ]
                [ span [ class "text-sm text-gray-600" ]
                    [ text selectionText ]
                , if selectionCount > 0 then
                    div [ class "flex space-x-2" ]
                        [ button
                            [ class "px-2 py-1 text-sm text-purple-600 hover:text-purple-800 hover:bg-purple-50 rounded-md transition-colors duration-200 flex items-center space-x-1"
                            , onClick EmailSelectedContacts
                            ]
                            [ viewIcon "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
                            , span [] [ text "Email" ]
                            ]
                        , if model.isDeletingContacts then
                            div [ class "px-2 py-1 flex items-center space-x-1" ]
                                [ viewSpinner ]

                          else
                            button
                                [ class "px-2 py-1 text-sm text-red-600 hover:text-red-800 hover:bg-red-50 rounded-md transition-colors duration-200 flex items-center space-x-1"
                                , onClick DeleteSelectedContacts
                                ]
                                [ viewIcon "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                , span [] [ text "Delete" ]
                                ]
                        ]

                  else
                    text ""
                ]
            , div [ class "bg-white shadow-sm rounded-lg border border-gray-200" ]
                [ div [ class "overflow-x-auto" ]
                    [ table [ class "min-w-full table-fixed" ]
                        [ viewTableHeader model filteredAndSortedContacts
                        , tbody [ class "divide-y divide-gray-200" ]
                            (List.map (viewContactRow model) filteredAndSortedContacts)
                        ]
                    ]
                ]
            ]


viewTableHeader : Model -> List Contact -> Html Msg
viewTableHeader model visibleContacts =
    let
        allSelected =
            not (List.isEmpty model.selectedContacts)
                && List.length model.selectedContacts
                == List.length visibleContacts
    in
    thead []
        [ tr [ class "bg-gray-50 border-b border-gray-200" ]
            (th
                [ class "w-12 px-4 py-3 border-r border-gray-200" ]
                [ div [ class "flex items-center justify-between" ]
                    [ input
                        [ type_ "checkbox"
                        , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                        , checked allSelected
                        , onClick
                            (if allSelected then
                                DeselectAllContacts

                             else
                                SelectAllContacts
                            )
                        ]
                        []
                    ]
                ]
                :: List.map
                    (\( col, label ) ->
                        viewSortableHeaderCell model col label
                    )
                    [ ( FirstNameCol, "First Name" )
                    , ( LastNameCol, "Last Name" )
                    , ( EmailCol, "Email" )
                    , ( CarrierCol, "Current Carrier" )
                    , ( PlanTypeCol, "Plan Type" )
                    , ( EffectiveDateCol, "Effective Date" )
                    , ( BirthDateCol, "Birth Date" )
                    , ( TobaccoCol, "Tobacco" )
                    , ( GenderCol, "Gender" )
                    , ( StateCol, "State" )
                    , ( ZipCodeCol, "ZIP Code" )
                    ]
            )
        ]


viewSortableHeaderCell : Model -> SortColumn -> String -> Html Msg
viewSortableHeaderCell model column label =
    th
        [ class "px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider border-r border-gray-200 cursor-pointer hover:bg-gray-100"
        , onClick (SetSort column)
        ]
        [ div [ class "flex items-center space-x-1" ]
            [ text label
            , viewSortIcon model column
            ]
        ]


viewSortIcon : Model -> SortColumn -> Html Msg
viewSortIcon model column =
    if model.sortColumn == Just column then
        case model.sortDirection of
            Ascending ->
                viewIcon "M5 15l7-7 7 7"

            Descending ->
                viewIcon "M19 9l-7 7-7-7"

    else
        text ""


viewContactRow : Model -> Contact -> Html Msg
viewContactRow model contact =
    let
        mainClass =
            [ class "px-4 py-3 text-sm text-gray-900 border-r border-gray-200" ]
    in
    tr [ class "hover:bg-gray-50" ]
        (td
            [ class "w-12 px-4 py-3 border-r border-gray-200" ]
            [ input
                [ type_ "checkbox"
                , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                , checked (List.member contact.id model.selectedContacts)
                , onClick (ToggleSelectContact contact.id)
                ]
                []
            ]
            :: [ td mainClass [ text contact.firstName ]
               , td mainClass [ text contact.lastName ]
               , td mainClass [ text contact.email ]
               , td mainClass [ text contact.currentCarrier ]
               , td mainClass [ text contact.planType ]
               , td mainClass [ text contact.effectiveDate ]
               , td mainClass [ text contact.birthDate ]
               , td mainClass
                    [ text
                        (if contact.tobaccoUser then
                            "Yes"

                         else
                            "No"
                        )
                    ]
               , td mainClass [ text contact.gender ]
               , td mainClass [ text contact.state ]
               , td mainClass [ text contact.zipCode ]
               , td [ class "px-4 py-3 text-sm text-gray-900" ] [ viewContactActions contact model.isDeletingContacts ]
               ]
        )


viewContactActions : Contact -> Bool -> Html Msg
viewContactActions contact isDeleting =
    div [ class "flex space-x-2 justify-center" ]
        [ button
            [ class "text-gray-400 hover:text-purple-500 transition-colors duration-200"
            , onClick (ShowEditModal contact)
            , title "Edit"
            ]
            [ viewIcon "M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"
            ]
        ]


viewIcon : String -> Html Msg
viewIcon path =
    svg
        [ Svg.Attributes.class "w-4 h-4"
        , Svg.Attributes.fill "none"
        , Svg.Attributes.stroke "currentColor"
        , Svg.Attributes.viewBox "0 0 24 24"
        ]
        [ Svg.path [ Svg.Attributes.d path ] [] ]



-- HELPERS


updateContact : Contact -> List Contact -> List Contact
updateContact updated contacts =
    List.map
        (\contact ->
            if contact.id == updated.id then
                updated

            else
                contact
        )
        contacts



-- HTTP


submitAddForm : ContactForm -> Cmd Msg
submitAddForm form =
    Http.post
        { url = "/api/contacts"
        , body = Http.jsonBody (encodeContactForm form)
        , expect = Http.expectJson ContactAdded contactDecoder
        }


submitEditForm : ContactForm -> Cmd Msg
submitEditForm form =
    case form.id of
        Just id ->
            Http.request
                { method = "PUT"
                , headers = []
                , url = "/api/contacts/" ++ String.fromInt id
                , body = Http.jsonBody (encodeContactForm form)
                , expect = Http.expectJson ContactUpdated contactDecoder
                , timeout = Nothing
                , tracker = Nothing
                }

        Nothing ->
            Cmd.none



-- JSON


contactDecoder : Decode.Decoder Contact
contactDecoder =
    Decode.succeed Contact
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "first_name" Decode.string
        |> Pipeline.required "last_name" Decode.string
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "current_carrier" Decode.string
        |> Pipeline.required "plan_type" Decode.string
        |> Pipeline.required "effective_date" Decode.string
        |> Pipeline.required "birth_date" Decode.string
        |> Pipeline.required "tobacco_user" Decode.bool
        |> Pipeline.required "gender" Decode.string
        |> Pipeline.required "state" Decode.string
        |> Pipeline.required "zip_code" Decode.string
        |> Pipeline.optional "agent_id" (Decode.nullable Decode.int) Nothing
        |> Pipeline.optional "last_emailed_date" (Decode.nullable Decode.string) Nothing


contactsDecoder : Decode.Decoder (List Contact)
contactsDecoder =
    Decode.list contactDecoder


encodeContactForm : ContactForm -> Encode.Value
encodeContactForm form =
    Encode.object
        [ ( "first_name", Encode.string form.firstName )
        , ( "last_name", Encode.string form.lastName )
        , ( "email", Encode.string form.email )
        , ( "current_carrier", Encode.string form.currentCarrier )
        , ( "plan_type", Encode.string form.planType )
        , ( "effective_date", Encode.string form.effectiveDate )
        , ( "birth_date", Encode.string form.birthDate )
        , ( "tobacco_user", Encode.bool form.tobaccoUser )
        , ( "gender", Encode.string form.gender )
        , ( "state", Encode.string form.state )
        , ( "zip_code", Encode.string form.zipCode )
        , ( "agent_id", Maybe.map Encode.int form.agentId |> Maybe.withDefault Encode.null )
        ]


viewModals : Model -> Html Msg
viewModals model =
    case model.showModal of
        NoModal ->
            text ""

        AddModal ->
            viewAddModal model.addForm model.isSubmittingForm

        EditModal contact ->
            viewEditModal model.editForm model.isSubmittingForm

        CsvUploadModal state ->
            viewCsvUploadModal state model.isUploadingCsv


viewAddModal : ContactForm -> Bool -> Html Msg
viewAddModal form isSubmitting =
    div [ class "fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-5xl w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Add New Client" ]
            , viewContactForm form UpdateAddForm SubmitAddForm "Add Client" isSubmitting
            ]
        ]


viewEditModal : ContactForm -> Bool -> Html Msg
viewEditModal form isSubmitting =
    div [ class "fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-5xl w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Edit Client" ]
            , viewContactForm form UpdateEditForm SubmitEditForm "Save Changes" isSubmitting
            ]
        ]


viewCsvUploadModal : UploadState -> Bool -> Html Msg
viewCsvUploadModal state isUploading =
    div [ class "fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-2xl w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Upload CSV" ]
            , div [ class "mb-6 text-sm text-gray-600" ]
                [ text "Need help formatting your CSV? "
                , Html.a
                    [ class "text-purple-600 hover:text-purple-800 hover:underline"
                    , Html.Attributes.href "/example.csv"
                    , Html.Attributes.download "example.csv"
                    ]
                    [ text "Download example CSV file" ]
                ]
            , div [ class "mb-4 flex items-center space-x-2" ]
                [ input
                    [ type_ "checkbox"
                    , checked state.overwriteDuplicates
                    , onInput (\val -> ToggleOverwriteDuplicates (val == "true"))
                    , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                    ]
                    []
                , label [ class "text-sm text-gray-600" ]
                    [ text "Overwrite existing contacts with matching email addresses" ]
                ]
            , div
                [ class
                    ("w-full h-64 border-2 border-dashed rounded-lg flex flex-col items-center justify-center p-8 transition-colors "
                        ++ (if state.dragOver then
                                "border-purple-500 bg-purple-50"

                            else
                                "border-gray-300 hover:border-purple-400"
                           )
                    )
                , preventDefaultOn "dragenter" (Decode.succeed ( DragEnter, True ))
                , preventDefaultOn "dragover" (Decode.succeed ( NoOp, True ))
                , preventDefaultOn "dragleave" (Decode.succeed ( DragLeave, True ))
                , preventDefaultOn "drop" (dropDecoder FileDrop)
                ]
                [ viewIcon "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                , div [ class "mt-4 text-center" ]
                    [ text "Drag and drop your CSV file here, or "
                    , button
                        [ class "text-purple-500 hover:text-purple-700 hover:underline"
                        , onClick ClickedSelectFile
                        ]
                        [ text "browse" ]
                    ]
                , case state.file of
                    Just file ->
                        div [ class "mt-4 text-sm text-gray-600" ]
                            [ text ("Selected: " ++ File.name file) ]

                    Nothing ->
                        text ""
                , case state.error of
                    Just error ->
                        div [ class "mt-4 text-sm text-red-600" ]
                            [ text error ]

                    Nothing ->
                        text ""
                ]
            , case state.stats of
                Just stats ->
                    div [ class "mt-4 space-y-2" ]
                        [ div [ class "text-sm text-gray-600" ]
                            [ text <| "Total rows: " ++ String.fromInt stats.totalRows ]
                        , div [ class "text-sm text-gray-600" ]
                            [ text <| "Valid rows: " ++ String.fromInt stats.validRows ]
                        , if stats.errorRows > 0 then
                            div [ class "text-sm text-red-600" ]
                                [ text <| "Error rows: " ++ String.fromInt stats.errorRows
                                , case state.errorCsv of
                                    Just csvContent ->
                                        button
                                            [ class "ml-2 text-purple-600 hover:text-purple-800 hover:underline"
                                            , onClick (DownloadErrorCsv csvContent)
                                            ]
                                            [ text "Download Errors" ]

                                    Nothing ->
                                        text ""
                                ]

                          else
                            text ""
                        ]

                Nothing ->
                    text ""
            , div [ class "mt-8 flex justify-end space-x-4" ]
                [ button
                    [ class "px-6 py-3 bg-white text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200"
                    , onClick CloseModal
                    ]
                    [ text "Cancel" ]
                , if isUploading then
                    div [ class "px-6 py-3 flex items-center space-x-2" ]
                        [ viewSpinner ]

                  else
                    button
                        [ class "px-6 py-3 bg-purple-500 text-white text-sm font-medium rounded-lg hover:bg-purple-600 transition-colors duration-200"
                        , onClick UploadCsv
                        , Html.Attributes.disabled (state.file == Nothing)
                        ]
                        [ text "Upload" ]
                ]
            ]
        ]


dropDecoder : (File -> msg) -> Decoder ( msg, Bool )
dropDecoder toMsg =
    Decode.at [ "dataTransfer", "files" ] (Decode.index 0 File.decoder)
        |> Decode.map (\file -> ( toMsg file, True ))


uploadCsv : File -> Bool -> Cmd Msg
uploadCsv file overwriteDuplicates =
    let
        body =
            Http.multipartBody
                [ Http.filePart "file" file
                , Http.stringPart "overwrite_duplicates"
                    (if overwriteDuplicates then
                        "true"

                     else
                        "false"
                    )
                ]
    in
    Http.post
        { url = "/api/contacts/upload"
        , body = body
        , expect = Http.expectJson CsvUploaded uploadResponseDecoder
        }


uploadResponseDecoder : Decode.Decoder UploadResponse
uploadResponseDecoder =
    let
        errorCsvDecoder =
            Decode.oneOf
                [ Decode.string |> Decode.map Just
                , Decode.null Nothing
                ]
    in
    Decode.succeed UploadResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "message" Decode.string
        |> Pipeline.required "error_csv" errorCsvDecoder
        |> Pipeline.required "total_rows" Decode.int
        |> Pipeline.required "error_rows" Decode.int
        |> Pipeline.required "valid_rows" Decode.int


type alias UploadResponse =
    { success : Bool
    , message : String
    , errorCsv : Maybe String
    , totalRows : Int
    , errorRows : Int
    , validRows : Int
    }



-- Add this new subscription function


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch
        [ case model.showModal of
            NoModal ->
                Sub.none

            _ ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))
        , case model.openFilter of
            Just _ ->
                Browser.Events.onMouseDown (Decode.succeed CloseFilterDropdown)

            Nothing ->
                Sub.none
        ]


sortContacts : Maybe SortColumn -> SortDirection -> List Contact -> List Contact
sortContacts maybeColumn direction contacts =
    case maybeColumn of
        Nothing ->
            contacts

        Just column ->
            let
                comparator =
                    case column of
                        FirstNameCol ->
                            \a b -> compare a.firstName b.firstName

                        LastNameCol ->
                            \a b -> compare a.lastName b.lastName

                        EmailCol ->
                            \a b -> compare a.email b.email

                        CarrierCol ->
                            \a b -> compare a.currentCarrier b.currentCarrier

                        PlanTypeCol ->
                            \a b -> compare a.planType b.planType

                        EffectiveDateCol ->
                            \a b -> compare a.effectiveDate b.effectiveDate

                        BirthDateCol ->
                            \a b -> compare a.birthDate b.birthDate

                        TobaccoCol ->
                            \a b ->
                                compare
                                    (if a.tobaccoUser then
                                        1

                                     else
                                        0
                                    )
                                    (if b.tobaccoUser then
                                        1

                                     else
                                        0
                                    )

                        GenderCol ->
                            \a b -> compare a.gender b.gender

                        StateCol ->
                            \a b -> compare a.state b.state

                        ZipCodeCol ->
                            \a b -> compare a.zipCode b.zipCode
            in
            List.sortWith
                (if direction == Ascending then
                    comparator

                 else
                    \a b -> comparator b a
                )
                contacts


filterContacts : Filters -> String -> Time.Posix -> List Contact -> List Contact
filterContacts filters searchQuery currentTime contacts =
    contacts
        |> filterBySearch searchQuery
        |> filterByList .currentCarrier filters.carriers
        |> filterByList .state filters.states
        |> filterByAge filters.ageRange


filterBySearch : String -> List Contact -> List Contact
filterBySearch query contacts =
    if String.isEmpty query then
        contacts

    else
        let
            loweredQuery =
                String.toLower query
        in
        List.filter
            (\contact ->
                String.contains loweredQuery (String.toLower contact.firstName)
                    || String.contains loweredQuery (String.toLower contact.lastName)
                    || String.contains loweredQuery (String.toLower contact.currentCarrier)
            )
            contacts


filterByAge : Maybe ( Int, Int ) -> List Contact -> List Contact
filterByAge maybeRange contacts =
    case maybeRange of
        Nothing ->
            contacts

        Just ( min, max ) ->
            List.filter
                (\contact ->
                    let
                        age =
                            calculateAge contact.birthDate
                    in
                    age >= min && age <= max
                )
                contacts


calculateAge : String -> Int
calculateAge birthDate =
    -- This is a simplified version. You might want to use a proper date library
    2024 - (String.left 4 birthDate |> String.toInt |> Maybe.withDefault 0)


toggleFilter : Filters -> FilterType -> String -> Filters
toggleFilter filters filterType value =
    case filterType of
        CarrierFilter ->
            { filters | carriers = toggleList filters.carriers value }

        StateFilter ->
            { filters | states = toggleList filters.states value }

        AgeFilter ->
            { filters | ageRange = toggleAgeRange filters.ageRange value }


toggleList : List String -> String -> List String
toggleList list value =
    if List.member value list then
        List.filter (\v -> v /= value) list

    else
        value :: list


toggleAgeRange : Maybe ( Int, Int ) -> String -> Maybe ( Int, Int )
toggleAgeRange maybeRange value =
    case maybeRange of
        Nothing ->
            Just ( String.toInt value |> Maybe.withDefault 0, String.toInt value |> Maybe.withDefault 0 )

        Just ( min, max ) ->
            if min == (String.toInt value |> Maybe.withDefault 0) then
                Just ( String.toInt value |> Maybe.withDefault 0, max )

            else if max == (String.toInt value |> Maybe.withDefault 0) then
                Just ( min, String.toInt value |> Maybe.withDefault 0 )

            else
                Just ( min, max )


setAgeFilter : Int -> Int -> Filters -> Filters
setAgeFilter min max filters =
    if max < 1 then
        { filters | ageRange = Nothing }
        -- Don't apply filter if max is 0 or negative

    else
        { filters | ageRange = Just ( min, max ) }



-- Helper function to get unique values from contacts


getUniqueValues : (Contact -> String) -> List Contact -> List String
getUniqueValues getter contacts =
    contacts
        |> List.map getter
        |> List.sort
        |> List.Extra.unique


zipInfoDecoder : Decode.Decoder ZipInfo
zipInfoDecoder =
    Decode.succeed ZipInfo
        |> Pipeline.required "state" Decode.string
        |> Pipeline.required "counties" (Decode.list Decode.string)
        |> Pipeline.required "cities" (Decode.list Decode.string)


filterByList : (Contact -> String) -> List String -> List Contact -> List Contact
filterByList getter selectedValues contacts =
    if List.isEmpty selectedValues then
        contacts

    else
        List.filter
            (\contact ->
                List.member (getter contact) selectedValues
            )
            contacts


viewContactForm : ContactForm -> (ContactFormField -> String -> Msg) -> Msg -> String -> Bool -> Html Msg
viewContactForm form updateMsg submitMsg buttonText isSubmitting =
    Html.form [ onSubmit submitMsg ]
        [ div [ class "grid grid-cols-2 gap-x-8 gap-y-6" ]
            [ viewFormInput "First Name" "text" form.firstName FirstName updateMsg True
            , viewFormInput "Last Name" "text" form.lastName LastName updateMsg True
            , viewFormInput "Email" "email" form.email Email updateMsg True
            , viewFormInput "Current Carrier" "text" form.currentCarrier CurrentCarrier updateMsg True
            , viewFormInput "Plan Type" "text" form.planType PlanType updateMsg True
            , viewFormInput "Effective Date" "date" form.effectiveDate EffectiveDate updateMsg True
            , viewFormInput "Birth Date" "date" form.birthDate BirthDate updateMsg True
            , viewFormSelect "Tobacco User"
                (if form.tobaccoUser then
                    "true"

                 else
                    "false"
                )
                TobaccoUser
                updateMsg
                [ ( "false", "No" )
                , ( "true", "Yes" )
                ]
            , viewFormSelect "Gender"
                form.gender
                Gender
                updateMsg
                [ ( "M", "Male" )
                , ( "F", "Female" )
                ]
            , div [ class "form-group" ]
                [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
                    [ text "ZIP Code" ]
                , Html.input
                    [ type_ "text"
                    , class "w-full px-4 py-3 bg-white border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200"
                    , value form.zipCode
                    , onInput
                        (\zip ->
                            if String.all Char.isDigit zip && String.length zip <= 5 then
                                Batch
                                    [ updateMsg ZipCode zip
                                    , if String.length zip == 5 then
                                        LookupZipCode zip

                                      else
                                        NoOp
                                    ]

                            else
                                NoOp
                        )
                    , required True
                    , Html.Attributes.maxlength 5
                    , Html.Attributes.pattern "[0-9]*"
                    ]
                    []
                ]
            , div [ class "form-group" ]
                [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
                    [ text "State" ]
                , Html.input
                    [ type_ "text"
                    , class "w-full px-4 py-3 bg-gray-100 border-[2.5px] border-gray-200 rounded-lg text-gray-700 cursor-not-allowed"
                    , value form.state
                    , Html.Attributes.disabled True
                    ]
                    []
                ]
            ]
        , div [ class "mt-10 flex justify-end space-x-4" ]
            [ button
                [ type_ "button"
                , onClick CloseModal
                , class "px-6 py-3 bg-white text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200 focus:ring-4 focus:ring-purple-100"
                ]
                [ text "Cancel" ]
            , if isSubmitting then
                div [ class "px-6 py-3 flex items-center space-x-2" ]
                    [ viewSpinner ]

              else
                button
                    [ type_ "submit"
                    , class "px-6 py-3 bg-purple-500 text-white text-sm font-medium rounded-lg hover:bg-purple-600 transition-colors duration-200 focus:ring-4 focus:ring-purple-200"
                    ]
                    [ text buttonText ]
            ]
        ]


viewFormInput : String -> String -> String -> ContactFormField -> (ContactFormField -> String -> Msg) -> Bool -> Html Msg
viewFormInput labelText inputType inputValue field updateMsg isRequired =
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text labelText ]
        , Html.input
            [ type_ inputType
            , class "w-full px-4 py-3 bg-white border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , value inputValue
            , onInput (updateMsg field)
            , required isRequired
            ]
            []
        ]


viewFormSelect : String -> String -> ContactFormField -> (ContactFormField -> String -> Msg) -> List ( String, String ) -> Html Msg
viewFormSelect labelText selectedValue field updateMsg options =
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text labelText ]
        , Html.select
            [ class "w-full px-4 py-3 bg-white border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200 appearance-none"
            , value selectedValue
            , onInput (updateMsg field)
            ]
            (List.map
                (\( val, txt ) ->
                    option [ value val ] [ text txt ]
                )
                options
            )
        ]


deleteContacts : List Int -> Cmd Msg
deleteContacts contactIds =
    Http.request
        { method = "DELETE"
        , headers = []
        , url = "/api/contacts"
        , body = Http.jsonBody (encodeContactIds contactIds)
        , expect = Http.expectJson ContactsDeleted deleteResponseDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


encodeContactIds : List Int -> Encode.Value
encodeContactIds ids =
    Encode.list Encode.int ids


deleteResponseDecoder : Decode.Decoder DeleteResponse
deleteResponseDecoder =
    Decode.succeed DeleteResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "deleted_ids" (Decode.list Decode.int)
        |> Pipeline.required "message" Decode.string


viewSpinner : Html Msg
viewSpinner =
    div [ class "animate-spin rounded-full h-5 w-5 border-2 border-purple-500 border-t-transparent" ] []

================
File: frontend/src/main.ts
================
import './styles.css'
import { Elm } from './Main.elm'

const root = document.querySelector('#app')
if (root) {
  const app = Elm.Main.init({
    node: root,
    flags: {
      apiUrl: 'http://localhost:3000'  // Pass the API URL as a flag
    }
  })

  // Add any ports here if needed
  // app.ports.sendToJs.subscribe((data) => {
  //   console.log('From Elm:', data)
  // })
}

================
File: frontend/src/style.css
================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vanilla:hover {
  filter: drop-shadow(0 0 2em #3178c6aa);
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: frontend/src/styles.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom styles can go here */
.form-group {
  @apply mb-4;
}

/* Add any other custom styles as needed */

================
File: frontend/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: frontend/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: frontend/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx,elm}",
  ],
  theme: {
    extend: {
      colors: {
        'cyber': {
          'primary': '#00fff5',    // Bright cyan
          'secondary': '#ff00ff',  // Magenta
          'accent': '#f700ff',     // Hot pink
          'dark': '#0d1117',       // Deep space black
          'light': '#1c1c1c',      // Lighter black
          'error': '#ff0044',      // Neon red
          'success': '#00ff9f',    // Neon green
          'text': '#ffffff',       // White text
          'muted': '#8b8b8b',      // Muted text
        },
        'gradient': {
          'start': '#00fff5',
          'end': '#ff00ff',
        }
      },
      boxShadow: {
        'cyber': '0 0 10px rgba(0, 255, 245, 0.3)',
        'cyber-hover': '0 0 20px rgba(0, 255, 245, 0.5)',
        'cyber-error': '0 0 10px rgba(255, 0, 68, 0.3)',
      },
      animation: {
        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
      }
    },
  },
  plugins: [],
}

================
File: frontend/vite.config.ts
================
import { defineConfig } from 'vite'
import elmPlugin from 'vite-plugin-elm'
import path from 'path'

export default defineConfig({
  plugins: [elmPlugin()],
  css: {
    postcss: {
      plugins: [
        (await import('tailwindcss')).default,
        (await import('autoprefixer')).default,
      ],
    },
  },
  resolve: {
    extensions: ['.ts', '.js', '.elm']
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
        secure: false,
        configure: (proxy, _options) => {
          proxy.on('error', (err) => {
            console.log('proxy error', err);
          });
          proxy.on('proxyReq', (proxyReq) => {
            console.log('Sending Request:', proxyReq.method, proxyReq.path);
          });
          proxy.on('proxyRes', (proxyRes) => {
            console.log('Received Response:', proxyRes.statusCode);
          });
        }
      }
    }
  },
  build: {
    outDir: '../dist',
    emptyOutDir: true,
    assetsDir: 'assets',
    rollupOptions: {
      input: {
        main: path.resolve(__dirname, 'index.html')
      }
    }
  }
})

================
File: migrations/001_initial.sql
================
CREATE TABLE IF NOT EXISTS contacts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    current_carrier TEXT NOT NULL,
    plan_type TEXT NOT NULL,
    effective_date DATE NOT NULL,
    birth_date DATE NOT NULL,
    tobacco_user BOOLEAN NOT NULL DEFAULT FALSE,
    gender TEXT CHECK(gender IN ('M', 'F')) NOT NULL,
    state TEXT NOT NULL,
    zip_code TEXT NOT NULL,
    last_emailed_date DATE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Trigger to update the updated_at timestamp
CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp 
AFTER UPDATE ON contacts
BEGIN
    UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
END;

================
File: migrations/002_add_email_and_agents.sql
================
-- Create agents table
CREATE TABLE IF NOT EXISTS agents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    phone TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Create trigger for agents updated_at
CREATE TRIGGER IF NOT EXISTS update_agents_timestamp 
AFTER UPDATE ON agents
BEGIN
    UPDATE agents SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
END;

-- Create temporary table with new schema
CREATE TABLE contacts_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL,
    current_carrier TEXT NOT NULL,
    plan_type TEXT NOT NULL,
    effective_date DATE NOT NULL,
    birth_date DATE NOT NULL,
    tobacco_user BOOLEAN NOT NULL DEFAULT FALSE,
    gender TEXT CHECK(gender IN ('M', 'F')) NOT NULL,
    state TEXT NOT NULL,
    zip_code TEXT NOT NULL,
    agent_id INTEGER,
    last_emailed_date DATE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (agent_id) REFERENCES agents(id)
);

-- Copy existing data with generated email addresses
INSERT INTO contacts_new (
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, tobacco_user,
    gender, state, zip_code, last_emailed_date, created_at,
    updated_at
)
SELECT 
    id, first_name, last_name,
    lower(first_name || '.' || last_name || '@example.com') as email,
    current_carrier, plan_type, effective_date, birth_date,
    tobacco_user, gender, state, zip_code, last_emailed_date,
    created_at, updated_at
FROM contacts;

-- Drop old table and rename new one
DROP TABLE contacts;
ALTER TABLE contacts_new RENAME TO contacts;

-- Recreate the updated_at trigger for contacts
CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp 
AFTER UPDATE ON contacts
BEGIN
    UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
END;

-- Create indexes
CREATE INDEX idx_contacts_email ON contacts(email);
CREATE INDEX idx_contacts_agent_id ON contacts(agent_id);
CREATE INDEX idx_agents_email ON agents(email);

================
File: scripts/setup_db.py
================
import os
from pathlib import Path
from dotenv import load_dotenv
from db.database import db

# Get the project root directory
BASE_DIR = Path(__file__).resolve().parent.parent

# Load environment variables from .env file in project root
load_dotenv(BASE_DIR / '.env')

def run_migrations():
    print(f"Using database URL: {os.getenv('TURSO_DATABASE_URL')}")  # Debug print
    
    # Read and execute migration files
    migrations_dir = BASE_DIR / "migrations"
    for migration_file in sorted(migrations_dir.glob("*.sql")):
        print(f"Running migration: {migration_file.name}")
        with open(migration_file) as f:
            migration_sql = f.read()
            db.execute(migration_sql)

if __name__ == "__main__":
    run_migrations()

================
File: static/css/main.css
================
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');

body {
  font-family: 'Space Grotesk', system-ui, sans-serif;
}

/* Table styles */
.table-header {
  padding: 0.75rem 1rem;
  text-align: left;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: uppercase;
  color: #6b7280;
}

.table-cell {
  padding: 0.75rem 1rem;
  font-size: 0.875rem;
  color: #111827;
}

/* Icon button styles */
.action-icon-btn {
  color: #9ca3af;
  transition: color 0.2s;
}

.action-icon-btn:hover {
  color: #8b5cf6;
}

================
File: .gitignore
================
.env

================
File: .python-version
================
3.13

================
File: example.env
================
# Turso Database
TURSO_DATABASE_URL="libsql://your-database-name.turso.io"  # Get this from: turso db show your-database-name --url
TURSO_AUTH_TOKEN="your-auth-token"  # Get this from: turso db tokens create your-database-name

# SendGrid (for email functionality)
SENDGRID_API_KEY="your-sendgrid-api-key"
SENDGRID_FROM_EMAIL="your-sender@email.com"

================
File: hello.py
================
def main():
    print("Hello from medicare-portal!")


if __name__ == "__main__":
    main()

This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/node_modules/, **/zipData.json, public/, frontend/backup/, **/public
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  mcp.json
backend/
  data/
    migrations/
      003_add_tracking_clicks.sql
      004_fix_tracking_clicks.sql
    plans.json
  migrations/
    007-pending-signups-table.sql
    20240324_create_contacts_table.sql
    20240324_optimize_contacts.sql
    20240325_fix_missing_updated_at.sql
    20240326_create_waitlist_table.sql
    20240326_deduplicate_contacts.sql
    20240326_fix_contact_email_unique.sql
    20240326_fix_duplicate_contacts.sql
    20240402_allow_null_current_carrier.sql
    20240406_add_contact_history_tracking.sql
    20250425_create_schema_no_contacts.sql
    20250425_fix_schema_with_contacts.sql
    20250425_make_optional_fields_nullable.sql
    add_aep_request_columns.sql
    add_deleted_contacts_table.sql
    add_email_tracking.sql
    add_onboarding_columns.sql
    add_send_time_col.sql
    add_updated_at_col.sql
    create_subscription_tables.sql
    fix_email_tracking.sql
    remove_eligibility_answers_fk.sql
  scripts/
    add-agent.ts
    apply-contact-migration.ts
    generate-test-data.ts
    generateQuoteId.ts
    generateQuoteUrl.ts
    manage-recommendations.ts
    manage-turso.ts
    migrate-tracking-clicks.js
    sample-contacts.csv
    setup-contact-tracking.sh
    test-bulk-import.ts
  sql/
    add_demo_mode_column.sql
    create_tables.sql
    update_org_limits.sql
    update_org_schema.sql
  src/
    config/
      index.ts
      turso.ts
    middleware/
      account-status.ts
      auth.copy.ts
      auth.ts
      error.ts
    routes/
      admin-portal.ts
      admin.ts
      auth.ts
      billing.ts
      brand.ts
      contact.ts
      contacts.ts
      contactTracking.ts
      dashboard.ts
      eligibility.ts
      onboarding.ts
      organizations.ts
      quotes.ts
      schedule.ts
      self-service.ts
      settings.ts
      signup.ts
      stage-demo.ts
      stripe.ts
      waitlist.ts
    scripts/
      apply_nullable_fields_migration.ts
      apply_org_migrations.ts
      migrate-add-aep-columns.ts
    services/
      agentSettings.ts
      auth.ts
      contactCount.ts
      contactTracking.ts
      email.ts
      stripe.ts
      subscription.ts
      turso.ts
      unifiedDatabase.ts
    utils/
      quoteId.ts
      tracking.ts
    config.ts
    database.ts
    errors.ts
    index.ts
    logger.ts
    types.ts
  .env.example
  .gitignore
  BULK-IMPORT-IMPLEMENTATION.md
  out.txt
  package.json
  README-bulk-import.md
  README.md
  tsconfig.json
docs/
  contact-tracking.md
  stripe-setup.md
frontend/
  src/
    assets/
      checkbox.svg
    Components/
      AccountStatusBanner.elm
      DemoModeBanner.elm
      LimitBanner.elm
      ProgressIndicator.elm
      SetupLayout.elm
    Utils/
      DiscountDescription.elm
      DiscountDescription.md
      Formatters.elm
      MyDate.elm
      QuoteHeader.elm
      RandomOrgName.elm
      UrlStuff.elm
    Accept.elm
    AddAgent.elm
    AgeCalc.elm
    BirthdayRules.elm
    Calculator.elm
    CarrierNaic.elm
    ChangePlan.elm
    chart-animations.ts
    ChoosePlan.elm
    Compare.elm
    Contact.elm
    Contacts.elm
    ContactUs.elm
    CsvProcessor.elm
    Dashboard.elm
    Decline.elm
    Earnings.elm
    Eligibility.elm
    EmailScheduler.elm
    Home.elm
    Landing.elm
    Login.elm
    Logout.elm
    Main.elm
    main.ts
    MyIcon.elm
    Onboarding.elm
    Ports.elm
    PriceModel.elm
    Pricing.elm
    Pricing2.elm
    Profile.elm
    Quote.elm
    QuoteBirthdayRules.elm
    Schedule.elm
    ScheduleMain.elm
    SelfServiceOnboarding.elm
    Settings.elm
    Signup.elm
    StageDemoCTA.elm
    StageDemoData.elm
    StageDemoHealth.elm
    StageDemoInput.elm
    StageDemoQuote.elm
    StageDemoQuote.elm.backup
    StateRegions.elm
    stripe-integration.d.ts
    stripe-integration.js
    stripe-integration.ts
    Stripe.elm
    styles.css
    Subscription.elm
    TempLanding.elm
    typescript.svg
    vite-env.d.ts
    Waitlist.elm
    Walkthrough.elm
  .gitignore
  elm-test.html
  elm.json
  index.html
  package.json
  tailwind.config.js.copy
  temp_bracket.txt
  tsconfig.json
  vite.config.ts
migrations/
  0005_add_org_slug.sql
  0005_fresh_start.sql
  0006_add_agent_settings.sql
  0006_add_demo_user.sql
  0007_organization_and_agent_settings.sql
  0007_verify_user.sql
  0008_recommended_state_carrier_settings.sql
  0009_carriers_table.sql
  0009_organization_turso_databases.sql
  0010_add_user_names.sql
  0011_remove_verification_tokens.sql
  0012_default_user_active.sql
  0013_add_org_updated_at.sql
  0014_add_phone_to_users.sql
  0015_update_user_roles.sql
  0016_fix_schema.sql
  0017_update_user_roles.sql
  0018_brand_settings.sql
  0019_add_user_role_booleans.sql
  002_add_email_and_agents.sql
  0020_fix_user_roles.sql
  0021_add_carrier_aliases.sql
  0022_add_subscription_status.sql
  0025_add_default_agent.sql
  0026_add_booking_link_to_users.sql
  0027_add_signature_to_users.sql
  20240227_add_aep_request_columns.sql
  20240325_fix_contacts_status.sql
  20250329_fix_email_unique_constraint.sql
  20250407_add_usage_based_subscription_fields.sql
  add_agent_settings_to_user.sql
  add_email_unique_index.sql
  add_turso_connection_optimization.sql
  contact_001.sql
  contact_002.sql
  contact_003.sql
  contact_004.sql
  contact_005.sql
  show_org.sql
  verify_schema.sql
scripts/
  apply_contact_schema_fix.sh
  apply_migration_to_orgs.sh
  check_user_fks.sh
  migrate-to-sqlite.ts
  setup_db.py
static/
  css/
    main.css
.cursorrules
.gitignore
.python-version
.replit
add_protected_route.txt
bun.lock
CLAUDE.md
cookies.txt
diff.txt
example.env
fix_elm.py
hardcode_quote.json
hello.py
Household Discounts Cheatsheet - HHD Simple.csv
msg.md
output.txt
package.json
port-example.js
replit.nix
sensitive-paths.txt
svgo-config.js
svgo.config.yml
tailwind.config.js
test_billing_endpoints.sh
todo.txt
w2.csv
ws.csv

================================================================
Files
================================================================

================
File: .cursor/mcp.json
================
{
    "mcpServers": {
        "figma-developer-mcp": {
            "url": "http://localhost:3333/sse"
        },
        "browser-tools": {
            "command": "bunx",
            "args": [
                "@agentdeskai/browser-tools-mcp@1.2.0"
            ]
        },
        "claude-code": {
            "command": "claude",
            "args": [
                "mcp",
                "serve"
            ],
            "env": {}
        },
        "mcp-turso-cloud": {
            "command": "bunx",
            "args": [
                "-y",
                "mcp-turso-cloud"
            ],
            "env": {
                "TURSO_API_TOKEN": "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJFZmlQZk9YV0VlLTBMVDR2OGtFcVZnIn0.w-zrnF1rC4cx-SP67c7PxwN1z6C9uVmmXcW_hf62nslf8PSoCq0N_XCd7RHN6Chqups5HciIDqsAWL076WaOCQ",
                "TURSO_ORGANIZATION": "pyrex41",
                "TURSO_DEFAULT_DATABASE": "main-max"
            }
        },
        "stripe": {
            "command": "bunx",
            "args": [
                "-y",
                "@stripe/mcp",
                "--tools=all"
            ],
            "env": {
                "STRIPE_SECRET_KEY": "sk_test_51Qyh7RCBUPXAZKNGFySALjap1pDAtEwPtuY5TAzEuKKDq7cfAmHhmQIn8W1UMf2CuOvQ1umjiUrlpPauOc159fpM00nfohCZH3"
            }
        }
    }
}

================
File: backend/data/migrations/003_add_tracking_clicks.sql
================
-- Migration: 003_add_tracking_clicks.sql
-- Description: Adds tracking_clicks table for link click tracking
-- Date: 2023-08-30

-- Create the tracking_clicks table if it doesn't exist
CREATE TABLE IF NOT EXISTS tracking_clicks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  tracking_id TEXT NOT NULL,
  path TEXT NOT NULL,
  query TEXT,
  contact_id INTEGER,
  ip_address TEXT,
  user_agent TEXT, 
  referrer TEXT,
  clicked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Create indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_tracking_clicks_tracking_id ON tracking_clicks(tracking_id);
CREATE INDEX IF NOT EXISTS idx_tracking_clicks_contact_id ON tracking_clicks(contact_id);
CREATE INDEX IF NOT EXISTS idx_tracking_clicks_clicked_at ON tracking_clicks(clicked_at);

-- Add versioning information to track that this migration has been applied

================
File: backend/data/migrations/004_fix_tracking_clicks.sql
================
-- Add quote_id column if it doesn't exist
ALTER TABLE tracking_clicks ADD COLUMN quote_id TEXT;

-- Create a new table with the desired structure
CREATE TABLE tracking_clicks_new (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  tracking_id TEXT NOT NULL,
  contact_id INTEGER,
  quote_id TEXT,
  clicked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Copy data from the old table to the new table
INSERT INTO tracking_clicks_new (id, tracking_id, contact_id, quote_id, clicked_at)
SELECT id, tracking_id, contact_id, quote_id, clicked_at FROM tracking_clicks;

-- Drop the old table
DROP TABLE tracking_clicks;

-- Rename the new table to the original name
ALTER TABLE tracking_clicks_new RENAME TO tracking_clicks;

-- Recreate the indexes
CREATE INDEX idx_tracking_clicks_tracking_id ON tracking_clicks(tracking_id);
CREATE INDEX idx_tracking_clicks_contact_id ON tracking_clicks(contact_id);
CREATE INDEX idx_tracking_clicks_clicked_at ON tracking_clicks(clicked_at);

================
File: backend/data/plans.json
================
[{"naic":"20699","group":-1,"company_name":"Ace Prop & Cas Ins Co","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":13958,"discount_rate":12981,"discount_category":"Roommate"}]},{"naic":"20699","group":-1,"company_name":"Ace Prop & Cas Ins Co","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":10575,"discount_rate":9835,"discount_category":"Roommate"}]},{"naic":"60380","group":-1,"company_name":"AFLAC","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":15756,"discount_rate":14180,"discount_category":"Roommate"}]},{"naic":"60380","group":-1,"company_name":"AFLAC","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":12196,"discount_rate":10976,"discount_category":"Roommate"}]},{"naic":"60984","group":-1,"company_name":"Humana Insurance Company","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":14944,"discount_rate":13152,"discount_category":"Roommate"}]},{"naic":"60984","group":-1,"company_name":"Humana Insurance Company","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":11321,"discount_rate":9962,"discount_category":"Roommate"}]},{"naic":"67369","group":-1,"company_name":"Cigna Hlth & Life Ins Co","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":12394,"discount_rate":11650,"discount_category":"Multi-Insured / Roommate"}]},{"naic":"67369","group":-1,"company_name":"Cigna Hlth & Life Ins Co","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":9011,"discount_rate":8470,"discount_category":"Multi-Insured / Roommate"}]},{"naic":"68500","group":-1,"company_name":"Continental Life Ins Co Brentwood","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":15277,"discount_rate":14208,"discount_category":"Multi-Insured"}]},{"naic":"68500","group":-1,"company_name":"Continental Life Ins Co Brentwood","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":11087,"discount_rate":10311,"discount_category":"Multi-Insured"}]},{"naic":"73288","group":-1,"company_name":"Humana Ins Co","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":26558,"discount_rate":25230,"discount_category":"Multi-Insured"}]},{"naic":"73288","group":-1,"company_name":"Humana Ins Co","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":20720,"discount_rate":19684,"discount_category":"Multi-Insured"}]},{"naic":"79413","group":-1,"company_name":"UnitedHealthcare Ins Co","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":21317,"discount_rate":20251,"discount_category":"Multi-Insured"}]},{"naic":"79413","group":-1,"company_name":"UnitedHealthcare Ins Co","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":19670,"discount_rate":18686,"discount_category":"Multi-Insured"}]},{"naic":"82538","group":-1,"company_name":"Allstate Health Solutions","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":15138,"discount_rate":14079,"discount_category":"Multi-Insured / Roommate"}]},{"naic":"82538","group":-1,"company_name":"Allstate Health Solutions","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":10976,"discount_rate":10208,"discount_category":"Multi-Insured / Roommate"}]}]

================
File: backend/migrations/007-pending-signups-table.sql
================
-- Create pending_signups table to store user information temporarily during signup
CREATE TABLE IF NOT EXISTS pending_signups (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  organization_id INTEGER NOT NULL,
  first_name TEXT NOT NULL,
  last_name TEXT,
  email TEXT NOT NULL,
  created_at TEXT NOT NULL,
  FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE
);

-- Add index for faster lookups
CREATE INDEX IF NOT EXISTS idx_pending_signups_org_id ON pending_signups(organization_id);
CREATE INDEX IF NOT EXISTS idx_pending_signups_email ON pending_signups(email);

================
File: backend/migrations/20240324_create_contacts_table.sql
================
-- Create contacts table if it doesn't exist
CREATE TABLE IF NOT EXISTS contacts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT NOT NULL,
  current_carrier TEXT NOT NULL,
  plan_type TEXT NOT NULL,
  effective_date TEXT NOT NULL,
  birth_date TEXT NOT NULL,
  tobacco_user INTEGER NOT NULL,
  gender TEXT NOT NULL,
  state TEXT NOT NULL,
  zip_code TEXT NOT NULL,
  agent_id INTEGER,
  last_emailed DATETIME,
  phone_number TEXT NOT NULL DEFAULT '',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Add indexes for common queries
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_current_carrier ON contacts(current_carrier);
CREATE INDEX IF NOT EXISTS idx_contacts_effective_date ON contacts(effective_date);

-- Add unique constraint on email
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

================
File: backend/migrations/20240324_optimize_contacts.sql
================
-- Optimize contacts table performance

-- Add missing columns if they don't exist
SELECT CASE 
    WHEN NOT EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'created_at') 
    THEN 'ALTER TABLE contacts ADD COLUMN created_at DATETIME DEFAULT CURRENT_TIMESTAMP;'
    ELSE 'SELECT 1;'
END AS sql_to_run;

SELECT CASE 
    WHEN NOT EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'updated_at') 
    THEN 'ALTER TABLE contacts ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP;'
    ELSE 'SELECT 1;'
END AS sql_to_run;

SELECT CASE 
    WHEN NOT EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'last_emailed') 
    THEN 'ALTER TABLE contacts ADD COLUMN last_emailed DATETIME;'
    ELSE 'SELECT 1;'
END AS sql_to_run;

-- Add core indexes that should work on all databases
-- Email is guaranteed to exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts (email COLLATE NOCASE);

-- Agent ID is guaranteed to exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts (agent_id);

-- Add carrier index which should exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_agent_carrier ON contacts (agent_id, current_carrier COLLATE NOCASE);

-- Add state index which should exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts (state COLLATE NOCASE);

-- Add plan type index which should exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_plan_type ON contacts (plan_type COLLATE NOCASE);

-- Add tobacco user index which should exist as it's a core field
CREATE INDEX IF NOT EXISTS idx_contacts_tobacco_user ON contacts (tobacco_user);

-- Add timestamp indexes only if columns exist
SELECT CASE 
    WHEN EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'created_at') 
    THEN 'CREATE INDEX IF NOT EXISTS idx_contacts_created_at ON contacts (created_at);'
    ELSE 'SELECT 1;'
END AS sql_to_run;

SELECT CASE 
    WHEN EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'updated_at') 
    THEN 'CREATE INDEX IF NOT EXISTS idx_contacts_updated_at ON contacts (updated_at);'
    ELSE 'SELECT 1;'
END AS sql_to_run;

SELECT CASE 
    WHEN EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'last_emailed') 
    THEN 'CREATE INDEX IF NOT EXISTS idx_contacts_last_emailed ON contacts (last_emailed);'
    ELSE 'SELECT 1;'
END AS sql_to_run;

-- Add date field indexes which should exist as they're core fields
CREATE INDEX IF NOT EXISTS idx_contacts_birth_date ON contacts (birth_date);
CREATE INDEX IF NOT EXISTS idx_contacts_effective_date ON contacts (effective_date);

-- Create a view for contact statistics that works with core fields only
CREATE VIEW IF NOT EXISTS v_contact_stats AS
WITH contact_metrics AS (
    SELECT 
        agent_id,
        current_carrier,
        state,
        COUNT(*) as total_contacts,
        SUM(CASE WHEN tobacco_user = 1 THEN 1 ELSE 0 END) as tobacco_users,
        SUM(CASE WHEN plan_type IS NOT NULL THEN 1 ELSE 0 END) as with_plan_type
    FROM contacts
    GROUP BY agent_id, current_carrier, state
)
SELECT 
    cm.*,
    (SELECT COUNT(DISTINCT current_carrier) FROM contacts WHERE agent_id = cm.agent_id) as unique_carriers,
    (SELECT COUNT(DISTINCT state) FROM contacts WHERE agent_id = cm.agent_id) as unique_states
FROM contact_metrics cm;

================
File: backend/migrations/20240325_fix_missing_updated_at.sql
================
-- Check if updated_at column exists, if not add it
PRAGMA foreign_keys=off;

BEGIN TRANSACTION;

-- Create a temporary table with the same structure plus the updated_at column
CREATE TABLE IF NOT EXISTS contacts_new (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT NOT NULL,
  current_carrier TEXT NOT NULL,
  plan_type TEXT NOT NULL,
  effective_date TEXT NOT NULL,
  birth_date TEXT NOT NULL,
  tobacco_user INTEGER NOT NULL,
  gender TEXT NOT NULL,
  state TEXT NOT NULL,
  zip_code TEXT NOT NULL,
  agent_id INTEGER,
  last_emailed DATETIME,
  phone_number TEXT NOT NULL DEFAULT '',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Copy data from the old table to the new table
INSERT INTO contacts_new 
SELECT 
  id, 
  first_name, 
  last_name, 
  email, 
  current_carrier, 
  plan_type, 
  effective_date, 
  birth_date, 
  tobacco_user, 
  gender, 
  state, 
  zip_code, 
  agent_id, 
  last_emailed, 
  phone_number, 
  COALESCE(created_at, CURRENT_TIMESTAMP),
  CURRENT_TIMESTAMP
FROM contacts;

-- Drop the old table
DROP TABLE contacts;

-- Rename the new table to the original name
ALTER TABLE contacts_new RENAME TO contacts;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_current_carrier ON contacts(current_carrier);
CREATE INDEX IF NOT EXISTS idx_contacts_effective_date ON contacts(effective_date);
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

COMMIT;

PRAGMA foreign_keys=on;

================
File: backend/migrations/20240326_create_waitlist_table.sql
================
-- Create waitlist table
CREATE TABLE IF NOT EXISTS waitlist (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    phone TEXT NOT NULL,
    num_agents INTEGER NOT NULL,
    book_size INTEGER NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Create index on email for faster lookups
CREATE INDEX IF NOT EXISTS idx_waitlist_email ON waitlist(email);

-- Create trigger to update updated_at timestamp
CREATE TRIGGER IF NOT EXISTS tg_waitlist_updated_at 
    AFTER UPDATE ON waitlist
    FOR EACH ROW
BEGIN
    UPDATE waitlist 
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = NEW.id;
END;

================
File: backend/migrations/20240326_deduplicate_contacts.sql
================
-- Migration to deduplicate contacts and ensure unique email constraint works properly
-- This script will:
-- 1. Check for duplicate emails
-- 2. Back up the existing contacts table
-- 3. Deduplicate contacts by keeping the most recently updated record for each email
-- 4. Create the unique index to prevent future duplicates

-- Print counts before
SELECT COUNT(*) as total_contacts_before FROM contacts;
SELECT COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as duplicate_emails FROM contacts;

-- Check if we already have a unique index on email
SELECT COUNT(*) as has_unique_index FROM sqlite_master 
WHERE type='index' AND name='idx_contacts_email_unique';

-- Create a backup of the original table for safety
DROP TABLE IF EXISTS contacts_backup;
CREATE TABLE contacts_backup AS SELECT * FROM contacts;

-- Only proceed with deduplication if there are duplicates
CREATE TABLE contacts_temp AS
SELECT * FROM (
  SELECT id, first_name, last_name, email, current_carrier, plan_type, effective_date,
         birth_date, tobacco_user, gender, state, zip_code, agent_id, last_emailed,
         phone_number, created_at, updated_at,
         ROW_NUMBER() OVER (PARTITION BY LOWER(TRIM(email)) ORDER BY updated_at DESC) as rn
  FROM contacts
) WHERE rn = 1;

-- Drop any existing unique index on email before we drop the table
DROP INDEX IF EXISTS idx_contacts_email_unique;
DROP INDEX IF EXISTS idx_contacts_email;

-- Drop original table
DROP TABLE contacts;

-- Rename the deduped table to contacts
ALTER TABLE contacts_temp RENAME TO contacts;

-- Recreate the primary key
CREATE UNIQUE INDEX sqlite_autoindex_contacts_1 ON contacts(id);

-- Add unique index on email with case and whitespace insensitivity
CREATE UNIQUE INDEX idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

-- Add other helpful indexes
CREATE INDEX idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);

-- Print counts after
SELECT COUNT(*) as total_contacts_after FROM contacts;

-- Verify indexes
SELECT name FROM sqlite_master WHERE type='index' AND tbl_name='contacts';

================
File: backend/migrations/20240326_fix_contact_email_unique.sql
================
-- Migration to deduplicate contacts and ensure unique email constraint works properly

-- Print counts before
SELECT COUNT(*) as total_contacts_before FROM contacts;
SELECT COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as duplicate_emails FROM contacts;

-- Check if we already have a unique index on email
SELECT COUNT(*) as has_unique_index FROM sqlite_master 
WHERE type='index' AND name='idx_contacts_email_unique';

-- Only proceed with deduplication if there are duplicates
CREATE TABLE IF NOT EXISTS contacts_temp AS
SELECT * FROM (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY LOWER(TRIM(email)) ORDER BY updated_at DESC) as rn
  FROM contacts
) WHERE rn = 1;

-- Drop any existing unique index on email before we drop the table
DROP INDEX IF EXISTS idx_contacts_email_unique;

-- Create a backup of the original table for safety
CREATE TABLE contacts_backup AS SELECT * FROM contacts;

-- Drop original table
DROP TABLE contacts;

-- Rename the deduped table to contacts
ALTER TABLE contacts_temp RENAME TO contacts;

-- Recreate the primary key
CREATE UNIQUE INDEX sqlite_autoindex_contacts_1 ON contacts(id);

-- Add unique index on email with case and whitespace insensitivity
CREATE UNIQUE INDEX idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

-- Add other helpful indexes
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);

-- Print counts after
SELECT COUNT(*) as total_contacts_after FROM contacts;

================
File: backend/migrations/20240326_fix_duplicate_contacts.sql
================
-- Migration to ensure unique index on email in contacts table
-- Run this script on all organization databases to prevent duplicate contacts

-- First check if we have duplicates
SELECT COUNT(*) as total_contacts FROM contacts;
SELECT COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as duplicate_emails FROM contacts;

-- Check if we already have the unique index on email
SELECT COUNT(*) as has_unique_index FROM sqlite_master 
WHERE type='index' AND name='idx_contacts_email_unique';

-- Create unique index if it doesn't exist 
-- (This will fail if there are duplicate emails, so run the deduplication process first)
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

-- Create or update the standard index
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);

-- Force indexes to be used by SQLite
ANALYZE;

-- Verify index creation
SELECT name FROM sqlite_master WHERE type='index' AND tbl_name='contacts';

================
File: backend/migrations/20240402_allow_null_current_carrier.sql
================
-- Migration to allow NULL values in current_carrier, plan_type and add current_premium column
-- This migration needs to be applied to all organization databases

-- Create a temporary table with the desired schema
CREATE TABLE contacts_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    current_carrier TEXT, -- Changed to allow NULL
    current_premium TEXT, -- New column, allows NULL
    plan_type TEXT, -- Changed to allow NULL
    effective_date TEXT NOT NULL,
    birth_date TEXT NOT NULL,
    tobacco_user INTEGER NOT NULL,
    gender TEXT NOT NULL,
    state TEXT NOT NULL,
    zip_code TEXT NOT NULL,
    agent_id INTEGER,
    last_emailed DATETIME,
    phone_number TEXT NOT NULL DEFAULT '',
    status TEXT NOT NULL DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Copy data from the old table to the new table
INSERT INTO contacts_new 
SELECT 
    id,
    first_name,
    last_name,
    email,
    current_carrier,
    NULL as current_premium, -- Set existing rows to NULL for new column
    plan_type,
    effective_date,
    birth_date,
    tobacco_user,
    gender,
    state,
    zip_code,
    agent_id,
    last_emailed,
    phone_number,
    status,
    created_at,
    updated_at
FROM contacts;

-- Drop the old table
DROP TABLE contacts;

-- Rename the new table to contacts
ALTER TABLE contacts_new RENAME TO contacts;

-- Recreate any indexes that existed on the original table
CREATE UNIQUE INDEX idx_contacts_email ON contacts(email);
CREATE INDEX idx_contacts_zip_code ON contacts(zip_code);
CREATE INDEX idx_contacts_state ON contacts(state);
CREATE INDEX idx_contacts_created_at ON contacts(created_at);
CREATE INDEX idx_contacts_updated_at ON contacts(updated_at);

================
File: backend/migrations/20240406_add_contact_history_tracking.sql
================
-- Migration: 20240406_add_contact_history_tracking.sql
-- Description: Adds contact history tracking table for usage-based billing

-- Create table to track unique contacts by email for billing purposes
CREATE TABLE IF NOT EXISTS contact_history (
  id TEXT PRIMARY KEY,
  organization_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  email TEXT NOT NULL,
  first_name TEXT,
  last_name TEXT,
  first_uploaded TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_uploaded TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  status TEXT DEFAULT 'active', -- active, deleted, blocked
  billing_cycle_key TEXT, -- To identify which billing cycle this contact belongs to
  UNIQUE(organization_id, email)
);

-- Add indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_contact_history_org_email ON contact_history(organization_id, email);
CREATE INDEX IF NOT EXISTS idx_contact_history_org_user ON contact_history(organization_id, user_id);
CREATE INDEX IF NOT EXISTS idx_contact_history_first_uploaded ON contact_history(first_uploaded);
CREATE INDEX IF NOT EXISTS idx_contact_history_billing_cycle ON contact_history(organization_id, billing_cycle_key);

-- Add tracking fields to organizations table if they don't exist
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS contact_count_billing_date TEXT; -- Date when billing cycle starts (e.g., '01' for 1st of month)
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS current_billing_cycle_key TEXT; -- Current billing cycle identifier
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS current_unique_contacts INTEGER DEFAULT 0; -- Count of unique contacts in current cycle

-- Create table to track billing cycle history
CREATE TABLE IF NOT EXISTS billing_cycle_history (
  id TEXT PRIMARY KEY,
  organization_id TEXT NOT NULL,
  cycle_key TEXT NOT NULL, -- Format: YYYY-MM for monthly cycles
  start_date TIMESTAMP NOT NULL,
  end_date TIMESTAMP NOT NULL,
  contact_count INTEGER DEFAULT 0,
  usage_reported BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(organization_id, cycle_key)
);

-- Create a trigger to update last_uploaded timestamp when existing contacts are re-uploaded
CREATE TRIGGER IF NOT EXISTS update_contact_last_uploaded
AFTER UPDATE ON contact_history
BEGIN
  UPDATE contact_history
  SET last_uploaded = CURRENT_TIMESTAMP
  WHERE id = NEW.id AND OLD.email = NEW.email;
END;

-- Create a function to generate a new billing cycle key
CREATE FUNCTION IF NOT EXISTS generate_billing_cycle_key(date_string TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN to_char(date_string::date, 'YYYY-MM');
END;
$$ LANGUAGE plpgsql;

================
File: backend/migrations/20250425_create_schema_no_contacts.sql
================
-- Migration for databases WITHOUT an existing contacts table
-- This script creates the contacts table with nullable fields

-- Drop any temporary tables that might exist
DROP TABLE IF EXISTS contacts_new;

-- Create contacts table with the correct schema
CREATE TABLE IF NOT EXISTS contacts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    current_carrier TEXT, 
    current_premium TEXT, 
    plan_type TEXT, 
    effective_date TEXT, 
    birth_date TEXT, 
    tobacco_user INTEGER NOT NULL DEFAULT 0,
    gender TEXT, 
    state TEXT, 
    zip_code TEXT, 
    agent_id INTEGER,
    last_emailed DATETIME,
    phone_number TEXT, 
    status TEXT NOT NULL DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Check if contacts_backup exists before trying to access it
CREATE TEMP TABLE IF NOT EXISTS table_check AS
SELECT EXISTS(SELECT 1 FROM sqlite_master WHERE type='table' AND name='contacts_backup') as has_contacts_backup;

-- If contacts_backup exists, check its columns
CREATE TEMP TABLE IF NOT EXISTS column_check AS
SELECT 
    CASE WHEN (SELECT has_contacts_backup FROM table_check) = 1 THEN
        EXISTS(SELECT 1 FROM pragma_table_info('contacts_backup') WHERE name='current_premium')
    ELSE 0 END as has_current_premium,
    CASE WHEN (SELECT has_contacts_backup FROM table_check) = 1 THEN
        EXISTS(SELECT 1 FROM pragma_table_info('contacts_backup') WHERE name='plan_type')
    ELSE 0 END as has_plan_type;

-- Copy data from contacts_backup if it exists
INSERT OR IGNORE INTO contacts(
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, tobacco_user, gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    status, created_at, updated_at
)
SELECT 
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, COALESCE(tobacco_user, 0), gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    COALESCE(status, ''), COALESCE(created_at, CURRENT_TIMESTAMP), 
    COALESCE(updated_at, CURRENT_TIMESTAMP)
FROM contacts_backup WHERE EXISTS(SELECT 1 FROM sqlite_master WHERE type='table' AND name='contacts_backup');

-- Clean up temp tables
DROP TABLE IF EXISTS table_check;
DROP TABLE IF EXISTS column_check;

-- Create indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_zip_code ON contacts(zip_code);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_created_at ON contacts(created_at);
CREATE INDEX IF NOT EXISTS idx_contacts_updated_at ON contacts(updated_at);
CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp AFTER UPDATE ON contacts 
BEGIN 
  UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; 
END;

================
File: backend/migrations/20250425_fix_schema_with_contacts.sql
================
-- Migration for databases WITH existing contacts table
-- This script makes optional fields nullable

-- Clean up any temporary tables from previous failed migrations
DROP TABLE IF EXISTS contacts_new;

-- Create new contacts table with the desired schema
CREATE TABLE contacts_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    current_carrier TEXT, 
    current_premium TEXT, 
    plan_type TEXT, 
    effective_date TEXT, 
    birth_date TEXT, 
    tobacco_user INTEGER NOT NULL DEFAULT 0,
    gender TEXT, 
    state TEXT, 
    zip_code TEXT, 
    agent_id INTEGER,
    last_emailed DATETIME,
    phone_number TEXT, 
    status TEXT NOT NULL DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Get schema information to determine available columns
CREATE TEMP TABLE IF NOT EXISTS pragma_table_info AS 
SELECT * FROM pragma_table_info('contacts');

-- Set variables for optional column existence
CREATE TEMP TABLE IF NOT EXISTS column_check AS
SELECT 
    EXISTS(SELECT 1 FROM pragma_table_info WHERE name='current_premium') as has_current_premium,
    EXISTS(SELECT 1 FROM pragma_table_info WHERE name='plan_type') as has_plan_type;

-- Copy data from the existing contacts table with safe column access
INSERT INTO contacts_new(
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, tobacco_user, gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    status, created_at, updated_at
)
SELECT 
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, COALESCE(tobacco_user, 0), gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    COALESCE(status, ''), COALESCE(created_at, CURRENT_TIMESTAMP), 
    COALESCE(updated_at, CURRENT_TIMESTAMP)
FROM contacts;

-- Handle current_premium separately based on column check
UPDATE contacts_new 
SET current_premium = (
    SELECT NULL
    FROM contacts 
    WHERE contacts.id = contacts_new.id
);

-- Rename tables
ALTER TABLE contacts RENAME TO contacts_backup;
ALTER TABLE contacts_new RENAME TO contacts;

-- Clean up temp tables
DROP TABLE IF EXISTS pragma_table_info;
DROP TABLE IF EXISTS column_check;

-- Recreate indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_zip_code ON contacts(zip_code);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_created_at ON contacts(created_at);
CREATE INDEX IF NOT EXISTS idx_contacts_updated_at ON contacts(updated_at);
CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp AFTER UPDATE ON contacts 
BEGIN 
  UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; 
END;

================
File: backend/migrations/20250425_make_optional_fields_nullable.sql
================
-- Migration to make optional fields nullable
-- This migration allows all non-critical fields to be NULL based on frontend changes
-- This migration needs to be applied to all organization databases
-- This version includes recovery from partial migration failures

-- Method: Split the migration into small, independent steps that can be run
-- even if a previous migration attempt was interrupted

-- STEP 1: Clean up any temporary tables from previous failed migrations
DROP TABLE IF EXISTS contacts_new;

-- STEP 2: Create new contacts table with the desired schema
CREATE TABLE IF NOT EXISTS contacts_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    current_carrier TEXT, 
    current_premium TEXT, 
    plan_type TEXT, 
    effective_date TEXT, 
    birth_date TEXT, 
    tobacco_user INTEGER NOT NULL DEFAULT 0,
    gender TEXT, 
    state TEXT, 
    zip_code TEXT, 
    agent_id INTEGER,
    last_emailed DATETIME,
    phone_number TEXT, 
    status TEXT NOT NULL DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- STEP 3: Import data from contacts table if it exists
-- This will fail gracefully if the table doesn't exist
INSERT OR IGNORE INTO contacts_new(
    id, first_name, last_name, email, current_carrier, current_premium, 
    plan_type, effective_date, birth_date, tobacco_user, gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    status, created_at, updated_at
)
SELECT 
    id, first_name, last_name, email, current_carrier, current_premium, 
    plan_type, effective_date, birth_date, COALESCE(tobacco_user, 0), gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    COALESCE(status, ''), COALESCE(created_at, CURRENT_TIMESTAMP), 
    COALESCE(updated_at, CURRENT_TIMESTAMP)
FROM contacts WHERE 1=1;

-- STEP 4: Import data from contacts_backup table if it exists and contacts doesn't
-- This handles cases where migration was interrupted
INSERT OR IGNORE INTO contacts_new(
    id, first_name, last_name, email, current_carrier, current_premium, 
    plan_type, effective_date, birth_date, tobacco_user, gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    status, created_at, updated_at
)
SELECT 
    id, first_name, last_name, email, current_carrier, current_premium, 
    plan_type, effective_date, birth_date, COALESCE(tobacco_user, 0), gender, 
    state, zip_code, agent_id, last_emailed, phone_number, 
    COALESCE(status, ''), COALESCE(created_at, CURRENT_TIMESTAMP), 
    COALESCE(updated_at, CURRENT_TIMESTAMP)
FROM contacts_backup WHERE 1=1;

-- STEP 5: Drop old tables and rename new table
DROP TABLE IF EXISTS contacts;

-- Rename the new table to contacts
ALTER TABLE contacts_new RENAME TO contacts;

-- STEP 6: Recreate indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_zip_code ON contacts(zip_code);
CREATE INDEX IF NOT EXISTS idx_contacts_state ON contacts(state);
CREATE INDEX IF NOT EXISTS idx_contacts_created_at ON contacts(created_at);
CREATE INDEX IF NOT EXISTS idx_contacts_updated_at ON contacts(updated_at);
CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp AFTER UPDATE ON contacts 
BEGIN 
  UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; 
END;

================
File: backend/migrations/add_aep_request_columns.sql
================
-- Migration script to add AEP request columns to contacts table

-- Add aep_request column (boolean field defaulting to false)
ALTER TABLE contacts ADD COLUMN aep_request BOOLEAN DEFAULT FALSE;

-- Add aep_request_date column (timestamp for when the request was made)
ALTER TABLE contacts ADD COLUMN aep_request_date DATETIME;

-- Create index for faster queries on aep_request status
CREATE INDEX IF NOT EXISTS idx_contacts_aep_request ON contacts(aep_request);

-- Sample query to check if migration worked:
-- SELECT name FROM pragma_table_info('contacts') WHERE name IN ('aep_request', 'aep_request_date');

================
File: backend/migrations/add_deleted_contacts_table.sql
================
CREATE TABLE IF NOT EXISTS deleted_contacts (
    original_contact_id INTEGER NOT NULL, -- The ID from the original 'contacts' table
    first_name TEXT, -- Made nullable as they might be empty in original
    last_name TEXT,  -- Made nullable
    email TEXT NOT NULL, -- Crucial for billable count
    current_carrier TEXT,
    plan_type TEXT,
    effective_date TEXT,
    birth_date TEXT,
    tobacco_user INTEGER,
    gender TEXT,
    state TEXT,
    zip_code TEXT,
    agent_id INTEGER,
    phone_number TEXT,
    -- Include any other fields from 'contacts' you want to preserve historically
    deleted_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL
    -- No primary key on original_contact_id + email to allow multiple deletions if a user is re-added and deleted again
    -- though the billing logic will only count the most recent deletion within 12 months.
    -- A new unique ID for this table might be useful if needed:
    -- id TEXT PRIMARY KEY DEFAULT (hex(randomblob(16)))
);

CREATE INDEX IF NOT EXISTS idx_deleted_contacts_email ON deleted_contacts (LOWER(TRIM(email)));
CREATE INDEX IF NOT EXISTS idx_deleted_contacts_deleted_at ON deleted_contacts (deleted_at);
CREATE INDEX IF NOT EXISTS idx_deleted_contacts_original_id ON deleted_contacts (original_contact_id);

================
File: backend/migrations/add_email_tracking.sql
================
-- Migration script to add email_send_tracking table and indexes to organization databases
-- This script can be applied to any organization database

-- Create the email_send_tracking table if it doesn't exist
CREATE TABLE IF NOT EXISTS email_send_tracking (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    org_id INTEGER NOT NULL,
    contact_id TEXT NOT NULL,
    email_type TEXT NOT NULL,
    scheduled_date TEXT NOT NULL,
    send_status TEXT NOT NULL CHECK(send_status IN ('pending', 'processing', 'accepted', 'delivered', 'sent', 'deferred', 'bounced', 'dropped', 'failed', 'skipped')) DEFAULT 'pending',
    send_mode TEXT NOT NULL CHECK(send_mode IN ('test', 'production')) DEFAULT 'test',
    test_email TEXT,
    send_attempt_count INTEGER NOT NULL DEFAULT 0,
    last_attempt_date TEXT,
    last_error TEXT,
    batch_id TEXT NOT NULL,
    message_id TEXT,
    delivery_status TEXT,
    status_checked_at TEXT,
    status_details TEXT,
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for the email_send_tracking table if they don't exist
-- We need to check if indexes exist before creating them to avoid errors

-- Index on batch_id for batch operations and lookups
CREATE INDEX IF NOT EXISTS idx_email_tracking_batch_id ON email_send_tracking(batch_id);

-- Index on send_status for filtering emails by status (pending/sent/failed/skipped)
CREATE INDEX IF NOT EXISTS idx_email_tracking_send_status ON email_send_tracking(send_status);

-- Index on send_mode for filtering by mode (test/production)
CREATE INDEX IF NOT EXISTS idx_email_tracking_send_mode ON email_send_tracking(send_mode);

-- Index on contact_id for looking up emails by contact
CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_id ON email_send_tracking(contact_id);

-- Composite index on contact_id and email_type for retrieving specific email types for a contact
CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_type ON email_send_tracking(contact_id, email_type);

-- Composite index on send_status and scheduled_date for retrieving emails by status within a date range
CREATE INDEX IF NOT EXISTS idx_email_tracking_status_date ON email_send_tracking(send_status, scheduled_date);

-- Index on message_id for looking up emails by SendGrid message ID
CREATE INDEX IF NOT EXISTS idx_email_tracking_message_id ON email_send_tracking(message_id);

-- Index on delivery_status for filtering by delivery status
CREATE INDEX IF NOT EXISTS idx_email_tracking_delivery_status ON email_send_tracking(delivery_status);

-- Create a trigger to update the updated_at timestamp when a record is modified
CREATE TRIGGER IF NOT EXISTS update_email_tracking_timestamp 
AFTER UPDATE ON email_send_tracking 
BEGIN
    UPDATE email_send_tracking SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; 
END;

================
File: backend/migrations/add_onboarding_columns.sql
================
-- Add columns for storing onboarding state

-- Add onboarding_step column (INT with default 0)
ALTER TABLE organizations ADD COLUMN onboarding_step INTEGER DEFAULT 0;

-- Add temp_session_id column (TEXT, nullable)
ALTER TABLE organizations ADD COLUMN temp_session_id TEXT;

================
File: backend/migrations/add_send_time_col.sql
================
-- Migration to add scheduled_send_time column to email_schedules table
-- This allows for separating the scheduling time from the actual send time

-- Check if email_schedules table exists
CREATE TABLE IF NOT EXISTS email_schedules (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER NOT NULL,
    email_type TEXT NOT NULL,
    scheduled_send_date TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pre-scheduled',
    skip_reason TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    tracking_id TEXT,
    FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Add scheduled_send_time column if it doesn't exist
PRAGMA foreign_keys=off;
BEGIN TRANSACTION;

-- Create a temporary table with the new schema
CREATE TABLE email_schedules_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER NOT NULL,
    email_type TEXT NOT NULL,
    scheduled_send_date TEXT NOT NULL,
    scheduled_send_time TEXT NOT NULL DEFAULT '08:30:00',
    status TEXT NOT NULL DEFAULT 'scheduled',
    skip_reason TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    batch_id TEXT,
    FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Copy data from the old table to the new table
INSERT INTO email_schedules_new 
    (id, contact_id, email_type, scheduled_send_date, status, skip_reason, created_at, updated_at, batch_id)
SELECT 
    id, contact_id, email_type, scheduled_send_date, status, skip_reason, created_at, updated_at, batch_id 
FROM email_schedules;

-- Drop the old table
DROP TABLE email_schedules;

-- Rename the new table to the original name
ALTER TABLE email_schedules_new RENAME TO email_schedules;

-- Add an index to improve query performance for scheduled email lookups
CREATE INDEX IF NOT EXISTS idx_email_schedules_date_time_status ON email_schedules 
    (scheduled_send_date, scheduled_send_time, status);

-- Create a unique index on contact_id, email_type, and scheduled_send_date
-- This prevents duplicate scheduling for the same contact, email type, and date
CREATE UNIQUE INDEX IF NOT EXISTS idx_email_schedules_unique ON email_schedules 
    (contact_id, email_type, scheduled_send_date);

COMMIT;
PRAGMA foreign_keys=on;

================
File: backend/migrations/add_updated_at_col.sql
================
ALTER TABLE contacts
ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP;

CREATE TRIGGER update_contacts_updated_at
AFTER UPDATE ON contacts
FOR EACH ROW
BEGIN
  UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
END;

================
File: backend/migrations/create_subscription_tables.sql
================
-- Create subscriptions table for tracking Stripe subscriptions
CREATE TABLE IF NOT EXISTS subscriptions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  stripe_subscription_id TEXT NOT NULL,
  stripe_customer_id TEXT NOT NULL,
  stripe_usage_item_id TEXT,  -- For usage-based billing
  status TEXT NOT NULL,
  current_contact_count INTEGER DEFAULT 0,  -- Current number of contacts for this user
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,
  cancel_at_period_end BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Track contact count changes for billing and auditing
CREATE TABLE IF NOT EXISTS contact_count_history (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  count INTEGER NOT NULL,
  previous_count INTEGER,
  change_type TEXT NOT NULL, -- 'add', 'remove', 'initial', etc.
  logged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Track contact counts for each user
CREATE TABLE IF NOT EXISTS contact_counts (
  user_id TEXT PRIMARY KEY,
  count INTEGER NOT NULL DEFAULT 0,
  last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Add auto_upgrade_limit column to users table
ALTER TABLE users ADD COLUMN IF NOT EXISTS auto_upgrade_limit INTEGER DEFAULT 0;

-- Create index on user_id for subscriptions
CREATE INDEX IF NOT EXISTS idx_subscriptions_user_id ON subscriptions(user_id);

-- Create index on status for quick filtering of active subscriptions
CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);

================
File: backend/migrations/fix_email_tracking.sql
================
PRAGMA foreign_keys=off;

-- Rename the old table
ALTER TABLE email_send_tracking RENAME TO email_send_tracking_old;

-- Recreate the table with the correct foreign key
CREATE TABLE email_send_tracking (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  org_id INTEGER NOT NULL,
  contact_id INTEGER NOT NULL,
  email_type TEXT NOT NULL,
  scheduled_date TEXT NOT NULL,
  send_status TEXT NOT NULL CHECK(send_status IN ('pending', 'processing', 'accepted', 'delivered', 'sent', 'deferred', 'bounced', 'dropped', 'failed', 'skipped')) DEFAULT 'pending',
  send_mode TEXT NOT NULL CHECK(send_mode IN ('test', 'production')) DEFAULT 'test',
  test_email TEXT,
  send_attempt_count INTEGER NOT NULL DEFAULT 0,
  last_attempt_date TEXT,
  last_error TEXT,
  batch_id TEXT NOT NULL,
  message_id TEXT,
  delivery_status TEXT,
  status_checked_at TEXT,
  status_details TEXT,
  created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Copy data from old table (if needed)
INSERT INTO email_send_tracking (
  id, org_id, contact_id, email_type, scheduled_date, send_status, send_mode, test_email, send_attempt_count, last_attempt_date, last_error, batch_id, message_id, delivery_status, status_checked_at, status_details, created_at, updated_at
)
SELECT
  id, org_id, contact_id, email_type, scheduled_date, send_status, send_mode, test_email, send_attempt_count, last_attempt_date, last_error, batch_id, message_id, delivery_status, status_checked_at, status_details, created_at, updated_at
FROM email_send_tracking_old;

DROP TABLE email_send_tracking_old;

PRAGMA foreign_keys=on;

================
File: backend/migrations/remove_eligibility_answers_fk.sql
================
-- Migration script to update foreign key constraints to reference contacts instead of contacts_backup

-- Part 1: Fix eligibility_answers table
-- Step 1: Create a new table with the correct foreign key constraint
CREATE TABLE eligibility_answers_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER NOT NULL,
    quote_id TEXT NOT NULL,
    answers TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
);

-- Step 2: Copy data from the old table to the new table
INSERT INTO eligibility_answers_new (id, contact_id, quote_id, answers, created_at)
SELECT id, contact_id, quote_id, answers, created_at
FROM eligibility_answers;

-- Step 3: Drop the old table
DROP TABLE eligibility_answers;

-- Step 4: Rename the new table to the original name
ALTER TABLE eligibility_answers_new RENAME TO eligibility_answers;

-- Part 2: Fix contact_events table
-- Step 1: Create a new table with the correct foreign key constraints
CREATE TABLE contact_events_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER,
    lead_id INTEGER,
    event_type TEXT NOT NULL,
    metadata TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE,
    FOREIGN KEY (lead_id) REFERENCES leads(id) ON DELETE CASCADE
);

-- Step 2: Copy data from the old table to the new table
INSERT INTO contact_events_new (id, contact_id, lead_id, event_type, metadata, created_at)
SELECT id, contact_id, lead_id, event_type, metadata, created_at
FROM contact_events;

-- Step 3: Drop the old table
DROP TABLE contact_events;

-- Step 4: Rename the new table to the original name
ALTER TABLE contact_events_new RENAME TO contact_events;

-- Create required indexes
CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id);
CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id);
CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type);

-- Optional: Add a comment or log to confirm the migration
-- Note: Foreign key constraints on contact_id now reference contacts(id) instead of contacts_backup

================
File: backend/scripts/add-agent.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for agent data
const AgentSchema = z.object({
  first_name: z.string().min(1),
  last_name: z.string().min(1),
  email: z.string().email(),
  phone: z.string().min(1),
  organization_id: z.number(),
});

async function main() {
  p.intro(chalk.green('✨ Interactive Agent Creation Tool ✨'));

  const db = new Database();

  // Get all organizations
  const orgs = await db.fetchAll<{ id: number; name: string }>('SELECT id, name FROM organizations');
  
  if (orgs.length === 0) {
    p.outro(chalk.red('No organizations found. Please create an organization first.'));
    exit(1);
  }

  // Gather information
  const firstName = await p.text({
    message: 'Enter agent first name:',
    validate: (value) => {
      if (value.length === 0) return 'First name cannot be empty';
    },
  });

  const lastName = await p.text({
    message: 'Enter agent last name:',
    validate: (value) => {
      if (value.length === 0) return 'Last name cannot be empty';
    },
  });

  const email = await p.text({
    message: 'Enter agent email:',
    validate: (value) => {
      if (!value.includes('@')) return 'Invalid email address';
    },
  });

  const phone = await p.text({
    message: 'Enter agent phone:',
    validate: (value) => {
      if (value.length === 0) return 'Phone cannot be empty';
    },
  });

  const organization = await p.select({
    message: 'Select organization:',
    options: orgs.map(org => ({
      value: org.id,
      label: org.name,
    })),
  });

  if (p.isCancel(firstName) || p.isCancel(lastName) || p.isCancel(email) || p.isCancel(phone) || p.isCancel(organization)) {
    p.outro(chalk.yellow('Operation cancelled'));
    exit(0);
  }

  try {
    // Validate data
    const agentData = AgentSchema.parse({
      first_name: firstName,
      last_name: lastName,
      email,
      phone,
      organization_id: organization,
    });

    // Start a transaction
    await db.execute('BEGIN TRANSACTION');

    try {
      // Insert into agents table
      await db.execute(
        `INSERT INTO agents (first_name, last_name, email, phone, organization_id)
         VALUES (?, ?, ?, ?, ?)`,
        [
          agentData.first_name,
          agentData.last_name,
          agentData.email,
          agentData.phone,
          agentData.organization_id
        ]
      );

      // Insert into users table
      await db.execute(
        `INSERT INTO users (email, organization_id, is_admin, is_agent, is_active)
         VALUES (?, ?, ?, ?, true)`,
        [agentData.email, agentData.organization_id, false, true]
      );

      // Commit the transaction
      await db.execute('COMMIT');

      p.outro(chalk.green('Agent created successfully! 🎉'));

    } catch (error) {
      // Rollback on error
      await db.execute('ROLLBACK');
      throw error;
    }

  } catch (error) {
    if (error instanceof z.ZodError) {
      p.outro(chalk.red(`Validation error: ${error.errors.map(e => e.message).join(', ')}`));
    } else {
      p.outro(chalk.red(`Error creating agent: ${error}`));
    }
    exit(1);
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: backend/scripts/apply-contact-migration.ts
================
#!/usr/bin/env bun
/**
 * Script to apply contact deduplication and index creation to all organization databases
 * Usage: bun run apply-contact-migration.ts
 */

import { Database } from '../src/database'
import { logger } from '../src/logger'
import fs from 'fs/promises'
import path from 'path'

async function main() {
  try {
    logger.info('Starting contact migration script')
    
    // Connect to main database
    const mainDb = new Database()
    
    // Get all organizations
    const organizations = await mainDb.fetchAll('SELECT id, name, turso_db_url, turso_auth_token FROM organizations WHERE turso_db_url IS NOT NULL')
    logger.info(`Found ${organizations.length} organizations to process`)
    
    // Read the migration SQL file
    const migrationPath = path.join(process.cwd(), 'migrations', '20240326_deduplicate_contacts.sql')
    
    try {
      await fs.access(migrationPath)
    } catch (error) {
      logger.error(`Migration file not found: ${migrationPath}`)
      process.exit(1)
    }
    
    const migrationSql = await fs.readFile(migrationPath, 'utf-8')
    logger.info(`Loaded migration from: ${migrationPath}`)
    
    // Process each organization
    for (let i = 0; i < organizations.length; i++) {
      const org = organizations[i]
      const orgId = org.id
      const orgName = org.name
      const dbUrl = org.turso_db_url
      const authToken = org.turso_auth_token
      
      logger.info(`Processing organization ${i+1}/${organizations.length}: ${orgName} (ID: ${orgId})`)
      
      try {
        // Connect to the organization's database
        const orgDb = new Database(dbUrl, authToken)
        
        // Check if the contacts table exists
        const tableExists = await orgDb.fetchOne('SELECT name FROM sqlite_master WHERE type="table" AND name="contacts"')
        
        if (!tableExists) {
          logger.info(`Organization ${orgId} does not have a contacts table, skipping`)
          continue
        }
        
        // Get contact count before migration
        const beforeCount = await orgDb.fetchOne<{ count: number }>('SELECT COUNT(*) as count FROM contacts')
        logger.info(`Organization ${orgId} has ${beforeCount?.count || 0} contacts before migration`)
        
        // Check for duplicates
        const dupeCheck = await orgDb.fetchOne<{ dupes: number }>('SELECT COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as dupes FROM contacts')
        logger.info(`Organization ${orgId} has ${dupeCheck?.dupes || 0} duplicate email addresses`)
        
        // Check if unique index exists
        const indexExists = await orgDb.fetchOne('SELECT name FROM sqlite_master WHERE type="index" AND name="idx_contacts_email_unique"')
        
        if ((dupeCheck?.dupes || 0) === 0 && indexExists) {
          logger.info(`No duplicates found and unique index exists for organization ${orgId}, skipping`)
          continue
        }
        
        if ((dupeCheck?.dupes || 0) === 0) {
          // No duplicates, just create the index
          logger.info(`No duplicates found, creating unique email index for organization ${orgId}`)
          await orgDb.execute('CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))')
          logger.info(`Created unique email index for organization ${orgId}`)
          continue
        }
        
        // Execute the migration SQL for this organization
        logger.info(`Found ${dupeCheck?.dupes || 0} duplicates, applying full migration to organization ${orgId}`)
        
        // Split the SQL into statements
        const statements = migrationSql
          .split(';')
          .map(stmt => stmt.trim())
          .filter(stmt => stmt.length > 0 && !stmt.startsWith('--'))
        
        for (const statement of statements) {
          try {
            await orgDb.execute(statement)
          } catch (error) {
            // Log the error but continue with next statement
            logger.error(`Error executing statement for org ${orgId}: ${error}`)
            logger.error(`Statement: ${statement}`)
          }
        }
        
        // Get contact count after migration
        const afterCount = await orgDb.fetchOne<{ count: number }>('SELECT COUNT(*) as count FROM contacts')
        logger.info(`Organization ${orgId} has ${afterCount?.count || 0} contacts after migration`)
        
        // Calculate removed duplicates
        const removedCount = (beforeCount?.count || 0) - (afterCount?.count || 0)
        logger.info(`Removed ${removedCount} duplicate contacts from organization ${orgId}`)
        
      } catch (error) {
        // Log the error but continue with next organization
        logger.error(`Error processing organization ${orgId}: ${error}`)
      }
    }
    
    logger.info(`Migration completed for all organizations`)
    
  } catch (error) {
    logger.error(`Error in migration script: ${error}`)
    process.exit(1)
  }
}

main()

================
File: backend/scripts/generate-test-data.ts
================
import fs from 'fs/promises';
import { stringify } from 'csv-stringify/sync';
import path from 'path';

/**
 * Script to generate a large dataset of test contacts for performance testing
 * 
 * Usage:
 *   bun run scripts/generate-test-data.ts <count> [output-file]
 * 
 * Where:
 *   <count> is the number of contacts to generate
 *   [output-file] is the optional output file path (defaults to ./scripts/test-contacts-{count}.csv)
 */

// Sample data for random generation
const firstNames = ['John', 'Jane', 'Robert', 'Mary', 'Michael', 'Jennifer', 'William', 'Patricia', 'Richard', 'Linda', 
  'David', 'Elizabeth', 'Joseph', 'Barbara', 'Thomas', 'Susan', 'Charles', 'Jessica', 'Daniel', 'Sarah', 'Matthew', 'Karen', 
  'Anthony', 'Nancy', 'Mark', 'Lisa', 'Donald', 'Betty', 'Steven', 'Dorothy'];

const lastNames = ['Smith', 'Johnson', 'Williams', 'Jones', 'Brown', 'Davis', 'Miller', 'Wilson', 'Moore', 'Taylor', 
  'Anderson', 'Thomas', 'Jackson', 'White', 'Harris', 'Martin', 'Thompson', 'Garcia', 'Martinez', 'Robinson', 'Clark', 
  'Rodriguez', 'Lewis', 'Lee', 'Walker', 'Hall', 'Allen', 'Young', 'Hernandez', 'King'];

const carriers = ['Aetna', 'Humana', 'UnitedHealthcare', 'Cigna', 'Blue Cross Blue Shield', 'Kaiser Permanente', 
  'Anthem', 'Wellcare', 'Centene', 'Molina Healthcare'];

const planTypes = ['A', 'B', 'C', 'D', 'F', 'G', 'K', 'L', 'M', 'N'];

const states = ['AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 
  'LA', 'ME', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 
  'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'];

// Helper functions for random data generation
function getRandomItem<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)];
}

function getRandomDate(start: Date, end: Date): string {
  const date = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
  return date.toISOString().split('T')[0];
}

function getRandomPhone(): string {
  return `${Math.floor(Math.random() * 900) + 100}-${Math.floor(Math.random() * 900) + 100}-${Math.floor(Math.random() * 9000) + 1000}`;
}

function getRandomZip(): string {
  return `${Math.floor(Math.random() * 90000) + 10000}`;
}

// Main function
async function main() {
  try {
    const args = process.argv.slice(2);
    
    if (args.length < 1) {
      console.error('Usage: bun run scripts/generate-test-data.ts <count> [output-file]');
      process.exit(1);
    }
    
    const count = parseInt(args[0], 10);
    
    if (isNaN(count) || count <= 0) {
      console.error('Count must be a positive number');
      process.exit(1);
    }
    
    const outputFile = args[1] || path.join(process.cwd(), 'scripts', `test-contacts-${count}.csv`);
    
    console.log(`Generating ${count} test contacts...`);
    
    // Generate the contacts
    const contacts = [];
    
    for (let i = 0; i < count; i++) {
      const firstName = getRandomItem(firstNames);
      const lastName = getRandomItem(lastNames);
      const email = `${firstName.toLowerCase()}.${lastName.toLowerCase()}${Math.floor(Math.random() * 10000)}@example.com`;
      
      contacts.push({
        first_name: firstName,
        last_name: lastName,
        email: email,
        current_carrier: getRandomItem(carriers),
        plan_type: getRandomItem(planTypes),
        effective_date: getRandomDate(new Date('2022-01-01'), new Date('2023-12-31')),
        birth_date: getRandomDate(new Date('1940-01-01'), new Date('1965-12-31')),
        tobacco_user: Math.random() > 0.8 ? 1 : 0, // 20% are tobacco users
        gender: Math.random() > 0.5 ? 'Male' : 'Female',
        state: getRandomItem(states),
        zip_code: getRandomZip(),
        phone_number: getRandomPhone()
      });
      
      // Log progress for large datasets
      if (i > 0 && i % 10000 === 0) {
        console.log(`Generated ${i} contacts...`);
      }
    }
    
    // Convert to CSV
    console.log('Converting to CSV...');
    const csv = stringify(contacts, { header: true });
    
    // Write to file
    console.log(`Writing to ${outputFile}...`);
    await fs.writeFile(outputFile, csv);
    
    console.log(`Successfully generated ${count} contacts in ${outputFile}`);
    
  } catch (error) {
    console.error(`Error generating test data: ${error}`);
    process.exit(1);
  }
}

main();

================
File: backend/scripts/generateQuoteId.ts
================
import { generateQuoteId } from '../src/utils/quoteId';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteId.ts <orgId> <contactId>');
  process.exit(1);
}

// Generate quote ID
const quoteId = generateQuoteId(orgId, contactId);

// Output results
console.log('Generated Quote ID:', quoteId);
console.log('Quote URL:', `http://localhost:5173/quote?id=${quoteId}`);

================
File: backend/scripts/generateQuoteUrl.ts
================
import axios, { AxiosError } from 'axios';

// Get command line arguments
const orgId = parseInt(process.argv[2]);
const contactId = parseInt(process.argv[3]);

if (isNaN(orgId) || isNaN(contactId)) {
  console.error('Usage: ts-node generateQuoteUrl.ts <orgId> <contactId>');
  process.exit(1);
}

// Call the API to generate a quote ID
const generateQuoteUrl = async () => {
  try {
    // Use the debug endpoint to generate a quote ID without authentication
    const response = await axios.get(`http://localhost:8000/api/quotes/debug-generate/${orgId}/${contactId}`);

    if (response.data.success) {
      console.log('Quote ID:', response.data.quoteId);
      console.log('Quote URL:', response.data.redirectUrl);
    } else {
      console.error('Failed to generate quote ID:', response.data.error);
      
      if (response.data.availableContacts) {
        console.log('\nAvailable contacts for organization', orgId, ':');
        response.data.availableContacts.forEach((contact: any) => {
          console.log(`- ID: ${contact.id}, Name: ${contact.first_name} ${contact.last_name || ''}, Email: ${contact.email || 'N/A'}`);
        });
      }
    }
  } catch (error) {
    if (error instanceof AxiosError) {
      console.error('Error:', error.response?.data || error.message);
    } else {
      console.error('Error:', error);
    }
  }
};

generateQuoteUrl();

================
File: backend/scripts/manage-recommendations.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';

// Schema validation for GI recommendation data
const RecommendationSchema = z.object({
  state: z.string().length(2),
  carrier: z.string().min(1),
});

async function main() {
  p.intro(chalk.green('✨ Guaranteed Issue Recommendations Manager ✨'));

  const db = new Database();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all GI recommendations' },
        { value: 'add', label: 'Add new GI recommendation' },
        { value: 'remove', label: 'Remove GI recommendation' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listRecommendations(db);
          break;
        case 'add':
          await addRecommendation(db);
          break;
        case 'remove':
          await removeRecommendation(db);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listRecommendations(db: Database) {
  const results = await db.fetchAll<{ state: string; carrier: string; created_at: string }>(
    `SELECT state, carrier, created_at 
     FROM guaranteed_issue_recommendations 
     ORDER BY carrier, state`
  );

  if (results.length === 0) {
    p.note('No GI recommendations found', 'Empty');
    return;
  }

  const groupedByCarrier = results.reduce((acc, curr) => {
    if (!acc[curr.carrier]) {
      acc[curr.carrier] = [];
    }
    acc[curr.carrier].push(curr.state);
    return acc;
  }, {} as Record<string, string[]>);

  p.note(
    Object.entries(groupedByCarrier)
      .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
      .join('\n\n'),
    'Current GI Recommendations'
  );
}

async function addRecommendation(db: Database) {
  // Get available carriers first
  const carriers = await db.fetchAll<{ name: string }>(
    'SELECT name FROM carriers ORDER BY name'
  );

  if (carriers.length === 0) {
    p.note(chalk.red('No carriers found in database'));
    return;
  }

  const carrier = await p.select({
    message: 'Select carrier:',
    options: carriers.map(c => ({
      value: c.name,
      label: c.name,
    })),
  });

  if (p.isCancel(carrier)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const states = await p.text({
    message: 'Enter state codes (comma/space separated, e.g., TX CA FL):',
    validate: (value) => {
      const stateList = value.toUpperCase().split(/[\s,]+/).filter(Boolean);
      if (stateList.length === 0) return 'At least one state code is required';
      const invalidStates = stateList.filter(s => s.length !== 2);
      if (invalidStates.length > 0) {
        return `Invalid state codes: ${invalidStates.join(', ')}`;
      }
    },
  });

  if (p.isCancel(states)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const stateList = states.toUpperCase().split(/[\s,]+/).filter(Boolean);
  const results: { state: string; success: boolean; message: string }[] = [];

  for (const state of stateList) {
    try {
      const data = RecommendationSchema.parse({
        state,
        carrier,
      });

      // Check if recommendation already exists
      const existing = await db.fetchOne(
        'SELECT 1 FROM guaranteed_issue_recommendations WHERE state = ? AND carrier = ?',
        [data.state, data.carrier]
      );

      if (existing) {
        results.push({
          state: data.state,
          success: false,
          message: 'Already exists'
        });
        continue;
      }

      await db.execute(
        'INSERT INTO guaranteed_issue_recommendations (state, carrier) VALUES (?, ?)',
        [data.state, data.carrier]
      );

      results.push({
        state: data.state,
        success: true,
        message: 'Added successfully'
      });

    } catch (error) {
      results.push({
        state,
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Unknown error'
      });
    }
  }

  // Display results summary
  const successful = results.filter(r => r.success);
  const failed = results.filter(r => !r.success);

  if (successful.length > 0) {
    p.note(
      chalk.green(
        `Successfully added GI recommendations for ${carrier}:\n` +
        successful.map(r => `  ${r.state}`).join('\n')
      ),
      'Success'
    );
  }

  if (failed.length > 0) {
    p.note(
      chalk.yellow(
        `Failed to add some recommendations for ${carrier}:\n` +
        failed.map(r => `  ${r.state}: ${r.message}`).join('\n')
      ),
      'Warnings'
    );
  }
}

async function removeRecommendation(db: Database) {
  const recommendations = await db.fetchAll<{ id: number; state: string; carrier: string }>(
    'SELECT id, state, carrier FROM guaranteed_issue_recommendations ORDER BY carrier, state'
  );

  if (recommendations.length === 0) {
    p.note(chalk.yellow('No recommendations to remove'));
    return;
  }

  const selections = await p.multiselect({
    message: 'Select recommendations to remove (space to select/deselect):',
    options: recommendations
      .sort((a, b) => a.carrier.localeCompare(b.carrier) || a.state.localeCompare(b.state))
      .map(rec => ({
        value: rec.id.toString(),
        label: `${rec.carrier} - ${rec.state}`,
      })),
    required: true,
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const idsToRemove = (selections as string[]).map(Number);

  if (idsToRemove.length === 0) {
    p.note(chalk.yellow('No recommendations selected for removal'));
    return;
  }

  await db.execute(
    `DELETE FROM guaranteed_issue_recommendations WHERE id IN (${idsToRemove.join(',')})`,
  );

  const removedItems = recommendations
    .filter(r => idsToRemove.includes(r.id))
    .reduce((acc, curr) => {
      if (!acc[curr.carrier]) {
        acc[curr.carrier] = [];
      }
      acc[curr.carrier].push(curr.state);
      return acc;
    }, {} as Record<string, string[]>);

  p.note(
    chalk.green(
      'Successfully removed recommendations:\n\n' +
      Object.entries(removedItems)
        .map(([carrier, states]) => `${carrier}:\n  ${states.sort().join(', ')}`)
        .join('\n\n')
    ),
    'Success'
  );
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: backend/scripts/manage-turso.ts
================
import * as p from '@clack/prompts';
import { z } from 'zod';
import { exit } from 'process';
import chalk from 'chalk';
import { Database } from '../src/database';
import { TURSO_CONFIG } from '../src/config/turso';
import fetch from 'node-fetch';

interface Organization {
  id: number;
  name: string;
  turso_db_url: string | null;
}

class TursoManager {
  private headers = {
    'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
    'Content-Type': 'application/json'
  };

  async listLocations(): Promise<string[]> {
    const response = await fetch(`${TURSO_CONFIG.API_URL}/locations`, {
      headers: this.headers
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch locations: ${await response.text()}`);
    }

    const data = await response.json() as { locations: Array<{ name: string }> };
    return data.locations.map(l => l.name);
  }

  async listDatabases(): Promise<Array<{name: string, hostname: string}>> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`,
      { headers: this.headers }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch databases: ${await response.text()}`);
    }

    const data = await response.json() as { databases: Array<{Name: string, Hostname: string}> };
    return data.databases.map(db => ({
      name: db.Name,
      hostname: db.Hostname
    }));
  }

  async updateGroup(name: string, location: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/groups/${TURSO_CONFIG.GROUP_NAME}`,
      {
        method: 'PATCH',
        headers: this.headers,
        body: JSON.stringify({ name, location })
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to update group: ${await response.text()}`);
    }
  }

  async deleteDatabase(name: string): Promise<void> {
    const response = await fetch(
      `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${name}`,
      {
        method: 'DELETE',
        headers: this.headers
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete database: ${await response.text()}`);
    }
  }
}

async function main() {
  p.intro(chalk.green('✨ Turso Database Manager ✨'));

  const db = new Database();
  const turso = new TursoManager();

  while (true) {
    const action = await p.select({
      message: 'What would you like to do?',
      options: [
        { value: 'list', label: 'List all databases and organizations' },
        { value: 'update-group', label: 'Update group configuration' },
        { value: 'delete-db', label: 'Delete a customer database' },
        { value: 'exit', label: 'Exit' },
      ],
    });

    if (p.isCancel(action) || action === 'exit') {
      p.outro(chalk.yellow('Goodbye!'));
      exit(0);
    }

    try {
      switch (action) {
        case 'list':
          await listDatabasesAndOrgs(db, turso);
          break;
        case 'update-group':
          await updateGroupConfig(turso);
          break;
        case 'delete-db':
          await deleteCustomerDatabase(db, turso);
          break;
      }
    } catch (error) {
      p.outro(chalk.red(`Error: ${error}`));
      exit(1);
    }
  }
}

async function listDatabasesAndOrgs(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  const mappedDatabases = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      name: database.name,
      hostname: database.hostname,
      organization: org ? org[1] : 'Not associated with any organization'
    };
  });

  if (mappedDatabases.length === 0) {
    p.note('No databases found', 'Empty');
    return;
  }

  p.note(
    mappedDatabases
      .map(db => `${db.name}:\n  URL: ${db.hostname}\n  Organization: ${db.organization}`)
      .join('\n\n'),
    'Current Databases'
  );
}

async function updateGroupConfig(turso: TursoManager) {
  // Get available locations
  const locations = await turso.listLocations();

  p.note(
    `Current Configuration:\n` +
    `  Group Name: ${TURSO_CONFIG.GROUP_NAME}\n` +
    `  Location: ${TURSO_CONFIG.LOCATION}`,
    'Current Settings'
  );

  const newGroupName = await p.text({
    message: 'Enter new group name (or press enter to keep current):',
    initial: TURSO_CONFIG.GROUP_NAME,
  });

  if (p.isCancel(newGroupName)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const newLocation = await p.select({
    message: 'Select new location:',
    options: locations.map(loc => ({
      value: loc,
      label: loc,
    })),
    initialValue: TURSO_CONFIG.LOCATION,
  });

  if (p.isCancel(newLocation)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const confirm = await p.confirm({
    message: `Update group "${TURSO_CONFIG.GROUP_NAME}" to:\n` +
             `  Name: ${newGroupName}\n` +
             `  Location: ${newLocation}\n` +
             `Are you sure?`,
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  await turso.updateGroup(newGroupName, newLocation as string);
  
  p.note(
    chalk.green(
      `Successfully updated group configuration.\n` +
      `Remember to update TURSO_CONFIG in your code!`
    ),
    'Success'
  );
}

async function deleteCustomerDatabase(db: Database, turso: TursoManager) {
  const databases = await turso.listDatabases();
  const result = await db.execute(
    'SELECT id, name, turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL'
  );
  const orgs = result.rows || [];

  if (databases.length === 0) {
    p.note('No databases found to delete', 'Empty');
    return;
  }

  const options = databases.map(database => {
    const org = orgs.find((o: any) => o[2] && o[2].toString().includes(database.hostname));
    return {
      value: database.name,
      label: `${database.name} (${org ? org[1] : 'Unassociated'})`,
    };
  });

  const selections = await p.multiselect({
    message: 'Select databases to delete (space to select, enter to confirm):',
    options,
    required: true
  });

  if (p.isCancel(selections)) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  const selectedDbs = selections as string[];
  if (selectedDbs.length === 0) {
    p.note(chalk.yellow('No databases selected'));
    return;
  }

  const confirm = await p.confirm({
    message: chalk.red(
      `Are you sure you want to delete the following databases?\n` +
      selectedDbs.map(db => `  - ${db}`).join('\n') +
      `\nThis action cannot be undone!`
    ),
  });

  if (p.isCancel(confirm) || !confirm) {
    p.note(chalk.yellow('Operation cancelled'));
    return;
  }

  for (const dbName of selectedDbs) {
    try {
      await turso.deleteDatabase(dbName);

      // Update organization record
      const org = orgs.find((o: any) => 
        o[2] && 
        o[2].toString().includes(
          databases.find(d => d.name === dbName)?.hostname || ''
        )
      );

      if (org) {
        await db.execute(
          'UPDATE organizations SET turso_db_url = NULL, turso_auth_token = NULL WHERE id = ?',
          [org[0]]
        );
      }

      p.note(
        chalk.green(`Successfully deleted database "${dbName}"`),
        'Success'
      );
    } catch (error) {
      p.note(
        chalk.red(`Failed to delete database "${dbName}": ${error}`),
        'Error'
      );
    }
  }
}

main().catch((error) => {
  p.outro(chalk.red(`Fatal error: ${error}`));
  exit(1);
});

================
File: backend/scripts/migrate-tracking-clicks.js
================
#!/usr/bin/env node

/**
 * Migration script to add tracking_clicks table to all organization databases
 * Usage: node migrate-tracking-clicks.js
 */

const fs = require('fs');
const path = require('path');
const { Database } = require('../dist/database');
const { logger } = require('../dist/logger');

// Path to the SQL migration
const MIGRATION_FILE = path.join(__dirname, '../data/migrations/003_add_tracking_clicks.sql');

async function main() {
  try {
    // Read the migration SQL
    const migrationSql = fs.readFileSync(MIGRATION_FILE, 'utf-8');
    logger.info(`Loaded migration SQL from ${MIGRATION_FILE}`);
    
    // Initialize the main database
    const db = new Database();
    logger.info('Connected to main database');

    // Get all organization IDs and their database URLs
    const orgs = await db.fetchAll(
      'SELECT id, name, slug, turso_db_url, turso_auth_token FROM organizations WHERE turso_db_url IS NOT NULL AND turso_auth_token IS NOT NULL'
    );
    
    logger.info(`Found ${orgs.length} organizations with database configurations`);

    // Process each organization
    for (const org of orgs) {
      const { id, name, slug, turso_db_url, turso_auth_token } = org;
      
      try {
        logger.info(`Migrating organization: ${name} (${id})`);
        
        // Connect to the organization's database
        const orgDb = new Database(turso_db_url, turso_auth_token);
        
        // Execute the migration SQL
        await orgDb.execute(migrationSql);
        
        // Verify the table was created
        const tableExists = await orgDb.fetchOne(
          "SELECT name FROM sqlite_master WHERE type='table' AND name='tracking_clicks'"
        );
        
        if (tableExists) {
          logger.info(`Successfully migrated organization ${name} (${id})`);
        } else {
          logger.error(`Migration failed for organization ${name} (${id}): table not created`);
        }
      } catch (error) {
        logger.error(`Error migrating organization ${name} (${id}): ${error.message}`);
      }
    }
    
    logger.info('Migration complete!');
    process.exit(0);
  } catch (error) {
    logger.error(`Migration failed: ${error.message}`);
    logger.error(error.stack);
    process.exit(1);
  }
}

// Start the migration
main();

================
File: backend/scripts/sample-contacts.csv
================
first_name,last_name,email,current_carrier,plan_type,effective_date,birth_date,tobacco_user,gender,state,zip_code,phone_number
John,Doe,john.doe@example.com,Aetna,F,2023-01-01,1955-08-21,0,Male,FL,33101,123-456-7890
Jane,Smith,jane.smith@example.com,Humana,G,2023-02-15,1953-04-12,0,Female,TX,75001,214-555-1234
Robert,Johnson,robert.j@example.com,UnitedHealthcare,N,2022-12-01,1949-11-30,1,Male,CA,90210,310-555-9876
Susan,Williams,susan.w@example.com,Cigna,G,2023-03-20,1960-02-28,0,Female,NY,10001,212-555-4321
Michael,Brown,michael.b@example.com,Aetna,F,2023-01-15,1952-07-14,0,Male,IL,60601,312-555-7890
Patricia,Davis,patricia.d@example.com,Humana,G,2022-11-10,1958-09-17,0,Female,GA,30301,404-555-3456
James,Miller,james.m@example.com,UnitedHealthcare,N,2023-02-01,1950-12-05,1,Male,AZ,85001,480-555-6789
Linda,Wilson,linda.w@example.com,Cigna,F,2023-03-01,1956-05-22,0,Female,PA,19101,215-555-2345
William,Moore,william.m@example.com,Aetna,G,2022-10-15,1947-03-08,1,Male,OH,44101,216-555-7890
Jennifer,Taylor,jennifer.t@example.com,Humana,F,2023-01-20,1962-08-11,0,Female,MI,48201,313-555-4567

================
File: backend/scripts/setup-contact-tracking.sh
================
#!/bin/bash

# Setup script for contact tracking system
# This script installs dependencies and sets up the database tables

# Exit on any error
set -e

echo "Setting up contact tracking system..."

# Install UUID package
echo "Installing dependencies..."
npm install uuid
npm install --save-dev @types/uuid

# Create necessary database tables
echo "Setting up database tables..."
DB_PATH="./database.db"

# Run the SQL migration
echo "Applying database migration..."
MIGRATION_PATH="./migrations/20240406_add_contact_history_tracking.sql"

# Use the migrate script if available
if [ -f "./scripts/migrate.sh" ]; then
  ./scripts/migrate.sh $MIGRATION_PATH
else
  # Fallback if migrate script doesn't exist
  echo "Migration script not found, attempting direct application..."
  
  # For SQLite
  if [ -f "$DB_PATH" ]; then
    sqlite3 $DB_PATH < $MIGRATION_PATH
  else
    echo "Database file not found at $DB_PATH"
    echo "Please run this script from the backend directory or update the DB_PATH variable."
    exit 1
  fi
fi

# Set file as executable
chmod +x ./scripts/setup-contact-tracking.sh

echo "Contact tracking system setup complete!"
echo ""
echo "Usage:"
echo "  - New contacts are automatically tracked when added to the system"
echo "  - Billing is based on unique contacts per billing cycle"
echo "  - Contact statistics are available at /api/contact-tracking/usage-stats"
echo ""

================
File: backend/scripts/test-bulk-import.ts
================
import { Database } from '../src/database';
import { ContactCreate } from '../src/types';
import { logger } from '../src/logger';
import fs from 'fs/promises';
import { parse } from 'csv-parse/sync';

/**
 * Test utility for the bulk contact import feature
 * 
 * Usage:
 *   bun run scripts/test-bulk-import.ts <org_id> <csv_file> [--overwrite]
 * 
 * Where:
 *   <org_id> is the organization ID to import contacts for
 *   <csv_file> is the path to a CSV file containing contacts
 *   --overwrite is an optional flag to overwrite existing contacts
 * 
 * The CSV file should have headers that match the ContactCreate interface properties
 * Columns can be in either camelCase (firstName) or snake_case (first_name) format
 */

async function main() {
  try {
    // Parse command line arguments
    const args = process.argv.slice(2);
    
    if (args.length < 2) {
      console.error('Usage: bun run scripts/test-bulk-import.ts <org_id> <csv_file> [--overwrite]');
      process.exit(1);
    }
    
    const orgId = args[0];
    const csvPath = args[1];
    const overwriteExisting = args.includes('--overwrite');
    
    // Read and parse the CSV file
    logger.info(`Reading contacts from ${csvPath}`);
    const csvContent = await fs.readFile(csvPath, 'utf-8');
    
    // Parse CSV with header row
    const records = parse(csvContent, {
      columns: true,
      skip_empty_lines: true,
      trim: true
    });
    
    logger.info(`Parsed ${records.length} records from CSV`);
    
    // Convert records to ContactCreate objects
    const contacts: ContactCreate[] = records.map((record: any) => {
      return {
        first_name: record.first_name || record.firstName || '',
        last_name: record.last_name || record.lastName || '',
        email: record.email || '',
        current_carrier: record.current_carrier || record.currentCarrier || '',
        plan_type: record.plan_type || record.planType || '',
        effective_date: record.effective_date || record.effectiveDate || '',
        birth_date: record.birth_date || record.birthDate || '',
        tobacco_user: record.tobacco_user === '1' || record.tobacco_user === 'true' || record.tobaccoUser === true || record.tobaccoUser === '1' || record.tobaccoUser === 'true',
        gender: record.gender || '',
        state: record.state || '',
        zip_code: record.zip_code || record.zipCode || '',
        phone_number: record.phone_number || record.phoneNumber || '',
        agent_id: record.agent_id || record.agentId || null
      };
    });
    
    // Log a sample contact
    logger.info(`Sample contact: ${JSON.stringify(contacts[0])}`);
    
    // Validate contacts
    const validContacts = contacts.filter(contact => {
      return contact.first_name && contact.last_name && contact.email;
    });
    
    logger.info(`Found ${validContacts.length} valid contacts out of ${contacts.length}`);
    
    // Confirm with user
    console.log(`Ready to import ${validContacts.length} contacts for organization ${orgId}.`);
    console.log(`Overwrite existing: ${overwriteExisting}`);
    
    // Add a delay to allow cancellation
    console.log('Starting import in 5 seconds... Press Ctrl+C to cancel');
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Execute bulk import
    const startTime = Date.now();
    logger.info('Starting bulk import...');
    
    await Database.bulkImportContacts(orgId, validContacts, overwriteExisting);
    
    const totalTime = (Date.now() - startTime) / 1000;
    logger.info(`Bulk import completed in ${totalTime.toFixed(2)} seconds`);
    
  } catch (error) {
    logger.error(`Error in test-bulk-import: ${error}`);
    process.exit(1);
  }
}

main();

================
File: backend/sql/add_demo_mode_column.sql
================


================
File: backend/sql/create_tables.sql
================
-- Create organizations table
CREATE TABLE IF NOT EXISTS organizations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  subscription_tier TEXT DEFAULT 'basic',
  agent_limit INTEGER DEFAULT 1,
  contact_limit INTEGER DEFAULT 1000,
  stripe_customer_id TEXT,
  stripe_subscription_id TEXT,
  stripe_checkout_session TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create subscription_tiers table
CREATE TABLE IF NOT EXISTS subscription_tiers (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  agent_limit INTEGER NOT NULL,
  contact_limit INTEGER NOT NULL,
  price_monthly INTEGER NOT NULL,
  price_yearly INTEGER NOT NULL,
  features TEXT NOT NULL
);

-- Insert default subscription tiers
INSERT INTO subscription_tiers 
(id, name, agent_limit, contact_limit, price_monthly, price_yearly, features)
VALUES 
('basic', 'Basic', 1, 1000, 2900, 29900, '["Email Support", "Basic Analytics", "1 Agent"]'),
('pro', 'Professional', 5, 10000, 9900, 99900, '["Email & Phone Support", "Advanced Analytics", "Team Collaboration", "API Access", "5 Agents"]'),
('enterprise', 'Enterprise', 10, 20000, 19900, 199900, '["24/7 Priority Support", "Custom Reporting", "Dedicated Account Manager", "White-labeling", "SSO Integration", "10 Agents"]');

================
File: backend/sql/update_org_limits.sql
================
-- Update organization tier limits
-- Basic tier: 1 agent, 1,000 contacts
UPDATE organizations 
SET agent_limit = 1, contact_limit = 1000 
WHERE subscription_tier = 'basic';

-- Pro tier: 5 agents, 10,000 contacts
UPDATE organizations 
SET agent_limit = 5, contact_limit = 10000 
WHERE subscription_tier = 'pro';

-- Enterprise tier: 10 agents, 20,000 contacts  
UPDATE organizations 
SET agent_limit = 10, contact_limit = 20000 
WHERE subscription_tier = 'enterprise';

-- Make sure subscription_tiers table is updated with correct limits
INSERT OR REPLACE INTO subscription_tiers 
(id, name, agent_limit, contact_limit, price_monthly, price_yearly, features)
VALUES 
('basic', 'Basic', 1, 1000, 2900, 29900, '["Email Support", "Basic Analytics", "1 Agent"]'),
('pro', 'Professional', 5, 10000, 9900, 99900, '["Email & Phone Support", "Advanced Analytics", "Team Collaboration", "API Access", "5 Agents"]'),
('enterprise', 'Enterprise', 10, 20000, 19900, 199900, '["24/7 Priority Support", "Custom Reporting", "Dedicated Account Manager", "White-labeling", "SSO Integration", "10 Agents"]');

================
File: backend/sql/update_org_schema.sql
================
-- Add stripe_checkout_session column to organizations table
ALTER TABLE organizations ADD COLUMN stripe_checkout_session TEXT;

================
File: backend/src/config/index.ts
================
interface Config {
  TURSO_DATABASE_URL?: string;
  TURSO_AUTH_TOKEN?: string;
  TURSO_DATABASE_PATH?: string;
  TURSO_API_TOKEN?: string;
  TURSO_ORG_GROUP: string;
  TURSO_ORG_SLUG: string;
  STRIPE_SECRET_KEY?: string;
  STRIPE_WEBHOOK_SECRET?: string;
  SENDGRID_API_KEY?: string;
  SENDGRID_FROM_EMAIL?: string;
  SENDGRID_TEMPLATES: Record<string, string>;
  USE_LOCAL_SQLITE: boolean;
  LOCAL_DB_PATH: string;
  clientUrl: string;
}

export const config: Config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  TURSO_API_TOKEN: process.env.TURSO_API_TOKEN,
  TURSO_ORG_GROUP: process.env.TURSO_ORG_GROUP || 'default',
  TURSO_ORG_SLUG: process.env.TURSO_ORG_SLUG || 'default',
  STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
  STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
  SENDGRID_API_KEY: process.env.SENDGRID_API_KEY,
  SENDGRID_FROM_EMAIL: process.env.SENDGRID_FROM_EMAIL,
  SENDGRID_TEMPLATES: {
    QUOTE_EMAIL: 'd-f43dasd8f9a8sd7f98asd7f',
    WELCOME_EMAIL: 'd-a9s8d7f98as7df89as7df9'
  },
  USE_LOCAL_SQLITE: process.env.USE_LOCAL_SQLITE !== 'false',
  LOCAL_DB_PATH: process.env.LOCAL_DB_PATH || 'data/organizations',
  clientUrl: process.env.NODE_ENV === 'production' 
    ? 'https://app.example.com'
    : 'http://localhost:5173'
}

================
File: backend/src/config/turso.ts
================
export const TURSO_CONFIG = {
  API_URL: 'https://api.turso.tech/v1',
  API_TOKEN: process.env.TURSO_API_TOKEN, // Add this to your .env
  ORG_SLUG: 'pyrex41',
  GROUP_NAME: 'maxretain',
  LOCATION: 'aws-us-east-1' // We can update this to your preferred location
}

================
File: backend/src/middleware/account-status.ts
================
import { Elysia } from 'elysia';
import { getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { Database } from '../database';

/**
 * Middleware to check if an organization's account is in good standing
 * This can be used on routes that should be blocked if the account has issues
 */
export const accountStatusMiddleware = new Elysia()
  .derive(async ({ request, set }) => {
    try {
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      if (!currentUser) {
        // If no user, let the auth middleware handle it
        return { accountStatus: null };
      }
      
      const db = new Database();
      
      // Query organization status from the view
      const statusResult = await db.query<{
        account_status: string;
        subscription_status: string;
      }>('SELECT account_status, subscription_status FROM organization_status WHERE id = ?', 
         [currentUser.organization_id]);
      
      if (!statusResult || statusResult.length === 0) {
        logger.error(`Could not find organization status for org ID: ${currentUser.organization_id}`);
        return { accountStatus: null };
      }
      
      const status = statusResult[0];
      
      // If account is not in good standing, block access to certain operations
      if (status.account_status !== 'good_standing') {
        logger.warn(`Blocked access due to account status: ${status.account_status} for org ${currentUser.organization_id}`);
        return { accountStatus: status.account_status, subscription_status: status.subscription_status };
      }
      
      // Account is in good standing
      return { accountStatus: 'good_standing' };
      
    } catch (error) {
      logger.error(`Error in account status middleware:`, error);
      return { accountStatus: null };
    }
  });

================
File: backend/src/middleware/auth.copy.ts
================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { Database } from '../database';

interface AuthenticatedRequest extends Request {
  user?: {
    id: number;
    email: string;
    organization_id: number;
    role: string;
    turso_db_url?: string;
    turso_auth_token?: string;
  };
}

export async function authMiddleware(
  req: AuthenticatedRequest, 
  res: Response, 
  next: NextFunction
) {
  try {
    // Verify JWT token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      res.status(401).json({ error: 'No token provided' });
      return;
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
      userId: number;
    };

    const db = new Database();

    // Get user with organization info from central DB
    const user = await db.execute(
      `SELECT u.*, o.turso_db_url, o.turso_auth_token
       FROM users u
       JOIN organizations o ON u.organization_id = o.id
       WHERE u.id = ?`,
      [decoded.userId]
    );

    if (!user) {
      res.status(401).json({ error: 'User not found' });
      return;
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Unauthorized' });
  }
}

================
File: backend/src/middleware/auth.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'
import { getUserFromSession } from '../services/auth'

// Auth middleware for protected routes
export const requireAuth = new Elysia()
  .derive(async ({ request, set }) => {
    try {
      // Check for auth bypass header - bypass if present (primarily for SPA non-API routes)
      const bypassAuth = request.headers.get('X-Bypass-Auth')
      if (bypassAuth) {
        logger.info(`Auth middleware: bypassing auth due to X-Bypass-Auth header for: ${new URL(request.url).pathname}`)
        return
      }

      // Check if this is a public endpoint that should bypass auth (e.g. SPA routes, if not caught by header)
      const url = new URL(request.url)
      const pathname = url.pathname
      
      // Bypass auth for SPA routes - belt and suspenders approach
      // This check might still be useful if the X-Bypass-Auth header isn't set for some SPA routes
      if ((!pathname.startsWith('/api/') && !pathname.includes('.')) || 
          pathname.startsWith('/compare/') ||
          pathname.startsWith('/quote/') ||
          pathname.startsWith('/eligibility') ||
          pathname.startsWith('/schedule')) {
        logger.info(`Auth middleware: bypassing auth for SPA route: ${pathname}`)
        return
      }
      
      // Get user from session
      const user = await getUserFromSession(request)
      logger.info(`Auth middleware: user: ${JSON.stringify(user)}`)
      
      // If no user or skip_auth not set, return 401
      if (!user ) {
        logger.warn(`not user: ${JSON.stringify(!user)}`)
        logger.warn(`Auth middleware: unauthorized access to ${pathname}`)
        set.status = 401
        // It's important to actually return the response object here for Elysia to halt processing
        return { success: false, error: 'Authentication required' }
      }
      
      // Return user object for routes to use
      return { user }
    } catch (error) {
      logger.error(`Auth middleware error: ${error}`)
      set.status = 500
      return { success: false, error: 'Internal server error' }
    }
  })

// Admin middleware - requires auth first
export const requireAdmin = new Elysia()
  .derive(async ({ request, set }) => {
    try {
      // Check for auth bypass header - bypass if present
      const bypassAuth = request.headers.get('X-Bypass-Auth')
      if (bypassAuth) {
        logger.info(`Admin middleware: bypassing auth due to X-Bypass-Auth header for: ${new URL(request.url).pathname}`)
        return
      }
      
      // Get user from session (should have been populated by requireAuth if it ran)
      const user = await getUserFromSession(request) // Or, if requireAuth decorates, this could come from context
      
      // If no user or not admin, return 403
      if (!user || !user.is_admin) {
        logger.warn(`Admin middleware: forbidden access to ${new URL(request.url).pathname}`)
        set.status = 403
        // It's important to actually return the response object here
        return { success: false, error: 'Admin access required' }
      }
      
      // Return user object for routes to use
      return { user }
    } catch (error) {
      logger.error(`Admin middleware error: ${error}`)
      set.status = 500
      return { success: false, error: 'Internal server error' }
    }
  })

================
File: backend/src/middleware/error.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'

export const errorHandler = new Elysia()
  .onError(({ code, error, set }) => {
    logger.error(`❌ Error: ${code} - ${error.message}`);
    logger.error(`Stack trace: ${error.stack}`);
    
    switch (code) {
      case 'NOT_FOUND':
        set.status = 404;
        return {
          success: false,
          message: 'Resource not found'
        };
      
      case 'VALIDATION':
        set.status = 400;
        return {
          success: false,
          message: error.message
        };
      
      default:
        set.status = 500;
        return {
          success: false,
          message: 'Internal server error'
        };
    }
  });

================
File: backend/src/routes/admin-portal.ts
================
import { Elysia } from 'elysia'
import { spawn } from 'child_process'
import path from 'path'
import { logger } from '../logger'
import { requireAuth, requireAdmin } from '../middleware/auth'

// Create admin portal routes
export const createAdminPortalRoutes = () => {
  const adminPortal = new Elysia({ prefix: '/api/admin' })
    .use(requireAuth)
    .use(requireAdmin)

    // Get available admin scripts
    .get('/scripts', () => {
      const availableScripts = [
        {
          id: 'add-agent',
          name: 'Add Agent',
          description: 'Interactive tool to add new agents',
          script: 'add-agent.ts'
        },
        {
          id: 'manage-recommendations',
          name: 'Manage GI Recommendations', 
          description: 'Manage guaranteed issue recommendations',
          script: 'manage-recommendations.ts'
        }
      ]
      
      return { scripts: availableScripts }
    })

    // Execute script endpoint
    .post('/execute/:scriptId', ({ params, set, server }) => {
      const { scriptId } = params
      const scriptPath = path.join(__dirname, '../../scripts', `${scriptId}.ts`)

      logger.info(`Executing admin script: ${scriptId}`)

      // Spawn script process
      const process = spawn('bun', ['run', scriptPath], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      // Get WebSocket server instance
      const wss = server.webSocket

      // Handle new WebSocket connections
      wss.on('connection', (ws) => {
        logger.info('Admin terminal WebSocket connected')

        // Handle input from client
        ws.on('message', (data: string) => {
          const parsed = JSON.parse(data)
          if (parsed.type === 'input') {
            process.stdin.write(parsed.data)
          }
        })

        // Send output to client
        process.stdout.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'output', 
            data: data.toString() 
          }))
        })

        process.stderr.on('data', (data) => {
          ws.send(JSON.stringify({ 
            type: 'error', 
            data: data.toString() 
          }))
        })

        // Handle process exit
        process.on('exit', (code) => {
          ws.send(JSON.stringify({ type: 'exit', code }))
          logger.info(`Admin script ${scriptId} exited with code ${code}`)
        })

        // Handle WebSocket close
        ws.on('close', () => {
          logger.info('Admin terminal WebSocket disconnected')
          process.kill()
        })
      })

      set.status = 200
      return { 
        success: true, 
        message: 'Script execution started' 
      }
    })

  return adminPortal
}

================
File: backend/src/routes/admin.ts
================
import { Elysia } from 'elysia'
import { staticPlugin } from '@elysiajs/static'
import { spawn } from 'child_process'
import path from 'path'
import { TursoService } from '../services/turso'

const tursoService = new TursoService()

export const adminRoutes = new Elysia()
  // Protect admin routes
  .guard({
    beforeHandle: ({ request, set }) => {
      // Add your admin authentication logic here
      const isAdmin = true // Replace with actual admin check
      if (!isAdmin) {
        set.status = 401
        return 'Unauthorized'
      }
    }
  })
  // Serve admin portal static files
  .use(staticPlugin({
    assets: '../admin-portal/dist',
    prefix: '/admin'
  }))
  // Terminal WebSocket endpoint
  .ws('/admin/terminal', {
    open(ws) {
      ws.send('Connected to admin terminal')
    },
    message(ws, message) {
      const { command, args } = JSON.parse(message as string)
      
      const scripts = {
        'add-agent': '../scripts/add-agent.ts',
        'manage-recommendations': '../scripts/manage-recommendations.ts'
      }

      if (!scripts[command]) {
        ws.send(JSON.stringify({ error: 'Invalid command' }))
        return
      }

      const script = spawn('bun', [path.resolve(__dirname, scripts[command]), ...args], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      script.stdout.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'output', data: data.toString() }))
      })

      script.stderr.on('data', (data) => {
        ws.send(JSON.stringify({ type: 'error', data: data.toString() }))
      })

      script.on('close', (code) => {
        ws.send(JSON.stringify({ type: 'exit', code }))
      })
    }
  })

// In your create organization endpoint:
app.post('/api/organizations', async (req, res) => {
  const { name, /* other org fields */ } = req.body
  
  try {
    // Create org in central DB
    const org = await db.one(`
      INSERT INTO organizations (name) 
      VALUES ($1) 
      RETURNING id`, 
      [name]
    )

    // Create Turso DB for org
    const { url, token } = await tursoService.createOrganizationDatabase(org.id)

    // Update org with Turso credentials
    await db.none(`
      UPDATE organizations 
      SET turso_db_url = $1, turso_auth_token = $2
      WHERE id = $3`,
      [url, token, org.id]
    )

    res.json({ success: true, organization: org })
  } catch (err) {
    res.status(500).json({ success: false, error: err.message })
  }
})

================
File: backend/src/routes/auth.ts
================
import { Elysia } from 'elysia';
import { cookie } from '@elysiajs/cookie';
import { AuthService } from '../services/auth';
import { EmailService } from '../services/email';
import { logger } from '../logger';
import { randomBytes } from 'crypto';
import { config } from '../config';
import crypto from 'crypto';
import { db } from '../database';
import { Database } from '../database';
import { getUserFromSession } from '../services/auth';
import type { User } from '../types';

const dbInstance = new Database();

export function createAuthRoutes() {
  const auth = new AuthService();
  const emailService = new EmailService();

  return new Elysia()
    .use(cookie())
    .post('/api/auth/set-session', async ({ body, set, setCookie }) => {
      const { email } = body as { email: string };
        logger.info(`Login request for email: ${email}`);

        // Check if user exists
        const client = dbInstance.getClient();
        const userResult = await client.execute({
          sql: 'SELECT id, email FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        if (userResult.rows.length === 0) {
          // Don't reveal if user exists or not
          logger.info(`No active user found for email: ${email}`);
          set.status = 404;
          return { success: false, error: 'User not found' };
        }
      const sessionId = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

      await db.execute(
        'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
        [sessionId, userResult.rows[0].id, expiresAt.toISOString()]
      );

      setCookie('session', sessionId, {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 24 * 1 // 1 day -- shorter to force them to login again soon after onboarding
      });

      set.status = 200;

      set.status = 200;
      return { success: true };
    })
    .post('/api/auth/login', async ({ body, set }) => {
      try {
        const { email } = body as { email: string };
        logger.info(`Login request for email: ${email}`);

        // Check if user exists
        const client = dbInstance.getClient();
        const userResult = await client.execute({
          sql: 'SELECT id, email FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        if (userResult.rows.length === 0) {
          // Don't reveal if user exists or not
          logger.info(`No active user found for email: ${email}`);
          return { success: true };
        }

        // Generate and send magic link
        const magicLink = await auth.createMagicLink(
          email,
          'default', // Default organization for now
          { redirectUrl: '/dashboard' }
        );

        // Always send the email, but also log in development
        if (process.env.NODE_ENV === 'development') {
          logger.info(`Development mode - Magic link: ${magicLink}`);
        }
        
        // Send the email
        await emailService.sendMagicLink(email, magicLink, 'default');

        set.status = 200;
        return { success: true };

      } catch (e) {
        logger.error(`Login error: ${e}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Internal server error'
        };
      }
    })

    .get('/api/signup/verify/:token', async ({ params, cookie, setCookie }) => {
      const { token } = params;
      logger.info(`Starting verification for token: ${token}`);

      try {
        const result = await auth.verifySignupLink(token);
        logger.info(`Signup verification result: ${JSON.stringify(result)}`);

        if (!result.valid) {
          logger.error('Signup verification failed');
          return {
            success: false, 
            redirectUrl: "/signup",
            session: "",
            email: ""
          };
        }

        logger.info(`Signup verification successful`);

        return {
          success: true,
          redirectUrl: result.redirectUrl || '/onboarding',
          session: "",
          email: result.email
        };
      } catch (error) {
        logger.error(`Signup verification error: ${error}`);
        return {
          success: false,
          redirectUrl: "/signup",
          session: "",  
          email: ""
        };
      }
    })

    .post('/api/auth/onboarding-login', async ({ body, set, setCookie }) => {
      const { emailRaw } = body as { emailRaw: string };
      logger.info(`Onboarding login request for email: ${emailRaw}`);

      // Decode the email if it's URL encoded and trim whitespace
      const email = decodeURIComponent(emailRaw).trim();
      
      const user = await db.fetchOne<User>(
        `SELECT u.*, o.slug as organization_slug 
        FROM users u 
        JOIN organizations o ON u.organization_id = o.id 
        WHERE LOWER(u.email) = LOWER(?) AND u.is_active = 1`,
        [email]
      );
      
      if (!user) {
        logger.error(`No active user found for email: ${email}`);
        return {
          success: false,
          redirectUrl: "/signup",
          email: ""
        };
      }
      
      logger.info(`Found user: ${JSON.stringify(user)}`);
      
      const sessionId = crypto.randomBytes(32).toString('hex');
      logger.info(`Created session ID: ${sessionId}`);
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 1); // 1 day from now

      await db.execute(
        'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
        [sessionId, user.id, expiresAt.toISOString()]
      );

      logger.info(`Created session in database for user ${user.id}`);

      setCookie('session', sessionId, {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 24 * 1 // 1 day -- shorter to force them to login again soon after onboarding
      });

      set.status = 200;
      return {
        success: true,  
        redirectUrl: "/dashboard?payment_success=true",
        email: user.email
      };
    })

    .get('/api/auth/verify/:organizationSlug/:token', async ({ params, cookie, setCookie }) => {
      const { token, organizationSlug } = params;
      
      logger.info(`Starting verification for org ${organizationSlug}`);

      try {
        logger.info('Verifying magic link');
        const result = await auth.verifyMagicLink(token, organizationSlug);
        logger.info(`Magic link verification result: ${JSON.stringify(result)}`);
        
        if (!result.valid) {
          logger.error('Magic link validation failed');
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        // Create session ID
        const sessionId = crypto.randomBytes(32).toString('hex');
        logger.info(`Created session ID: ${sessionId}`);

        // First find user by email
        const user = await db.fetchOne<User>(
          `SELECT u.*, o.slug as organization_slug 
           FROM users u 
           JOIN organizations o ON u.organization_id = o.id 
           WHERE LOWER(u.email) = LOWER(?) AND u.is_active = 1`,
          [result.email]
        );

        if (!user) {
          logger.error(`No active user found for email: ${result.email}`);
          return {
            success: false,
            redirectUrl: "/login",
            session: "",
            email: ""
          };
        }

        logger.info(`Found user: ${JSON.stringify(user)}`);

        // Create session in database
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

        await db.execute(
          'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
          [sessionId, user.id, expiresAt.toISOString()]
        );

        logger.info(`Created session in database for user ${user.id}`);

        // Set session cookie
        setCookie('session', sessionId, {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 7 // 7 days
        });

        const verificationResult = {
          success: true,
          redirectUrl: result.redirectUrl || '/walkthrough',  // Use the redirectUrl from magic link payload
          session: sessionId,
          email: result.email,
          orgSlug: user.organization_id.toString()  // Use organization_id since organization_slug may not exist
        };
        logger.info(`Sending verification response: ${JSON.stringify(verificationResult)}`);
        return verificationResult;

      } catch (error) {
        logger.error(`Verification error: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return {
          success: false,
          redirectUrl: "/login",
          session: "",
          email: ""
        };
      }
    })

    .get('/api/auth/session', async ({ cookie, set }) => {
      const sessionId = cookie.session;
      logger.info(`Session check - Cookie session ID: ${sessionId}`);
      
      if (!sessionId) {
        logger.info('No session cookie found');
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          id: "",
          demo_mode: true,
          orgCreateDate: ""
        };
      }

      try {
        // Get user and organization info from session
        logger.info(`Looking up session in database: ${sessionId}`);
        const sessionUser = await db.fetchOne<{
          id: number;
          email: string;
          first_name: string;
          last_name: string;
          is_admin: boolean;
          organization_slug: string;
          demo_mode: boolean;
          orgCreateDate: string;
        }>(
          `SELECT u.id, u.email, u.first_name, u.last_name, u.is_admin, o.slug as organization_slug, o.demo_mode, o.created_at as orgCreateDate
           FROM sessions s
           JOIN users u ON s.user_id = u.id
           JOIN organizations o ON u.organization_id = o.id
           WHERE s.id = ?`,
          [sessionId]
        );

        if (!sessionUser) {
          logger.info(`No session found in database for ID: ${sessionId}`);
          return { 
            valid: false,
            session: "",
            email: "",
            organizationSlug: "",
            first_name: "",
            last_name: "",
            is_admin: false,
            id: "",
            demo_mode: true,
            orgCreateDate: ""
          };
        }

        logger.info(`Found valid session for user: ${sessionUser.email}`);
        logger.info(`Session details: ${JSON.stringify(sessionUser, null, 2)}`);

        set.status = 200;
        return { 
          valid: true,
          session: sessionId,
          email: sessionUser.email,
          organizationSlug: sessionUser.organization_slug,
          first_name: sessionUser.first_name,
          last_name: sessionUser.last_name,
          is_admin: sessionUser.is_admin,
          id: sessionUser.id,
          demo_mode: sessionUser.demo_mode,
          orgCreateDate: sessionUser.orgCreateDate.split(/[ T]/)[0]
        };
      } catch (error) {
        logger.error(`Error getting session info: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error details: ${error.message}`);
          logger.error(`Stack trace: ${error.stack}`);
        }
        return { 
          valid: false,
          session: "",
          email: "",
          organizationSlug: "",
          first_name: "",
          last_name: "",
          is_admin: false,
          id: "",
          demo_mode: true,
          orgCreateDate: ""
        };
      }
    })

    .post('/api/auth/logout', async ({ set }) => {
      set.headers['Set-Cookie'] = 'session=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT';
      return { success: true };
    });
}

================
File: backend/src/routes/billing.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { config } from '../config';
import { requireAuth } from '../middleware/auth';
import Stripe from 'stripe';

const stripe = new Stripe(config.stripeSecretKey || '', {
  apiVersion: '2025-02-24.acacia'
});

interface PlanInfo {
  name: string;
  contactCount: number;
  totalClients: number;
  priceDescription?: string;
  basePrice?: number;
  contactsIncluded?: number;
  pricePerAdditionalContact?: number;
}

interface PaymentMethod {
  id: string;
  type: string;
  last4: string;
  brand: string;
  expiryMonth: number;
  expiryYear: number;
  email: string;
}

interface Invoice {
  id: string;
  number: string;
  date: string;
  status: 'pending' | 'paid' | 'failed';
  amount: number;
  currency: string;
  plan: string;
  pdfUrl?: string;
}

export const createBillingRoutes = (app: Elysia) => {
  app.use(requireAuth)
    
    // Get current plan information
    .get('/api/billing/plan', async ({ user, set }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        logger.info(`Fetching plan for organization_id: ${user.organization_id}`);
        
        const mainDb = new Database(); // For main 'organizations' table
        
        // Get organization details (excluding contact_count) from main DB
        const orgDetailsFromMain = await mainDb.fetchOne<{
          id: number; 
          name: string;
          stripe_customer_id: string | null;
          stripe_subscription_id: string | null;
          subscription_tier: string | null;
        }>(
          `SELECT 
              id,
              name,
              stripe_customer_id,
              stripe_subscription_id,
              subscription_tier 
            FROM organizations
            WHERE id = ?`,
          [user.organization_id]
        );
        
        logger.info(`Organization details from DB for org ${user.organization_id}: ${JSON.stringify(orgDetailsFromMain)}`);

        if (!orgDetailsFromMain) {
          set.status = 404;
          logger.error(`Organization not found in main DB for id: ${user.organization_id}`);
          return { success: false, error: 'Organization not found' };
        }

        let contactCount = 0;
        try {
          // Get contact_count from org-specific DB
          // Ensure user.organization_id is passed as a string to getOrgDb
          const orgDb = await Database.getOrgDb(user.organization_id.toString());
          const contactCountResult = await orgDb.fetchOne<{ count: number }>(
            // Count all contacts in the table, as all are considered active
            "SELECT COUNT(id) as count FROM contacts"
          );
          if (contactCountResult) {
            contactCount = contactCountResult.count;
          }
          logger.info(`Fetched contact_count: ${contactCount} for org ${user.organization_id} from orgDB.`);
        } catch (orgDbError) {
          logger.error(`Error fetching contact count from orgDB for org ${user.organization_id}: ${orgDbError}`);
          // Continue with contactCount = 0 and rely on defaults.
        }
        
        // Combine org details with contact count
        const org = {
          ...orgDetailsFromMain,
          contact_count: contactCount // Add the count here
        };
        
        // Default plan info
        let planInfo: PlanInfo = {
          name: 'Monthly Plan',
          contactCount: Number(org.contact_count) || 0,
          totalClients: 500, // Default limit
          priceDescription: 'Plan details not available', // Default description
        };
        
        // If they have a Stripe subscription, get details from Stripe
        if (org.stripe_subscription_id) {
          try {
            let subscriptionIdToUse = org.stripe_subscription_id as string;
            logger.info(`Initial stripe_subscription_id from DB for org ${user.organization_id}: ${org.stripe_subscription_id}`);
            try {
              // Attempt to parse as JSON and get the id field
              const parsedSubscription = JSON.parse(org.stripe_subscription_id as string);
              if (parsedSubscription && typeof parsedSubscription.id === 'string') {
                subscriptionIdToUse = parsedSubscription.id;
              } else {
                // Log a warning if parsing succeeded but 'id' field is missing or not a string
                logger.warn(`Parsed stripe_subscription_id but 'id' field is missing or not a string for org ${user.organization_id}`);
              }
            } catch (parseError) {
              // If parsing fails, assume it's already a plain string ID. Log this for awareness.
              logger.info(`stripe_subscription_id for org ${user.organization_id} is not valid JSON, using as plain string: ${parseError}`);
            }

            logger.info(`Using subscriptionIdToUse: ${subscriptionIdToUse} for org ${user.organization_id}`);

            const subscription = await stripe.subscriptions.retrieve(
              subscriptionIdToUse
            );
            logger.info(`Full retrieved subscription object for org ${user.organization_id}: ${JSON.stringify(subscription, null, 2)}`);

            if (subscription.items.data.length > 0 && subscription.items.data[0].price) {
              // The full price object is part of the full subscription object logged above, so this specific log can be removed if desired.
            }
            
            // Get the price details
            if (subscription.items.data.length > 0) {
              const item = subscription.items.data[0];
              const price = item.price; // This is a Stripe.Price object
              
              // Update plan name from Stripe product
              if (price.product) {
                try {
                  const productObjectOrId = price.product;
                  const productId = typeof productObjectOrId === 'string' ? productObjectOrId : productObjectOrId.id;
                  
                  const stripeProduct = await stripe.products.retrieve(productId);
                  
                  logger.info(`Full retrieved product object for org ${user.organization_id} (product ID ${productId}): ${JSON.stringify(stripeProduct, null, 2)}`);

                  if (stripeProduct && stripeProduct.name) {
                    planInfo.name = stripeProduct.name;
                  }

                  // Initialize price fields before attempting to parse or use defaults
                  planInfo.basePrice = undefined;
                  planInfo.contactsIncluded = undefined;
                  planInfo.pricePerAdditionalContact = undefined;

                  if (price.unit_amount) {
                    planInfo.basePrice = price.unit_amount / 100;
                  } else if (price.billing_scheme === 'tiered' || price.billing_scheme === 'per_unit') {
                    planInfo.basePrice = 0; // Indicates usage-based or tiers, to be refined by description
                    logger.warn(`Price object for org ${user.organization_id} has null unit_amount (billing_scheme: ${price.billing_scheme}). Base price set to 0 initially.`);
                  }

                  // Try to parse detailed pricing from the product description.
                  if (stripeProduct && stripeProduct.description) {
                    planInfo.priceDescription = stripeProduct.description; // Store the raw description first
                    
                    const priceRegex = /\$(\d+(?:\.\d{1,2})?)[^\d]*?(\d+)\s+contacts\D*\$(\d+(?:\.\d{1,2})?)\s*\/\s*contact/i;
                    const matches = stripeProduct.description.match(priceRegex);

                    if (matches && matches.length >= 4) {
                      planInfo.basePrice = parseFloat(matches[1]); // Override if parsed
                      planInfo.contactsIncluded = parseInt(matches[2], 10);
                      planInfo.pricePerAdditionalContact = parseFloat(matches[3]);
                      planInfo.priceDescription = `\$${planInfo.basePrice}/month for first ${planInfo.contactsIncluded} contacts, then \$${planInfo.pricePerAdditionalContact}/contact.`;
                      logger.info(`Parsed detailed pricing for org ${user.organization_id}: Base: ${planInfo.basePrice}, Included: ${planInfo.contactsIncluded}, Additional: ${planInfo.pricePerAdditionalContact}`);
                    } else {
                      logger.warn(`Could not parse detailed pricing structure from product description for org ${user.organization_id}: ${stripeProduct.description}. Using full description.`);
                      // Fallback for basePrice if not parsed from complex structure but a simple price exists in description
                      if (planInfo.basePrice === 0 || planInfo.basePrice === undefined) { // Only if not set by unit_amount or complex parse
                        const singlePriceMatch = stripeProduct.description.match(/\$(\d+(?:\.\d{1,2})?)/);
                        if (singlePriceMatch && singlePriceMatch[1]) {
                          planInfo.basePrice = parseFloat(singlePriceMatch[1]);
                          logger.info(`Fallback: Parsed base price $${planInfo.basePrice} from product description for org ${user.organization_id}`);
                        }
                      }
                    }
                  } else {
                    planInfo.priceDescription = 'Pricing details not available in product description.';
                  }

                } catch (productError) {
                  logger.error(`Error fetching product details from Stripe: ${productError} for product ID: ${price.product}`);
                  // Continue with default plan name or previously set name
                }
              }

              if (price.unit_amount) {
                // planInfo.pricePerMonth = price.unit_amount / 100; // Convert from cents
              } else if (price.billing_scheme === 'tiered' || price.billing_scheme === 'per_unit') {
                // For tiered or metered plans without a simple unit_amount, actual price is usage-dependent.
                // Set to 0 or a specific indicator. For now, 0 and log.
                // planInfo.pricePerMonth = 0;
                logger.warn(`Price object for org ${user.organization_id} has null unit_amount (billing_scheme: ${price.billing_scheme}). Display price set to 0. Full pricing is usage-dependent or tiered.`);
              }
              // If unit_amount is null and it's not explicitly tiered/per_unit, it will keep the default 60, 
              // which might indicate an issue or a different pricing model not yet handled.
            }
            
            // You can customize the total clients based on the plan
            if (org.subscription_tier === 'premium') {
              planInfo.totalClients = 1000;
            } else if (org.subscription_tier === 'enterprise') {
              planInfo.totalClients = 5000;
            }
          } catch (stripeError) {
            logger.error(`Error fetching subscription from Stripe: ${stripeError}`);
            // Continue with default values
          }
        }
        
        logger.info(`Final planInfo for org ${user.organization_id}: ${JSON.stringify(planInfo)}`);
        return {
          success: true,
          data: planInfo
        };
      } catch (error) {
        logger.error(`Error in plan info route: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to fetch plan information'
        };
      }
    })
    
    // Get payment method information
    .get('/api/billing/payment-method', async ({ user, set }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const db = new Database();
        const client = db.getClient();
        
        const orgResult = await client.execute({
          sql: 'SELECT stripe_customer_id FROM organizations WHERE id = ?',
          args: [user.organization_id]
        });
        
        if (orgResult.rows.length === 0 || !orgResult.rows[0].stripe_customer_id) {
          return {
            success: true,
            data: null // No Stripe customer ID, so no payment method
          };
        }
        
        const stripeCustomerId = orgResult.rows[0].stripe_customer_id as string;

        // Retrieve the customer, expanding the default payment method
        const customer = await stripe.customers.retrieve(stripeCustomerId, {
          expand: ['invoice_settings.default_payment_method']
        });

        if (!customer || customer.deleted) {
          logger.warn(`Stripe customer not found or deleted for customer ID: ${stripeCustomerId}`);
          return {
            success: true,
            data: null
          };
        }
        
        const defaultPaymentMethod = customer.invoice_settings?.default_payment_method;

        if (defaultPaymentMethod && typeof defaultPaymentMethod !== 'string' && defaultPaymentMethod.type === 'card' && defaultPaymentMethod.card) {
          const paymentMethodDetails: PaymentMethod = {
            id: defaultPaymentMethod.id,
            type: defaultPaymentMethod.type,
            last4: defaultPaymentMethod.card.last4 || '',
            brand: defaultPaymentMethod.card.brand || '',
            expiryMonth: defaultPaymentMethod.card.exp_month || 0,
            expiryYear: defaultPaymentMethod.card.exp_year || 0,
            email: (customer as Stripe.Customer).email || ''
          };
          return {
            success: true,
            data: paymentMethodDetails
          };
        } else {
          // No default payment method, or it's not a card, or card details are missing
          logger.info(`No default card payment method found or details incomplete for customer ${stripeCustomerId}`);
          return {
            success: true,
            data: null // No suitable payment method found
          };
        }
      } catch (error) {
        logger.error(`Error in payment method route: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to fetch payment method information' 
        };
      }
    })
    
    // Get invoices list
    .get('/api/billing/invoices', async ({ user, set, query }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const db = new Database();
        const client = db.getClient();
        
        // Get organization's Stripe customer ID
        const orgResult = await client.execute({
          sql: 'SELECT stripe_customer_id FROM organizations WHERE id = ?',
          args: [user.organization_id]
        });
        
        if (orgResult.rows.length === 0 || !orgResult.rows[0].stripe_customer_id) {
          return {
            success: true,
            data: [] // No invoices
          };
        }
        
        const stripeCustomerId = orgResult.rows[0].stripe_customer_id as string;
        
        // Get invoices from Stripe
        const limit = query?.limit ? parseInt(query.limit as string) : 10;
        const stripeInvoices = await stripe.invoices.list({
          customer: stripeCustomerId,
          limit: limit
        });
        
        const invoices: Invoice[] = stripeInvoices.data.map(inv => ({
          id: inv.id,
          number: inv.number || `#${inv.id.slice(-4).toUpperCase()}`,
          date: new Date(inv.created * 1000).toISOString(),
          status: inv.status === 'paid' ? 'paid' : 
                  inv.status === 'open' ? 'pending' : 'failed',
          amount: (inv.amount_paid || inv.amount_due) / 100, // Convert from cents
          currency: inv.currency.toUpperCase(),
          plan: 'Monthly', // You can customize this based on subscription
          pdfUrl: inv.invoice_pdf || undefined
        }));
        
        return {
          success: true,
          data: invoices
        };
      } catch (error) {
        logger.error(`Error in invoices route: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to fetch invoices'
        };
      }
    })
    
    // Update payment method
    .post('/api/billing/update-payment-method', async ({ user, body, set }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const { paymentMethodId } = body as { paymentMethodId: string };
        
        if (!paymentMethodId) {
          set.status = 400;
          return {
            success: false,
            error: 'Payment method ID is required'
          };
        }
        
        const db = new Database();
        const client = db.getClient();
        
        // Get organization's Stripe customer ID
        const orgResult = await client.execute({
          sql: 'SELECT stripe_customer_id, stripe_subscription_id FROM organizations WHERE id = ?',
          args: [user.organization_id]
        });
        
        if (orgResult.rows.length === 0 || !orgResult.rows[0].stripe_customer_id) {
          set.status = 400;
          return {
            success: false,
            error: 'No Stripe customer found for organization'
          };
        }
        
        const stripeCustomerId = orgResult.rows[0].stripe_customer_id as string;
        const stripeSubscriptionId = orgResult.rows[0].stripe_subscription_id as string;
        
        // Attach the payment method to the customer
        await stripe.paymentMethods.attach(paymentMethodId, {
          customer: stripeCustomerId
        });
        
        // Set as default payment method for the customer
        await stripe.customers.update(stripeCustomerId, {
          invoice_settings: {
            default_payment_method: paymentMethodId
          }
        });
        
        // If there's a subscription, update its default payment method too
        if (stripeSubscriptionId) {
          await stripe.subscriptions.update(stripeSubscriptionId, {
            default_payment_method: paymentMethodId
          });
        }
        
        return {
          success: true,
          message: 'Payment method updated successfully'
        };
      } catch (error) {
        logger.error(`Error updating payment method: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to update payment method'
        };
      }
    })
    
    // Download invoice
    .get('/api/billing/invoices/:invoiceId/download', async ({ user, params, set }) => {
      try {
        if (!user?.organization_id) {
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const { invoiceId } = params;
        
        // Retrieve the invoice from Stripe
        const invoice = await stripe.invoices.retrieve(invoiceId);
        
        // Verify the invoice belongs to the user's organization
        const db = new Database();
        const client = db.getClient();
        
        const orgResult = await client.execute({
          sql: 'SELECT stripe_customer_id FROM organizations WHERE id = ?',
          args: [user.organization_id]
        });
        
        if (orgResult.rows.length === 0 || 
            orgResult.rows[0].stripe_customer_id !== invoice.customer) {
          set.status = 403;
          return {
            success: false,
            error: 'Unauthorized to access this invoice'
          };
        }
        
        if (!invoice.invoice_pdf) {
          set.status = 404;
          return {
            success: false,
            error: 'Invoice PDF not available'
          };
        }
        
        // Return the PDF URL for the client to download
        return {
          success: true,
          data: {
            url: invoice.invoice_pdf
          }
        };
      } catch (error) {
        logger.error(`Error downloading invoice: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to download invoice'
        };
      }
    });

  return app;
};

================
File: backend/src/routes/brand.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';

const db = new Database();

interface Organization {
  id: number;
}

interface BrandSettings {
  brand_name: string;
  primary_color: string;
  secondary_color: string;
  logo_data: string | null;
}

export function createBrandRoutes() {
  return new Elysia()
    .get('/api/organizations/:orgSlug/brand', async ({ params }) => {
      try {
        const { orgSlug } = params;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Get brand settings
        const settings = await db.fetchOne<BrandSettings>(
          'SELECT brand_name, primary_color, secondary_color, logo_data FROM brand_settings WHERE organization_id = ?',
          [org.id]
        );

        if (!settings) {
          // Return defaults if no settings exist
          return {
            brand_name: '',
            primary_color: '#6B46C1',
            secondary_color: '#9F7AEA',
            logo: null
          };
        }

        return {
          brand_name: settings.brand_name,
          primary_color: settings.primary_color,
          secondary_color: settings.secondary_color,
          logo: settings.logo_data
        };
      } catch (error) {
        logger.error('Error fetching brand settings', error);
        return {
          success: false,
          error: 'Failed to fetch brand settings'
        };
      }
    })
    .put('/api/organizations/:orgSlug/brand', async ({ params, body }) => {
      try {
        const { orgSlug } = params;
        const { brand_name, primary_color, secondary_color, logo } = body as any;

        // Get organization ID
        const org = await db.fetchOne<Organization>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!org) {
          return {
            success: false,
            error: 'Organization not found'
          };
        }

        // Upsert brand settings
        await db.execute(`
          INSERT INTO brand_settings 
            (organization_id, brand_name, primary_color, secondary_color, logo_data)
          VALUES (?, ?, ?, ?, ?)
          ON CONFLICT(organization_id) DO UPDATE SET
            brand_name = excluded.brand_name,
            primary_color = excluded.primary_color,
            secondary_color = excluded.secondary_color,
            logo_data = excluded.logo_data
        `, [org.id, brand_name, primary_color, secondary_color, logo]);

        return {
          success: true
        };
      } catch (error) {
        logger.error('Error saving brand settings', error);
        return {
          success: false,
          error: 'Failed to save brand settings'
        };
      }
    });
}

================
File: backend/src/routes/contact.ts
================
import { Elysia } from "elysia";
import sgMail from '@sendgrid/mail';
import { logger } from '../logger';

// Initialize SendGrid
if (process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY);
}

export const contactUsRoutes = new Elysia({ prefix: "/api/contact-us" })
  .post("/", async ({ body, set }) => {
    try {
      const { name, email, phone, message } = body as {
        name: string;
        email: string;
        phone?: string;
        message: string;
      };

      // Validate required fields
      if (!name || !email || !message) {
        set.status = 400;
        return { error: "Missing required fields" };
      }

      // Send email notification to support
      const fromEmail = process.env.SENDGRID_FROM_EMAIL || 'noreply@medicaremax.ai';
      
      await sgMail.send({
        to: "information@medicaremax.ai",
        from: {
          email: fromEmail,
          name: 'Medicare Max Contact Form'
        },
        subject: `Contact Form Submission from ${name}`,
        html: `
          <h2>New Contact Form Submission</h2>
          <p><strong>Name:</strong> ${name}</p>
          <p><strong>Email:</strong> ${email}</p>
          ${phone ? `<p><strong>Phone:</strong> ${phone}</p>` : ""}
          <p><strong>Message:</strong></p>
          <p>${message.replace(/\n/g, "<br>")}</p>
        `,
      });

      // Send confirmation email to the user
      await sgMail.send({
        to: email,
        from: {
          email: fromEmail,
          name: 'Medicare Max'
        },
        subject: "Thank you for contacting Medicare Max",
        html: `
          <h2>Thank you for contacting us!</h2>
          <p>Dear ${name},</p>
          <p>We have received your message and will get back to you as soon as possible.</p>
          <p>Here's a copy of your message:</p>
          <blockquote style="background: #f0f0f0; padding: 10px; margin: 10px 0;">
            ${message.replace(/\n/g, "<br>")}
          </blockquote>
          <p>Best regards,<br>Medicare Max Team</p>
        `,
      });
      
      logger.info(`Contact form submitted by ${name} (${email})`);

      return { success: true };
    } catch (error) {
      console.error("Error processing contact form:", error);
      set.status = 500;
      return { error: "Failed to process contact form" };
    }
  });

================
File: backend/src/routes/contacts.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { validateSession, getUserFromSession } from '../services/auth';
import fs from 'fs';
import path from 'path';
import { stringify } from 'csv-stringify/sync';
import { nanoid } from 'nanoid';
import { ZIP_DATA } from '../index';
import { TursoService } from '../services/turso';
import { TURSO_CONFIG } from '../config/turso';
import fetch from 'node-fetch';
import { 
  trackContact, 
  trackContactBatch, 
  getContactUsageStats, 
  getUniqueContactCount,
  resetContactCount
} from '../services/contactTracking';

type User = {
  id: number;
  organization_id: number;
  is_admin: boolean;
};

interface ContactImport {
  first_name: string;
  last_name: string;
  email: string;
  phone_number: string;
  state?: string;
  current_carrier: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: boolean;
  gender: string;
  zip_code: string;
  plan_type: string;
}

type BulkImportRequest = {
  contacts: ContactImport[];
  overwriteExisting: boolean;
  agentId?: number | null;
};

interface Contact {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  phone_number?: string;
  state: string;
  current_carrier?: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: number;
  gender: string;
  zip_code: string;
  plan_type?: string;
  agent_id?: number;
  last_emailed?: string;
  created_at: string;
  updated_at: string;
  status?: string;
}

type Context = {
  request: Request;
  user: User;
  set: { status: number };
};

function normalizeEmail(email: string): string {
    return email.trim().toLowerCase();
}

/**
 * Contacts API endpoints
 */
export const contactsRoutes = new Elysia({ prefix: '/api/contacts' })
  .use(app => app
    .derive(async ({ request, set }) => {
      const sessionCookie = request.headers.get('cookie')?.split(';')
        .find(c => c.trim().startsWith('session='))
        ?.split('=')[1];

      if (!sessionCookie) {
        set.status = 401;
        return { error: 'Not authorized' };
      }

      const user = await validateSession(sessionCookie);
      if (!user) {
        set.status = 401;
        return { error: 'Not authorized' };
      }

      return { user };
    })
  )
  .get('/', async ({ request, user, set }: Context) => {
    if (!user || !user.organization_id) {
      set.status = 401;
      return { error: 'Not authorized' };
    }

    try {
      // Parse query parameters
      const url = new URL(request.url);
      const page = parseInt(url.searchParams.get('page') || '1');
      const limit = parseInt(url.searchParams.get('limit') || '100');
      const search = url.searchParams.get('search') || '';
      const states = url.searchParams.get('states')?.split(',').filter(Boolean) || [];
      const carriers = url.searchParams.get('carriers')?.split(',').filter(Boolean) || [];
      const agents = url.searchParams.get('agents')?.split(',').map(Number).filter(Boolean) || [];

      logger.info(`Fetching contacts for org ${user.organization_id} - page: ${page}, limit: ${limit}, search: ${search || 'none'}, states: ${states.length ? states.join(',') : 'none'}, carriers: ${carriers.length ? carriers.join(',') : 'none'}, agents: ${agents.length ? agents.join(',') : 'none'}`);

      // Build base query parts
      let whereConditions = ['1=1'];
      let params: any[] = [];

      // Add search condition if present
      if (search) {
        const searchTerms = search.trim().split(/\s+/);
        
        if (searchTerms.length === 1) {
          // Single word search - check each column individually
          whereConditions.push('(first_name LIKE ? OR last_name LIKE ? OR email LIKE ? OR phone_number LIKE ?)');
          params.push(`%${search}%`, `%${search}%`, `%${search}%`, `%${search}%`);
        } else {
          // Multi-word search - treat first word as first name and remaining words as last name
          const firstName = searchTerms[0];
          const lastName = searchTerms.slice(1).join(' ');
          
          whereConditions.push('((first_name LIKE ? AND last_name LIKE ?) OR first_name LIKE ? OR last_name LIKE ? OR email LIKE ? OR phone_number LIKE ?)');
          params.push(
            `%${firstName}%`, `%${lastName}%`, // Combined name search
            `%${search}%`, `%${search}%`, // Full search term in either name field
            `%${search}%`, `%${search}%` // Email and phone
          );
        }
      }

      // Add state filter
      if (states.length > 0) {
        const zipCodesForStates = Object.entries(ZIP_DATA)
          .filter(([_, info]) => states.includes(info.state))
          .map(([zipCode]) => zipCode);
        whereConditions.push(`zip_code IN (${zipCodesForStates.map(() => '?').join(',')})`);
        params.push(...zipCodesForStates);
      }

      // Add carrier filter
      if (carriers.length > 0) {
        whereConditions.push(`(${carriers.map(() => 'current_carrier LIKE ?').join(' OR ')})`);
        params.push(...carriers.map(c => `%${c}%`));
      }

      // Add agent filter
      if (agents.length > 0) {
        whereConditions.push(`agent_id IN (${agents.map(() => '?').join(',')})`);
        params.push(...agents);
      }

      // Combine conditions
      const whereClause = whereConditions.join(' AND ');

      // Get organization database with retry logic
      let orgDb;
      try {
        orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
      } catch (error) {
        // If database not found, check if it exists in the list
        if (error instanceof Error && error.message.includes('database not configured')) {
          logger.info(`Database not found for org ${user.organization_id}, checking database list...`);
          
          const tursoService = new TursoService();
          const mainDb = new Database();
          
          // Get the org's database URL
          const orgData = await mainDb.fetchOne<{ turso_db_url: string }>(
            'SELECT turso_db_url FROM organizations WHERE id = ?',
            [user.organization_id]
          );

          if (!orgData?.turso_db_url) {
            logger.error(`No database URL found for org ${user.organization_id}`);
            set.status = 500;
            return { error: 'Organization database not configured' };
          }

          // Extract database name from URL
          const dbName = orgData.turso_db_url.split('/').pop()?.split('.')[0]?.replace(/-[^-]*$/, '');
          if (!dbName) {
            logger.error(`Could not extract database name from URL: ${orgData.turso_db_url}`);
            set.status = 500;
            return { error: 'Invalid database configuration' };
          }

          // Check if database exists in Turso
          const response = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
            }
          });

          if (!response.ok) {
            logger.error(`Failed to list databases, status: ${response.status}`);
            set.status = 500;
            return { error: 'Failed to verify database status' };
          }

          const data = await response.json();
          const dbExists = data.databases.some((db: any) => db.Name === dbName);

          if (dbExists) {
            logger.info(`Database ${dbName} found in list, retrying connection...`);
            // Retry getting the database
            try {
              orgDb = await Database.getOrgDb(user.organization_id.toString());
            } catch (retryError) {
              logger.error(`Failed to connect to database after verification: ${retryError}`);
              set.status = 500;
              return { error: 'Database exists but connection failed' };
            }
          } else {
            logger.error(`Database ${dbName} not found in Turso organization`);
            set.status = 500;
            return { error: 'Database not found in organization' };
          }
        } else {
          // For other errors, throw them
          throw error;
        }
      }

      logger.info(`Connected to org database for ${user.organization_id}`);

      // First get total count with a simpler query
      const countQuery = `SELECT COUNT(*) as total FROM contacts WHERE ${whereClause}`;
      logger.info(`Executing count query: ${countQuery} with params: ${JSON.stringify(params)}`);
      
      const countResult = await orgDb.fetchOne<{ total: number }>(countQuery, params);
      let total = countResult?.total || 0;
      logger.info(`Found total of ${total} contacts matching criteria`);

      // If no contacts found, verify database is properly synced
      if (total === 0) {
        logger.info(`No contacts found for org ${user.organization_id}, verifying database sync status...`);
        
        const mainDb = new Database();
        
        // Get the org's database URL
        const orgData = await mainDb.fetchOne<{ turso_db_url: string }>(
          'SELECT turso_db_url FROM organizations WHERE id = ?',
          [user.organization_id]
        );

        if (!orgData?.turso_db_url) {
          logger.error(`No database URL found for org ${user.organization_id}`);
          set.status = 500;
          return { error: 'Organization database not configured' };
        }

        // Extract database name from URL
        const dbName = orgData.turso_db_url.split('/').pop()?.split('.')[0]?.replace(/-[^-]*$/, '');
        if (!dbName) {
          logger.error(`Could not extract database name from URL: ${orgData.turso_db_url}`);
          set.status = 500;
          return { error: 'Invalid database configuration' };
        }

        // Check if database exists in Turso
        const response = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${TURSO_CONFIG.API_TOKEN}`,
          }
        });

        if (!response.ok) {
          logger.error(`Failed to list databases, status: ${response.status}`);
          set.status = 500;
          return { error: 'Failed to verify database status' };
        }

        const data = await response.json();
        const dbExists = data.databases.some((db: any) => db.Name === dbName);

        if (dbExists) {
          logger.info(`Database ${dbName} found in list, retrying connection and count...`);
          // Retry getting the database and count
          try {
            orgDb = await Database.getOrgDb(user.organization_id.toString());
            const retryCountResult = await orgDb.fetchOne<{ total: number }>(countQuery, params);
            const retryTotal = retryCountResult?.total || 0;
            logger.info(`Retry count found ${retryTotal} contacts`);
            if (retryTotal > 0) {
              total = retryTotal; // Update total if we found contacts on retry
            }
          } catch (retryError) {
            logger.error(`Failed to reconnect to database after verification: ${retryError}`);
            set.status = 500;
            return { error: 'Database exists but connection failed' };
          }
        } else {
          logger.error(`Database ${dbName} not found in Turso organization`);
          set.status = 500;
          return { error: 'Database not found in organization' };
        }
      }

      // Then get paginated results
      const offset = (page - 1) * limit;
      const selectQuery = `
        SELECT 
          COALESCE(id, rowid) as id,
          first_name, last_name, email, phone_number, state,
          current_carrier, effective_date, birth_date, tobacco_user,
          gender, zip_code, plan_type, agent_id, last_emailed,
          created_at, updated_at, status
        FROM contacts 
        WHERE ${whereClause}
        ORDER BY created_at DESC 
        LIMIT ? OFFSET ?`;
      
      logger.info(`Executing select query: ${selectQuery} with params: ${JSON.stringify([...params, limit, offset])}`);
      
      const contacts = await orgDb.query<Contact>(selectQuery, [...params, limit, offset]);
      logger.info(`Retrieved ${contacts.length} contacts for current page`);

      // Log first contact for debugging
      if (contacts.length > 0) {
        logger.info(`First contact: ${JSON.stringify(contacts[0])}`);
      }

      // Get filter options using separate queries for unique values
      const carrierQuery = `SELECT DISTINCT current_carrier FROM contacts WHERE ${whereClause} AND current_carrier IS NOT NULL ORDER BY current_carrier`;
      const zipQuery = `SELECT DISTINCT zip_code FROM contacts WHERE ${whereClause} AND zip_code IS NOT NULL ORDER BY zip_code`;
      
      const [carrierRows, zipRows] = await Promise.all([
        orgDb.query<{current_carrier: string}>(carrierQuery, params),
        orgDb.query<{zip_code: string}>(zipQuery, params)
      ]);

      // Get unique states from zip codes using ZIP_DATA
      const uniqueStates = zipRows
        .map(row => {
          const zipInfo = ZIP_DATA[row.zip_code];
          return zipInfo?.state;
        })
        .filter((state): state is string => state !== undefined)
        .filter((value, index, self) => self.indexOf(value) === index)
        .sort();
      
      const filterOptions = {
        carriers: carrierRows.map(row => row.current_carrier).filter(Boolean),
        states: uniqueStates
      };
      
      logger.info(`Filter options - carriers: ${filterOptions.carriers.join(',')}, states: ${filterOptions.states.join(',')}`);

      // Map contacts to expected format using snake_case
      const mappedContacts = contacts.map(contact => {
        // Get state from ZIP code
        const zipInfo = ZIP_DATA[contact.zip_code];
        const state = zipInfo?.state || contact.state; // Fallback to stored state if ZIP lookup fails

        // Ensure we have a valid ID
        if (!contact.id) {
          logger.error(`Contact missing ID: ${JSON.stringify(contact)}`);
        }

        return {
          id: contact.id || 0, // Fallback to 0 if null (shouldn't happen with COALESCE)
          first_name: contact.first_name,
          last_name: contact.last_name,
          email: contact.email,
          phone_number: contact.phone_number || '',
          state: state,
          current_carrier: contact.current_carrier,
          effective_date: contact.effective_date,
          birth_date: contact.birth_date,
          tobacco_user: Boolean(contact.tobacco_user),
          gender: contact.gender,
          zip_code: contact.zip_code,
          plan_type: contact.plan_type,
          agent_id: contact.agent_id,
          last_emailed: contact.last_emailed,
          status: contact.status || 'New'
        };
      });

      const response = {
        contacts: mappedContacts,
        filterOptions,
        total,
        page,
        limit
      };

      logger.info(`Returning response with ${mappedContacts.length} contacts, total: ${total}`);
      return response;

    } catch (error) {
      logger.error(`Error fetching contacts: ${error}`);
      set.status = 500;
      return { error: 'Failed to fetch contacts' };
    }
  })
  .post('/bulk-import', async ({ body, user, set }: { body: BulkImportRequest; user: User; set: { status: number } }) => {
    if (!user || !user.organization_id || !user.is_admin) {
      set.status = 401;
      return { success: false, message: 'Not authorized for bulk import', totalRows: 0 };
    }

    try {
      // For non-admin agents, force overwriteExisting to false
      const overwriteExisting = user.is_admin ? body.overwriteExisting : false;

      // Validate contacts array
      if (!Array.isArray(body.contacts) || body.contacts.length === 0) {
        set.status = 400;
        return { success: false, message: 'No contacts provided', totalRows: 0 };
      }

      // Create temp directory if it doesn't exist
      const tempDir = path.join(process.cwd(), 'tmp');
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }

      // Generate temp file name with random ID to avoid conflicts
      const tempFile = path.join(tempDir, `contacts-${nanoid()}.csv`);
      
      try {
        // Convert contacts array to CSV string
        const csvData = stringify(body.contacts, {
          header: true,
          
          columns: [
            'first_name', 'last_name', 'email', 'phone_number',
            'current_carrier', 'effective_date', 'birth_date', 'tobacco_user',
            'gender', 'zip_code', 'plan_type'
          ]
        });
        
        // Write CSV data to temp file
        fs.writeFileSync(tempFile, csvData);
        logger.info(`Created temporary CSV file: ${tempFile} with ${body.contacts.length} contacts`);
        
        // Use the bulk import function with the temp CSV file
        const result = await Database.bulkImportContacts(
          user.organization_id.toString(),
          tempFile,
          overwriteExisting,
          undefined, // columnMapping
          undefined, // carrierMapping
          body.agentId // Pass the agentId
        );
        
        logger.info(`Bulk import completed: ${result}`);

        // After bulk import, handle re-activation from deleted_contacts
        // This assumes the new org DB is now live and accessible via getOrInitOrgDb
        if (body.contacts && body.contacts.length > 0) {
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString()); // Connects to the NEW live DB
          const importedEmails = body.contacts.map(contact => normalizeEmail(contact.email)).filter(Boolean);

          if (importedEmails.length > 0) {
            const placeholders = importedEmails.map(() => '?').join(',');
            await orgDb.execute(
              `DELETE FROM deleted_contacts WHERE LOWER(TRIM(email)) IN (${placeholders})`,
              importedEmails
            );
            logger.info(`Cleared ${importedEmails.length} reactivated emails from deleted_contacts for org ${user.organization_id} post-bulk-import.`);
          }
        }
        
        return {
          success: true,
          message: 'Contacts imported successfully',
          totalRows: body.contacts.length
        };
      } finally {
        // Clean up temp file
        if (fs.existsSync(tempFile)) {
          fs.unlinkSync(tempFile);
          logger.info(`Removed temporary CSV file: ${tempFile}`);
        }
      }
    } catch (error) {
      logger.error(`Error in bulk import: ${error}`);
      set.status = 500;
      return { 
        success: false,
        message: error instanceof Error ? error.message : 'Failed to process import',
        totalRows: 0
      };
    }
  })
  .post('/track', 
    async ({ request, body, set }) => {
      try {
        const user = await getUserFromSession(request);
        
        // Check if request includes required fields
        if (!user || !body || 'skip_auth' in user) {
          set.status = 400;
          return { 
            success: false, 
            error: 'Invalid request' 
          };
        }
        
        const { email, firstName, lastName } = body as {
          email: string;
          firstName?: string;
          lastName?: string;
        };
        
        if (!email) {
          set.status = 400;
          return { 
            success: false, 
            error: 'Email is required' 
          };
        }
        
        // Track the contact
        const result = await trackContact(
          user.organization_id.toString(),
          user.id.toString(),
          email,
          firstName,
          lastName
        );
        
        // Get updated usage stats
        const stats = await getContactUsageStats(user.organization_id.toString());
        
        return {
          success: true,
          isNew: result.isNew,
          contactId: result.contactId,
          stats
        };
      } catch (error) {
        logger.error(`Error tracking contact: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Failed to track contact' 
        };
      }
    },
    {
      body: t.Object({
        email: t.String(),
        firstName: t.Optional(t.String()),
        lastName: t.Optional(t.String())
      })
    }
  )
  
  // Track a batch of contacts
  .post('/batch', 
    async ({ request, body, set }) => {
      try {
        const user = await getUserFromSession(request);
        
        // Check if request includes required fields
        if (!user || !body || !body.contacts || !Array.isArray(body.contacts) || 'skip_auth' in user) {
          set.status = 400;
          return { 
            success: false, 
            error: 'Invalid request' 
          };
        }
        
        const { contacts } = body as {
          contacts: Array<{
            email: string;
            firstName?: string;
            lastName?: string;
          }>
        };
        
        // Track the contacts in batch
        const result = await trackContactBatch(
          user.organization_id.toString(),
          user.id.toString(),
          contacts
        );
        
        // Get updated usage stats
        const stats = await getContactUsageStats(user.organization_id.toString());
        
        return {
          success: true,
          newCount: result.newCount,
          totalProcessed: result.totalProcessed,
          stats
        };
      } catch (error) {
        logger.error(`Error tracking contact batch: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Failed to track contacts' 
        };
      }
    },
    {
      body: t.Object({
        contacts: t.Array(
          t.Object({
            email: t.String(),
            firstName: t.Optional(t.String()),
            lastName: t.Optional(t.String())
          })
        )
      })
    }
  )
  
  // Get contact usage stats
  .get('/usage-stats', async ({ request, set }) => {
    try {
      const user = await getUserFromSession(request);
      
      if (!user || 'skip_auth' in user) {
        set.status = 401;
        return { 
          success: false, 
          error: 'Unauthorized' 
        };
      }
      
      const stats = await getContactUsageStats(user.organization_id.toString());
      
      return {
        success: true,
        stats
      };
    } catch (error) {
      logger.error(`Error getting contact usage stats: ${error}`);
      set.status = 500;
      return { 
        success: false, 
        error: 'Failed to get contact usage stats' 
      };
    }
  })
  
  // Reset contact count (admin/support only)
  .post('/reset', 
    async ({ request, body, set }) => {
      try {
        const user = await getUserFromSession(request);
        
        // Check if user is admin
        if (!user || 'skip_auth' in user || !user.is_admin) {
          set.status = 403;
          return { 
            success: false, 
            error: 'You do not have permission to perform this action' 
          };
        }
        
        const { email, reason } = body as {
          email: string;
          reason: string;
        };
        
        if (!email || !reason) {
          set.status = 400;
          return { 
            success: false, 
            error: 'Email and reason are required' 
          };
        }
        
        // Reset the contact
        const success = await resetContactCount(
          user.organization_id.toString(),
          email,
          reason
        );
        
        if (!success) {
          set.status = 404;
          return { 
            success: false, 
            error: 'Contact not found' 
          };
        }
        
        // Get updated stats
        const stats = await getContactUsageStats(user.organization_id.toString());
        
        return {
          success: true,
          stats
        };
      } catch (error) {
        logger.error(`Error resetting contact: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Failed to reset contact' 
        };
      }
    },
    {
      body: t.Object({
        email: t.String(),
        reason: t.String()
      })
    }
  )
  
  // Check if an email exists
  .get('/check-email/:email', async ({ params, request, set }) => {
    try {
      const user = await getUserFromSession(request);
      
      if (!user || 'skip_auth' in user) {
        set.status = 401;
        return { 
          success: false, 
          error: 'Unauthorized' 
        };
      }
      
      const { email } = params;
      
      if (!email) {
        set.status = 400;
        return { 
          success: false, 
          error: 'Email is required' 
        };
      }
      
      try {
        // Get the organization database
        const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
        
        // Check if the email exists
        const contact = await orgDb.fetchOne(
          'SELECT id FROM contacts WHERE email = ?',
          [email]
        );
        
        logger.info(`Email check for "${email}" - exists: ${!!contact}`);
        
        return {
          exists: !!contact
        };
      } catch (dbError) {
        logger.error(`Database error checking email ${email}: ${dbError}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Database error checking email',
          message: dbError instanceof Error ? dbError.message : 'Unknown database error'
        };
      }
    } catch (error) {
      logger.error(`Error checking email: ${error}`);
      set.status = 500;
      return { 
        success: false, 
        error: 'Failed to check email',
        message: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  
  // Add new POST endpoint for single contact creation/update
  .post('', 
    async ({ body, user, set }: { body: any; user: User; set: { status: number } }) => {
      if (!user || !user.organization_id) {
        set.status = 401;
        return { success: false, message: 'Not authorized' };
      }

      // TODO: Define a proper schema for single contact body using t.Object
      const contactData = body as ContactImport; // Assuming ContactImport for now, adjust as needed

      if (!contactData || !contactData.email) {
        set.status = 400;
        return { success: false, message: 'Invalid contact data: email is required' };
      }

      try {
        const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
        const normalizedEmail = normalizeEmail(contactData.email);

        // Handle re-activation: Remove from deleted_contacts if exists
        await orgDb.execute(
          'DELETE FROM deleted_contacts WHERE LOWER(TRIM(email)) = ?',
          [normalizedEmail]
        );
        logger.info(`Cleared ${normalizedEmail} from deleted_contacts (if existed) for org ${user.organization_id} during contact creation/update.`);

        // Logic to INSERT or UPDATE the contact in the 'contacts' table
        // This assumes an UPSERT-like behavior based on email.
        // Column names in 'contacts' table might differ slightly from ContactImport, adjust as needed.
        const { 
          first_name, last_name, email, phone_number, state, 
          current_carrier, effective_date, birth_date, tobacco_user, 
          gender, zip_code, plan_type 
        } = contactData;

        // Ensure zip_code and inferred_state are handled correctly
        let inferredState = state; // Use provided state by default
        if (zip_code && ZIP_DATA[zip_code]) {
          inferredState = ZIP_DATA[zip_code].state;
        }
        if (!inferredState && state) { // Fallback if zip lookup failed but state was provided
            inferredState = state;
        } else if (!inferredState) {
            inferredState = ''; // Default to empty string if no state can be determined
            logger.warn(`No state could be determined for contact ${email}`);
        }


        const result = await orgDb.execute(`
          INSERT INTO contacts (
            first_name, last_name, email, phone_number, state, 
            current_carrier, effective_date, birth_date, tobacco_user, 
            gender, zip_code, plan_type, agent_id, created_at, updated_at, status
          )
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 'New')
          ON CONFLICT(LOWER(TRIM(email))) DO UPDATE SET
            first_name = excluded.first_name,
            last_name = excluded.last_name,
            phone_number = excluded.phone_number,
            state = excluded.state,
            current_carrier = excluded.current_carrier,
            effective_date = excluded.effective_date,
            birth_date = excluded.birth_date,
            tobacco_user = excluded.tobacco_user,
            gender = excluded.gender,
            zip_code = excluded.zip_code,
            plan_type = excluded.plan_type,
            agent_id = excluded.agent_id, -- This might need to be handled differently if agent_id comes from user or elsewhere
            updated_at = CURRENT_TIMESTAMP,
            status = CASE WHEN contacts.status = 'Deleted' THEN 'Reactivated' ELSE contacts.status END -- Example status update
          RETURNING id;
        `, [
          first_name, last_name, normalizedEmail, phone_number, inferredState,
          current_carrier, effective_date, birth_date, tobacco_user ? 1 : 0,
          gender, zip_code, plan_type, user.id // Assuming agent_id is the creating user's ID for new contacts
        ]);
        
        const contactId = result.rows?.[0]?.id;

        logger.info(`Successfully created/updated contact ${normalizedEmail} with ID ${contactId} for org ${user.organization_id}.`);
        return { success: true, message: 'Contact created/updated successfully', contactId };

      } catch (error) {
        logger.error(`Error creating/updating contact: ${error}`);
        set.status = 500;
        return { success: false, message: 'Failed to create/update contact' };
      }
    },
    {
      // Define a proper schema for the request body using Elysia's 't' object
      // This is a placeholder and should be refined based on actual Contact model fields for creation/update
      body: t.Object({
        first_name: t.String(),
        last_name: t.String(),
        email: t.String({ format: 'email' }), // Elysia can validate email format
        phone_number: t.Optional(t.String()),
        state: t.Optional(t.String()),
        current_carrier: t.Optional(t.String()),
        effective_date: t.Optional(t.String()), // Consider t.Date() or string format validation
        birth_date: t.Optional(t.String()),     // Consider t.Date() or string format validation
        tobacco_user: t.Optional(t.Boolean()),
        gender: t.Optional(t.String()),
        zip_code: t.Optional(t.String()),
        plan_type: t.Optional(t.String())
        // agent_id might be derived from the user session or explicitly passed
      })
    }
  )
  // Add DELETE endpoint for contacts
  .delete('/', 
    async ({ body, set, request }) => {
      try {
        const user = await getUserFromSession(request);
        if (!user || 'skip_auth' in user || !user.organization_id) {
          set.status = 401;
          return { error: 'Not authorized' };
        }

        const contactIdsToDelete = body as number[]; // Assuming body is an array of numbers (contact IDs)
        if (!Array.isArray(contactIdsToDelete) || contactIdsToDelete.length === 0) {
          set.status = 400;
          return { error: 'No contact IDs provided' };
        }
        
        logger.info(`DELETE /api/contacts - Attempting to move ${contactIdsToDelete.length} contacts to deleted_contacts for org ${user.organization_id}`);
        
        const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());

        const successfullyMovedIds: number[] = [];
        const failedToMoveIds: any[] = [];

        for (const contactId of contactIdsToDelete) {
          if (typeof contactId !== 'number') {
            logger.warn(`Invalid contactId type: ${contactId}, skipping.`);
            failedToMoveIds.push({ id: contactId, error: 'Invalid ID type' });
            continue;
          }

          try {
            await orgDb.transaction(async (tx) => {
              // 1. Select the contact from the 'contacts' table
              const contact = await tx.fetchOne<Contact>(
                'SELECT * FROM contacts WHERE id = ?',
                [contactId]
              );

              if (!contact) {
                logger.warn(`Contact with ID ${contactId} not found in contacts table for org ${user.organization_id}.`);
                failedToMoveIds.push({ id: contactId, error: 'Not found' });
                return; // Exit transaction for this contactId
              }

              const normalizedEmail = normalizeEmail(contact.email);

              // 2. Insert into 'deleted_contacts' table
              // Ensure all fields match the deleted_contacts schema
              await tx.execute(`
                INSERT INTO deleted_contacts (
                  original_contact_id, first_name, last_name, email, phone_number, 
                  current_carrier, plan_type, effective_date, birth_date, 
                  tobacco_user, gender, state, zip_code, agent_id, status, deleted_at
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
              `, [
                contact.id, contact.first_name, contact.last_name, normalizedEmail, contact.phone_number,
                contact.current_carrier, contact.plan_type, contact.effective_date, contact.birth_date,
                contact.tobacco_user, contact.gender, contact.state, contact.zip_code, 
                contact.agent_id, contact.status
              ]);

              // 3. Delete from related tables (e.g., email_send_tracking, eligibility_answers, contact_events etc.)
              // It's important to delete from child tables before deleting from the parent (contacts) if ON DELETE CASCADE is not set up for all relations
              // or if you want to log/handle these deletions specifically.
              // Assuming ON DELETE CASCADE is set for email_send_tracking, eligibility_answers on contacts.id
              // If not, add explicit deletes here:
              // await tx.execute('DELETE FROM email_send_tracking WHERE contact_id = ?', [contactId]);
              // await tx.execute('DELETE FROM eligibility_answers WHERE contact_id = ?', [contactId]);
              // await tx.execute('DELETE FROM contact_events WHERE contact_id = ?', [contactId]);
              // etc.

              // 4. Delete from 'contacts' table
              await tx.execute(
                'DELETE FROM contacts WHERE id = ?',
                [contactId]
              );
              
              successfullyMovedIds.push(contactId);
              logger.info(`Successfully moved contact ID ${contactId} to deleted_contacts for org ${user.organization_id}`);
            });
          } catch (e) {
            logger.error(`Error moving contact ID ${contactId} to deleted_contacts: ${e}`);
            failedToMoveIds.push({ id: contactId, error: e instanceof Error ? e.message : String(e) });
            // Transaction will be rolled back automatically by the Database class if an error is thrown from the callback
          }
        }

        const responseMessage = `Moved ${successfullyMovedIds.length} contacts. Failed to move ${failedToMoveIds.length} contacts.`;
        logger.info(`DELETE /api/contacts - Result for org ${user.organization_id}: ${responseMessage}`);

        if (failedToMoveIds.length > 0) {
          // Partial success, or complete failure if successfullyMovedIds is empty
          set.status = successfullyMovedIds.length > 0 ? 207 : 500; // 207 Multi-Status or 500 Internal Server Error
          return {
            success: successfullyMovedIds.length > 0,
            message: responseMessage,
            deleted_ids: successfullyMovedIds,
            failed_to_move_ids: failedToMoveIds
          };
        }

        return {
          success: true,
          message: responseMessage,
          deleted_ids: successfullyMovedIds
        };

      } catch (e) {
        logger.error(`Error processing delete contacts request: ${e}`);
        // Ensure set.status is managed by Elysia's error handling or set manually
        const currentStatus = typeof set.status === 'number' ? set.status : 0;
        if (currentStatus < 400) { // If not already an error status, set to 500
            set.status = 500;
        }
        return { error: e instanceof Error ? e.message : 'Failed to delete contacts' };
      }
    },
    {
      body: t.Array(t.Number())
    }
  );

================
File: backend/src/routes/contactTracking.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { getUserFromSession } from '../services/auth';
import { 
  trackContact, 
  trackContactBatch, 
  getContactUsageStats, 
  getUniqueContactCount,
  resetContactCount
} from '../services/contactTracking';

export const createContactTrackingRoutes = () => {
  return new Elysia({ prefix: '/api/contact-tracking' })

    // Track a single contact
    .post('/track', 
      async ({ request, body, set }) => {
        try {
          const user = await getUserFromSession(request);
          
          // Check if request includes required fields
          if (!user || !body) {
            set.status = 400;
            return { 
              success: false, 
              error: 'Invalid request' 
            };
          }
          
          const { email, firstName, lastName } = body as {
            email: string;
            firstName?: string;
            lastName?: string;
          };
          
          if (!email) {
            set.status = 400;
            return { 
              success: false, 
              error: 'Email is required' 
            };
          }
          
          // Track the contact
          const result = await trackContact(
            user.organization_id.toString(),
            user.id.toString(),
            email,
            firstName,
            lastName
          );
          
          // Get updated usage stats
          const stats = await getContactUsageStats(user.organization_id.toString());
          
          return {
            success: true,
            isNew: result.isNew,
            contactId: result.contactId,
            stats
          };
        } catch (error) {
          logger.error(`Error tracking contact: ${error}`);
          set.status = 500;
          return { 
            success: false, 
            error: 'Failed to track contact' 
          };
        }
      },
      {
        body: t.Object({
          email: t.String(),
          firstName: t.Optional(t.String()),
          lastName: t.Optional(t.String())
        })
      }
    )
    
    // Track a batch of contacts
    .post('/batch', 
      async ({ request, body, set }) => {
        try {
          const user = await getUserFromSession(request);
          
          // Check if request includes required fields
          if (!user || !body || !body.contacts || !Array.isArray(body.contacts)) {
            set.status = 400;
            return { 
              success: false, 
              error: 'Invalid request' 
            };
          }
          
          const { contacts } = body as {
            contacts: Array<{
              email: string;
              firstName?: string;
              lastName?: string;
            }>
          };
          
          // Track the contacts in batch
          const result = await trackContactBatch(
            user.organization_id.toString(),
            user.id.toString(),
            contacts
          );
          
          // Get updated usage stats
          const stats = await getContactUsageStats(user.organization_id.toString());
          
          return {
            success: true,
            newCount: result.newCount,
            totalProcessed: result.totalProcessed,
            stats
          };
        } catch (error) {
          logger.error(`Error tracking contact batch: ${error}`);
          set.status = 500;
          return { 
            success: false, 
            error: 'Failed to track contacts' 
          };
        }
      },
      {
        body: t.Object({
          contacts: t.Array(
            t.Object({
              email: t.String(),
              firstName: t.Optional(t.String()),
              lastName: t.Optional(t.String())
            })
          )
        })
      }
    )
    
    // Get contact usage stats
    .get('/usage-stats', async ({ request, set }) => {
      try {
        const user = await getUserFromSession(request);
        
        if (!user) {
          set.status = 401;
          return { 
            success: false, 
            error: 'Unauthorized' 
          };
        }
        
        const stats = await getContactUsageStats(user.organization_id.toString());
        
        return {
          success: true,
          stats
        };
      } catch (error) {
        logger.error(`Error getting contact usage stats: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: 'Failed to get contact usage stats' 
        };
      }
    })
    
    // Reset contact count (admin/support only)
    .post('/reset', 
      async ({ request, body, set }) => {
        try {
          const user = await getUserFromSession(request);
          
          // Check if user is admin
          if (!user || !user.is_admin) {
            set.status = 403;
            return { 
              success: false, 
              error: 'You do not have permission to perform this action' 
            };
          }
          
          const { email, reason } = body as {
            email: string;
            reason: string;
          };
          
          if (!email || !reason) {
            set.status = 400;
            return { 
              success: false, 
              error: 'Email and reason are required' 
            };
          }
          
          // Reset the contact
          const success = await resetContactCount(
            user.organization_id.toString(),
            email,
            reason
          );
          
          if (!success) {
            set.status = 404;
            return { 
              success: false, 
              error: 'Contact not found' 
            };
          }
          
          // Get updated stats
          const stats = await getContactUsageStats(user.organization_id.toString());
          
          return {
            success: true,
            stats
          };
        } catch (error) {
          logger.error(`Error resetting contact: ${error}`);
          set.status = 500;
          return { 
            success: false, 
            error: 'Failed to reset contact' 
          };
        }
      },
      {
        body: t.Object({
          email: t.String(),
          reason: t.String()
        })
      }
    );
};

================
File: backend/src/routes/dashboard.ts
================
import { Elysia } from 'elysia'
import { Database } from '../database'
import { logger } from '../logger'
import { getUserFromSession } from '../services/auth'

// Helper function to get date range for SQL queries
function getDateRange(period?: string): { startDateStr: string, endDateStr: string } {
    const today = new Date();
    let startDate = new Date(today);
    let endDate = new Date(today);

    startDate.setHours(0, 0, 0, 0);
    endDate.setHours(23, 59, 59, 999); // End of today for endDate default

    // Default to '30days' if period is undefined or invalid
    const effectivePeriod = ['today', 'yesterday', '7days', '30days', '90days', 'ytd'].includes(period || '') ? period : '30days';

    switch (effectivePeriod) {
        case 'today':
            // startDate is already beginning of today
            // endDate is already end of today
            break;
        case 'yesterday':
            startDate.setDate(today.getDate() - 1);
            endDate.setDate(today.getDate() - 1);
            // endDate still needs to be end of that day
            endDate.setHours(23, 59, 59, 999);
            break;
        case '7days':
            startDate.setDate(today.getDate() - 6); // today is the 7th day
            break;
        case '90days':
            startDate.setDate(today.getDate() - 89); // today is the 90th day
            break;
        case 'ytd':
            startDate = new Date(today.getFullYear(), 0, 1); // First day of current year
            startDate.setHours(0, 0, 0, 0);
            break;
        case '30days':
        default:
            startDate.setDate(today.getDate() - 29); // today is the 30th day
            break;
    }
    const formatDate = (d: Date) => d.toISOString().slice(0, 10); // YYYY-MM-DD
    return {
        startDateStr: formatDate(startDate),
        endDateStr: formatDate(endDate), // endDate is always today's date
    };
}

/**
 * Creates and configures dashboard-related routes
 */
export function createDashboardRoutes() {
  return new Elysia({ prefix: '/api/dashboard' })
    // Dashboard statistics endpoint
    .get('/stats', async ({ request, set, query }) => {
      try {
        // Get current user from session
        const currentUser = await getUserFromSession(request)
        if (!currentUser || !currentUser.organization_id) {
          set.status = 401
          return {
            success: false,
            error: 'Authentication required'
          }
        }

        // Get organization-specific database
        const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())

        const period = query?.period as string | undefined;
        let startDateStr: string, endDateStr: string;

        if (period === 'custom' && query?.startDate && query?.endDate) {
            startDateStr = query.startDate as string;
            endDateStr = query.endDate as string;
            // Basic validation for custom dates can be added here if needed
            // For now, assume they are valid YYYY-MM-DD strings
            logger.info(`Using custom date range: ${startDateStr} to ${endDateStr}`);
        } else {
            const range = getDateRange(period);
            startDateStr = range.startDateStr;
            endDateStr = range.endDateStr;
        }
          

        logger.info(`Fetching dashboard stats for org ${currentUser.organization_id} for period: ${period || '30days'} (range: ${startDateStr} to ${endDateStr})`);

        // For accurate counts, we need to be precise about what we're counting
        // Log all tables to help diagnose
        logger.info(`Checking available tables in org DB for ${currentUser.organization_id}`)
        const tablesResult = await orgDb.fetchAll(
          "SELECT name FROM sqlite_master WHERE type='table'"
        )
        logger.info(`Available tables: ${JSON.stringify(tablesResult.map((r: any) => r.name || r[0]))}`)
        
        // Better debug query to understand tracking_clicks structure
        const sampleClicks = await orgDb.fetchAll(
          "SELECT * FROM tracking_clicks LIMIT 5"
        )
        logger.info(`Sample tracking_clicks: ${JSON.stringify(sampleClicks)}`)
        
        // 1. "Quotes Sent" - count emails that have been sent (status = 'scheduled') - EXCLUDE follow-ups
        const quotesSentSql = `
          SELECT COUNT(*) as count 
          FROM email_schedules 
          WHERE actual_send_datetime IS NOT NULL
            AND DATE(actual_send_datetime) BETWEEN ? AND ?
            AND (email_type IS NULL OR email_type NOT LIKE 'followup%')
        `
        const quotesSentResult = await orgDb.fetchOne<{ count: number }>(quotesSentSql, [startDateStr, endDateStr])
        const quotesSent = quotesSentResult?.count || 0
        logger.info(`Quotes Sent count: ${quotesSent}`)

        // 1b. "Manual Quotes Sent" - count manual quote emails from email_send_tracking
        const manualQuotesSql = `
          SELECT COUNT(*) as count
          FROM email_send_tracking
          WHERE email_type = 'quote_email' AND send_status IN ('sent', 'delivered', 'scheduled')
            AND DATE(created_at) BETWEEN ? AND ?
        `
        const manualQuotesResult = await orgDb.fetchOne<{ count: number }>(manualQuotesSql, [startDateStr, endDateStr])
        const manualQuotesSent = manualQuotesResult?.count || 0
        logger.info(`Manual Quotes Sent count: ${manualQuotesSent}`)

        // 2. "Quotes Viewed" - count unique contacts who clicked links, attributed to an original send in the period
        const quotesViewedSql = `
          WITH
          original_sends_in_period_for_stats AS (
              SELECT
                  es.contact_id,
                  es.actual_send_datetime AS original_send_datetime_full
              FROM email_schedules es
              WHERE es.actual_send_datetime IS NOT NULL
                AND DATE(es.actual_send_datetime) BETWEEN ? AND ? -- Reporting period for original sends
                AND (es.email_type IS NULL OR es.email_type NOT LIKE 'followup%')
          ),
          clicks_attributed_for_stats AS (
              SELECT
                  tc.contact_id,
                  (
                      SELECT 1 -- We just need to know it's attributable
                      FROM original_sends_in_period_for_stats osip
                      WHERE osip.contact_id = tc.contact_id
                        AND osip.original_send_datetime_full <= tc.clicked_at
                      ORDER BY osip.original_send_datetime_full DESC 
                      LIMIT 1
                  ) AS is_attributable
              FROM tracking_clicks tc
              WHERE tc.contact_id IS NOT NULL AND tc.clicked_at IS NOT NULL
          )
          SELECT COUNT(DISTINCT cas.contact_id) AS count
          FROM clicks_attributed_for_stats cas
          WHERE cas.is_attributable = 1;
        `
        const quotesViewedResult = await orgDb.fetchOne<{ count: number }>(quotesViewedSql, [startDateStr, endDateStr])
        const quotesViewed = quotesViewedResult?.count || 0
        logger.info(`Quotes Viewed count: ${quotesViewed}`)

        // 3. Get "Follow Ups Requested" count from email_schedules (Performance context)
        // These are follow-ups scheduled to be sent in the period.
        const followUpsSql = `
          SELECT COUNT(*) as count
          FROM email_schedules
          WHERE actual_send_datetime IS NOT NULL
            AND DATE(actual_send_datetime) BETWEEN ? AND ?
            AND email_type LIKE 'followup%'
        `
        const followUpsResult = await orgDb.fetchOne<{ count: number }>(followUpsSql, [startDateStr, endDateStr])
        const followUpsRequested = followUpsResult?.count || 0
        logger.info(`Follow Ups Requested count: ${followUpsRequested}`)

        // 4. "Health Questions Completed" - unique contacts who completed health questions during the period
        const healthQuestionsCompletedSql = `
          WITH
          original_sends_in_period_for_stats AS (
              SELECT
                  es.contact_id,
                  es.actual_send_datetime AS original_send_datetime_full
              FROM email_schedules es
              WHERE es.actual_send_datetime IS NOT NULL
                AND DATE(es.actual_send_datetime) BETWEEN ? AND ? -- Reporting period for original sends
                AND (es.email_type IS NULL OR es.email_type NOT LIKE 'followup%')
          ),
          health_completions_attributed_for_stats AS (
              SELECT
                  ea.contact_id,
                  (
                      SELECT 1 -- We just need to know it's attributable
                      FROM original_sends_in_period_for_stats osip
                      WHERE osip.contact_id = ea.contact_id
                        AND osip.original_send_datetime_full <= ea.created_at
                      ORDER BY osip.original_send_datetime_full DESC
                      LIMIT 1
                  ) AS is_attributable
              FROM eligibility_answers ea
              WHERE ea.contact_id IS NOT NULL AND ea.created_at IS NOT NULL
          )
          SELECT COUNT(DISTINCT hcas.contact_id) AS count
          FROM health_completions_attributed_for_stats hcas
          WHERE hcas.is_attributable = 1;
        `
        const healthQuestionsResult = await orgDb.fetchOne<{ count: number }>(healthQuestionsCompletedSql, [startDateStr, endDateStr])
        const healthQuestionsCompleted = healthQuestionsResult?.count || 0
        logger.info(`Health Questions Completed count: ${healthQuestionsCompleted}`)

        // Show data for all 12 months, with real data for current month and zeros for others
        const currentMonth = new Date().getMonth(); // 0-11

        // Create array of chart data for all months
        const chartData = [];
        const monthsToShow = 12;

        // Create entries for all 12 months, but only put real data in current month
        for (let i = 0; i < monthsToShow; i++) {
          // Only the current month has actual data, rest are zeros
          const isCurrentMonth = i === currentMonth;

          let sentValue = 0;
          let viewedValue = 0;
          let followUpValue = 0;
          let healthCompletedValue = 0;

          if (isCurrentMonth) {
            // Use real data for current month
            sentValue = quotesSent;
            viewedValue = quotesViewed;
            followUpValue = followUpsRequested;
            healthCompletedValue = healthQuestionsCompleted;
          }

          chartData.push({
            x: i, // 0-11 for months (Jan-Dec)
            sends: sentValue,
            views: viewedValue,
            followUps: followUpValue,
            healthCompleted: healthCompletedValue
          });
        }

        // No need to transform the chart data anymore

        logger.info(`Dashboard stats for org ${currentUser.organization_id} (period ${period}): Quotes Sent: ${quotesSent}, Manual Quotes Sent: ${manualQuotesSent}, Quotes Viewed: ${quotesViewed}, FollowUps: ${followUpsRequested}, HealthCompleted: ${healthQuestionsCompleted}`)

        // UPCOMING EMAILS LOGIC
        // Only include emails scheduled in the next 30 days and status = 'pre-scheduled'
        const now = new Date();
        const in30Days = new Date(now);
        in30Days.setDate(now.getDate() + 30);
        const upcomingStartDate = now.toISOString().slice(0, 10);
        const upcomingEndDate = in30Days.toISOString().slice(0, 10);

        // Total count - EXCLUDE follow-ups
        const upcomingTotalResult = await orgDb.fetchOne<{ total: number } | null>(
          `SELECT COUNT(*) as total FROM email_schedules
           WHERE status = 'pre-scheduled'
             AND scheduled_send_date >= ?
             AND scheduled_send_date <= ?
             AND (email_type IS NULL OR email_type NOT LIKE 'followup%')`,
          [upcomingStartDate, upcomingEndDate]
        );
        const upcomingEmailsTotal = upcomingTotalResult?.total ?? 0;

        // First page (up to 20) - EXCLUDE follow-ups
        const upcomingEmailsPage = await orgDb.fetchAll(
          `SELECT es.id, es.contact_id, es.email_type, es.scheduled_send_date, es.status,
                  c.first_name, c.last_name
           FROM email_schedules es
           LEFT JOIN contacts c ON es.contact_id = c.id
           WHERE es.status = 'pre-scheduled'
             AND es.scheduled_send_date >= ?
             AND es.scheduled_send_date <= ?
             AND (es.email_type IS NULL OR es.email_type NOT LIKE 'followup%')
           ORDER BY es.scheduled_send_date ASC
           LIMIT 30 OFFSET 0`,
          [upcomingStartDate, upcomingEndDate]
        );

        return {
          success: true,
          stats: {
            quotesSent,
            manualQuotesSent,
            quotesViewed,
            followUpsRequested,
            healthQuestionsCompleted,
            chartData,
            upcomingEmailsTotal,
            upcomingEmailsPage
          }
        }
      } catch (error) {
        logger.error(`Error fetching dashboard stats: ${error instanceof Error ? error.message : String(error)}`)
        set.status = 500
        return {
          success: false,
          error: 'Failed to load dashboard stats'
        }
      }
    })
    // Send ranking endpoint
    .get('/send-ranking', async ({ request, set, query }) => {
      try {
        logger.info('=== SEND RANKING ENDPOINT HIT ===')
        
        const currentUser = await getUserFromSession(request)
        if (!currentUser || !currentUser.organization_id) {
          logger.error('Send ranking: No authenticated user or organization_id')
          set.status = 401
          return {
            success: false,
            error: 'Authentication required'
          }
        }

        logger.info(`Send ranking: User ${currentUser.id} from org ${currentUser.organization_id}`)

        const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())
        logger.info(`Send ranking: Got org database for ${currentUser.organization_id}`)

        // Always show last 30 days for send ranking, regardless of dropdown
        const today = new Date();
        const thirtyDaysAgo = new Date(today);
        thirtyDaysAgo.setDate(today.getDate() - 29); // Last 30 days including today
        
        const startDateStr = thirtyDaysAgo.toISOString().slice(0, 10);
        const endDateStr = today.toISOString().slice(0, 10);

        logger.info(`Send ranking: Fetching for org ${currentUser.organization_id} for last 30 days (range: ${startDateStr} to ${endDateStr})`);

        // Get daily breakdown of email performance - track emails sent on each date and their outcomes - EXCLUDE follow-ups
        const sendRankingSql = `
          WITH
          original_sends_in_period AS (
              SELECT
                  es.contact_id,
                  DATE(es.actual_send_datetime) AS original_send_date,
                  es.actual_send_datetime AS original_send_datetime_full
              FROM email_schedules es
              WHERE es.actual_send_datetime IS NOT NULL
                AND DATE(es.actual_send_datetime) BETWEEN ? AND ? -- Params: startDateStr, endDateStr
                AND (es.email_type IS NULL OR es.email_type NOT LIKE 'followup%')
          ),
          daily_quotes_sent_agg AS (
              SELECT
                  original_send_date,
                  COUNT(DISTINCT contact_id) AS total_quotes_sent
              FROM original_sends_in_period
              GROUP BY original_send_date
          ),
          clicks_attributed AS (
              SELECT
                  tc.contact_id,
                  (
                      SELECT osip.original_send_date
                      FROM original_sends_in_period osip
                      WHERE osip.contact_id = tc.contact_id
                        AND osip.original_send_datetime_full <= tc.clicked_at -- Original send must be <= click time
                      ORDER BY osip.original_send_datetime_full DESC
                      LIMIT 1
                  ) AS attributable_original_send_date
              FROM tracking_clicks tc
              WHERE tc.contact_id IS NOT NULL AND tc.clicked_at IS NOT NULL
          ),
          daily_quotes_viewed_agg AS (
              SELECT
                  attributable_original_send_date,
                  COUNT(DISTINCT contact_id) AS total_quotes_viewed
              FROM clicks_attributed
              WHERE attributable_original_send_date IS NOT NULL -- Ensures linked to an original send in our reporting period
              GROUP BY attributable_original_send_date
          ),
          health_completions_attributed AS (
              SELECT
                  ea.contact_id,
                  (
                      SELECT osip.original_send_date
                      FROM original_sends_in_period osip
                      WHERE osip.contact_id = ea.contact_id
                        AND osip.original_send_datetime_full <= ea.created_at -- Original send must be <= completion time
                      ORDER BY osip.original_send_datetime_full DESC
                      LIMIT 1
                  ) AS attributable_original_send_date
              FROM eligibility_answers ea
              WHERE ea.contact_id IS NOT NULL AND ea.created_at IS NOT NULL
          ),
          daily_health_completed_agg AS (
              SELECT
                  attributable_original_send_date,
                  COUNT(DISTINCT contact_id) AS total_health_completed
              FROM health_completions_attributed
              WHERE attributable_original_send_date IS NOT NULL
              GROUP BY attributable_original_send_date
          )
          SELECT
              dqs.original_send_date AS sendDate,
              dqs.total_quotes_sent AS quotesSent,
              COALESCE(dqv.total_quotes_viewed, 0) AS quotesViewed,
              COALESCE(dhc.total_health_completed, 0) AS healthCompleted
          FROM daily_quotes_sent_agg dqs
          LEFT JOIN daily_quotes_viewed_agg dqv ON dqs.original_send_date = dqv.attributable_original_send_date
          LEFT JOIN daily_health_completed_agg dhc ON dqs.original_send_date = dhc.attributable_original_send_date
          ORDER BY dqs.original_send_date DESC;
        `;

        logger.info(`Send ranking: Executing SQL with params: [${startDateStr}, ${endDateStr}]`)
        logger.info(`Send ranking: SQL query: ${sendRankingSql}`)

        const sendRankingResult = await orgDb.fetchAll(sendRankingSql, [
          startDateStr, endDateStr
        ]);

        logger.info(`Send ranking: Raw SQL result count: ${sendRankingResult.length}`)
        logger.info(`Send ranking: Raw SQL first 3 results: ${JSON.stringify(sendRankingResult.slice(0, 3))}`)

        // Transform results into the expected format with ranking
        const sendRankingData = sendRankingResult.map((row: any, index: number) => ({
          rank: index + 1,
          sendDate: row.sendDate, // Directly use the aliased column
          quotesSent: parseInt(row.quotesSent || 0), // Directly use the aliased column
          quotesViewed: parseInt(row.quotesViewed || 0), // Directly use the aliased column
          healthCompleted: parseInt(row.healthCompleted || 0) // Directly use the aliased column
        }));

        logger.info(`Send ranking: Transformed data count: ${sendRankingData.length}`)
        logger.info(`Send ranking: Transformed data first 3: ${JSON.stringify(sendRankingData.slice(0, 3))}`)

        logger.info(`Send ranking: Returning response with ${sendRankingData.length} entries`)

        return {
          success: true,
          data: sendRankingData
        }
      } catch (error) {
        logger.error(`=== SEND RANKING ERROR ===`)
        logger.error(`Send ranking error: ${error instanceof Error ? error.message : String(error)}`)
        logger.error(`Send ranking error stack: ${error instanceof Error ? error.stack : 'No stack trace'}`)
        set.status = 500
        return {
          success: false,
          error: 'Failed to load send ranking data'
        }
      }
    })
}

/**
 * Creates and configures dashboard activity-related routes
 */
export function createDashboardActivityRoutes() {
  return new Elysia({ prefix: '/api/dashboard' })
    .get('/activity', async ({ request, set, query }) => {
      try {
        const currentUser = await getUserFromSession(request)
        if (!currentUser || !currentUser.organization_id) {
          set.status = 401
          return {
            success: false,
            error: 'Authentication required'
          }
        }

        const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())

        const period = query?.period as string | undefined;
        let startDateStr: string, endDateStr: string;

        if (period === 'custom' && query?.startDate && query?.endDate) {
            startDateStr = query.startDate as string;
            endDateStr = query.endDate as string;
            // Basic validation for custom dates can be added here if needed
             logger.info(`Using custom date range for activity: ${startDateStr} to ${endDateStr}`);
        } else {
            const range = getDateRange(period);
            startDateStr = range.startDateStr;
            endDateStr = range.endDateStr;
        }

        logger.info(`Fetching dashboard activity stats for org ${currentUser.organization_id} for period: ${period || '30days'} (range: ${startDateStr} to ${endDateStr})`);

        // 0. "Total Emails Sent" - unique contacts who were sent an email in the period
        const emailsSentSql = `
          SELECT COUNT(DISTINCT contact_id) as count
          FROM email_schedules
          WHERE contact_id IS NOT NULL
            AND status IN ('scheduled', 'send', 'delivered')
            AND scheduled_send_date BETWEEN ? AND ?
        `;
        const emailsSentResult = await orgDb.fetchOne<{ count: number }>(emailsSentSql, [startDateStr, endDateStr])
        const emailsSent = emailsSentResult?.count || 0
        logger.info(`Emails Sent (Activity, unique contacts) count: ${emailsSent}`)

        // 1. "Links Clicked" - count unique contacts who clicked in the period (no double counting)
        const linksClickedSql = `
          SELECT COUNT(DISTINCT contact_id) as count
          FROM tracking_clicks
          WHERE contact_id IS NOT NULL
            AND DATE(clicked_at) BETWEEN ? AND ?
        `;
        const linksClickedResult = await orgDb.fetchOne<{ count: number }>(linksClickedSql, [startDateStr, endDateStr])
        const linksClicked = linksClickedResult?.count || 0
        logger.info(`Links Clicked (Activity, unique contacts) count: ${linksClicked}`)

        // 2. "Health Questions Completed" - unique contacts who completed eligibility_answers in the period
        const healthQuestionsCompletedActivitySql = `
          SELECT COUNT(DISTINCT contact_id) as count
          FROM eligibility_answers
          WHERE contact_id IS NOT NULL
            AND DATE(created_at) BETWEEN ? AND ?
        `;
        const healthQuestionsCompletedActivityResult = await orgDb.fetchOne<{ count: number }>(healthQuestionsCompletedActivitySql, [startDateStr, endDateStr])
        const healthQuestionsCompletedActivity = healthQuestionsCompletedActivityResult?.count || 0
        logger.info(`Health Questions Completed (Activity, unique contacts) count: ${healthQuestionsCompletedActivity}`)
        
        // For the activity tab, chartData might be simpler or not used extensively initially.
        // We can return raw values that could be used for simple bar charts if needed.
        const activityChartData = [
          {
            x: 0, // Representing Emails Sent
            value: emailsSent
          },
          {
            x: 1, // Representing Links Clicked
            value: linksClicked 
          },
          {
            x: 2, // Representing Health Questions Completed
            value: healthQuestionsCompletedActivity
          }
        ];
        set.status = 200
        return {
          success: true,
          stats: {
            emailsSent,
            linksClicked,
            healthQuestionsCompleted: healthQuestionsCompletedActivity,
            activityChartData // Sending a simple chart data structure
          }
        }
      } catch (error) {
        logger.error(`Error fetching dashboard activity stats: ${error instanceof Error ? error.message : String(error)}`)
        set.status = 500
        return {
          success: false,
          error: 'Failed to load dashboard activity stats'
        }
      }
    })
}

// Make sure to integrate this new route group in your main server setup, similar to createDashboardRoutes.
// For example, in src/index.ts or where Elysia app is instantiated:
// app.use(createDashboardRoutes())
//    .use(createDashboardActivityRoutes()) // Add this line

================
File: backend/src/routes/eligibility.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';

interface EligibilityAnswers {
    quote_id?: string;
    contact_id?: string;
    answers: Record<string, {
        question_text: string;
        question_type: string;
        answer: boolean | string | null;
    }>;
}

export const eligibilityRoutes = (app: Elysia) => {
    app
        // Get organization details
        .get('/api/org/:orgId/details', async ({ params }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                // Get organization details from main database
                const mainDb = new Database();
                const orgDetails = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                    'SELECT name, logo_data FROM organizations WHERE id = ?',
                    [orgId]
                );

                if (!orgDetails) {
                    return {
                        success: false,
                        error: 'Organization not found'
                    };
                }

                return {
                    name: orgDetails.name,
                    logo_data: orgDetails.logo_data
                };
            } catch (error) {
                logger.error(`Error getting organization details: ${error}`);
                throw new Error('Failed to get organization details');
            }
        })

        // Get existing eligibility answers for a contact
        .get('/api/org/:orgId/eligibility-answers/:contactId', async ({ params }) => {
            try {
                const { orgId, contactId } = params;
                if (!orgId || !contactId) {
                    return {
                        success: false,
                        error: 'Missing required parameters'
                    };
                }

                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);

                // Get the most recent answers for this contact
                const result = await orgDb.fetchOne<{ answers: string }>(
                    'SELECT answers FROM eligibility_answers WHERE contact_id = ? ORDER BY created_at DESC LIMIT 1',
                    [contactId]
                );

                if (!result) {
                    return {
                        success: false,
                        error: 'No answers found'
                    };
                }

                // Get organization details from main database
                const mainDb = new Database();
                const orgDetails = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                    'SELECT name, logo_data FROM organizations WHERE id = ?',
                    [orgId]
                );

                return {
                    answers: JSON.parse(result.answers),
                    orgName: orgDetails?.name || 'Medicare Max',
                    orgLogo: orgDetails?.logo_data || null
                };
            } catch (error) {
                logger.error(`Error getting eligibility answers: ${error}`);
                throw new Error('Failed to get eligibility answers');
            }
        })

        // Create a temporary contact for collecting eligibility answers
        .post('/api/org/:orgId/temp-contact', async ({ params }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);
                
                // Create a minimal contact record for just eligibility assessment
                const result = await orgDb.execute(
                    `INSERT INTO contacts 
                    (first_name, last_name, email, current_carrier, plan_type, effective_date, birth_date, tobacco_user, gender, state, zip_code, phone_number, status) 
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    [
                        'Temporary', 
                        'Contact', 
                        `temp-${Date.now()}@example.com`, 
                        '', 
                        'G', 
                        '', 
                        '1950-01-01', 
                        0, 
                        'M', 
                        '', 
                        '00000', 
                        '', 
                        'temp'
                    ]
                );

                // Get the inserted ID from the result
                const contactId = result.lastInsertRowid?.toString();
                
                if (!contactId) {
                    throw new Error('Failed to create temporary contact');
                }

                // Add a record to contact_events to track this
                await orgDb.execute(
                    `INSERT INTO contact_events 
                    (contact_id, event_type, metadata) 
                    VALUES (?, ?, ?)`,
                    [
                        contactId,
                        'temp_contact_created',
                        JSON.stringify({ source: 'eligibility_assessment' })
                    ]
                );

                return contactId;
            } catch (error) {
                logger.error(`Error creating temporary contact: ${error}`);
                throw new Error('Failed to create temporary contact');
            }
        })

        // Save eligibility answers
        .post('/api/org/:orgId/eligibility-answers', async ({ params, body }) => {
            try {
                const orgId = params.orgId;
                if (!orgId) {
                    return {
                        success: false,
                        error: 'Missing organization ID'
                    };
                }

                const data = body as EligibilityAnswers;
                
                // Get org-specific database
                const orgDb = await Database.getOrInitOrgDb(orgId);
                
                let contactId: string | null = null;
                
                // If quote_id is provided, get the contact_id from it
                if (data.quote_id) {
                    try {
                        const decodedQuoteId = decodeQuoteId(data.quote_id);
                        if (decodedQuoteId) {
                            contactId = decodedQuoteId.contactId.toString();
                            
                            // Verify the org ID matches
                            if (decodedQuoteId.orgId.toString() !== orgId) {
                                return {
                                    success: false,
                                    error: 'Invalid quote ID - organization mismatch'
                                };
                            }
                        }
                    } catch (error) {
                        logger.error(`Error decoding quote ID: ${error}`);
                        return {
                            success: false,
                            error: 'Invalid quote ID'
                        };
                    }
                } else if (data.contact_id) {
                    // If contact_id is provided directly, use it
                    contactId = data.contact_id;
                }
                
                if (!contactId) {
                    return {
                        success: false,
                        error: 'Missing contact ID'
                    };
                }
                
                // Ensure contactId is a number for database operations
                const contactIdNum = parseInt(contactId, 10);
                if (isNaN(contactIdNum)) {
                    return {
                        success: false,
                        error: 'Invalid contact ID format'
                    };
                }

                // Verify contact exists in this org using the number
                const contact = await orgDb.fetchOne(
                    'SELECT id FROM contacts WHERE id = ?',
                    [contactIdNum]
                );
                
                if (!contact) {
                    return {
                        success: false,
                        error: 'Contact not found'
                    };
                }

                // Get organization details from main database
                const mainDb = new Database();
                const orgDetails = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                    'SELECT name, logo_data FROM organizations WHERE id = ?',
                    [orgId]
                );
                
                // Store the eligibility answers
                const verifiedQuoteId = data.quote_id || "";
                const answersJson = JSON.stringify(data.answers);
                
                // Determine the quote ID to save, defaulting to empty string if null
                const finalQuoteId = verifiedQuoteId ?? "";
                
                logger.info(`Saving eligibility answers for contact_id: ${contactIdNum}, quote_id: ${finalQuoteId}`);
                
                // Check if we already have answers for this contact using the number
                const existingAnswers = await orgDb.fetchOne(
                    'SELECT id FROM eligibility_answers WHERE contact_id = ?',
                    [contactIdNum]
                );
                
                if (existingAnswers) {
                    // Update existing answers using the number
                    logger.info(`Updating existing answers for contact_id: ${contactIdNum}`);
                    await orgDb.execute(
                        'UPDATE eligibility_answers SET answers = ?, quote_id = ?, created_at = CURRENT_TIMESTAMP WHERE contact_id = ?',
                        [answersJson, finalQuoteId, contactIdNum]
                    );
                } else {
                    // Insert new answers using the number
                    logger.info(`Inserting new answers for contact_id: ${contactIdNum}`);
                    await orgDb.execute(
                        'INSERT INTO eligibility_answers (contact_id, quote_id, answers) VALUES (?, ?, ?)', 
                        [contactIdNum, finalQuoteId, answersJson]
                    );
                }
                
                // Extract analytics data from enhanced answers
                const analyticsData = {
                    answers_count: Object.keys(data.answers).length,
                    source: data.quote_id ? 'quote' : 'direct',
                    main_questions_yes_count: Object.values(data.answers).filter(a => 
                        a.question_type === 'main' && a.answer === true
                    ).length,
                    has_medical_conditions: Object.values(data.answers).some(a => 
                        a.question_type === 'main' && a.answer === true
                    )
                };
                
                // Add a record to contact_events using the number
                await orgDb.execute(
                    `INSERT INTO contact_events 
                    (contact_id, event_type, metadata) 
                    VALUES (?, ?, ?)`, 
                    [
                        contactIdNum,
                        'eligibility_answered',
                        JSON.stringify(analyticsData)
                    ]
                );
                
                return {
                    contactId: contactIdNum.toString(), // Return as string if needed by frontend
                    orgName: orgDetails?.name || 'Medicare Max',
                    orgLogo: orgDetails?.logo_data || null
                };
            } catch (error) {
                logger.error(`Error saving eligibility answers: ${error}`);
                throw new Error('Failed to save eligibility answers');
            }
        });

    return app;
};

================
File: backend/src/routes/onboarding.ts
================
import { Elysia } from 'elysia'
import { logger } from '../logger'
import { Database } from '../database'
import { config } from '../config'
import { cookie } from '@elysiajs/cookie'
import Stripe from 'stripe'

// Initialize Stripe with secret key from environment variables
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || 'sk_test_51Qyh7RCBUPXAZKNGFySALjap1pDAtEwPtuY5TAzEuKKDq7cfAmHhmQIn8W1UMf2CuOvQ1umjiUrlpPauOc159fpM00nfohCZH3')
const YOUR_DOMAIN = config.clientUrl || 'http://localhost:3000'

// Helper function for generating unique slugs from names
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

// Helper function to ensure emails are properly decoded before storing in the database
function ensureEmailDecoded(email: string): string {
  try {
    // Check if email appears to be encoded
    if (email.includes('%')) {
      let decoded = email;
      let previous = '';
      
      // Apply decoding until the string no longer changes
      // This handles scenarios where the email might be double-encoded
      while (decoded !== previous) {
        previous = decoded;
        decoded = decodeURIComponent(decoded);
      }
      
      // Log if we actually changed something
      if (decoded !== email) {
        logger.info(`Decoded email from ${email} to ${decoded}`);
        return decoded;
      }
    }
    return email;
  } catch (error) {
    logger.warn(`Error decoding email ${email}: ${error}`);
    return email; // Return original if decoding fails
  }
}

export function createOnboardingRoutes() {
  const dbInstance = new Database()
  
  // Log that we're creating the routes, for debugging
  logger.info('Initializing onboarding routes including resume endpoint');

  // Define the resume endpoint separately to ensure it's properly registered
  const resumeHandler = async ({ query, set, request }: { query: any, set: any, request: any }) => {
    // Log request headers for debugging authentication issues
    logger.info(`Request headers: ${JSON.stringify(request.headers)}`);
    logger.info(`Resume endpoint called with query: ${JSON.stringify(query)}`);
    
    try {
      const { email } = query as { email: string };
      
      if (!email) {
        set.status = 400;
        return {
          success: false,
          message: 'Email is required'
        };
      }
      
      // Properly decode the email parameter
      const decodedEmail = ensureEmailDecoded(email);
      logger.info(`Processing resume request for email: ${decodedEmail}`);
      
      // Find the user and their organization
      logger.info(`Searching for user with email: ${decodedEmail}`);
      let userInfo = await dbInstance.fetchOne<{ 
        id: number, 
        organization_id: number, 
        first_name: string,
        last_name: string,
        email: string,
        phone: string
      }>(
        'SELECT id, organization_id, first_name, last_name, email, phone FROM users WHERE email = ?',
        [decodedEmail]
      );
      
      if (!userInfo) {
        logger.warn(`User not found with email: ${decodedEmail}`);
        // Try a case-insensitive search as a fallback
        const userByLowercase = await dbInstance.fetchOne<{ 
          id: number, 
          organization_id: number, 
          first_name: string,
          last_name: string,
          email: string,
          phone: string
        }>(
          'SELECT id, organization_id, first_name, last_name, email, phone FROM users WHERE LOWER(email) = LOWER(?)',
          [decodedEmail]
        );
        
        if (userByLowercase) {
          logger.info(`Found user with case-insensitive email match: ${userByLowercase.email}`);
          // Continue with the found user
          userInfo = userByLowercase;
        } else {
          logger.error(`User not found with email (case insensitive): ${decodedEmail}`);
          set.status = 401;
          return {
            success: false,
            message: 'User not found'
          };
        }
      }
      
      const organizationId = userInfo.organization_id;
      logger.info(`Found user with organization ID: ${organizationId}`);
      
      // Get organization details
      let orgInfo;
      try {
        orgInfo = await dbInstance.fetchOne<{
          id: number,
          name: string,
          onboarding_completed: number,
          website: string,
          phone: string,
          primary_color: string,
          secondary_color: string,
          logo_data: string | null,
          org_settings: string | null,
          payment_completed: number,
          stripe_customer_id: string | null,
          stripe_subscription_id: string | null
        }>(
          `SELECT id, name, onboarding_completed, website, phone, 
           primary_color, secondary_color, logo_data, org_settings,
           payment_completed, stripe_customer_id, stripe_subscription_id
           FROM organizations WHERE id = ?`,
          [organizationId]
        );
        
        logger.info(`Organization query result: ${orgInfo ? 'Found' : 'Not found'}`);
        
        if (!orgInfo) {
          logger.warn(`Organization with ID ${organizationId} not found`);
          set.status = 404;
          return {
            success: false,
            message: 'Organization not found'
          };
        }
      } catch (error) {
        logger.error(`Error retrieving organization with ID ${organizationId}: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Error retrieving organization'
        };
      }
      
      // Check if onboarding is already completed
      if (orgInfo.onboarding_completed === 1) {
        set.status = 200;
        return {
          success: true,
          onboardingComplete: true,
          redirectToLogin: true
        };
      }
      
      // Get all agents/users for this organization
      const agents = await dbInstance.query<{
        id: number,
        first_name: string,
        last_name: string,
        email: string,
        phone: string,
        is_admin: number
      }>(
        `SELECT id, first_name, last_name, email, phone, is_admin 
         FROM users WHERE organization_id = ?`,
        [organizationId]
      );
      
      // Parse org settings if exists
      let orgSettings = {};
      if (orgInfo.org_settings) {
        try {
          orgSettings = JSON.parse(orgInfo.org_settings);
        } catch (e) {
          logger.warn(`Could not parse org_settings for org ${organizationId}: ${e}`);
        }
      }
      
      // Check if payment fields exist in orgInfo to prevent errors
      logger.info(`Payment data: completed=${orgInfo.payment_completed !== undefined}, customerID=${orgInfo.stripe_customer_id !== undefined}, subscriptionID=${orgInfo.stripe_subscription_id !== undefined}`);
      
      // Construct response data
      set.status = 200;
      return {
        success: true,
        onboardingComplete: false,
        organization: {
          id: orgInfo.id,
          name: orgInfo.name,
          website: orgInfo.website || '',
          phone: orgInfo.phone || '',
          primaryColor: orgInfo.primary_color || '#6B46C1',
          secondaryColor: orgInfo.secondary_color || '#9F7AEA',
          logo: orgInfo.logo_data || null
        },
        user: {
          id: userInfo.id,
          firstName: userInfo.first_name,
          lastName: userInfo.last_name,
          email: userInfo.email,
          phone: userInfo.phone || ''
        },
        agents: agents.map(agent => ({
          firstName: agent.first_name,
          lastName: agent.last_name,
          email: agent.email,
          phone: agent.phone || '',
          isAdmin: agent.is_admin === 1
        })),
        carrierSettings: {
          selectedCarriers: (orgSettings as any)?.carrierContracts || [],
          useSmartSend: (orgSettings as any)?.smartSendEnabled || true
        },
        paymentStatus: {
          paymentCompleted: orgInfo.payment_completed === 1,
          stripeCustomerId: orgInfo.stripe_customer_id || null,
          stripeSubscriptionId: orgInfo.stripe_subscription_id || null
        }
      };
      
    } catch (error) {
      logger.error(`Error resuming onboarding: ${error}`);
      set.status = 500;
      return {
        success: false,
        message: 'Failed to resume onboarding'
      };
    }
  };

  const app = new Elysia()
    // Register the resume endpoint with the correct path - bypass auth
    .get('/api/onboarding/resume', (context) => {
      // Explicitly set the status to 200
      context.set.status = 200;
      return resumeHandler(context);
    })
    
    // Create a Stripe checkout session
    .post('/api/create-checkout-session', async ({ body, set }) => {
      try {
        const { priceId, meteredPriceId, customerEmail, customerName } = body as { 
          priceId: string, 
          meteredPriceId?: string,
          customerEmail?: string,
          customerName?: string
        }
        
        if (!priceId) {
          set.status = 400
          return {
            success: false,
            message: 'Price ID is required'
          }
        }
        
        // Decode the email address if it exists and contains encoded characters
        let decodedEmail: string | undefined;
        if (customerEmail) {
          try {
            // Check if the email contains encoded characters
            if (customerEmail.includes('%')) {
              decodedEmail = decodeURIComponent(customerEmail);
            } else {
              decodedEmail = customerEmail;
            }
            logger.info(`Decoded email from ${customerEmail} to ${decodedEmail}`);
          } catch (error) {
            logger.warn(`Failed to decode email: ${customerEmail}. Using as-is.`);
            decodedEmail = customerEmail;
          }
        }
        
        logger.info(`Creating checkout session for base price: ${priceId}, metered price: ${meteredPriceId || 'none'}, customer: ${decodedEmail || 'anonymous'}`);
        
        // Build line items array for the checkout session
        const lineItems: any[] = [
          {
            price: priceId,
            //quantity: 1, // Required for regular subscription
          }
        ];
        
        // Add metered price if provided, WITHOUT a quantity (Stripe doesn't want quantity for metered prices)
        if (meteredPriceId) {
          lineItems.push({
            price: meteredPriceId,
            // No quantity for metered prices
          });
        }
        
        logger.info(`Creating checkout session with line items: ${JSON.stringify(lineItems)}`);
        
        // Create the session
        const session = await stripe.checkout.sessions.create({
          ui_mode: 'embedded',
          line_items: lineItems,
          mode: 'subscription',
          redirect_on_completion: 'never',
          automatic_tax: { enabled: true },
          ...(decodedEmail ? { customer_email: decodedEmail } : {})
        })
        
        set.status = 200;
        return {
          success: true,
          clientSecret: session.client_secret
        }
      } catch (error) {
        logger.error(`Error creating checkout session: ${error}`)
        set.status = 500
        return {
          success: false,
          message: 'Failed to create checkout session'
        }
      }
    })
    
    // Get session status
    .get('/api/session-status', async ({ query, set }) => {
      try {
        const { session_id } = query as { session_id: string }
        
        if (!session_id) {
          logger.error('No session ID provided in status request');
          set.status = 400
          return {
            success: false,
            message: 'Session ID is required'
          }
        }
        
        logger.info(`Checking status for session ID: ${session_id}`);
        const session = await stripe.checkout.sessions.retrieve(session_id)
        
        logger.info(`Retrieved session with status: ${session.status}, payment status: ${session.payment_status || 'unknown'}`);
        
        // If payment is complete, store the customer and subscription info in the database
        if (session.status === 'complete' && session.customer_details?.email) {
          const customerEmail = session.customer_details.email;
          // Ensure the email is decoded
          const decodedEmail = ensureEmailDecoded(customerEmail);
          const stripeCustomerId = session.customer as string;
          const stripeSubscriptionId = session.subscription as string;
          
          logger.info(`Payment completed for ${decodedEmail}, updating database records`);
          logger.info(`Customer ID: ${stripeCustomerId}, Subscription ID: ${stripeSubscriptionId}`);
          
          // Find the user by email
          const userInfo = await dbInstance.fetchOne<{ organization_id: number }>(
            'SELECT organization_id FROM users WHERE email = ?',
            [decodedEmail]
          );
          
          if (userInfo) {
            // Update the organization with payment info
            await dbInstance.execute(
              `UPDATE organizations SET 
                payment_completed = 1,
                stripe_customer_id = ?,
                stripe_subscription_id = ?
               WHERE id = ?`,
              [stripeCustomerId, stripeSubscriptionId, userInfo.organization_id]
            );
            
            logger.info(`Updated payment status for organization ID: ${userInfo.organization_id}`);
          } else {
            logger.warn(`Could not find user with email ${decodedEmail} to update payment status`);
          }
        } else if (session.status === 'open') {
          logger.info(`Session ${session_id} is still open, payment not completed yet`);
        } else {
          logger.info(`Session ${session_id} has status ${session.status}, no database update needed`);
        }
        
        return {
          success: true,
          status: session.status,
          payment_status: session.payment_status || null,
          customer_email: session.customer_details?.email || null,
          amount_total: session.amount_total,
          customer: session.customer,
          subscription: session.subscription
        }
      } catch (error) {
        logger.error(`Error checking session status: ${error}`)
        set.status = 500
        return {
          success: false,
          message: 'Failed to check session status'
        }
      }
    })
    
    // Get checkout session from client secret
    .get('/api/checkout-session', async ({ query, set }) => {
      try {
        const { clientSecret } = query as { clientSecret: string }
        
        if (!clientSecret) {
          logger.error('No client secret provided in checkout session request');
          set.status = 400
          return {
            success: false,
            message: 'Client secret is required'
          }
        }
        
        // Extract the session ID from the client secret (format: cs_<id>_secret_<secret>)
        const sessionId = clientSecret.split('_secret_')[0];
        if (!sessionId) {
          logger.error(`Could not extract session ID from client secret: ${clientSecret.substring(0, 10)}...`);
          set.status = 400;
          return {
            success: false,
            message: 'Invalid client secret format'
          };
        }
        
        logger.info(`Retrieving checkout session with ID: ${sessionId}`);
        
        // Retrieve the session from Stripe
        logger.info(`Calling Stripe API to retrieve session ${sessionId} with expanded subscription data`);
        const session = await stripe.checkout.sessions.retrieve(sessionId, {
          expand: ['subscription', 'subscription.items']
        });
        
        if (!session) {
          logger.error(`Could not find session with ID: ${sessionId}`);
          set.status = 404;
          return {
            success: false,
            message: 'Session not found'
          };
        }
        
        logger.info(`Session retrieved successfully. Status: ${session.status}, Customer: ${session.customer ? (session.customer as string).substring(0, 10) + '...' : 'none'}`);
        logger.info(`Session subscription data: ${session.subscription ? 'present' : 'missing'}`);
        
        // Get subscription item ID if it exists
        let subscriptionItemId = null;
        if (session.subscription && typeof session.subscription !== 'string') {
          const subscription = session.subscription;
          const items = subscription.items?.data || [];
          
          logger.info(`Found ${items.length} subscription items`);
          
          // Log item details for debugging
          items.forEach((item, index) => {
            logger.info(`Subscription item ${index + 1}:`);
            logger.info(`  ID: ${item.id}`);
            logger.info(`  Price: ${item.price ? item.price.id : 'unknown'}`);
            if (item.price && typeof item.price === 'object') {
              logger.info(`  Price Type: ${(item.price as any).type || 'unknown'}`);
              logger.info(`  Price Nickname: ${(item.price as any).nickname || 'unknown'}`);
            }
          });
          
          // Use a type-safe approach to identify the metered price item
          const meteredItem = items.find(item => {
            if (item.price && typeof item.price === 'object' && 'type' in item.price) {
              const priceType = (item.price as any).type;
              logger.info(`Checking item with price type: ${priceType}`);
              return priceType === 'metered';
            }
            return false;
          });
          
          if (meteredItem) {
            subscriptionItemId = meteredItem.id;
            logger.info(`Found metered subscription item: ${subscriptionItemId}`);
          } else {
            logger.info('No metered subscription item found');
            // Fallback: just use the last item if there are multiple items (often the metered item is second)
            if (items.length > 1) {
              subscriptionItemId = items[items.length - 1].id;
              logger.info(`Using last subscription item as fallback: ${subscriptionItemId}`);
            }
          }
        } else {
          logger.info(`Subscription data is not expanded or missing: ${typeof session.subscription}`);
        }
        
        const result = {
          success: true,
          customer: session.customer as string,
          subscription: session.subscription as string || null,
          subscription_item: subscriptionItemId
        };
        
        logger.info(`Returning checkout session data: ${JSON.stringify(result)}`);
        return result;
      } catch (error) {
        logger.error(`Error retrieving checkout session: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: `Failed to retrieve checkout session: ${error instanceof Error ? error.message : 'Unknown error'}`
        }
      }
    })
    
    // Save company details during onboarding
    .post('/api/onboarding/company', async ({ body, set }) => {
      try {
        const { 
          email,
          companyName, 
          companyPhone, 
          companyWebsite, 
          primaryColor, 
          secondaryColor, 
          logo,
          firstName,
          lastName,
          phone
        } = body as { 
          email: string,
          companyName?: string,
          companyPhone?: string,
          companyWebsite?: string,
          primaryColor?: string,
          secondaryColor?: string,
          logo?: string,
          firstName?: string,
          lastName?: string,
          phone?: string
        };
        
        if (!email) {
          set.status = 400;
          return {
            success: false,
            message: 'Email is required'
          };
        }
        
        // Ensure email is decoded
        const decodedEmail = ensureEmailDecoded(email);
        const decodedFirstName = decodeURIComponent(firstName || '');
        const decodedLastName = decodeURIComponent(lastName || '');
        logger.info(`Processing onboarding company update for email: ${decodedEmail}`);
        
        // Find the organization by user email
        let userInfo = await dbInstance.fetchOne<{ id: number, organization_id: number }>(
          'SELECT id, organization_id FROM users WHERE email = ?',
          [decodedEmail]
        );
        
        let organizationId;
        
        if (!userInfo) {
          // Create new organization first
          const slug = await generateUniqueSlug(dbInstance, companyName || 'New Organization');
          
          // Insert the organization
          const orgResult = await dbInstance.query<{ id: number }>(
            `INSERT INTO organizations (
              name, 
              slug,
              phone,
              website,
              primary_color,
              secondary_color,
              logo_data,
              onboarding_completed
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            RETURNING id`,
            [
              companyName || 'New Organization',
              slug,
              companyPhone || '',
              companyWebsite || '',
              primaryColor || '#6B46C1',
              secondaryColor || '#9F7AEA',
              logo || null,
              0 // Not completed yet
            ]
          );
          
          if (!orgResult || orgResult.length === 0) {
            throw new Error('Failed to create organization');
          }
          
          organizationId = orgResult[0].id;
          logger.info(`Created new organization with ID: ${organizationId}`);
          
          // Create the user with all available fields
          const userResult = await dbInstance.query<{ id: number }>(
            `INSERT INTO users (
              email,
              first_name,
              last_name,
              phone,
              organization_id,
              is_admin,
              is_agent
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
            RETURNING id`,
            [
              decodedEmail,
              decodedFirstName,
              decodedLastName,
              phone || '',
              organizationId,
              1, // Set as admin
              1  // Set as agent
            ]
          );
          
          if (!userResult || userResult.length === 0) {
            throw new Error('Failed to create user');
          }
          
          userInfo = {
            id: userResult[0].id,
            organization_id: organizationId
          };

          const defaultAgentId = userResult[0].id;

          await dbInstance.execute(
            'UPDATE organizations SET default_agent_id = ? WHERE id = ?',
            [defaultAgentId, organizationId]
          );  
          
          logger.info(`Created new user (${userInfo.id}) for organization (${organizationId})`);
          
          // Set success status
          set.status = 200;
          return {
            success: true,
            message: 'Organization and user created successfully',
            organizationId,
            userId: userInfo.id
          };
        } else {
          organizationId = userInfo.organization_id;
          
          // Update existing organization
          await dbInstance.execute(
            `UPDATE organizations SET 
              name = COALESCE(?, name),
              phone = COALESCE(?, phone),
              website = COALESCE(?, website),
              primary_color = COALESCE(?, primary_color),
              secondary_color = COALESCE(?, secondary_color),
              logo_data = COALESCE(?, logo_data)
            WHERE id = ?`,
            [
              companyName,
              companyPhone,
              companyWebsite,
              primaryColor,
              secondaryColor,
              logo,
              organizationId
            ]
          );
          
          // Update existing user if we have new information
          if (firstName || lastName || phone) {
            await dbInstance.execute(
              `UPDATE users SET 
                first_name = COALESCE(?, first_name),
                last_name = COALESCE(?, last_name),
                phone = COALESCE(?, phone)
              WHERE id = ?`,
              [firstName, lastName, phone, userInfo.id]
            );
          }
          
          logger.info(`Updated existing organization: ${organizationId} and user: ${userInfo.id}`);
          
          // Set success status
          set.status = 200;
          return {
            success: true,
            message: 'Organization and user updated successfully',
            organizationId,
            userId: userInfo.id
          };
        }
        
      } catch (error) {
        logger.error(`Error in company details endpoint: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to process company details'
        };
      }
    })
    
    // Save licensing settings during onboarding
    .post('/api/onboarding/licensing', async ({ body, set }) => {
      try {
        const { 
          email,
          selectedCarriers,
          useSmartSend
        } = body as { 
          email: string,
          selectedCarriers: string[],
          useSmartSend?: boolean
        };
        
        if (!email) {
          set.status = 400;
          return {
            success: false,
            message: 'Email is required'
          };
        }
        
        // Ensure email is decoded
        const decodedEmail = ensureEmailDecoded(email);
        logger.info(`Processing onboarding licensing for email: ${decodedEmail}`);
        
        // Find the organization by user email
        const userInfo = await dbInstance.fetchOne<{ organization_id: number }>(
          'SELECT organization_id FROM users WHERE email = ?',
          [decodedEmail]
        );
        
        if (!userInfo) {
          logger.warn(`User not found for email: ${decodedEmail}`);
          set.status = 404;
          return {
            success: false,
            message: 'User not found - please start from signup'
          };
        }
        
        const organizationId = userInfo.organization_id;
        
        // Verify organization exists
        const orgExists = await dbInstance.fetchOne<{ id: number }>(
          'SELECT id FROM organizations WHERE id = ?',
          [organizationId]
        );
        
        if (!orgExists) {
          logger.warn(`Organization ${organizationId} not found for user ${decodedEmail}`);
          set.status = 404;
          return {
            success: false,
            message: 'Organization not found - please start from signup'
          };
        }
        
        // Get current org settings if any
        const currentSettings = await dbInstance.fetchOne<{ org_settings: string | null }>(
          'SELECT org_settings FROM organizations WHERE id = ?',
          [organizationId]
        );
        
        // Parse existing settings or create empty object
        let settings = {};
        if (currentSettings?.org_settings) {
          try {
            settings = JSON.parse(currentSettings.org_settings);
          } catch (e) {
            logger.warn(`Could not parse existing org_settings for org ${organizationId}: ${e}`);
          }
        }
        
        // Update with new carrier contracts
        settings = {
          ...settings,
          carrierContracts: selectedCarriers || [],
          smartSendEnabled: useSmartSend !== undefined ? useSmartSend : ((settings as any)['smartSendEnabled'] || false)
        };
        
        // Convert back to JSON string
        const updatedSettingsJson = JSON.stringify(settings);
        
        // Update the organization
        await dbInstance.execute(
          'UPDATE organizations SET org_settings = ? WHERE id = ?',
          [updatedSettingsJson, organizationId]
        );
        
        logger.info(`Updated licensing settings for organization ID: ${organizationId}`);
        
        set.status = 200
        return {
          success: true,
          message: 'Licensing settings updated successfully'
        };
        
      } catch (error) {
        logger.error(`Error updating licensing settings: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to update licensing settings'
        };
      }
    })
    
    // Save agents during onboarding
    .post('/api/onboarding/agents', async ({ body, set }) => {
      try {
        const { 
          email,
          agents
        } = body as { 
          email: string,
          agents: Array<{
            firstName: string;
            lastName: string;
            email: string;
            phone: string;
            isAdmin: boolean;
          }>;
        };
        
        if (!email) {
          set.status = 400;
          return {
            success: false,
            message: 'Email is required'
          };
        }
        
        // Ensure owner email is decoded
        const decodedOwnerEmail = ensureEmailDecoded(email);
        logger.info(`Processing onboarding agents for owner email: ${decodedOwnerEmail}`);
        
        // Find the organization by user email
        const userInfo = await dbInstance.fetchOne<{ id: number, organization_id: number }>(
          'SELECT id, organization_id FROM users WHERE email = ?',
          [decodedOwnerEmail]
        );
        
        if (!userInfo) {
          logger.warn(`User not found for email: ${decodedOwnerEmail}`);
          set.status = 404;
          return {
            success: false,
            message: 'User not found - please start from signup'
          };
        }
        
        const organizationId = userInfo.organization_id;
        
        // Verify organization exists
        const orgExists = await dbInstance.fetchOne<{ id: number }>(
          'SELECT id FROM organizations WHERE id = ?',
          [organizationId]
        );
        
        if (!orgExists) {
          logger.warn(`Organization ${organizationId} not found for user ${decodedOwnerEmail}`);
          set.status = 404;
          return {
            success: false,
            message: 'Organization not found - please start from signup'
          };
        }
        
        // Process each agent
        let createdCount = 0;
        let skippedCount = 0;
        
        for (const agent of agents) {
          // Ensure agent email is decoded
          const decodedAgentEmail = ensureEmailDecoded(agent.email);
          
          // Skip if this is the owner (already in the database)
          if (decodedAgentEmail.toLowerCase() === decodedOwnerEmail.toLowerCase()) {
            skippedCount++;
            continue;
          }
          
          // Check if this email already exists
          const existingAgent = await dbInstance.fetchOne<{ count: number }>(
            'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
            [decodedAgentEmail]
          );
          
          if (existingAgent && existingAgent.count > 0) {
            skippedCount++;
            continue;
          }
          
          // Create the new user with decoded email
          await dbInstance.execute(
            `INSERT INTO users (
              first_name, 
              last_name, 
              email, 
              phone, 
              is_admin, 
              is_agent, 
              organization_id
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [
              agent.firstName,
              agent.lastName,
              decodedAgentEmail,
              agent.phone || '',
              agent.isAdmin ? 1 : 0,
              1, // All users in this context are agents
              organizationId
            ]
          );
          
          createdCount++;
        }
        
        // Set the onboarding user as the default agent for the organization
        if (userInfo) {
          await dbInstance.execute(
            'UPDATE organizations SET default_agent_id = ? WHERE id = ?',
            [userInfo.id, organizationId]
          );
          logger.info(`Set user ${userInfo.id} as default agent for organization ID: ${organizationId}`);
        } else {
          logger.warn(`Could not set default agent for organization ${organizationId} because owner user info was not found.`);
        }
        
        logger.info(`Created ${createdCount} agents, skipped ${skippedCount}, for organization ID: ${organizationId}. Onboarding NOT YET marked complete.`);
        
        return {
          success: true,
          message: `Successfully added ${createdCount} agents and completed onboarding`,
          created: createdCount,
          skipped: skippedCount
        };
        
      } catch (error) {
        logger.error(`Error adding agents: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to add agents'
        };
      }
    })
    .get('/api/subscription/pricing', async ({ set }) => {
      try {
        const publishableKey = process.env.STRIPE_PUBLISHABLE_KEY;
        const priceId = process.env.STRIPE_PRICE_ID;

        if (!publishableKey || !priceId) {
          set.status = 500;
          return {
            success: false,
            message: 'Stripe configuration missing'
          };
        }

        set.status = 200;
        return {
          success: true,
          publishableKey,
          priceId
        };
      } catch (error) {
        logger.error(`Error getting Stripe pricing: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to get Stripe pricing'
        };
      }
    })
    // Simplified checkout endpoint that creates the account
    .post('/api/subscription/checkout', async ({ body, set }) => {
      try {
        logger.info(`Processing account creation request: ${JSON.stringify(body)}`);
        const { firstName, lastName, email, tierId = 'basic', 
                companyName, companyPhone, companyWebsite, 
                primaryColor, secondaryColor, logo } = body as { 
          firstName: string, 
          lastName: string, 
          email: string,
          tierId?: string,
          companyName?: string,
          companyPhone?: string,
          companyWebsite?: string,
          primaryColor?: string,
          secondaryColor?: string,
          logo?: string
        };
        
        logger.info(`User info: ${firstName} ${lastName} (${email})`);
        
        if (!firstName || !lastName || !email) {
          logger.warn(`Missing required user information. Received: firstName=${!!firstName}, lastName=${!!lastName}, email=${!!email}`);
          set.status = 400;
          return { 
            success: false,
            message: 'Missing required user information'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ id: number, organization_id: number, count: number }>(
          'SELECT id, organization_id, COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        let organizationId;
        
        if (existingUser[0]?.count > 0) {
          // User exists, check if their organization has completed onboarding
          const orgInfo = await dbInstance.query<{ onboarding_completed: number }>(
            'SELECT onboarding_completed FROM organizations WHERE id = ?',
            [existingUser[0].organization_id]
          );
          
          if (orgInfo[0]?.onboarding_completed === 1) {
            logger.warn(`Email ${email} is already registered with completed onboarding`);
            set.status = 400;
            return { 
              success: false, 
              message: 'This email address is already registered with completed onboarding'
            };
          }
          
          // Use the existing organization if onboarding is not complete
          logger.info(`Found existing organization ${existingUser[0].organization_id} with incomplete onboarding`);
          organizationId = existingUser[0].organization_id;
          
          // Update organization details if provided
          if (companyName || companyPhone || companyWebsite || primaryColor || secondaryColor || logo) {
            const updates = [];
            const params = [];
            
            if (companyName) {
              updates.push('name = ?');
              params.push(companyName);
            }
            
            if (companyPhone) {
              updates.push('phone = ?');
              params.push(companyPhone);
            }
            
            if (companyWebsite) {
              updates.push('website = ?');
              params.push(companyWebsite);
            }
            
            if (primaryColor) {
              updates.push('primary_color = ?');
              params.push(primaryColor);
            }
            
            if (secondaryColor) {
              updates.push('secondary_color = ?');
              params.push(secondaryColor);
            }
            
            if (logo) {
              updates.push('logo_data = ?');
              params.push(logo);
            }
            
            if (updates.length > 0) {
              params.push(organizationId);
              await dbInstance.execute(
                `UPDATE organizations SET ${updates.join(', ')} WHERE id = ?`,
                params
              );
              logger.info(`Updated organization details for ID: ${organizationId}`);
            }
          }
        } else {
          // Create new organization for new user
          // Generate a unique slug from the name
          const organizationName = companyName || `${firstName}'s Organization`;
          const slug = await generateUniqueSlug(dbInstance, organizationName);
          
          logger.info(`Generated organization name: "${organizationName}" and slug: "${slug}"`);
          
          // Create new organization with optional fields if provided
          const orgFields = ['name', 'slug'];
          const orgValues = [organizationName, slug];
          const orgPlaceholders = ['?', '?'];
          
          if (companyPhone) {
            orgFields.push('phone');
            orgValues.push(companyPhone);
            orgPlaceholders.push('?');
          }
          
          if (companyWebsite) {
            orgFields.push('website');
            orgValues.push(companyWebsite);
            orgPlaceholders.push('?');
          }
          
          if (primaryColor) {
            orgFields.push('primary_color');
            orgValues.push(primaryColor);
            orgPlaceholders.push('?');
          }
          
          if (secondaryColor) {
            orgFields.push('secondary_color');
            orgValues.push(secondaryColor);
            orgPlaceholders.push('?');
          }
          
          if (logo) {
            orgFields.push('logo_data');
            orgValues.push(logo);
            orgPlaceholders.push('?');
          }
          
          const result = await dbInstance.query<{ id: number }>(
            `INSERT INTO organizations (${orgFields.join(', ')}) VALUES (${orgPlaceholders.join(', ')})`,
            orgValues
          );
          
          if (result.length > 0) {
            organizationId = result[0].id;
          } else {
            throw new Error('Failed to create organization');
          }
        }
        
        // Create new user
        const resultUser = await dbInstance.query<{ id: number }>(
          'INSERT INTO users (firstName, lastName, email, organization_id) VALUES (?, ?, ?, ?)',
          [firstName, lastName, email, organizationId]
        );
        
        if (resultUser.length > 0) {
          logger.info(`User ${firstName} ${lastName} (${email}) successfully created`);
          set.status = 200;
          return {
            success: true,
            message: 'Account created successfully'
          };
        } else {
          throw new Error('Failed to create user');
        }
      } catch (error) {
        logger.error(`Error processing account creation: ${error}`)
        set.status = 500
        return {
          success: false,
          message: 'Failed to process account creation'
        }
      }
    })

    // Debug endpoint to list users (development only)
    .get('/api/debug/users', async ({ set }) => {
      // Only allow in development environment
      if (process.env.NODE_ENV === 'production') {
        set.status = 404;
        return { error: 'Not found' };
      }
      
      try {
        logger.info('Debug endpoint called to list users');
        
        // Get all users with email addresses
        const users = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users LIMIT 50'
        );
        
        logger.info(`Found ${users.length} users in the database`);
        
        // Map the results to include both the raw and decoded email
        const mappedUsers = users.map(user => {
          let decodedEmail;
          try {
            decodedEmail = user.email.includes('%') 
              ? decodeURIComponent(user.email) 
              : user.email;
          } catch (e: unknown) {
            decodedEmail = `[Decode error: ${e instanceof Error ? e.message : String(e)}]`;
          }
          
          return {
            id: user.id,
            email: user.email,
            decodedEmail: decodedEmail
          };
        });
        
        return mappedUsers;
      } catch (error) {
        logger.error(`Error in debug endpoint: ${error}`);
        set.status = 500;
        return { error: String(error) };
      }
    })

    // Debug endpoint to list and fix encoded emails (development only)
    .get('/api/debug/fix-emails', async ({ set }) => {
      // Only allow in development environment
      if (process.env.NODE_ENV === 'production') {
        set.status = 404;
        return { error: 'Not found' };
      }
      
      try {
        logger.info('Debug endpoint called to list and fix encoded emails');
        
        // Get all users with potentially encoded emails
        const users = await dbInstance.query<{ id: number, email: string }>(
          "SELECT id, email FROM users WHERE email LIKE '%\%%'"
        );
        
        logger.info(`Found ${users.length} users with potentially encoded emails`);
        
        // Process each user email
        const results = [];
        for (const user of users) {
          try {
            const originalEmail = user.email;
            const decodedEmail = ensureEmailDecoded(originalEmail);
            
            // Only update if there's a change
            if (decodedEmail !== originalEmail) {
              // Update the email in the database
              await dbInstance.execute(
                'UPDATE users SET email = ? WHERE id = ?',
                [decodedEmail, user.id]
              );
              
              results.push({
                id: user.id,
                originalEmail,
                fixedEmail: decodedEmail,
                status: 'fixed'
              });
              
              logger.info(`Fixed encoded email: ${originalEmail} -> ${decodedEmail} for user ID ${user.id}`);
            } else {
              results.push({
                id: user.id,
                email: originalEmail,
                status: 'no change needed'
              });
            }
          } catch (error) {
            results.push({
              id: user.id,
              email: user.email,
              status: 'error',
              message: String(error)
            });
            logger.error(`Error fixing email for user ${user.id}: ${error}`);
          }
        }
        
        return {
          success: true,
          processed: users.length,
          results
        };
      } catch (error) {
        logger.error(`Error in debug endpoint: ${error}`);
        set.status = 500;
        return { 
          success: false, 
          error: String(error)
        };
      }
    })

    // Debug endpoint to check a specific email (development only)
    .get('/api/debug/check-email', async ({ query, set }) => {
      // Only allow in development environment
      if (process.env.NODE_ENV === 'production') {
        set.status = 404;
        return { error: 'Not found' };
      }
      
      try {
        const { email } = query as { email: string };
        if (!email) {
          set.status = 400;
          return { error: 'Email parameter is required' };
        }
        
        const decodedEmail = ensureEmailDecoded(email);
        logger.info(`Debug endpoint checking email: ${email} -> ${decodedEmail}`);
        
        // Try various methods to find the user
        const exactMatch = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users WHERE email = ?',
          [decodedEmail]
        );
        
        const lowercaseMatch = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users WHERE LOWER(email) = LOWER(?)',
          [decodedEmail]
        );
        
        const likeMatch = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users WHERE email LIKE ?',
          [`%${decodedEmail.split('@')[0]}%`]
        );
        
        // List all users for reference (limited to first 10)
        const allUsers = await dbInstance.query<{ id: number, email: string }>(
          'SELECT id, email FROM users LIMIT 10'
        );
        
        return {
          searchEmail: email,
          decodedEmail: decodedEmail,
          exactMatch: exactMatch.length > 0 ? exactMatch : null,
          lowercaseMatch: lowercaseMatch.length > 0 ? lowercaseMatch : null,
          likeMatch: likeMatch.length > 0 ? likeMatch : null,
          allUsers: allUsers
        };
      } catch (error) {
        logger.error(`Error in email debug endpoint: ${error}`);
        set.status = 500;
        return { error: String(error) };
      }
    })

    // Debug endpoint to test the resume data for a specific organization ID
    .get('/api/debug/test-resume', async ({ query, set }) => {
      // Only allow in development environment
      if (process.env.NODE_ENV === 'production') {
        set.status = 404;
        return { error: 'Not found' };
      }
      
      try {
        const { orgId } = query as { orgId: string };
        if (!orgId) {
          set.status = 400;
          return { error: 'orgId parameter is required' };
        }
        
        const organizationId = parseInt(orgId, 10);
        logger.info(`Debug endpoint testing resume data for organization ID: ${organizationId}`);
        
        // Get organization details directly by ID
        const orgInfo = await dbInstance.fetchOne<{
          id: number,
          name: string,
          onboarding_completed: number,
          website: string,
          phone: string,
          primary_color: string,
          secondary_color: string,
          logo_data: string | null,
          org_settings: string | null,
          payment_completed: number,
          stripe_customer_id: string | null,
          stripe_subscription_id: string | null
        }>(
          `SELECT id, name, onboarding_completed, website, phone, 
           primary_color, secondary_color, logo_data, org_settings,
           payment_completed, stripe_customer_id, stripe_subscription_id
           FROM organizations WHERE id = ?`,
          [organizationId]
        );
        
        if (!orgInfo) {
          set.status = 404;
          return { error: `Organization ID ${organizationId} not found` };
        }
        
        // Get a user from this organization (first one found)
        const userInfo = await dbInstance.fetchOne<{ 
          id: number, 
          first_name: string,
          last_name: string,
          email: string,
          phone: string
        }>(
          'SELECT id, first_name, last_name, email, phone FROM users WHERE organization_id = ? LIMIT 1',
          [organizationId]
        );
        
        if (!userInfo) {
          return {
            organization: orgInfo,
            error: 'No users found for this organization'
          };
        }
        
        // Get all agents/users for this organization
        const agents = await dbInstance.query<{
          id: number,
          first_name: string,
          last_name: string,
          email: string,
          phone: string,
          is_admin: number
        }>(
          `SELECT id, first_name, last_name, email, phone, is_admin 
           FROM users WHERE organization_id = ?`,
          [organizationId]
        );
        
        // Parse org settings if exists
        let orgSettings = {};
        if (orgInfo.org_settings) {
          try {
            orgSettings = JSON.parse(orgInfo.org_settings);
          } catch (e) {
            logger.warn(`Could not parse org_settings for org ${organizationId}: ${e}`);
          }
        }
        
        // Format the response in the same way as the resume endpoint
        return {
          success: true,
          onboardingComplete: orgInfo.onboarding_completed === 1,
          organization: {
            id: orgInfo.id,
            name: orgInfo.name,
            website: orgInfo.website || '',
            phone: orgInfo.phone || '',
            primaryColor: orgInfo.primary_color || '#6B46C1',
            secondaryColor: orgInfo.secondary_color || '#9F7AEA',
            logo: orgInfo.logo_data || null
          },
          user: {
            id: userInfo.id,
            firstName: userInfo.first_name,
            lastName: userInfo.last_name,
            email: userInfo.email,
            phone: userInfo.phone || ''
          },
          agents: agents.map(agent => ({
            firstName: agent.first_name,
            lastName: agent.last_name,
            email: agent.email,
            phone: agent.phone || '',
            isAdmin: agent.is_admin === 1
          })),
          carrierSettings: {
            selectedCarriers: (orgSettings as any)?.carrierContracts || [],
            useSmartSend: (orgSettings as any)?.smartSendEnabled || true
          },
          paymentStatus: {
            paymentCompleted: orgInfo.payment_completed === 1,
            stripeCustomerId: orgInfo.stripe_customer_id || null,
            stripeSubscriptionId: orgInfo.stripe_subscription_id || null
          },
          // Include the raw data for debugging
          raw: {
            orgInfo,
            userInfo,
            orgSettings
          }
        };
      } catch (error) {
        logger.error(`Error in resume test endpoint: ${error}`);
        set.status = 500;
        return { error: String(error) };
      }
    })

  // Ensure we're properly registering all routes with explicit paths
  logger.info(`Registered routes: ${app.routes.map(r => r.path).join(', ')}`);
  
  return app;
}

================
File: backend/src/routes/organizations.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { TursoService } from '../services/turso';
import { z } from 'zod';
import { sendMagicLink } from '../services/email';
import { generateToken, getUserFromSession } from '../services/auth';
import { logger } from '../logger';
import { AuthService } from '../services/auth';
import { config } from '../config';
import sgMail from '@sendgrid/mail';
import { cookie } from '@elysiajs/cookie';

// Update the validation schema to include slug rules
const signupSchema = z.object({
  organizationName: z.string()
    .min(1, "Organization name is required")
    .max(100, "Organization name must be less than 100 characters")
    .regex(/^[a-zA-Z0-9\s\-_.]+$/, "Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores"),
  adminFirstName: z.string().min(1, "First name is required"),
  adminLastName: z.string().min(1, "Last name is required"),
  adminEmail: z.string().email("Invalid email address"),
  phone: z.string().optional(),
  planType: z.string().optional(),
});

// Helper function to ensure emails are properly decoded before storing in the database
function ensureEmailDecoded(email: string): string {
  try {
    // First check if email contains encoded characters
    if (email.includes('%')) {
      const decoded = decodeURIComponent(email);
      // Check if decoding made a difference
      if (decoded !== email) {
        logger.info(`Decoded email from ${email} to ${decoded}`);
        return decoded;
      }
    }
    return email;
  } catch (error) {
    logger.warn(`Error decoding email ${email}: ${error}`);
    return email; // Return original if decoding fails
  }
}

// Enhanced slug generation with uniqueness check
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

// Add this function to handle the mapping from old tier to new contact-based tier
function mapLegacyTierToContactTier(tierId: string): number {
  // Extract tier number from ID if format is "tier-X"
  if (tierId.startsWith('tier-')) {
    const tierNumber = parseInt(tierId.substring(5), 10);
    if (!isNaN(tierNumber)) {
      return tierNumber;
    }
  }
  
  // Handle legacy tiers
  switch (tierId) {
    case 'basic':
      return 1; // 500 contacts
    case 'pro':
      return 2; // 1000 contacts
    case 'enterprise':
      return 5; // 2500 contacts
    default:
      return 1; // Default to Tier 1
  }
}

// Add this function to calculate the agent limit based on contact tier
function getAgentLimitForContactTier(contactTier: number): number {
  switch (contactTier) {
    case 1: return 5;    // 500 contacts
    case 2: return 10;   // 1,000 contacts
    case 5: return 25;   // 2,500 contacts
    case 10: return 50;  // 5,000 contacts
    case 20: return 100; // 10,000 contacts
    case 50: return 200; // 25,000 contacts
    case 100: return 300; // 50,000 contacts
    case 200: return 500; // 100,000 contacts
    default:
      // Formula for tiers not explicitly defined
      if (contactTier <= 0) return 5;
      if (contactTier <= 10) return contactTier * 5;
      if (contactTier <= 50) return contactTier * 4;
      if (contactTier <= 100) return contactTier * 3;
      return contactTier * 2.5; // For very high tiers
  }
}

export const organizationRoutes = new Elysia({ prefix: '/api' })
  .post('/organizations/signup', async ({ body, set }) => {
    const db = new Database();
    const turso = new TursoService();
    const auth = new AuthService();

    try {
      logger.info(`Attempting to create organization with data: ${JSON.stringify(body)}`);
      const data = signupSchema.parse(body);
      
      // Decode email to ensure it's stored properly
      const decodedEmail = ensureEmailDecoded(data.adminEmail);
      
      // Generate unique slug
      const slug = await generateUniqueSlug(db, data.organizationName);
      logger.info(`Generated unique slug: ${slug}`);
      
      // Check if email is already registered in any organization
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
        [decodedEmail]
      );

      logger.info(`Existing user check result: ${JSON.stringify(existingUser)}`);

      if (existingUser[0]?.count > 0) {
        logger.warn(`Email ${decodedEmail} is already registered`);
        set.status = 400;
        return {
          success: false,
          message: 'This email address is already registered. Please use a different email or contact support.'
        };
      }

      // Check if organization name or slug is taken
      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [data.organizationName, slug]
      );

      logger.info(`Existing org check result: ${JSON.stringify(existingOrg)}`);

      if (existingOrg[0]?.count > 0) {
        logger.warn(`Organization name ${data.organizationName} or slug ${slug} is already taken`);
        set.status = 400;
        return {
          success: false,
          message: 'Organization name is already taken'
        };
      }

      // Wrap all database operations in a transaction
      const orgId = await db.transaction('write', async (transactionDb) => {
        // Create organization
        logger.info('Creating organization');
        const org = await transactionDb.execute(
          `INSERT INTO organizations (
            name,
            slug,
            subscription_tier,
            agent_limit,
            contact_limit
          ) VALUES (?, ?, 'basic', 5, 100) RETURNING id`,
          [data.organizationName, slug]
        );

        const orgId = org.rows?.[0]?.id;
        if (!orgId) {
          throw new Error('Failed to create organization');
        }

        logger.info(`Organization created with ID: ${orgId}`);

        // Create inactive admin user
        logger.info('Creating admin user');
        await transactionDb.execute(
          `INSERT INTO users (
            email,
            organization_id,
            is_admin,
            is_agent,
            is_active,
            first_name,
            last_name,
            created_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            decodedEmail,
            orgId,
            1, // is_admin
            1, // is_agent - Set to 1 for basic tier since admin is also an agent
            1, // is_active
            data.adminFirstName,
            data.adminLastName,
            new Date().toISOString()
          ]
        );

        return orgId;
      });

      // Return success response without sending magic link
      set.status = 201;
      return { 
        success: true,
        message: 'Organization created successfully',
        slug: slug
      };

    } catch (error) {
      logger.error(`Organization creation error: ${error}`);
      set.status = 400;
      return {
        success: false,
        message: error instanceof z.ZodError 
          ? error.errors.map(e => e.message).join(', ')
          : 'Failed to create organization. Please try again.'
      };
    }
  })
  .get('/organizations/check-name/:name', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedName = decodeURIComponent(params.name);
      const potentialSlug = decodedName
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');

      const existingOrg = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM organizations WHERE name = ? OR slug = ?',
        [decodedName, potentialSlug]
      );

      const count = existingOrg[0]?.count || 0;

      if (count > 0) {
        return {
          available: false,
          message: 'Organization name is already taken'
        };
      }

      // Validate name format
      if (!/^[a-zA-Z0-9\s\-_.]+$/.test(decodedName)) {
        return {
          available: false,
          message: 'Organization name can only contain letters, numbers, spaces, hyphens, dots, and underscores'
        };
      }

      return {
        available: true,
        message: 'Organization name is available'
      };

    } catch (error) {
      logger.error(`Error checking organization name: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check organization name'
      };
    }
  })
  .get('/organizations/check-email/:email', async ({ params, set }) => {
    const db = new Database();

    try {
      const decodedEmailParam = decodeURIComponent(params.email);
      // Ensure the email is fully decoded
      const decodedEmail = ensureEmailDecoded(decodedEmailParam);
      
      logger.info(`Checking email availability for: "${decodedEmail}"`);
      
      // Basic email format validation
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(decodedEmail)) {
        logger.info(`Email validation failed for: "${decodedEmail}"`);
        return {
          available: false,
          message: 'Invalid email format'
        };
      }

      // Use LOWER() for case-insensitive comparison to match unique constraint behavior
      logger.info(`Running SQL query: SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER('${decodedEmail}')`);
      const existingUser = await db.query<{ count: number }>(
        'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
        [decodedEmail]
      );

      const count = existingUser[0]?.count || 0;
      logger.info(`Email check query result count: ${count} for email: "${decodedEmail}"`);

      if (count > 0) {
        logger.info(`Email "${decodedEmail}" is already registered`);
        return {
          available: false,
          message: 'This email address is already registered'
        };
      }

      logger.info(`Email "${decodedEmail}" is available`);
      return {
        available: true,
        message: 'Email is available'
      };

    } catch (error) {
      logger.error(`Error checking email: ${error}`);
      set.status = 500;
      return {
        available: false,
        message: 'Failed to check email availability'
      };
    }
  })
  .get('/organizations/subscription-tiers', async ({ set }) => {
    try {
      // Define a broader range of contact-based pricing tiers
      const tiers = [
        {
          id: "tier-1",
          name: "Tier 1",
          price: "$60/mo",
          agentLimit: 5,
          contactLimit: 500,
          features: ["Up to 500 contacts", "Email scheduling", "CRM features", "Analytics dashboard", "5 agent accounts"]
        },
        {
          id: "tier-2",
          name: "Tier 2",
          price: "$100/mo", 
          agentLimit: 10,
          contactLimit: 1000,
          features: ["Up to 1,000 contacts", "Email scheduling", "CRM features", "Analytics dashboard", "10 agent accounts"]
        },
        {
          id: "tier-5",
          name: "Tier 5",
          price: "$220/mo",
          agentLimit: 25,
          contactLimit: 2500, 
          features: ["Up to 2,500 contacts", "Email scheduling", "CRM features", "Premium support", "25 agent accounts"]
        },
        {
          id: "tier-10",
          name: "Tier 10",
          price: "$420/mo",
          agentLimit: 50,
          contactLimit: 5000,
          features: ["Up to 5,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "50 agent accounts"]
        },
        {
          id: "tier-20",
          name: "Tier 20",
          price: "$820/mo",
          agentLimit: 100,
          contactLimit: 10000,
          features: ["Up to 10,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "100 agent accounts"]
        },
        {
          id: "tier-50",
          name: "Tier 50",
          price: "$2020/mo",
          agentLimit: 200,
          contactLimit: 25000,
          features: ["Up to 25,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "Dedicated account manager", "200 agent accounts"]
        },
        {
          id: "tier-100",
          name: "Tier 100",
          price: "$3820/mo",
          agentLimit: 300,
          contactLimit: 50000,
          features: ["Up to 50,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "Dedicated account manager", "300 agent accounts"]
        },
        {
          id: "tier-200",
          name: "Tier 200",
          price: "$7620/mo",
          agentLimit: 500,
          contactLimit: 100000,
          features: ["Up to 100,000 contacts", "Email scheduling", "CRM features", "Premium support", "Priority service", "Dedicated account manager", "Custom integrations", "500 agent accounts"]
        }
      ];

      // Add an endpoint for calculating custom tier pricing
      return { success: true, tiers };
    } catch (error) {
      logger.error(`Error fetching subscription tiers: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to fetch subscription tiers' };
    }
  })
  .get('/organizations/:orgSlug/subscription', async ({ params, request, set }) => {
    try {
      const db = new Database();
      const orgSlug = params.orgSlug;
      
      logger.info(`GET /organizations/${orgSlug}/subscription - Request received`);
      
      // Get session cookie for debugging
      const sessionCookie = request.headers.get('cookie');
      logger.info(`Session cookie: ${sessionCookie ? 'Present' : 'Missing'}`);
      
      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('Subscription fetch failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Log request information for debugging
      logger.info(`Fetching subscription - orgSlug: ${orgSlug}, userId: ${currentUser.id}, orgId: ${currentUser.organization_id}`);
      
      // Get organization details
      const orgResult = await db.query<{ 
        id: number,
        subscription_tier: string,
        agent_limit: number,
        contact_limit: number
      }>(
        'SELECT id, subscription_tier, agent_limit, contact_limit FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`Subscription fetch failed: Organization not found - ${orgSlug}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Verify user has permission for this org
      if (organization.id !== currentUser.organization_id) {
        logger.error(`Subscription fetch failed: Permission denied - User from org ${currentUser.organization_id} attempted to access org ${organization.id}`);
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to view this organization'
        };
      }
      
      // Set up the response with subscription details
      const response = {
        success: true,
        tierId: organization.subscription_tier,
        agentLimit: organization.agent_limit,
        contactLimit: organization.contact_limit
      };

      logger.info(`Successfully fetched subscription for org ${organization.id}: tier=${organization.subscription_tier}, agents=${organization.agent_limit}, contacts=${organization.contact_limit}`);
      
      return response;
      
    } catch (error) {
      logger.error(`Error fetching organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to fetch subscription details'
      };
    }
  })
  .get('/organizations/my-subscription', async ({ request, set }) => {
    try {
      const db = new Database();
      
      logger.info('GET /organizations/my-subscription - Request received');
      
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('My subscription fetch failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Get organization details using user's organization_id
      const orgResult = await db.query<{ 
        id: number,
        name: string,
        slug: string,
        subscription_tier: string,
        agent_limit: number,
        contact_limit: number,
        stripe_subscription_id: string | null
      }>(
        'SELECT id, name, slug, subscription_tier, agent_limit, contact_limit, stripe_subscription_id FROM organizations WHERE id = ?',
        [currentUser.organization_id]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`My subscription fetch failed: Organization not found for user ${currentUser.id}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Get subscription tier details from subscription_tiers table
      const tierResult = await db.query<{
        name: string,
        agent_limit: number,
        contact_limit: number,
        features: string
      }>(
        'SELECT name, agent_limit, contact_limit, features FROM subscription_tiers WHERE id = ?',
        [organization.subscription_tier]
      );
      
      const tier = tierResult[0] || null;
      
      // Determine subscription status based on Stripe subscription
      const subscriptionStatus = organization.stripe_subscription_id ? 'active' : 'inactive';
      
      // Set up the response with complete subscription details
      const response = {
        success: true,
        organization: {
          id: organization.id,
          name: organization.name,
          slug: organization.slug
        },
        subscription: {
          tierId: organization.subscription_tier,
          tierName: tier?.name || organization.subscription_tier,
          status: subscriptionStatus,
          agentLimit: organization.agent_limit,
          contactLimit: organization.contact_limit,
          features: tier ? JSON.parse(tier.features) : []
        }
      };

      logger.info(`Successfully fetched my subscription for org ${organization.id}: tier=${organization.subscription_tier}, agents=${organization.agent_limit}, contacts=${organization.contact_limit}`);
      
      return response;
      
    } catch (error) {
      logger.error(`Error fetching my organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to fetch subscription details'
      };
    }
  })
  .post('/organizations/:orgSlug/subscription', async ({ params, body, request, set }) => {
    try {
      const db = new Database();
      const orgSlug = params.orgSlug;
      
      logger.info(`POST /organizations/${orgSlug}/subscription - Request received`);
      
      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request);
      logger.info(`User authentication result: ${currentUser ? `Authenticated as ${currentUser.email}` : 'Not authenticated'}`);
      
      if (!currentUser) {
        set.status = 401;
        logger.error('Subscription update failed: User not authenticated');
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }

      // Get organization details
      const orgResult = await db.query<{ 
        id: number, 
        subscription_tier: string,
        stripe_customer_id: string | null
      }>(
        'SELECT id, subscription_tier, stripe_customer_id FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        logger.error(`Subscription update failed: Organization not found - ${orgSlug}`);
        return {
          success: false,
          error: 'Organization not found'
        };
      }

      const organization = orgResult[0];
      
      // Verify user has permission for this org
      if (organization.id !== currentUser.organization_id) {
        logger.error(`Subscription update failed: Permission denied - User from org ${currentUser.organization_id} attempted to access org ${organization.id}`);
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to update this organization'
        };
      }

      // Extract the tier ID and additional resources from the request body
      const { tierId, extraAgents, extraContacts } = body as { 
        tierId: 'basic' | 'pro' | 'enterprise' | string,
        extraAgents: number,
        extraContacts: number
      };
      
      // Map the legacy tier to a contact-based tier
      const contactTier = mapLegacyTierToContactTier(tierId);
      const agentLimit = getAgentLimitForContactTier(contactTier);
      
      logger.info(`Updating subscription - orgId: ${organization.id}, tier: ${tierId}, contactTier: ${contactTier}, agentLimit: ${agentLimit}`);

      // Check if we need to update the Stripe subscription
      if (organization.subscription_tier !== tierId) {
        logger.info(`Organization tier is changing from ${organization.subscription_tier} to ${tierId}`);
        
        // Update Stripe subscription
        const stripe = await import('../services/stripe');
        
        try {
          // Create or update the subscription with Stripe
          await stripe.createOrUpdateSubscription({
            tierId: tierId as any, // Type cast to avoid type error with new tier IDs
            organizationId: organization.id,
            email: currentUser.email,
            extraAgents,
            extraContacts,
            stripeCustomerId: organization.stripe_customer_id || undefined,
            userId: currentUser.id.toString() // Add the userId to fix the linter error
          });
          
          logger.info(`Successfully updated Stripe subscription for organization ${organization.id}`);
        } catch (stripeError) {
          logger.error(`Error updating Stripe subscription: ${stripeError}`);
        }
      } else {
        logger.info(`Organization tier is not changing, skipping Stripe update`);
      }

      // Update the organization's subscription tier in the database
      await db.execute(
        `UPDATE organizations 
         SET subscription_tier = ?,
             agent_limit = ?,
             contact_limit = ?
         WHERE id = ?`,
        [
          tierId,
          agentLimit,
          contactTier * 500, // Contact limit is based on tier
          organization.id
        ]
      );
      
      logger.info(`Successfully updated subscription in database for organization ${organization.id}`);
      
      // Return success
      return {
        success: true,
        message: 'Subscription updated successfully'
      };
      
    } catch (error) {
      logger.error(`Error updating organization subscription: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to update subscription'
      };
    }
  })
  // Add new endpoint to create Turso database after plan selection
  .post('/organizations/:orgSlug/setup-database', async ({ params, set }) => {
    const db = new Database();
    const turso = new TursoService();

    try {
      const orgSlug = params.orgSlug;

      // Get organization ID from slug
      const orgResult = await db.query<{ id: number, has_db: number }>(
        'SELECT id, CASE WHEN turso_db_url IS NOT NULL THEN 1 ELSE 0 END as has_db FROM organizations WHERE slug = ?',
        [orgSlug]
      );

      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        return {
          success: false,
          message: 'Organization not found'
        };
      }

      const orgId = orgResult[0].id;

      if (orgResult[0].has_db === 1) {
        set.status = 400;
        return {
          success: false,
          message: 'Organization already has a database'
        };
      }

      // Create Turso database for the organization
      const { url, token } = await turso.createOrganizationDatabase(orgId.toString());

      // Update organization with Turso database credentials and default org_signature to false
      await db.execute(
        'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ?, org_signature = 0 WHERE id = ?',
        [url, token, orgId]
      );

      logger.info(`Successfully created Turso database for organization ${orgId}`);

      return {
        success: true,
        message: 'Database created successfully'
      };

    } catch (error) {
      logger.error(`Error creating database for organization ${params.orgSlug}: ${error}`);
      set.status = 500;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return {
        success: false,
        message: `Failed to create database: ${errorMessage}`
      };
    }
  })
  // Get organization account status
  .get('/organizations/:orgSlug/account-status', async ({ params, set, request }) => {
    try {
      const db = new Database();
      
      // Authenticate the request
      const currentUser = await getUserFromSession(request);
      if (!currentUser) {
        set.status = 401;
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        };
      }
      
      // Get organization ID from slug
      const orgResult = await db.query<{ id: number }>(
        'SELECT id FROM organizations WHERE slug = ?',
        [params.orgSlug]
      );
      
      if (!orgResult || orgResult.length === 0) {
        set.status = 404;
        return {
          success: false,
          error: 'Organization not found'
        };
      }
      
      const organizationId = orgResult[0].id;
      
      // Verify user has permission to access this organization
      if (organizationId !== currentUser.organization_id) {
        set.status = 403;
        return {
          success: false,
          error: 'You do not have permission to access this organization'
        };
      }
      
      // Import the subscription service
      const { checkAccountStatus } = await import('../services/subscription');
      
      // Check account status
      const statusDetails = await checkAccountStatus(organizationId);
      
      return {
        success: true,
        status: statusDetails
      };
      
    } catch (error) {
      logger.error(`Error checking account status: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  
  // Stripe webhook handler
  .post('/stripe-webhook', async ({ body, set, request }) => {
    try {
      const signature = request.headers.get('stripe-signature');
      
      if (!signature) {
        set.status = 400;
        return { success: false, error: 'Stripe signature missing' };
      }
      
      // Import Stripe to verify the webhook
      const Stripe = await import('stripe');
      const stripe = new Stripe.default(config.stripe.secretKey, {
        apiVersion: '2025-02-24.acacia',
      });
      
      const event = stripe.webhooks.constructEvent(
        JSON.stringify(body),
        signature,
        config.stripe.webhookSecret
      );
      
      // Import the Stripe service to handle the webhook
      const { handleStripeWebhook } = await import('../services/stripe');
      await handleStripeWebhook(event);
      
      logger.info(`Processed Stripe webhook: ${event.type}`);
      return { success: true };
      
    } catch (error) {
      logger.error(`Error processing Stripe webhook: ${error}`);
      set.status = 400;
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  })
  // Add interface for enterprise contact form data
  .post('/enterprise-contact', async ({ body, set, request }: { 
    body: { name: string; email: string; phone: string; company: string; companySize?: string; message?: string }, 
    set: { status: number },
    request: Request 
  }) => {
    try {
      const { name, email, phone, company, companySize, message } = body;
      
      // Validate required fields
      if (!name || !email || !phone || !company) {
        set.status = 400;
        return { success: false, error: 'Missing required fields' };
      }
      
      // Try to get user/organization info from session if available
      let orgInfo = "";
      try {
        const user = await getUserFromSession(request);
        if (user) {
          orgInfo = `
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <p><strong>User is logged in with the following details:</strong></p>
            <p>Organization: ${user.organization_name} (ID: ${user.organization_id})</p>
            <p>User: ${user.first_name} ${user.last_name} (${user.email})</p>
          </div>`;
        }
      } catch (sessionError) {
        // Just log the error but continue - the session info is optional
        logger.warn(`Unable to get session info: ${sessionError}`);
      }
      
      // Format the email content
      const emailContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">New Enterprise Plan Inquiry</h2>
          
          <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
            <p><strong>Name:</strong> ${name}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Phone:</strong> ${phone}</p>
            <p><strong>Company:</strong> ${company}</p>
            <p><strong>Company Size:</strong> ${companySize || 'Not specified'}</p>
            <p><strong>Message:</strong></p>
            <p style="white-space: pre-line;">${message || 'No message provided'}</p>
          </div>
          ${orgInfo}
          <p style="color: #666; font-size: 14px;">
            This inquiry was submitted through the Enterprise Contact form on the MedicareMax portal.
          </p>
        </div>
      `;
      
      // Configure email
      const msg = {
        to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: `Enterprise Plan Inquiry from ${name} at ${company}`,
        text: `New Enterprise Plan Inquiry:\n\nName: ${name}\nEmail: ${email}\nPhone: ${phone}\nCompany: ${company}\nCompany Size: ${companySize || 'Not specified'}\n\nMessage: ${message || 'No message provided'}\n\n${orgInfo ? `User is logged in from organization: ${orgInfo}` : ''}\n\nThis inquiry was submitted through the Enterprise Contact form on the MedicareMax portal.`,
        html: emailContent
      };
      
      // Send the email
      await sgMail.send(msg);
      
      // Log successful submission
      logger.info(`Enterprise plan inquiry submitted by ${name} from ${company}`);
      
      // Return success response
      return { success: true };
    } catch (error) {
      logger.error(`Error processing enterprise contact submission: ${error}`);
      set.status = 500;
      return { 
        success: false, 
        error: 'Failed to process your request. Please try again later.' 
      };
    }
  })
  // Add endpoint for enterprise inquiry during onboarding
  .post('/enterprise-inquiry', async ({ body, set, request }: { 
    body: { companyName: string; contactName: string; email: string; phone: string; message?: string }, 
    set: { status: number },
    request: Request 
  }) => {
    try {
      const { companyName, contactName, email, phone, message } = body;
      
      // Validate required fields
      if (!companyName || !contactName || !email || !phone) {
        set.status = 400;
        return { success: false, error: 'Missing required fields' };
      }
      
      // Try to get user/organization info from session if available
      let orgInfo = "";
      try {
        const user = await getUserFromSession(request);
        if (user) {
          orgInfo = `
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
            <p><strong>User is logged in with the following details:</strong></p>
            <p>Organization: ${user.organization_name} (ID: ${user.organization_id})</p>
            <p>User: ${user.first_name} ${user.last_name} (${user.email})</p>
          </div>`;
        }
      } catch (sessionError) {
        // Just log the error but continue - the session info is optional
        logger.warn(`Unable to get session info: ${sessionError}`);
      }
      
      // Format the email content
      const emailContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">New Enterprise Plan Inquiry (Onboarding)</h2>
          
          <div style="margin: 20px 0; background-color: #f7f7f7; padding: 20px; border-radius: 5px;">
            <p><strong>Company:</strong> ${companyName}</p>
            <p><strong>Contact Name:</strong> ${contactName}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Phone:</strong> ${phone}</p>
            <p><strong>Message:</strong></p>
            <p style="white-space: pre-line;">${message || 'No message provided'}</p>
          </div>
          ${orgInfo}
          <p style="color: #666; font-size: 14px;">
            This inquiry was submitted through the Enterprise Form during the onboarding process on MedicareMax.
          </p>
        </div>
      `;
      
      // Configure email
      const msg = {
        to: ['information@medicaremax.ai', 'reuben.brooks@medicaremax.ai'],
        from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
        subject: `Enterprise Plan Inquiry from ${contactName} at ${companyName} (Onboarding)`,
        text: `New Enterprise Plan Inquiry (Onboarding):\n\nCompany: ${companyName}\nContact Name: ${contactName}\nEmail: ${email}\nPhone: ${phone}\n\nMessage: ${message || 'No message provided'}\n\n${orgInfo ? `User is logged in from organization: ${orgInfo}` : ''}\n\nThis inquiry was submitted through the Enterprise Form during onboarding on MedicareMax.`,
        html: emailContent
      };
      
      // Send the email
      await sgMail.send(msg);
      
      // Log successful submission
      logger.info(`Enterprise plan inquiry (onboarding) submitted by ${contactName} from ${companyName}`);
      
      // Return success response
      return { success: true };
    } catch (error) {
      logger.error(`Error processing enterprise inquiry submission: ${error}`);
      set.status = 500;
      return { success: false, error: 'Failed to process inquiry' };
    }
  })
  .post('/api/agents', async ({ body, request, set }) => {
    try {
      // Get current user from session to determine their org
      const currentUser = await getUserFromSession(request)
      if (!currentUser) {
        set.status = 401
        return {
          success: false,
          error: 'You must be logged in to perform this action'
        }
      }

      // Check if user is an admin
      if (!currentUser.is_admin) {
        set.status = 403
        return {
          success: false,
          error: 'Only administrators can create new agents'
        }
      }

      const newAgent = body as NewAgentRequest
      
      // Decode the email to ensure it's stored properly
      newAgent.email = ensureEmailDecoded(newAgent.email);
      
      logger.info(`Creating new agent: ${newAgent.email} (org: ${currentUser.organization_id})`)

      // Ensure that the new user has at least one role
      if (!newAgent.is_admin && !newAgent.is_agent) {
        logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
        newAgent.is_agent = true
      }

      // ... rest of the function ...
    } catch (error) {
      logger.error(`Error creating new agent: ${error}`);
      set.status = 500;
      return {
        success: false,
        error: 'Failed to create new agent'
      };
    }
  })
  .post('/organizations/exit-demo-mode', async ({ request, set }) => {
    const db = new Database();
    
    try {
      // Get current user from session
      const currentUser = await getUserFromSession(request);
      
      if (!currentUser) {
        set.status = 401;
        return { success: false, message: 'Unauthorized' };
      }

      // Only allow admins to exit demo mode
      if (!currentUser.is_admin) {
        set.status = 403;
        return { success: false, message: 'Only administrators can exit demo mode' };
      }

      // Update the organization's demo_mode to false
      const result = await db.execute(
        `UPDATE organizations 
         SET demo_mode = 0
         WHERE id = ?`,
        [currentUser.organization_id]
      );

      /* TODO: Uncomment this when we have a way to enable regular and followup scheduling
      const result = await db.execute(
        `UPDATE organizations 
         SET demo_mode = 0, regular_scheduling_active = 1, followup_scheduling_active = 1
         WHERE id = ?`,
        [currentUser.organization_id]
      );
      */

      const rowsAffected = result.rowsAffected || 0;
      
      if (rowsAffected === 0) {
        logger.info(`No changes made when exiting demo mode for org ${currentUser.organization_id}`);
      } else {
        logger.info(`Successfully exited demo mode for organization ${currentUser.organization_id}`);
      }
      set.status = 200;
      return { success: true };
    } catch (error) {
      logger.error(`Error exiting demo mode: ${error}`);
      set.status = 500;
      return { success: false, message: 'Internal server error' };
    }
  });

export function createOrganizationRoutes() {
  const dbInstance = new Database();
  const authService = new AuthService();

  return new Elysia()
    .use(cookie())
    // Add a new endpoint for direct signup from UserDetails page
    .post('/api/organizations/signup', async ({ body, set, setCookie }) => {
      try {
        const { adminFirstName, adminLastName, adminEmail, phone, organizationName, planType } = body as {
          adminFirstName: string;
          adminLastName: string;
          adminEmail: string;
          phone?: string;
          organizationName: string;
          planType?: string;
        };

        // Decode email to ensure it's stored properly
        const decodedEmail = ensureEmailDecoded(adminEmail);

        // Validate input
        const validation = signupSchema.safeParse({
          ...body,
          adminEmail: decodedEmail // Use decoded email for validation
        });
        if (!validation.success) {
          set.status = 400;
          return {
            success: false,
            message: validation.error.errors[0].message
          };
        }

        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [decodedEmail]
        );

        if (existingUser[0]?.count > 0) {
          set.status = 400;
          return {
            success: false,
            message: 'This email address is already registered'
          };
        }

        // Generate a unique slug from the organization name
        const slug = await generateUniqueSlug(dbInstance, organizationName);

        // Create temporary session token
        const tempSessionId = generateToken();

        // Set session cookie for 24 hours
        setCookie('onboardingSession', tempSessionId, {
          httpOnly: true,
          maxAge: 60 * 60 * 24, // 24 hours
          path: '/'
        });

        // Set org slug cookie (not HTTP only so frontend can access it)
        setCookie('orgSlug', slug, {
          httpOnly: false,
          maxAge: 60 * 60 * 24 * 30, // 30 days
          path: '/'
        });

        // Create organization
        const orgResult = await dbInstance.execute(`
          INSERT INTO organizations (
            name, 
            subscription_tier, 
            created_at, 
            onboarding_completed, 
            slug, 
            onboarding_step,
            temp_session_id
          ) VALUES (?, ?, datetime('now'), FALSE, ?, ?, ?)`,
          [organizationName, planType || 'basic', slug, 2, tempSessionId]
        );

        const orgId = Number(orgResult.lastInsertRowid);
        logger.info(`Created organization: ${orgId} with slug: ${slug}`);

        // Create admin user with decoded email
        await dbInstance.execute(
          `INSERT INTO users (
            email, 
            first_name, 
            last_name, 
            phone, 
            is_admin, 
            is_agent, 
            organization_id, 
            created_at,
            is_active
          ) VALUES (?, ?, ?, ?, 1, 1, ?, datetime('now'), 0)`,
          [decodedEmail, adminFirstName, adminLastName, phone || '', orgId]
        );

        logger.info(`Created admin user for org ${slug} - Name: ${adminFirstName} ${adminLastName}, Email: ${decodedEmail}`);

        // Generate a magic link for verification
        const magicLink = `${config.clientUrl}/auth/verify/${slug}/${tempSessionId}`;

        // Send welcome email
        try {
          await sendMagicLink({
            email: decodedEmail,
            magicLink: magicLink,
            name: adminFirstName
          });
          logger.info(`Sent welcome email to ${decodedEmail}`);
        } catch (emailError) {
          logger.error(`Failed to send welcome email: ${emailError}`);
          // Continue even if email fails
        }

        return {
          success: true,
          message: 'Organization and admin user created successfully',
          slug: slug
        };

      } catch (error) {
        logger.error(`Error creating organization: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to create organization'
        };
      }
    })
    
    // Add a new endpoint to check email availability
    .get('/api/organizations/check-email/:email', async ({ params, set }) => {
      try {
        const { email } = params;
        
        if (!email || !email.trim()) {
          set.status = 400;
          return {
            available: false,
            message: 'Email is required'
          };
        }
        
        // Ensure email is fully decoded
        const decodedEmail = ensureEmailDecoded(email);
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(decodedEmail)) {
          return {
            available: false,
            message: 'Invalid email format'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [decodedEmail]
        );
        
        const count = existingUser[0]?.count || 0;
        
        if (count > 0) {
          return {
            available: false,
            message: 'This email address is already registered'
          };
        }
        
        // If we get here, the email is available
        return {
          available: true,
          message: 'Email is available'
        };
        
      } catch (error) {
        logger.error(`Error checking email availability: ${error}`);
        set.status = 500;
        return {
          available: false,
          message: 'Error checking email availability'
        };
      }
    });
}

================
File: backend/src/routes/quotes.ts
================
import { Elysia } from 'elysia';
import axios from 'axios';
import { config } from '../config';
import { logger } from '../logger';
import { Database } from '../database';
import { generateQuoteId, decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';
import { readFile } from 'fs/promises';
import { join } from 'path';
import { readFileSync } from 'fs';


interface ZipInfo {
  state: string;
  counties: string[];
  // Add other ZIP info properties as needed
}


// Update ZIP_DATA declaration
let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'))
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}


interface Quote {
    age: number;
    gender: string;
    plan: string;
    tobacco: number;
    rate: number;
    discount_rate: number;
    discount_category: string;
    original_plan_name?: string;
}

interface QuoteResponse {
    naic: string;
    group: number;
    company_name: string;
    quotes: Quote[];
}

interface QuoteRequestBody {
    zip_code: string;
    state: string;
    age: string | number;
    tobacco: string | boolean;
    gender: string;
    county?: string;
    effective_date?: string;
}

interface QuoteRequest {
    zip_code: string;
    state: string;
    age: number;
    tobacco: boolean;
    gender: string;
    plans: string[];
    carriers: string;
    county?: string;
    effective_date?: string;
}

interface ContactQuoteInfo {
    zip_code: string;
    birth_date: string;
    age: number;
    tobacco_user: number;
    gender: string;
    email: string;
    first_name: string;
    last_name: string;
    current_carrier: string;
    phone_number: string;
    plan_type: string;
}

// Add new interface for org info response
interface OrgRedirectInfo {
    redirect_url: string | null;
    agent_name: string;
}

function calculateAgeOnFirstOfNextMonth(birthDate: string, currentDate: string): number {
    const birth = new Date(birthDate);
    const current = new Date(currentDate);
    
    // Get first day of next month
    const nextMonth = new Date(current.getFullYear(), current.getMonth() + 1, 1);
    
    // Calculate age based on year difference
    let age = nextMonth.getFullYear() - birth.getFullYear();
    
    // Adjust age if birthday hasn't occurred yet in the target month
    if (
        nextMonth.getMonth() < birth.getMonth() || 
        (nextMonth.getMonth() === birth.getMonth() && 1 < birth.getDate())
    ) {
        age--;
    }
    
    return age;
}


export const quotesRoutes = (app: Elysia) => {
    app
    .get('/api/quotes/generate/:contactId', async ({ params, request }) => {
        try {
            const user = await getUserFromSession(request);
            if (!user?.organization_id) {
                throw new Error('No organization ID found in session');
            }

            const contactId = parseInt(params.contactId);
            if (isNaN(contactId)) {
                throw new Error('Invalid contact ID');
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString());
            
            // Verify contact exists and belongs to this org
            const contact = await orgDb.fetchOne(
                'SELECT id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                throw new Error('Contact not found');
            }

            // Generate quote ID
            const quoteId = generateQuoteId(user.organization_id, contactId);

            return {
                success: true,
                quoteId,
                redirectUrl: `${process.env.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`
            };
        } catch (e) {
            logger.error(`Error generating quote ID: ${e}`);
            throw new Error(String(e));
        }
    })
    .get('/api/quotes/decode/:quoteId', async ({ params, set }) => {
        try {
            logger.info(`Decoding quote ID: ${params.quoteId}`);
            
            const decoded = decodeQuoteId(params.quoteId);
            if (!decoded) {
                logger.error(`Invalid quote ID format: ${params.quoteId}`);
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID format'
                };
            }
            
            logger.info(`Decoded quote ID: orgId=${decoded.orgId}, contactId=${decoded.contactId}`);

            // Get org-specific database
            logger.info(`Getting database for org: ${decoded.orgId}`);
            const orgDb = await Database.getOrInitOrgDb(decoded.orgId.toString());
            
            const mainDb = new Database();
            logger.info(`Fetching organization details for orgId: ${decoded.orgId}`);
            const result = await mainDb.fetchOne<{ slug: string, org_settings: string, name: string, logo_data: string, phone: string, redirect_url: string, org_signature: boolean, signature: string | null }>(
                'SELECT slug, org_settings, name, logo_data, phone, redirect_url, org_signature, signature FROM organizations WHERE id = ?',
                [decoded.orgId]
            );

            if (!result) {
                logger.error(`Organization not found: ${decoded.orgId}`);
                set.status = 404;
                return {
                    success: false,
                    error: 'Organization not found'
                };
            }

            const orgSlug = result.slug;
            logger.info(`Found organization: ${orgSlug} (ID: ${decoded.orgId})`);
            
            let orgSettings;
            try {
                orgSettings = JSON.parse(result.org_settings || '{}');
            } catch (e) {
                logger.warn(`Error parsing org settings for ${decoded.orgId}: ${e}`);
                orgSettings = {};
            }
            
            const carrierContracts = orgSettings?.carrierContracts || [];

            // Get forceOrgSenderDetails from org settings with backwards compatibility
            const forceOrgSenderDetails = orgSettings?.forceOrgSenderDetails !== undefined 
                ? orgSettings.forceOrgSenderDetails 
                : Boolean(result.org_signature);

            // Get signature from either orgSettings, database column, or fall back to org name
            let signature = orgSettings?.signature || result.signature || result.name;

            // First try to get the assigned agent from the contact
            const contactQuery = 'SELECT zip_code, birth_date, tobacco_user, gender, email, first_name, last_name, current_carrier, phone_number, plan_type, agent_id FROM contacts WHERE id = ?';
            const contactParams = [decoded.contactId];
            
            logger.info(`Executing contact query: ${contactQuery} with params: [${contactParams}]`);
            
            const contact = await orgDb.fetchOne<ContactQuoteInfo & { agent_id: number | null }>(contactQuery, contactParams);

            if (!contact) {
                logger.error(`Contact not found: contactId=${decoded.contactId} in orgId=${decoded.orgId}`);
                
                // Additional debugging: List all contacts in this org
                try {
                    const allContacts = await orgDb.query('SELECT id, email, first_name, last_name FROM contacts LIMIT 5');
                    logger.info(`First 5 contacts in org ${decoded.orgId}: ${JSON.stringify(allContacts)}`);
                } catch (e) {
                    logger.error(`Error listing contacts: ${e}`);
                }
                
                set.status = 404;
                return {
                    success: false,
                    error: `Contact not found: ID=${decoded.contactId}`
                };
            }

            // Get agent info - first try assigned agent, then default agent, then fall back to first user
            let agent = null;
            
            // Try assigned agent first
            if (contact.agent_id) {
                agent = await mainDb.fetchOne<{ first_name: string, last_name: string, email: string, phone: string, booking_link: string, use_org_sender_details: number, signature: string }>(
                    'SELECT first_name, last_name, email, phone, booking_link, use_org_sender_details, signature FROM users WHERE id = ?',
                    [contact.agent_id]
                );
            }
            
            // If no assigned agent, try default agent from org settings
            if (!agent) {
                const defaultAgentResult = await mainDb.fetchOne<{ default_agent_id: number }>(
                    'SELECT default_agent_id FROM organizations WHERE id = ?',
                    [decoded.orgId]
                );
                
                if (defaultAgentResult?.default_agent_id) {
                    agent = await mainDb.fetchOne<{ first_name: string, last_name: string, email: string, phone: string, booking_link: string, use_org_sender_details: number, signature: string }>(
                        'SELECT first_name, last_name, email, phone, booking_link, use_org_sender_details, signature FROM users WHERE id = ?',
                        [defaultAgentResult.default_agent_id]
                    );
                    
                    // If we found the default agent, update the contact's agent_id
                    if (agent) {
                        try {
                            await orgDb.execute(
                                'UPDATE contacts SET agent_id = ? WHERE id = ?',
                                [defaultAgentResult.default_agent_id, decoded.contactId]
                            );
                            logger.info(`Updated contact ${decoded.contactId} with default agent ${defaultAgentResult.default_agent_id}`);
                        } catch (e) {
                            logger.error(`Error updating contact's agent_id: ${e}`);
                        }
                    }
                }
            }
            
            // If still no agent, fall back to first active user
            if (!agent) {
                agent = await mainDb.fetchOne<{ first_name: string, last_name: string, email: string, phone: string, booking_link: string, use_org_sender_details: number, signature: string }>(
                    'SELECT first_name, last_name, email, phone, booking_link, use_org_sender_details, signature FROM users WHERE organization_id = ? AND is_active = 1 ORDER BY id ASC LIMIT 1',
                    [decoded.orgId]
                );
            }

            if (!agent) {
                logger.error(`No users found for organization: ${decoded.orgId}`);
                set.status = 404;
                return {
                    success: false,
                    error: 'No users found for organization'
                };
            }

            logger.info(`Found contact: ${contact.first_name} ${contact.last_name} (ID: ${decoded.contactId})`);
            
            const zipInfo = ZIP_DATA[contact.zip_code];
            const contactState = zipInfo?.state;
            
            if (!contactState) {
                logger.warn(`No state found for zip code: ${contact.zip_code}`);
            }

            const output = {
                success: true,
                orgId: decoded.orgId.toString(),
                orgSlug: orgSlug || null,
                orgName: result.name,
                orgLogo: result.logo_data || null,
                orgPhone: orgSettings?.phone || result.phone || null,
                orgRedirectUrl: orgSettings?.redirectUrl || result.redirect_url || null,
                orgSignature: Boolean(result.org_signature) || false,
                orgSignatureText: signature,
                carrierContracts: carrierContracts || null,
                forceOrgSenderDetails: forceOrgSenderDetails,
                agent: {
                    firstName: agent.first_name,
                    lastName: agent.last_name,
                    email: agent.email,
                    phone: agent.phone,
                    bookingLink: agent.booking_link || '',
                    useOrgSenderDetails: Boolean(agent.use_org_sender_details),
                    signature: agent.signature || ''
                },
                contact: {
                    id: decoded.contactId,
                    zipCode: contact.zip_code,
                    state: contactState,
                    dateOfBirth: contact.birth_date,
                    age: calculateAgeOnFirstOfNextMonth(contact.birth_date, new Date().toISOString()),
                    tobacco: Boolean(contact.tobacco_user),
                    gender: contact.gender,
                    email: contact.email,
                    firstName: contact.first_name,
                    lastName: contact.last_name,
                    currentCarrier: contact.current_carrier,
                    planType: contact.plan_type,
                    phoneNumber: contact.phone_number
                }
            };

            logger.info(`Returning success response for quote ID: ${params.quoteId}`);
            logger.info(`Output: ${JSON.stringify(output, null, 2)}`);
            return output;
        } catch (e) {
            logger.error(`Error decoding quote ID: ${e}`);
            set.status = 500;
            return {
                success: false,
                error: String(e)
            };
        }
    })
    .post('/api/quotes', async ({ body, set }: { body: QuoteRequestBody, set: any }) => {
        try {
            // Check if state uses special plans
            const stateSpecificPlans: Record<string, string[]> = {
                'MN': ['MN_BASIC', 'MN_EXTB'],
                'WI': ['WI_BASE', 'WI_HDED'],
                'MA': ['MA_CORE', 'MA_SUPP1']
            };

            // Determine which plans to request based on state
            const plansToRequest = stateSpecificPlans[body.state] || ['G', 'N'];

            // Format request body
            const requestBody: QuoteRequest = {
                zip_code: body.zip_code,
                state: body.state,
                age: Math.max(65, Math.min(110, Number(body.age))),
                tobacco: body.tobacco === 'true' || body.tobacco === true,
                gender: body.gender,
                plans: plansToRequest,
                carriers: 'supported',
                county: body.county
            };

            if (body.effective_date) {
                requestBody.effective_date = body.effective_date;
            }

            // Log incoming request details
            logger.info(`Incoming quote request body: ${JSON.stringify(requestBody, null, 2)}`);
            
            // Construct request config
            const quoteEngineUrl = 'https://quote-engine.replit.app/quotes/';
            const requestConfig = {
                url: quoteEngineUrl,
                method: 'POST' as const,
                headers: {
                    'X-API-Key': config.quoteApiKey,
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                data: requestBody
            };

            logger.info(`Making request to quote engine with config: ${JSON.stringify({
                url: requestConfig.url,
                method: requestConfig.method,
                headers: {
                    ...requestConfig.headers,
                    'X-API-Key': '[REDACTED]'
                }
            }, null, 2)}`);

            // Make request to quote engine API
            const response = await axios(requestConfig);
            
            logger.info(`Quote engine response status: ${response.status}`);
            logger.info(`Quote engine response headers: ${JSON.stringify(response.headers, null, 2)}`);
            logger.info(`Quote engine response data length: ${JSON.stringify(response.data).length} characters`);
            // logger.info(`Quote engine response data preview: ${JSON.stringify(response.data).substring(0, 500)}...`); // Log more for debugging complex structures
            
            if (!response.data || !Array.isArray(response.data)) {
                logger.error('Quote engine returned empty or invalid response data');
                set.status = 500;
                return { error: 'No quote data received from engine or data is not an array' };
            }

            // Define state-specific plan mappings to their standard equivalents
            const planAliasMapping: Record<string, { standard: string, original: string }> = {
                'MN_BASIC': { standard: 'N', original: 'MN_BASIC' },
                'MN_EXTB': { standard: 'G', original: 'MN_EXTB' },
                'WI_BASE': { standard: 'N', original: 'WI_BASE' },
                'WI_HDED': { standard: 'N', original: 'WI_HDED' }, // Assuming WI_HDED maps to N, adjust if needed
                'MA_CORE': { standard: 'N', original: 'MA_CORE' },
                'MA_SUPP1': { standard: 'G', original: 'MA_SUPP1' }
            };

            const processedData = response.data.map((companyQuote: QuoteResponse) => {
                if (companyQuote.quotes && Array.isArray(companyQuote.quotes)) {
                    companyQuote.quotes = companyQuote.quotes.map((quote: Quote) => {
                        const mapping = planAliasMapping[quote.plan.toUpperCase()];
                        if (mapping) {
                            return {
                                ...quote,
                                original_plan_name: mapping.original,
                                plan: mapping.standard
                            };
                        }
                        // If not a state-specific plan that needs aliasing, ensure original_plan_name is null or undefined
                        // if the quote engine might send it for G/N plans directly.
                        // For now, assume if it's not in mapping, it doesn't get an original_plan_name unless already present.
                        return {
                            ...quote,
                            original_plan_name: quote.original_plan_name || undefined // or null if preferred by Elm decoder
                        };
                    });
                }
                return companyQuote;
            });

            logger.info(`Processed quote data preview: ${JSON.stringify(processedData).substring(0, 500)}...`);

            // Return quotes from response data
            set.status = 200; // Explicitly set 200 status
            return processedData;
        } catch (error: any) {
            logger.error(`Error fetching quotes: ${error}`);
            if (axios.isAxiosError(error)) {
                logger.error(`Axios error details: ${JSON.stringify({
                    status: error.response?.status,
                    statusText: error.response?.statusText,
                    headers: error.response?.headers,
                    data: error.response?.data
                }, null, 2)}`);
            }
            set.status = error.response?.status || 500;
            throw new Error(String(error));
        }
    })
    .get('/api/contact-request/org-info/:orgId', async ({ params }) => {
        try {
            const db = new Database();
            
            // Get organization info including redirect URL and signature
            const orgResult = await db.fetchOne<{ redirect_url: string | null, name: string, signature: string | null, org_settings: string | null }>(
                'SELECT redirect_url, name, signature, org_settings FROM organizations WHERE id = ?',
                [params.orgId]
            );

            if (!orgResult) {
                throw new Error('Organization not found');
            }

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(params.orgId);

            // Try to get default agent (first admin or agent)
            const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                `SELECT first_name, last_name 
                FROM users 
                WHERE (is_admin = 1 OR is_agent = 1) 
                AND is_active = 1 
                ORDER BY is_admin DESC, id ASC 
                LIMIT 1`
            );

            if (!defaultAgent) {
                throw new Error('No active agents or admins found');
            }

            // Parse org settings to try to get signature from there first
            let orgSettings = {};
            try {
                if (orgResult.org_settings) {
                    orgSettings = JSON.parse(orgResult.org_settings);
                }
            } catch (e) {
                logger.warn(`Error parsing org settings: ${e}`);
            }

            // Prioritize signature in this order: orgSettings, signature column, org name
            const signature = (orgSettings as any)?.signature || orgResult.signature || orgResult.name;

            return {
                success: true,
                redirect_url: orgResult.redirect_url,
                agent_name: `${defaultAgent.first_name} ${defaultAgent.last_name}`,
                org_name: orgResult.name,
                signature: signature
            };
        } catch (e) {
            logger.error(`Error getting org redirect info: ${e}`);
            throw new Error(String(e));
        }
    })
    .post('/api/contact-request', async ({ body }) => {
        try {
            const { name, email, type, quoteId } = body as { 
                name: string;
                email: string;
                type: 'accept' | 'decline' | 'generic';
                quoteId?: string;
            };

            // Get contact info from quoteId if available
            let orgId: number | undefined;
            let contactId: number | undefined;
            let agentName: string | undefined;

            if (!quoteId) {
                throw new Error('Quote ID is required');
            }

            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                throw new Error('Invalid quote ID');
            }

            orgId = decoded.orgId;
            contactId = decoded.contactId;

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // If we have a contact ID, try to get the assigned agent's name
            if (contactId) {
                const contact = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT u.first_name, u.last_name 
                    FROM contacts c
                    JOIN users u ON c.agent_id = u.id
                    WHERE c.id = ? AND u.is_active = 1`,
                    [contactId]
                );
                if (contact) {
                    agentName = `${contact.first_name} ${contact.last_name}`;
                }
            }

            // If no agent assigned to contact, get default agent
            if (!agentName) {
                const defaultAgent = await orgDb.fetchOne<{ first_name: string, last_name: string }>(
                    `SELECT first_name, last_name 
                    FROM users 
                    WHERE (is_admin = 1 OR is_agent = 1) 
                    AND is_active = 1 
                    ORDER BY is_admin DESC, id ASC 
                    LIMIT 1`
                );
                if (defaultAgent) {
                    agentName = `${defaultAgent.first_name} ${defaultAgent.last_name}`;
                }
            }

            // Store request in org-specific database
            await orgDb.execute(
                `INSERT INTO contact_requests (
                    name, email, request_type, contact_id, status, agent_name, created_at
                ) VALUES (?, ?, ?, ?, 'new', ?, CURRENT_TIMESTAMP)`,
                [name, email, type, contactId || null, agentName || null]
            );

            // Get org redirect URL from central database
            const db = new Database();
            const orgResult = await db.fetchOne<{ redirect_url: string | null }>(
                'SELECT redirect_url FROM organizations WHERE id = ?',
                [orgId]
            );

            return { 
                success: true,
                redirect: orgResult?.redirect_url ? { redirect_url: orgResult.redirect_url } : null
            };
        } catch (e) {
            logger.error(`Error saving contact request: ${e}`);
            throw new Error(String(e));
        }
    })
    // Add new endpoint for zip code information
    .get('/api/zipinfo/:zipCode', async ({ params }) => {
        try {
            const { zipCode } = params;
            
            // Read the zip data file from the ROOT directory, not the backend directory
            const zipDataPath = join(process.cwd(), '..', 'zipData.json');
            logger.info(`Looking for zip data at: ${zipDataPath}`);
            const zipDataContent = await readFile(zipDataPath, 'utf-8');
            const zipData = JSON.parse(zipDataContent);
            
            // Look up the zip code
            if (zipData[zipCode]) {
                return {
                    success: true,
                    data: zipData[zipCode]
                };
            } else {
                return {
                    success: false,
                    error: 'Zip code not found'
                };
            }
        } catch (error) {
            logger.error(`Error fetching zip code info: ${error}`);
            return {
                success: false,
                error: 'Failed to fetch zip code information'
            };
        }
    })
    .get('/api/quotes/debug-generate/:orgId/:contactId', async ({ params }) => {
        try {
            logger.info(`Debug endpoint - generating quote ID for org: ${params.orgId}, contact: ${params.contactId}`);
            
            const orgId = parseInt(params.orgId);
            const contactId = parseInt(params.contactId);
            
            if (isNaN(orgId) || isNaN(contactId)) {
                return {
                    success: false,
                    error: 'Invalid organization or contact ID'
                };
            }
            
            // Get org-specific database to verify the contact exists
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());
            
            // Verify contact exists
            const contact = await orgDb.fetchOne(
                'SELECT id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                // List first 5 contacts in this org for debugging
                const contacts = await orgDb.query('SELECT id FROM contacts LIMIT 5');
                logger.info(`Available contacts in org ${orgId}: ${JSON.stringify(contacts)}`);
                
                return {
                    success: false,
                    error: 'Contact not found',
                    availableContacts: contacts
                };
            }
            
            // Generate quote ID
            const quoteId = generateQuoteId(orgId, contactId);
            
            logger.info(`Generated debug quote ID: ${quoteId} for orgId: ${orgId}, contactId: ${contactId}`);

            return {
                success: true,
                quoteId,
                redirectUrl: `${process.env.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`
            };
        } catch (e) {
            logger.error(`Error in debug quote generation: ${e}`);
            return {
                success: false,
                error: String(e)
            };
        }
    });

    return app;
};

================
File: backend/src/routes/schedule.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { decodeQuoteId } from '../utils/quoteId';

export const scheduleRoutes = (app: Elysia) => {
    app.get('/api/schedule/info/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get main database instance
            const mainDb = new Database();
            
            // Get organization info including slug
            const orgResult = await mainDb.fetchOne<{ name: string, logo_data: string | null, slug: string, phone: string | null, redirect_url: string | null, org_signature: boolean, org_settings: string | null }>(
                'SELECT name, logo_data, slug, phone, redirect_url, org_signature, org_settings FROM organizations WHERE id = ?',
                [orgId]
            );

            if (!orgResult) {
                set.status = 404;
                return {
                    success: false,
                    error: 'Organization not found'
                };
            }

            // Parse org settings to get forceOrgSenderDetails
            let orgSettings;
            try {
                orgSettings = JSON.parse(orgResult.org_settings || '{}');
            } catch (e) {
                logger.warn(`Error parsing org settings for ${orgId}: ${e}`);
                orgSettings = {};
            }
            
            const forceOrgSenderDetails = orgSettings?.forceOrgSenderDetails !== undefined 
                ? orgSettings.forceOrgSenderDetails 
                : Boolean(orgResult.org_signature);

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Get contact information and agent_id in a single query
            const contact = await orgDb.fetchOne<{ 
                first_name: string, 
                last_name: string, 
                email: string, 
                phone_number: string, 
                agent_id: number | null 
            }>(
                'SELECT first_name, last_name, email, phone_number, agent_id FROM contacts WHERE id = ?',
                [contactId]
            );

            if (!contact) {
                set.status = 404;
                return {
                    success: false,
                    error: 'Contact not found'
                };
            }

            // Get agent info - first try assigned agent, then fall back to first user
            const agent = contact.agent_id 
                ? await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string, booking_link: string, use_org_sender_details: number, signature: string }>(
                    'SELECT first_name, last_name, phone, booking_link, use_org_sender_details, signature FROM users WHERE id = ? AND is_active = 1',
                    [contact.agent_id]
                  )
                : await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string, booking_link: string, use_org_sender_details: number, signature: string }>(
                    'SELECT first_name, last_name, phone, booking_link, use_org_sender_details, signature FROM users WHERE organization_id = ? AND is_active = 1 ORDER BY id ASC LIMIT 1',
                    [orgId]
                  );

            if (!agent) {
                set.status = 404;
                return {
                    success: false,
                    error: 'No active agents found for organization'
                };
            }

            // Return all information in a single response
            return {
                success: true,
                contact: {
                    firstName: contact.first_name,
                    lastName: contact.last_name,
                    email: contact.email,
                    phoneNumber: contact.phone_number
                },
                organization: {
                    name: orgResult.name,
                    logo: orgResult.logo_data,
                    slug: orgResult.slug,
                    phone: orgSettings?.phone || orgResult.phone || "",
                    redirectUrl: orgSettings?.redirectUrl || orgResult.redirect_url || null
                },
                agent: {
                    name: `${agent.first_name} ${agent.last_name}`,
                    firstName: agent.first_name,
                    phone: agent.phone || "",
                    booking_link: agent.booking_link || "",
                    use_org_sender_details: Boolean(agent.use_org_sender_details),
                    signature: agent.signature || ""
                },
                force_org_sender_details: forceOrgSenderDetails,
                useOrg: Boolean(orgResult.org_signature)
            };

        } catch (error) {
            logger.error(`Error getting schedule info: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    // Keep the original endpoint for backward compatibility
    app.get('/api/schedule/org-info/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get main database instance
            const mainDb = new Database();
            
            // Get organization info
            const orgResult = await mainDb.fetchOne<{ name: string, logo_data: string | null }>(
                'SELECT name, logo_data FROM organizations WHERE id = ?',
                [orgId]
            );

            if (!orgResult) {
                set.status = 404;
                return {
                    success: false,
                    error: 'Organization not found'
                };
            }

            logger.info(`logo data: ${orgResult.logo_data?.slice(0, 50)}`);

            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Try to get the assigned agent from the contact
            const contact = await orgDb.fetchOne<{ agent_id: number | null }>(
                'SELECT agent_id FROM contacts WHERE id = ?',
                [contactId]
            );

            // Get agent info - first try assigned agent, then fall back to first user
            const agent = contact?.agent_id 
                ? await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE id = ? AND is_active = 1',
                    [contact.agent_id]
                  )
                : await mainDb.fetchOne<{ first_name: string, last_name: string, phone: string }>(
                    'SELECT first_name, last_name, phone FROM users WHERE organization_id = ? AND is_active = 1 ORDER BY id ASC LIMIT 1',
                    [orgId]
                  );

            if (!agent) {
                set.status = 404;
                return {
                    success: false,
                    error: 'No active agents found for organization'
                };
            }

            return {
                success: true,
                orgName: orgResult.name,
                orgLogo: orgResult.logo_data,
                agentName: `${agent.first_name} ${agent.last_name}`,
                agentPhone: agent.phone || ""
            };

        } catch (error) {
            logger.error(`Error getting schedule org info: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    app.post('/api/schedule/aep-request/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Update the contact with AEP request
            await orgDb.execute(
                'UPDATE contacts SET aep_request = TRUE, aep_request_date = CURRENT_TIMESTAMP WHERE id = ?',
                [contactId]
            );

            return {
                success: true,
                message: 'AEP request recorded successfully'
            };

        } catch (error) {
            logger.error(`Error recording AEP request: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    app.post('/api/schedule/request-follow-up/:quoteId', async ({ params, set }) => {
        try {
            const { quoteId } = params;
            
            // Decode quote ID to get org ID and contact ID
            const decoded = decodeQuoteId(quoteId);
            if (!decoded) {
                set.status = 400;
                return {
                    success: false,
                    error: 'Invalid quote ID'
                };
            }

            const { orgId, contactId } = decoded;
            
            // Get org-specific database
            const orgDb = await Database.getOrInitOrgDb(orgId.toString());

            // Update the contact status to requested_follow_up
            await orgDb.execute(
                'UPDATE contacts SET status = ? WHERE id = ?',
                ['requested_follow_up', contactId]
            );

            return {
                success: true,
                message: 'Follow-up request recorded successfully'
            };

        } catch (error) {
            logger.error(`Error recording follow-up request: ${error}`);
            set.status = 500;
            return {
                success: false,
                error: 'Internal server error'
            };
        }
    });

    return app;
};

================
File: backend/src/routes/self-service.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import crypto from 'crypto';
import { config } from '../config';
import { generateQuoteId, decodeQuoteId } from '../utils/quoteId';
import { getUserFromSession } from '../services/auth';
import { readFileSync } from 'fs';
import { EmailService } from '../services/email';
import { get } from 'http';

// Import ZIP_DATA
interface ZipInfo {
  state: string;
  counties: string[];
}

// Import Contact type
type Contact = {
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  dateOfBirth: string;
  gender: string;
  tobacco: boolean;
  state: string;
  zipCode: string;
  currentCarrier: string | null;
  planType: string | null;
  optInQuarterlyUpdates: boolean;
};

// Load ZIP data
let ZIP_DATA: Record<string, ZipInfo> = {};
try {
  ZIP_DATA = JSON.parse(readFileSync('../zipData.json', 'utf-8'));
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`);
}

// Import generateHash function - reimplementing it since it's not exported from email.ts
function generateHash(orgId: string, email: string): string {
  const SECRET = process.env.HASH_SECRET || 'default-hash-secret';
  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
}

export function createSelfServiceRoutes() {
  return new Elysia()
    .get('/api/self-service/init', async ({ query, set }) => {
      // Extract query parameters
      const { orgId, email, hash } = query as { 
        orgId?: string; 
        email?: string; 
        hash?: string;
      };

      // Validate required parameters
      if (!orgId) {
        set.status = 400;
        return { error: 'orgId is required' };
      }

      // Validate hash if email is provided
      if (email && hash) {
        const expectedHash = generateHash(orgId, email);
        if (hash !== expectedHash) {
          logger.warn(`Invalid hash for email ${email} and orgId ${orgId}`);
          set.status = 403;
          return { error: 'Invalid email or hash' };
        }
      }

      try {
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        
        // If email is provided, check for existing contact
        if (email) {
          const client = orgDb.getClient();
          const result = await client.execute({
            sql: `SELECT 
                  email, 
                  first_name AS firstName, 
                  last_name AS lastName
                FROM contacts 
                WHERE email = ?`,
            args: [email]
          });

          // If contact exists, return contact details
          if (result.rows.length > 0) {
            const contact = result.rows[0];
            logger.info(`Contact found for email ${email} in organization ${orgId}`);
            return { 
              contact, 
              email, 
              emailReadOnly: true 
            };
          }

          // If no contact exists but email is provided
          logger.info(`No contact found for email ${email} in organization ${orgId}`);
          return { 
            email, 
            emailReadOnly: true 
          };
        }

        // If no email is provided
        return { emailReadOnly: false };

      } catch (error) {
        logger.error(`Error in self-service init endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    .post('/api/self-service/signup', async ({ body, set }) => {
      logger.info('Starting signup process with detailed logging...');
      logger.info(`Request body: ${JSON.stringify(body, null, 2)}`);
      
      const { orgId, email, firstName, lastName, optInQuarterlyUpdates, zipCode, dateOfBirth, gender, tobacco, phoneNumber, currentPremium, currentCarrier, planType, state, county, agentId } = body as {
        orgId: string;
        email: string;
        firstName: string;
        lastName: string;
        optInQuarterlyUpdates: boolean;
        zipCode: string;
        dateOfBirth: string;
        gender: string;
        tobacco: boolean;
        phoneNumber: string;
        currentPremium: string;
        currentCarrier: string;
        planType: string;
        state: string;
        county: string;
        agentId?: number;
      };

      logger.info(`[1/6] Validating input parameters...`);
      logger.info(`Input validation data:
        - orgId: ${orgId ? 'present' : 'missing'}
        - email: ${email ? 'present' : 'missing'}
        - firstName: ${firstName ? 'present' : 'missing'}
        - lastName: ${lastName ? 'present' : 'missing'}
        - zipCode: ${zipCode ? 'present' : 'missing'}
        - dateOfBirth: ${dateOfBirth ? 'present' : 'missing'}
        - gender: ${gender ? 'present' : 'missing'}
        - state: ${state ? 'present' : 'missing'}`
      );

      // Validate required parameters
      if (!orgId || !email || !firstName || !lastName || !zipCode || !dateOfBirth || !gender || !state) {
        const missingFields = [];
        if (!orgId) missingFields.push('orgId');
        if (!email) missingFields.push('email');
        if (!firstName) missingFields.push('firstName');
        if (!lastName) missingFields.push('lastName');
        if (!zipCode) missingFields.push('zipCode');
        if (!dateOfBirth) missingFields.push('dateOfBirth');
        if (!gender) missingFields.push('gender');
        if (!state) missingFields.push('state');
        
        logger.error(`[ERROR] Missing required fields: ${missingFields.join(', ')}`);
        set.status = 400;
        return { error: 'Missing required fields', missingFields };
      }
      
      logger.info('[2/6] All required fields present, proceeding with database connection...');

      try {
        logger.info(`[3/6] Attempting to get org database for orgId: ${orgId}`);
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        logger.info('[4/6] Successfully connected to org database');
        
        const client = orgDb.getClient();
        logger.info('[4.5/6] Successfully got database client');
        
        // Get default agent ID from organization if not provided
        const mainDb = new Database();
        const defaultAgentResult = await mainDb.fetchOne<{ default_agent_id: number }>(
          'SELECT default_agent_id FROM organizations WHERE id = ?',
          [parseInt(orgId)]
        );
        const finalAgentId = agentId || defaultAgentResult?.default_agent_id || null;
        logger.info(`Using agent ID: ${finalAgentId}`);
        
        // Check if contact already exists
        logger.info(`[5/6] Checking for existing contact with email: ${email}`);
        const existingContact = await client.execute({
          sql: 'SELECT id FROM contacts WHERE email = ?',
          args: [email]
        });
        logger.info(`[5.5/6] Existing contact check complete. Found: ${existingContact.rows.length > 0}`);

        let contactId: number;
        let isNewContact = false;

        if (existingContact.rows.length > 0) {
          // Update existing contact
          contactId = existingContact.rows[0].id;
          logger.info(`[6/6] Updating existing contact ${contactId}`);
          
          try {
            await client.execute({
              sql: `UPDATE contacts SET 
                    first_name = ?, 
                    last_name = ?,
                    phone_number = ?,
                    zip_code = ?,
                    state = ?,
                    gender = ?,
                    birth_date = ?,
                    tobacco_user = ?,
                    current_carrier = ?,
                    plan_type = ?,
                    agent_id = ?
                    WHERE id = ?`,
              args: [
                firstName, 
                lastName, 
                phoneNumber || '', 
                zipCode, 
                state,
                gender,
                dateOfBirth,
                tobacco ? 1 : 0,
                currentCarrier || '', 
                planType || null,
                finalAgentId,
                contactId
              ]
            });
            
            logger.info(`Successfully updated contact ${contactId}`);
            
          } catch (updateError) {
            logger.error(`Error updating existing contact: ${updateError}`);
            throw updateError;
          }
        } else {
          // Create new contact
          logger.info('[6/6] Creating new contact');
          isNewContact = true;
          try {
            const result = await client.execute({
              sql: `INSERT INTO contacts (
                    email, 
                    first_name, 
                    last_name,
                    phone_number,
                    zip_code,
                    state,
                    gender,
                    birth_date,
                    tobacco_user,
                    current_carrier,
                    plan_type,
                    effective_date,
                    agent_id
                  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
              args: [
                email, 
                firstName, 
                lastName, 
                phoneNumber || '', 
                zipCode, 
                state,
                gender,
                dateOfBirth,
                tobacco ? 1 : 0,
                currentCarrier || null,
                planType || null,
                new Date().toISOString().split('T')[0],
                finalAgentId
              ]
            });
            logger.info('Successfully inserted new contact');
            
            // Get the ID of the newly created contact
            logger.info('Getting ID of new contact');
            const newContactResult = await client.execute({
              sql: 'SELECT id FROM contacts WHERE email = ?',
              args: [email]
            });
            
            contactId = newContactResult.rows[0]?.id;
            logger.info(`Got new contact ID: ${contactId}`);
            
          } catch (insertError) {
            logger.error(`Error creating new contact: ${insertError}`);
            throw insertError;
          }
        }
        
        // Send email to the contact
        /*
        try {
          logger.info(`[7/6] Sending welcome email to contact ${contactId}`);

          const mainDb = new Database();  
          const mainClient = mainDb.getClient();
          
          // Get organization name
          const orgResult = await mainClient.execute({
            sql: 'SELECT name, logo_data, primary_color, phone, website FROM organizations WHERE id = ?',
            args: [orgId]
          });
          
          const orgInfo = orgResult.rows.length > 0 ? {
            name: orgResult.rows[0].name,
            logo_data: orgResult.rows[0].logo_data,
            primary_color: orgResult.rows[0].primary_color, 
            phone: orgResult.rows[0].phone,
            website: orgResult.rows[0].website
          } : undefined;
          
          // Initialize email service
          const emailService = new EmailService();

          // Generate quote ID
          const quoteId = generateQuoteId(parseInt(orgId), contactId);
          
          // Create welcome email with quote link
          const baseUrl = process.env.PUBLIC_URL || 'https://medicaremax.ai';
          const quoteUrl = `${baseUrl}/compare?id=${quoteId}`;
          await emailService.sendQuoteEmail({
            email,
            firstName,
            lastName,
            quoteUrl,
            planType: planType || 'G',
            organization: orgInfo,
            phone: phoneNumber
          });
          
          // Record the email in tracking table
          await emailService.recordEmailSend(orgDb, {
            orgId: parseInt(orgId),
            contactId,
            emailType: 'onboarding_welcome',
            sendStatus: 'sent',
            sendMode: 'production',
            batchId: crypto.randomUUID()
          });
          
          logger.info(`Welcome email sent successfully to ${email}`);
        } catch (emailError) {
          // Log but don't fail if email sending fails
          logger.error(`Error sending welcome email: ${emailError}`);
          // We still want to return success for the signup even if email fails
        }
        */
       
        // Return success response
        set.status = 200;
        return { 
          success: true,
          contactId,
          email
        };
      } catch (error) {
        logger.error(`[ERROR] Error in self-service signup endpoint: ${error}`);
        if (error instanceof Error) {
          logger.error(`Error stack trace: ${error.stack}`);
        }
        set.status = 500;
        return { error: 'Internal server error', details: error instanceof Error ? error.message : String(error) };
      }
    })
    .post('/api/self-service/update-location', async ({ body, set }) => {
      const { orgSlug, contactId, zipCode } = body as {
        orgSlug: string;
        contactId: string;
        zipCode: string;
      };

      // Validate required parameters
      if (!orgSlug || !contactId || !zipCode) {
        set.status = 400;
        return { error: 'Missing required fields' };
      }

      try {
        // Get state and county from ZIP_DATA
        const zipInfo = ZIP_DATA[zipCode];
        if (!zipInfo) {
          set.status = 400;
          return { error: 'Invalid zip code' };
        }
        logger.info(`Zip info: ${JSON.stringify(zipInfo)}`);

        // Get organization ID from slug
        const db = new Database();
        const orgResult = await db.fetchOne<{ id: number }>(
          'SELECT id FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!orgResult) {
          set.status = 404;
          return { error: 'Organization not found' };
        }

        // Get organization database
        const orgDb = await Database.getOrgDb(orgResult.id.toString());
        const client = orgDb.getClient();

  

        // Use provided county or first county if only one available

        // Update contact's zip code, state and county
        await client.execute({
          sql: `UPDATE contacts SET 
                zip_code = ?
                WHERE id = ?`,
          args: [
            zipCode,
            contactId
          ]
        });

        logger.info(`Updated location for contact ${contactId} in organization ${orgSlug} to ${zipCode}, ${zipInfo.state}`);

        let output = {
          success: true,
          zipCode,
          state: zipInfo.state,
          counties: zipInfo.counties
        };

        logger.info(`Output: ${JSON.stringify(output)}`);
        set.status = 200;
        return output;

      } catch (error) {
        logger.error(`Error updating location: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    // Add a new endpoint to generate a quote for a contact
    .post('/api/self-service/generate-quote', async ({ body, set }) => {
      const { orgId, contactEmail } = body as {
        orgId: string;
        contactEmail: string;
      };

      logger.info(`Generate quote request received: orgId=${orgId}, contactEmail=${contactEmail}`);

      // Validate required parameters
      if (!orgId || !contactEmail) {
        logger.error(`Missing required fields: orgId=${orgId}, contactEmail=${contactEmail}`);
        set.status = 400;
        return { error: 'Missing required fields (orgId and contactEmail)' };
      }

      try {
        // Get organization database
        const orgDb = await Database.getOrgDb(orgId);
        const client = orgDb.getClient();
        
        // Lookup contact by email
        const contactResult = await client.execute({
          sql: 'SELECT id FROM contacts WHERE email = ?',
          args: [contactEmail]
        });

        if (contactResult.rows.length === 0) {
          logger.error(`Contact not found for email ${contactEmail} in organization ${orgId}`);
          set.status = 404;
          return { error: 'Contact not found' };
        }

        const contactId = contactResult.rows[0].id;
        logger.info(`Found contact ID ${contactId} for email ${contactEmail} in organization ${orgId}`);
        
        // Generate quote ID using the proper utility function (with base36 encoding)
        const quoteId = generateQuoteId(parseInt(orgId), contactId);
        
        // Get plan type from contact
        let planType = 'MedSupp';
        try {
          const planTypeResult = await client.execute({
            sql: 'SELECT plan_type FROM contacts WHERE id = ?',
            args: [contactId]
          });
          
          if (planTypeResult.rows.length > 0 && planTypeResult.rows[0].plan_type) {
            planType = planTypeResult.rows[0].plan_type;
          } else {
            // Default to MedSupp if no plan type is set
            planType = 'MedSupp';
          }
          logger.info(`Found plan type ${planType} for contact ${contactId}`);
        } catch (error) {
          logger.warn(`Could not get plan type for contact ${contactId}: ${error}`);
          // Continue with default plan type
        }
        
        // Build redirect URL with just the quote ID
        const redirectUrl = `${config.PUBLIC_URL || 'http://localhost:5173'}/quote?id=${quoteId}`;
        
        // Log response details
        logger.info(`Generated quote ID: ${quoteId}`);
        logger.info(`Redirect URL: ${redirectUrl}`);

        // Return successful response with quote information
        set.status = 200;
        return {
          success: true,
          contactId,
          quoteId,
          redirectUrl
        };
      } catch (error) {
        logger.error(`Error generating quote ID: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    })
    .get('/api/self-service-info', async ({ params, set, request }) => {
      const userFromSession = await getUserFromSession(request);
    
      // Get organization from central database
      const db = new Database();
      const orgResult = await db.fetchOne<{ id: number, slug: string, logo_data: string | null }>(
        'SELECT id, slug, logo_data FROM organizations WHERE id = ?',
        [userFromSession?.organization_id]
      );

      // logger.info(`Org result: ${JSON.stringify(orgResult)}`);
      
      if (!orgResult) {
        set.status = 404;
        return { success: false, message: 'Organization not found' };
      }
      
      return {
        success: true,
        orgId: userFromSession?.organization_id.toString(),
        orgSlug: orgResult.slug,
        selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgResult.slug}`,
        logo: orgResult.logo_data
      };  
    })
    .get('/api/self-service/:orgSlug', async ({ params, query, set, request }) => {
      const { orgSlug } = params;
      const { email, id } = query as { email?: string; id?: string };
      
      
      logger.info(`Self-service request for orgSlug=${orgSlug}, email=${email || 'none'}, quoteId=${id || 'none'}`);
      
      try {
        // For the 'latest' slug, get the current user's organization
        if (orgSlug === 'latest') {
          const userFromSession = await getUserFromSession(request);
          logger.info(`User from session: ${JSON.stringify(userFromSession)}`);
          // Add type guard to check for organization_id
          if (!userFromSession || !('organization_id' in userFromSession) || !userFromSession.organization_id) {
            set.status = 401;
            return { success: false, error: 'Unauthorized' };
          }
          
          // Get organization from central database
          const db = new Database();
          const orgResult = await db.fetchOne<{ id: number, slug: string, logo_data: string | null }>(
            'SELECT id, slug, logo_data FROM organizations WHERE id = ?',
            [userFromSession.organization_id]
          );

          logger.info(`Org result: ${JSON.stringify(orgResult)}`);
          
          if (!orgResult) {
            set.status = 404;
            return { success: false, message: 'Organization not found' };
          }
          
          return {
            success: true,
            orgId: userFromSession.organization_id.toString(),
            orgSlug: orgResult.slug,
            selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgResult.slug}`,
            logo: orgResult.logo_data
          };
        }
        
        // Regular slug lookup
        const db = new Database();
        const result = await db.query(
          'SELECT id, name, logo_data FROM organizations WHERE slug = ?',
          [orgSlug]
        );

        if (!result || result.length === 0) {
          set.status = 404;
          return { success: false, message: 'Organization not found' };
        }

        const orgId = result[0].id;
        logger.info(`orgId: ${orgId}`);
        const orgIdStr = orgId.toString();
        const logo = result[0].logo_data;
        logger.info(`logo data: ${logo?.slice(0, 50)}`);
        const orgName = result[0].name;
        // Create response object with organization info
        const response = {
          success: true,
          orgId: orgIdStr,
          orgSlug,
          selfOnboardingUrl: `${config.PUBLIC_URL}/self-onboarding/${orgSlug}`,
          logo,
          orgName
        };
        
        // Try to find contact information if email or quoteId provided
        if (email || id) {
          try {
            const orgDb = await Database.getOrgDb(orgIdStr);
            const client = orgDb.getClient();
            let contactResult;
            
            // First try by email if provided
            if (email) {
              logger.info(`Looking up contact by email: ${email}`);
              contactResult = await client.execute({
                sql: `SELECT 
                  id,
                  email, 
                  first_name AS firstName, 
                  last_name AS lastName,
                  phone_number AS phone,
                  zip_code AS zipCode,
                  state,
                  gender,
                  birth_date AS dateOfBirth,
                  tobacco_user AS tobacco,
                  current_carrier AS currentCarrier,
                  plan_type AS planType
                FROM contacts 
                WHERE email = ?`,
                args: [email]
              });
            }
            
            // If no results and we have a quoteId, try that
            if ((!contactResult || contactResult.rows.length === 0) && id) {
              try {
                logger.info(`Looking up contact by quoteId: ${id}`);
                // Decode the quoteId using our utility function
                const decoded = decodeQuoteId(id);
                if (decoded) {
                  const contactId = decoded.contactId;
                  
                  contactResult = await client.execute({
                    sql: `SELECT 
                      id,
                      email, 
                      first_name AS firstName, 
                      last_name AS lastName,
                      phone_number AS phone,
                      zip_code AS zipCode,
                      state,
                      gender,
                      birth_date AS dateOfBirth,
                      tobacco_user AS tobacco,
                      current_carrier AS currentCarrier,
                      plan_type AS planType
                    FROM contacts 
                    WHERE id = ?`,
                    args: [contactId]
                  });
                }
              } catch (err) {
                logger.warn(`Error decoding quoteId ${id}: ${err}`);
              }
            }
            
            // If we found a contact, add it to the response
            if (contactResult && contactResult.rows.length > 0) {
              const contact = contactResult.rows[0];
              // Convert tobacco_user from number to boolean
              contact.tobacco = contact.tobacco === 1;
              
              logger.info(`Found contact for ${email || id}`);
              let output = {
                ...response,
                contact: {
                  ...contact,
                  id: contactResult.rows[0].id
                }
              };
              logger.info(`Output: ${JSON.stringify(output)}`);
              return output;
            }
          } catch (contactError) {
            logger.error(`Error looking up contact: ${contactError}`);
            // Continue without contact info
          }
        }
        
        // Return basic organization info for the frontend if no contact was found
        return response;
      } catch (error) {
        logger.error(`Error in self-service org slug endpoint: ${error}`);
        set.status = 500;
        return { error: 'Internal server error' };
      }
    });
}

================
File: backend/src/routes/settings.ts
================
import { Elysia } from 'elysia';
import { validateSession } from '../services/auth';
import { Database } from '../database';
import { type User, type BaseSettings } from '../types';
import { logger } from '../logger';
import { cookie } from '@elysiajs/cookie';

interface StateCarrierSetting {
  state: string;
  carrier: string;
  active: boolean;
  targetGI: boolean;
}

interface SettingsBody {
    settings?: BaseSettings;
    inheritOrgSettings?: boolean;
}

interface AgentSettingsResponse {
  orgSettings: BaseSettings;
  agentSettings: {
    inheritOrgSettings: boolean;
    settings: BaseSettings;
  } | null;
  canEditOrgSettings: boolean;
}

const defaultSettings: BaseSettings = {
    stateLicenses: [],
    carrierContracts: [],
    stateCarrierSettings: [],
    allowAgentSettings: false,
    emailSendBirthday: false,
    emailSendPolicyAnniversary: false,
    emailSendAep: false,
    smartSendEnabled: false,
    brandName: "",
    logo: null,
    orgSignature: false,
    signature: ""
};

// Helper function to generate default state/carrier settings
function generateDefaultStateCarrierSettings(states: string[], carriers: string[]): StateCarrierSetting[] {
  return states.flatMap(state => 
    carriers.map(carrier => ({
      state,
      carrier,
      active: true,  // Default to active
      targetGI: false  // Default to no GI
    }))
  );
}

export const settingsRoutes = new Elysia()
  .get('/api/settings', async ({ cookie }) => {
    logger.info('GET /api/settings - Starting');
    
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization settings, logo, and name
        const orgRow = await db.fetchOne<{ org_settings: string | null, logo_data: string | null, name: string, org_signature: boolean, phone: string | null, redirect_url: string | null, signature: string | null }>(
            'SELECT org_settings, logo_data, name, org_signature, phone, redirect_url, signature FROM organizations WHERE id = ?',
            [user.organization_id]
        );
        
        logger.info(`Retrieved org settings row`);

        // Parse the JSON string into an object
        let orgSettings: BaseSettings;
        try {
            orgSettings = orgRow?.org_settings 
                ? { ...defaultSettings, ...JSON.parse(orgRow.org_settings) }
                : { ...defaultSettings };

            // Prioritize signature from database column
            if (!orgSettings.signature && orgRow?.signature) {
                orgSettings.signature = orgRow.signature;
            }

            // If brandName is not set in settings, use the organization name
            if (!orgSettings.brandName && orgRow?.name) {
                orgSettings.brandName = orgRow.name;
            }

            // Add phone and redirectUrl from database columns if available
            if (orgRow?.phone) {
                orgSettings.phone = orgRow.phone;
            }
            
            if (orgRow?.redirect_url) {
                orgSettings.redirectUrl = orgRow.redirect_url;
            }
            
            // If we have states and carriers but no settings array, generate them
            if (orgSettings.stateLicenses.length > 0 && 
                orgSettings.carrierContracts.length > 0 && 
                !Array.isArray(orgSettings.stateCarrierSettings)) {
                
                logger.info('Generating default state/carrier settings');
                orgSettings.stateCarrierSettings = generateDefaultStateCarrierSettings(
                    orgSettings.stateLicenses,
                    orgSettings.carrierContracts
                );
            }
            
            // For backwards compatibility, ensure both orgSignature and forceOrgSenderDetails are in sync
            // If forceOrgSenderDetails doesn't exist, use orgSignature value
            if (!('forceOrgSenderDetails' in orgSettings)) {
                orgSettings.forceOrgSenderDetails = orgSettings.orgSignature || false;
            }
            // Ensure orgSignature matches forceOrgSenderDetails
            orgSettings.orgSignature = orgSettings.forceOrgSenderDetails;
        } catch (parseError) {
            logger.error(`Error parsing org settings: ${parseError}`);
            orgSettings = { ...defaultSettings };
        }

        // Get agent settings if they exist
        const agentSettingsRow = await db.fetchOne<{ inherit_org_settings: boolean, settings: string | null }>(
            'SELECT inherit_org_settings, settings FROM agent_settings WHERE agent_id = ?',
            [user.id]
        );

        // Parse agent settings
        let agentSettings = null;
        if (agentSettingsRow) {
            try {
                const parsedSettings = agentSettingsRow.settings 
                    ? { ...defaultSettings, ...JSON.parse(agentSettingsRow.settings) }
                    : { ...defaultSettings };

                agentSettings = {
                    inheritOrgSettings: agentSettingsRow.inherit_org_settings,
                    settings: parsedSettings
                };
            } catch (parseError) {
                logger.error(`Error parsing agent settings: ${parseError}`);
            }
        }

        const canEditOrgSettings = user.is_admin;

        const response = {
            success: true,
            name: orgRow?.name || null,
            orgSettings,
            logo: orgRow?.logo_data || null,
            orgSignature: orgRow?.org_signature || false,
            agentSettings,
            canEditOrgSettings
        };

        logger.info(`Sending response`);
        return response;

    } catch (error) {
        logger.error(`Error fetching settings: ${error}`);
        return {
            success: false,
            error: 'Failed to load settings'
        };
    }
  })

  .put('/api/settings/:scope', async ({ cookie, body, params }) => {
    const { scope } = params;
    logger.info(`PUT /api/settings/${scope} - Starting`);
    
    const user = await validateSession(cookie?.session?.toString() || '');
    if (!user?.id) {
        return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
        // Get organization's subscription tier
        const orgRow = await db.fetchOne<{ subscription_tier: string }>(
            'SELECT subscription_tier FROM organizations WHERE id = ?',
            [user.organization_id]
        );

        const isBasicTier = orgRow?.subscription_tier === 'basic';
        const typedBody = body as SettingsBody;

        if (scope === 'org') {
            logger.info('Updating organization settings');
            logger.info(`Organization settings body: ${JSON.stringify(typedBody, null, 2)}`);
            
            // Extract logo from settings if it exists
            const settingsObj = typedBody.settings || typedBody;
            const name = 'name' in settingsObj ? settingsObj.name : null;
            const logo = 'logo' in settingsObj ? settingsObj.logo : null;
            const orgSignature = 'orgSignature' in settingsObj ? settingsObj.orgSignature : false;
            const phone = 'phone' in settingsObj ? settingsObj.phone : null;
            const redirectUrl = 'redirectUrl' in settingsObj ? settingsObj.redirectUrl : null;
            const signature = 'signature' in settingsObj ? settingsObj.signature : null;
            
            // For backwards compatibility, sync forceOrgSenderDetails with orgSignature
            const forceOrgSenderDetails = 'forceOrgSenderDetails' in settingsObj ? settingsObj.forceOrgSenderDetails : orgSignature;
            
            const settingsWithoutLogo = { ...settingsObj };
            if ('logo' in settingsWithoutLogo) {
                delete (settingsWithoutLogo as any).logo;
            }
            
            // Ensure both fields are in sync
            settingsWithoutLogo.orgSignature = forceOrgSenderDetails;
            settingsWithoutLogo.forceOrgSenderDetails = forceOrgSenderDetails;
            
            // Update organization settings and logo separately
            await db.execute(
                'UPDATE organizations SET org_settings = ?, logo_data = ?, name = ?, org_signature = ?, phone = ?, redirect_url = ?, signature = ? WHERE id = ?',
                [JSON.stringify(settingsWithoutLogo), logo || null, name || null, forceOrgSenderDetails, 
                 forceOrgSenderDetails ? phone : null, forceOrgSenderDetails ? redirectUrl : null, forceOrgSenderDetails ? signature : null, user.organization_id]
            );

            
        } else if (scope === 'agent') {
            // For basic tier, don't allow direct agent settings updates
            if (isBasicTier) {
                return {
                    success: false,
                    error: 'Agent settings cannot be modified directly in basic tier - update organization settings instead'
                };
            }

            logger.info('Updating agent settings');
            logger.info(`Agent settings body: ${JSON.stringify(typedBody, null, 2)}`);

            try {
                await db.execute(
                    `INSERT INTO agent_settings (agent_id, inherit_org_settings, settings)
                     VALUES (?, ?, ?)
                     ON CONFLICT (agent_id) DO UPDATE
                     SET inherit_org_settings = ?, settings = ?`,
                    [
                        user.id,
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings),
                        typedBody.inheritOrgSettings,
                        JSON.stringify(typedBody.settings)
                    ]
                );
                logger.info('Agent settings updated successfully');
            } catch (dbError) {
                logger.error(`Database execute error details: ${JSON.stringify(dbError, null, 2)}`);
                throw dbError;
            }
        }
        logger.info('Settings updated successfully');
        return {
            success: true,
            settings: typedBody.settings || typedBody,
            error: null
        };
    } catch (error) {
        logger.error(`Error updating settings: ${error}`);
        logger.error(`Error stack: ${(error as Error).stack}`);
        return {
            success: false,
            error: 'Failed to update settings'
        };
    }
  })

  // Update the GI recommendations endpoint to use Elysia style
  .get('/api/settings/gi-recommendations', async ({ cookie }) => {
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const recommendations = await db.fetchAll(
        `SELECT state, carrier
         FROM guaranteed_issue_recommendations
         ORDER BY carrier, state`
      );

      // Transform the results to match the expected format
      const formattedRecommendations = recommendations.map((rec: { state: string; carrier: string }) => ({
        state: rec.state,
        carrier: rec.carrier,
        active: true,
        targetGI: true
      }));

      return formattedRecommendations;

    } catch (error) {
      logger.error(`Error fetching GI recommendations: ${error}`);
      return { success: false, error: 'Failed to fetch GI recommendations' };
    }
  })

  // Fetch the logo for the organization
  .get('/api/settings/logo', async ({ cookie }) => {
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const logo = await db.fetchOne<{ logo_data: string | null }>(
        'SELECT logo_data FROM organizations WHERE id = ?',
        [user.organization_id]
      );

      if (!logo) {
        return { success: false, error: 'Organization not found' };
      }

      return {
        success: true,
        logo: logo.logo_data
      };

    } catch (error) {
      logger.error(`Error fetching organization logo: ${error}`);
      return { success: false, error: 'Failed to fetch organization logo' };
    }
  })
  .get('/api/settings/:orgId/logo', async ({ params }) => {
    const { orgId } = params;
    const db = new Database();

    try {
      const logo = await db.fetchOne<{ logo_data: string | null }>(
        'SELECT logo_data FROM organizations WHERE id = ?',
        [orgId]
      );

      if (!logo) {
        return { success: false, error: 'Organization logo not found' }; 
      }

      return {
        success: true,
        logo: logo.logo_data
      };
    } catch (error) {
      logger.error(`Error fetching organization logo: ${error}`);
      return { success: false, error: 'Failed to fetch organization logo' };
    }
  })
  

  // Update carriers endpoint to use Elysia style
  .get('/api/settings/carriers', async ({ cookie }) => {
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll(
        `SELECT name
         FROM carriers
         ORDER BY name`
      );

      return carriers;

    } catch (error) {
      logger.error(`Error fetching carriers: ${error}`);
      return { success: false, error: 'Failed to fetch carriers' };
    }
  })

  .get('/api/settings/carriers-with-aliases', async ({ cookie }) => {
    const user = await validateSession(cookie.session.toString());
    if (!user?.id) {
      return { success: false, error: 'No authenticated user' };
    }

    const db = new Database();

    try {
      const carriers = await db.fetchAll(
        `SELECT name, aliases
         FROM carriers
         ORDER BY name`
      );

      return carriers.map((carrier: { name: string, aliases: string | null }) => ({
        name: carrier.name,
        aliases: carrier.aliases ? JSON.parse(carrier.aliases) : []
      }));

    } catch (error) {
      logger.error(`Error fetching carriers with aliases: ${error}`);
      return { success: false, error: 'Failed to fetch carriers with aliases' };
    }
  });

================
File: backend/src/routes/signup.ts
================
import { Elysia } from 'elysia';
import { logger } from '../logger';
import { Database } from '../database';
import { EmailService } from '../services/email';
import { AuthService } from '../services/auth';
import { cookie } from '@elysiajs/cookie';

// Enhanced slug generation with uniqueness check
async function generateUniqueSlug(db: Database, name: string): Promise<string> {
  let slug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric chars with hyphens
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length

  // Check if slug exists
  let counter = 0;
  let uniqueSlug = slug;
  
  while (true) {
    const existing = await db.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM organizations WHERE slug = ?',
      [uniqueSlug]
    );

    if (existing[0]?.count === 0) {
      break;
    }

    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}

// Create a standalone email check handler that doesn't require authentication
// This function can be directly mounted at the root level
export async function checkEmailHandler({ params, set }: { params: { email: string }, set: { status: number } }) {
  try {
    const { email } = params;
    const dbInstance = new Database();
    
    logger.info(`Public email check for: "${email}"`);
    
    if (!email || !email.trim()) {
      set.status = 400;
      return {
        available: false,
        message: 'Email is required'
      };
    }
    
    // Basic email format validation
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      logger.info(`Email validation failed for: "${email}"`);
      return {
        available: false,
        message: 'Invalid email format'
      };
    }
    
    // Check if email already exists
    const existingUser = await dbInstance.query<{ count: number }>(
      'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
      [email]
    );
    
    const count = existingUser[0]?.count || 0;
    logger.info(`Email check query result count: ${count} for email: "${email}"`);
    
    if (count > 0) {
      logger.info(`Email "${email}" is already registered`);
      return {
        available: false,
        message: 'This email address is already registered'
      };
    }
    
    logger.info(`Email "${email}" is available`);
    return {
      available: true,
      message: 'Email is available'
    };
    
  } catch (error) {
    logger.error(`Error checking email availability: ${error}`);
    set.status = 500;
    return {
      available: false,
      message: 'Failed to check email availability'
    };
  }
}

// Simple function to validate the token structure without strict verification
// For signup flow, we're just making sure the token format is valid
const validateSignupToken = (token: string): boolean => {
  try {
    // Token should have the format stored in our magic link
    const parts = token.split(':');
    return parts.length >= 2; // At minimum should have IV and encrypted data parts
  } catch (error) {
    logger.error(`Error validating signup token: ${error}`);
    return false;
  }
};

export function createSignupRoutes() {
  const dbInstance = new Database();
  const emailService = new EmailService();
  const authService = new AuthService();

  return new Elysia()
    .use(cookie())
    
    // New route for handling signup verification that just redirects to onboarding
    .get('/signup/verify', async ({ query, set }) => {
      try {
        // Extract query parameters
        const { token } = query as { 
          token: string, 
        };
        
        logger.info(`Processing signup verification for token: ${token}`);
        
        if (!token) {
          logger.warn('Missing token in signup verification');
          set.status = 400;
          set.redirect = '/signup';
          return { error: 'Invalid verification link' };
        }
        
        // Verify the token format is valid - simpler check for signup flow
        const { valid, email, redirectUrl } = await authService.verifySignupLink(token);
        
        logger.info(`Signup verified successfully, redirecting to: ${redirectUrl}`);
        set.redirect = redirectUrl;
        
        return {
          success: true,
          message: 'Email verified successfully'
        };
        
      } catch (error) {
        logger.error(`Error processing signup verification: ${error}`);
        set.status = 500;
        set.redirect = '/signup';
        return {
          success: false,
          message: 'Failed to verify email'
        };
      }
    })
    
    // Simplified signup process - only validate and send magic link
    .post('/api/signup', async ({ body, set }) => {
      try {
        const { name, email } = body as { name: string, email: string };
        
        logger.info(`Processing signup for name: "${name}", email: "${email}"`);
        
        if (!name || !name.trim() || !email || !email.trim()) {
          set.status = 400;
          return {
            success: false,
            message: 'Name and email are required'
          };
        }
        
        // Basic email format validation
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          logger.info(`Email validation failed for: "${email}"`);
          set.status = 400;
          return {
            success: false,
            message: 'Invalid email format'
          };
        }
        
        // Check if email already exists
        const existingUser = await dbInstance.query<{ count: number }>(
          'SELECT COUNT(*) as count FROM users WHERE LOWER(email) = LOWER(?)',
          [email]
        );
        
        if (existingUser[0]?.count > 0) {
          logger.info(`Email "${email}" is already registered`);
          set.status = 400;
          return {
            success: false,
            message: 'This email address is already registered'
          };
        }
        
        // Split name into first and last
        const nameParts = name.trim().split(' ');
        const firstName = nameParts[0];
        const lastName = nameParts.length > 1 ? nameParts.slice(1).join(' ') : '';
        
        // Generate magic link with user info in query parameters
        const magicLink = await authService.createSignupLink(
          email,
          { 
            // Use signup-verify instead of auth/verify to use a different flow
            redirectUrl: `/onboarding?firstName=${encodeURIComponent(firstName)}&lastName=${encodeURIComponent(lastName)}&email=${encodeURIComponent(email)}` 
          }
        );
        
        // Send the email with magic link
        await emailService.sendMagicLink(email, magicLink, firstName);
        
        logger.info(`Sent signup magic link to ${email}`);
        
        set.status = 201;
        return {
          success: true,
          message: 'Please check your email to continue with account setup.'
        };
        
      } catch (error) {
        logger.error(`Error processing signup: ${error}`);
        set.status = 500;
        return {
          success: false,
          message: 'Failed to create account'
        };
      }
    });
}

================
File: backend/src/routes/stage-demo.ts
================
import { Elysia, t } from 'elysia';
import { logger } from '../logger';
import Database from '../services/unifiedDatabase';
import fs from 'fs/promises';
import path from 'path';

const generateTempId = () => Math.random().toString(36).substring(2, 10);

// Initialize database - automatically uses Replit DB if available, otherwise JSON mock
const db = new Database();

export const createStageDemoRoutes = () => {
  return new Elysia({ prefix: '/api/stage-demo' })
    .post('/submit', async ({ body, set }) => {
      try {
        const { firstName, lastName, email, phone } = body as {
          firstName: string;
          lastName: string;
          email: string;
          phone: string;
        };

        if (!firstName || !lastName || !email || !phone) {
          set.status = 400;
          return { success: false, error: 'All fields are required.' };
        }

        logger.info(`Stage Demo: Submission received for ${email}`);

        const tempQuoteId = generateTempId();
        const quoteLink = `${process.env.PUBLIC_URL || 'http://localhost:5173'}/stage-demo/quote/${tempQuoteId}`;

        // Store the submission data
        const submissionData = {
          firstName,
          lastName,
          email,
          phone,
          submittedAt: new Date().toISOString(),
          quoteId: tempQuoteId,
          quoteLink
        };

        await db.set(`stage_demo_${tempQuoteId}`, submissionData);
        logger.info(`Stage Demo: Stored submission data for ${email} with ID ${tempQuoteId}`);

        const mailData = {
          to: email,
          subject: "Your MedicareMax Demo Quote",
          html: `<p>Hi ${firstName},</p>
<p>Thanks for your interest! Here's your personalized Medicare quote:</p>
<p><a href="${quoteLink}" style="background-color: #7C3AED; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">View Your Quote</a></p>
<p>Best,<br>The MedicareMax Team</p>`,
          text: `Hi ${firstName},\n\nThanks for your interest! Here's your personalized Medicare quote: ${quoteLink}\n\nBest,\nThe MedicareMax Team`
        };

        // Send email using SendGrid directly
        const sgMail = require('@sendgrid/mail');
        sgMail.setApiKey(process.env.SENDGRID_API_KEY);
        
        await sgMail.send({
          to: email,
          from: process.env.SENDGRID_FROM_EMAIL || 'noreply@medicaremax.ai',
          subject: mailData.subject,
          text: mailData.text,
          html: mailData.html
        });
        logger.info(`Stage Demo: Email sent to ${email}`);

        // SMS sending - format phone to E.164 if needed
        const formattedPhone = phone.replace(/\D/g, '');
        const e164Phone = formattedPhone.startsWith('1') ? `+${formattedPhone}` : `+1${formattedPhone}`;
        
        // Send SMS using Twilio if configured
        if (process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN && process.env.TWILIO_PHONE_NUMBER) {
          try {
            const twilio = require('twilio');
            const client = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);
            
            await client.messages.create({
              body: `Hi ${firstName}, here's your MedicareMax quote: ${quoteLink}`,
              from: process.env.TWILIO_PHONE_NUMBER,
              to: e164Phone
            });
            logger.info(`Stage Demo: SMS sent to ${e164Phone}`);
          } catch (smsError) {
            logger.warn(`Stage Demo: SMS sending failed: ${smsError}`);
          }
        } else {
          logger.warn(`Stage Demo: SMS not configured - missing: ${!process.env.TWILIO_ACCOUNT_SID ? 'TWILIO_ACCOUNT_SID ' : ''}${!process.env.TWILIO_AUTH_TOKEN ? 'TWILIO_AUTH_TOKEN ' : ''}${!process.env.TWILIO_PHONE_NUMBER ? 'TWILIO_PHONE_NUMBER' : ''}`);
        }
        set.status = 200;
        return { success: true, message: 'Check your email and texts for your personalized quote!' };
      } catch (error) {
        logger.error(`Stage Demo Error: ${error}`);
        set.status = 500;
        return { success: false, error: 'An error occurred. Please try again.' };
      }
    }, {
      body: t.Object({
        firstName: t.String(),
        lastName: t.String(),
        email: t.String({ format: 'email' }),
        phone: t.String()
      })
    })
    .get('/submissions', async ({ set }) => {
      try {
        // Get all stage demo submissions
        const listResult = await db.list('stage_demo_');
        
        if (!listResult.ok) {
          set.status = 500;
          return { success: false, error: 'Failed to retrieve submissions' };
        }

        const submissions = [];
        for (const key of listResult.value) {
          const dataResult = await db.get(key);
          if (dataResult.ok && dataResult.value) {
            submissions.push({
              id: key.replace('stage_demo_', ''),
              ...dataResult.value
            });
          }
        }

        // Sort by submission date (newest first)
        submissions.sort((a, b) => 
          new Date(b.submittedAt).getTime() - new Date(a.submittedAt).getTime()
        );

        return { 
          success: true, 
          count: submissions.length,
          submissions 
        };
      } catch (error) {
        logger.error(`Stage Demo Error: ${error}`);
        set.status = 500;
        return { success: false, error: 'Failed to retrieve submissions' };
      }
    })
    .get('/submission/:id', async ({ params, set }) => {
      try {
        const { id } = params;
        const result = await db.get(`stage_demo_${id}`);
        
        if (!result.ok) {
          set.status = 500;
          return { success: false, error: 'Failed to retrieve submission' };
        }

        if (!result.value) {
          set.status = 404;
          return { success: false, error: 'Submission not found' };
        }

        return { 
          success: true, 
          submission: {
            id,
            ...result.value
          }
        };
      } catch (error) {
        logger.error(`Stage Demo Error: ${error}`);
        set.status = 500;
        return { success: false, error: 'Failed to retrieve submission' };
      }
    })
    .get('/plans', async ({ set }) => {
      try {
        const filePath = path.join(__dirname, '../../data/plans.json');
        const fileContent = await fs.readFile(filePath, 'utf-8');
        const plansData = JSON.parse(fileContent);
        return plansData;
      } catch (error) {
        logger.error(`Stage Demo Plans Error: ${error}`);
        set.status = 500;
        return { success: false, error: 'Failed to retrieve plans data.' };
      }
    }, {
      beforeHandle: []
    });
};

================
File: backend/src/routes/stripe.ts
================
import { Elysia } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { config } from '../config';
import { getUserFromSession } from '../services/auth';
import { requireAuth } from '../middleware/auth';
import { checkPaymentStatus } from '../services/stripe';
import crypto from 'crypto';
import { cookie } from '@elysiajs/cookie';  

interface SubscriptionStatus {
  isActive: boolean;
  tier: string;
  currentPeriodEnd?: number;
  cancelAtPeriodEnd?: boolean;
  paymentStatus: string;
}

export const createStripeRoutes = (app: Elysia) => {
  app.use(requireAuth)
    .get('/api/stripe/subscription-status', async ({ user, set }) => {
      try {
        if (!user?.organization_id) {
          logger.info('No organization ID in request');
          set.status = 400;
          return { 
            success: false,
            error: 'No organization ID found' 
          };
        }
        
        const db = new Database();
        const status = await checkPaymentStatus(db, user.organization_id);
        logger.info(`Returning subscription status: ${JSON.stringify(status)}`);
        
        set.status = 200;
        return {
          success: true,
          data: status as SubscriptionStatus
        };
      } catch (error) {
        logger.error(`Error in subscription status route: ${error}`);
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to fetch subscription status',
          details: error instanceof Error ? error.message : 'Unknown error'
        };
      }
    });
    
  // Create separate instance without auth middleware for the payment-complete endpoint
  app.use(cookie())
    .post('/api/stripe/payment-complete', async ({ body, set, setCookie }) => {
      try {
        const { 
          email: encodedEmail, 
          firstName, 
          lastName,
          stripeCustomerId,
          stripeSubscriptionId,
          stripeUsageItemId
        } = body as { 
          email: string;
          firstName: string;
          lastName: string;
          stripeCustomerId?: string;
          stripeSubscriptionId?: string;
          stripeUsageItemId?: string;
        };

        // Decode the email in case it contains URL-encoded characters
        const email = decodeURIComponent(encodedEmail);

        logger.info(`Processing payment completion for email: ${email}`);
        logger.info(`Payment data: StripeCustomer=${stripeCustomerId ? (typeof stripeCustomerId === 'string' ? stripeCustomerId.substring(0, 10) + '...' : 'object') : 'missing'}, StripeSubscription=${stripeSubscriptionId ? (stripeSubscriptionId && typeof stripeSubscriptionId === 'string' ? stripeSubscriptionId.substring(0, 10) + '...' : 'object') : 'missing'}, UsageItem=${stripeUsageItemId ? (typeof stripeUsageItemId === 'string' ? stripeUsageItemId.substring(0, 10) + '...' : 'object') : 'missing'}`);

        const db = new Database();
        const client = db.getClient();

        // First get the user and organization
        logger.info(`Looking up user record for email: ${email}`);
        const userResult = await client.execute({
          sql: 'SELECT users.id, users.organization_id FROM users WHERE email = ? AND is_active = 1',
          args: [email]
        });

        logger.info(`User query returned ${userResult.rows.length} rows`);
        
        if (userResult.rows.length === 0) {
          logger.error(`No active user found for email: ${email}`);
          // Let's try a case-insensitive search as a fallback
          logger.info(`Trying case-insensitive search for email: ${email}`);
          const caseInsensitiveResult = await client.execute({
            sql: 'SELECT users.id, users.organization_id FROM users WHERE LOWER(email) = LOWER(?) AND is_active = 1',
            args: [email]
          });
          
          if (caseInsensitiveResult.rows.length === 0) {
            logger.error(`Still no user found with case-insensitive search for email: ${email}`);
            set.status = 404;
            return { success: false, error: 'User not found' };
          } else {
            logger.info(`Found user with case-insensitive match: ${caseInsensitiveResult.rows[0].id}`);
            // Continue with the found user
            userResult.rows = caseInsensitiveResult.rows;
          }
        }

        const userId = userResult.rows[0].id;
        const organizationId = userResult.rows[0].organization_id;
        logger.info(`Found user ID: ${userId}, organization ID: ${organizationId}`);

        // Construct the SQL update based on available Stripe data
        let sql = `UPDATE organizations 
                  SET payment_completed = 1, 
                      subscription_status = 'active',
                      onboarding_completed = TRUE`;
        
        const args = [];
        
        if (stripeCustomerId) {
          sql += ', stripe_customer_id = ?';
          args.push(stripeCustomerId);
        }
        
        if (stripeSubscriptionId) {
          sql += ', stripe_subscription_id = ?';
          args.push(typeof stripeSubscriptionId === 'object' ? JSON.stringify(stripeSubscriptionId) : stripeSubscriptionId);
        }
        
        if (stripeUsageItemId) {
          sql += ', stripe_usage_item_id = ?';
          args.push(typeof stripeUsageItemId === 'object' ? JSON.stringify(stripeUsageItemId) : stripeUsageItemId);
        }
        
        sql += ' WHERE id = ?';
        args.push(organizationId);

        // Update organization with payment and Stripe info
        logger.info(`Updating organization ${organizationId} with payment data`);
        const updateResult = await client.execute({ sql, args });
        logger.info(`Organization update affected ${updateResult.rowsAffected} rows`);

        // Create a new session
        const sessionId = crypto.randomBytes(32).toString('hex');
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

        logger.info(`Creating new session for user ${userId}: ${sessionId.substring(0, 16)}...`);
        const sessionResult = await client.execute({
          sql: 'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
          args: [sessionId, userId, expiresAt.toISOString()]
        });
        logger.info(`Session creation affected ${sessionResult.rowsAffected} rows`);

        // Set the session cookie
        logger.info(`Setting session cookie with expiry: ${expiresAt.toISOString()}`);
        setCookie('session', sessionId, {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 1 // 1 day -- shorter to force them to login again soon after onboarding
        });
        logger.info(`Session cookie set successfully`);

        // Get the subscription status to return to client
        logger.info(`Fetching subscription status for organization ${organizationId}`);
        const status = await checkPaymentStatus(db, organizationId);
        logger.info(`Subscription status: ${JSON.stringify(status)}`);

        logger.info(`Successfully completed payment setup for user ${userId} in organization ${organizationId}`);
        
        set.status = 200;
        return {
          success: true,
          data: status
        };

      } catch (error) {
        logger.error(`Error in payment completion: ${error}`);
        if (error instanceof Error && error.stack) {
          logger.error(`Stack trace: ${error.stack}`);
        }
        set.status = 500;
        return { 
          success: false,
          error: 'Failed to complete payment setup',
          details: error instanceof Error ? error.message : 'Unknown error'
        };
      }
    });

  return app;
};

================
File: backend/src/routes/waitlist.ts
================
import { Elysia, t } from 'elysia';
import { Database } from '../database';
import { logger } from '../logger';
import { cors } from '@elysiajs/cors';
import sgMail from '@sendgrid/mail';

// Types for request body
interface WaitlistEntry {
    name: string;
    email: string;
    phone: string;
    numAgents: string;
    bookSize: string;
}

// Validation functions
function validateEmail(email: string): boolean {
    const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    return emailRegex.test(email.trim());
}

function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
    const digits = phone.replace(/\D/g, '').slice(0, 10);
    return {
        isValid: digits.length === 10,
        standardized: digits
    };
}

export const createWaitlistRoutes = () => {
    const app = new Elysia({ prefix: '/api/waitlist' })
    .use(cors({
        origin: process.env.NODE_ENV === 'development' 
            ? 'http://localhost:5173' 
            : false,
        methods: ['POST', 'OPTIONS'],
        allowedHeaders: ['Content-Type'],
        credentials: false  // Don't require credentials for waitlist
    }));
    
    const db = new Database(); // Create a new instance of the main database

    // Initialize SendGrid
    if (!process.env.SENDGRID_API_KEY) {
        throw new Error('Missing SENDGRID_API_KEY environment variable');
    }
    sgMail.setApiKey(process.env.SENDGRID_API_KEY);

    app.post('/', async ({ body, set }: { body: WaitlistEntry, set: any }) => {
        try {
            logger.info(`Received waitlist submission: ${JSON.stringify(body)}`);
            const { name, email, phone, numAgents, bookSize } = body;

            // Validate inputs
            if (!name || typeof name !== 'string' || name.trim().length === 0) {
                logger.warn(`Invalid name: ${name}`);
                set.status = 400;
                return { success: false, message: 'Name is required' };
            }

            if (!email || typeof email !== 'string' || !validateEmail(email)) {
                logger.warn(`Invalid email: ${email}`);
                set.status = 400;
                return { success: false, message: 'Invalid email format' };
            }

            const phoneResult = standardizePhoneNumber(phone);
            if (!phoneResult.isValid) {
                logger.warn(`Invalid phone: ${phone}`);
                set.status = 400;
                return { success: false, message: 'Phone number must be 10 digits' };
            }

            if (!numAgents || isNaN(Number(numAgents)) || Number(numAgents) <= 0) {
                logger.warn(`Invalid numAgents: ${numAgents}`);
                set.status = 400;
                return { success: false, message: 'Number of agents must be a positive number' };
            }

            if (!bookSize || isNaN(Number(bookSize)) || Number(bookSize) <= 0) {
                logger.warn(`Invalid bookSize: ${bookSize}`);
                set.status = 400;
                return { success: false, message: 'Book size must be a positive number' };
            }

            // Check if email exists first to determine if this is an update
            const existing = await db.execute(
                'SELECT id FROM waitlist WHERE email = ?',
                [email.trim()]
            );
            const isUpdate = existing.rows && existing.rows.length > 0;

            // Insert or update waitlist entry
            logger.info('Upserting waitlist entry');
            const upsertResult = await db.execute(`
                INSERT INTO waitlist (name, email, phone, num_agents, book_size)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(email) DO UPDATE SET
                    name = EXCLUDED.name,
                    phone = EXCLUDED.phone,
                    num_agents = EXCLUDED.num_agents,
                    book_size = EXCLUDED.book_size,
                    updated_at = CURRENT_TIMESTAMP
            `, [
                name.trim(),
                email.trim(),
                phoneResult.standardized,
                Number(numAgents),
                Number(bookSize)
            ]);

            logger.info(`Upsert result: ${JSON.stringify(upsertResult)}`);

            // Send confirmation email
            try {
                await sgMail.send({
                    to: email.trim(),
                    from: {
                        email: process.env.HELLO_EMAIL || 'information@medicaremax.ai',
                        name: 'Medicare Max'
                    },
                    replyTo: process.env.HELLO_EMAIL || 'information@medicaremax.ai',
                    subject: "You're In. Time to Max What's Yours.",
                    text: `Hey ${name.trim()},

You made it on the Medicare Max waitlist—and not a moment too soon. 

You're doing the work, building the book, and watching revenue slip through the cracks. That stops here.

It's time to keep more, earn smarter, and finally get what's yours.

Early access is on the way. Stay ready.

Have questions? Just reply to this email and we'll get back to you.

Cheers,
THe Medicare Max Team`,
                    html: `
                        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #ffffff; padding: 40px 20px;">
                            <div style="text-align: center; margin-bottom: 30px;">
                                <a href="https://medicaremax.ai" style="text-decoration: none; display: inline-block;">
                                    <img src="https://medicaremax.ai/images/medicare-max-logo.png" alt="Medicare Max Logo" style="height: 40px; margin: 0 auto;">
                                </a>
                            </div>
                            <div style="background-color: #f0f9ff; border-radius: 12px; padding: 30px; margin: 20px 0;">
                                <h2 style="color: #03045E; font-size: 24px; margin-bottom: 20px;">Hey ${name.trim()},</h2>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                                    You made it on the Medicare Max waitlist—and not a moment too soon.
                                </p>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                                    You're doing the work, building the book, and watching revenue slip through the cracks. That stops here.
                                </p>
                                <div style="text-align: center;">
                                    <div style="background-color: #03045E; color: white; padding: 15px 25px; border-radius: 8px; display: inline-block; margin: 20px 0;">
                                        <span style="font-size: 20px; vertical-align: middle; margin-right: 8px;">🎉</span>
                                        <span style="vertical-align: middle;">Time to max what's yours</span>
                                    </div>
                                </div>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                                    It's time to keep more, earn smarter, and finally get what's yours.
                                </p>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                                    Early access is on the way. Stay ready.
                                </p>
                                <p style="color: #1a1f5f; font-size: 16px; line-height: 1.6; margin-top: 20px; font-style: italic;">
                                    Have questions? Just reply to this email and we'll get back to you.
                                </p>
                            </div>
                            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center;">
                                <p style="color: #6b7280; font-size: 14px;">
                                    Cheers,<br>
                                    The Medicare Max Team
                                </p>
                            </div>
                        </div>
                    `
                });
                logger.info(`Confirmation email sent to ${email}`);
            } catch (emailError) {
                // Log the error but don't fail the request
                logger.error(`Failed to send confirmation email: ${emailError instanceof Error ? emailError.message : String(emailError)}`);
            }

            // Explicitly set success status
            set.status = 200;
            
            return { 
                success: true, 
                message: isUpdate ? 'Successfully updated your waitlist entry' : 'Successfully joined waitlist'
            };
        } catch (error) {
            logger.error(`Waitlist error: ${error instanceof Error ? error.message : String(error)}`);
            set.status = 500;
            return { 
                success: false, 
                message: 'Internal server error' 
            };
        }
    });

    return app;
};

================
File: backend/src/scripts/apply_nullable_fields_migration.ts
================
/**
 * Script to apply the make_optional_fields_nullable migration to all organizations
 * 
 * Usage: 
 * bun run backend/src/scripts/apply_nullable_fields_migration.ts
 */

import fs from 'fs';
import path from 'path';
import { Database } from '../database';
import { logger } from '../logger';

const migrationPath = path.resolve(__dirname, '../../../backend/migrations/20250425_make_optional_fields_nullable.sql');

if (!fs.existsSync(migrationPath)) {
  logger.error(`Migration file not found: ${migrationPath}`);
  process.exit(1);
}

const migrationSQL = fs.readFileSync(migrationPath, 'utf-8');

// Function to split SQL dump into individual statements
// This handles SQL statements more precisely than just splitting on semicolons
function splitSqlStatements(sql: string): string[] {
  const statements: string[] = [];
  let currentStatement = "";
  let inString = false;
  let inComment = false;
  let inBlockComment = false;
  let stringQuote: string | null = null;

  for (let i = 0; i < sql.length; i++) {
    const char = sql[i];
    const nextChar = i + 1 < sql.length ? sql[i + 1] : null;

    // Handle comments
    if (!inString) {
      if (char === "-" && nextChar === "-" && !inBlockComment) {
        inComment = true;
        i++; // Skip next char
        currentStatement += char + nextChar;
        continue;
      }
      if (char === "/" && nextChar === "*" && !inComment) {
        inBlockComment = true;
        i++;
        currentStatement += char + nextChar;
        continue;
      }
      if (inComment && char === "\n") {
        inComment = false;
        currentStatement += char;
        continue;
      }
      if (inBlockComment && char === "*" && nextChar === "/") {
        inBlockComment = false;
        i++;
        currentStatement += char + nextChar;
        continue;
      }
      if (inComment || inBlockComment) {
        currentStatement += char;
        continue;
      }
    }

    // Handle string literals
    if ((char === "'" || char === '"') && !inComment && !inBlockComment) {
      if (!inString) {
        inString = true;
        stringQuote = char;
      } else if (char === stringQuote) {
        // Check for escaped quotes
        if (i > 0 && sql[i - 1] !== "\\") {
          inString = false;
          stringQuote = null;
        }
      }
    }

    // Handle statement termination
    if (char === ";" && !inString && !inComment && !inBlockComment) {
      currentStatement += char;
      statements.push(currentStatement.trim());
      currentStatement = "";
      continue;
    }

    currentStatement += char;
  }

  // Add the last statement if it exists
  if (currentStatement.trim()) {
    statements.push(currentStatement.trim());
  }

  return statements.filter(stmt => stmt.length > 0);
}

async function applyMigration() {
  try {
    // Get list of all organizations
    const mainDb = new Database();
    const orgs = await mainDb.fetchAll('SELECT id, name, turso_db_url, turso_auth_token FROM organizations WHERE active = 1');
    
    logger.info(`Found ${orgs.length} active organizations`);
    
    // Split SQL statements properly
    const statements = splitSqlStatements(migrationSQL);
    logger.info(`Parsed ${statements.length} SQL statements from migration file`);
    
    // Apply migration to each organization
    for (const org of orgs) {
      try {
        logger.info(`Applying migration to organization ${org.id} (${org.name})...`);
        
        // Connect to the org's database
        const orgDb = new Database(org.turso_db_url, org.turso_auth_token);
        
        // Execute each statement in a transaction if possible
        try {
          await orgDb.transaction(async (tx) => {
            for (const stmt of statements) {
              if (stmt.trim()) {
                try {
                  logger.info(`Executing statement: ${stmt.substring(0, 50)}...`);
                  await tx.execute(stmt);
                } catch (err) {
                  logger.error(`Error executing statement for org ${org.id}: ${err}`);
                  logger.error(`Statement: ${stmt}`);
                  throw err; // Rethrow to trigger transaction rollback
                }
              }
            }
            logger.info(`All statements executed successfully for organization ${org.id}`);
          });
        } catch (txError) {
          // If transaction fails, try executing statements individually without transaction
          logger.warn(`Transaction failed, trying to execute statements individually: ${txError}`);
          
          for (const stmt of statements) {
            if (stmt.trim()) {
              try {
                // Skip transaction control statements when executing individually
                if (!/^\s*(BEGIN|COMMIT|ROLLBACK|PRAGMA)/i.test(stmt)) {
                  await orgDb.execute(stmt);
                }
              } catch (err) {
                logger.error(`Error executing individual statement for org ${org.id}: ${err}`);
                logger.error(`Statement: ${stmt}`);
                // Continue with next statement
              }
            }
          }
        }
        
        logger.info(`Migration applied successfully to organization ${org.id} (${org.name})`);
      } catch (err) {
        logger.error(`Error applying migration to organization ${org.id} (${org.name}): ${err}`);
        // Continue with next organization even if one fails
      }
    }
    
    logger.info('Migration process completed for all organizations');
  } catch (err) {
    logger.error(`Fatal error in migration process: ${err}`);
    process.exit(1);
  }
}

// Run the migration
applyMigration().then(() => {
  logger.info('Migration process completed successfully');
  process.exit(0);
}).catch((err) => {
  logger.error(`Unhandled error: ${err}`);
  process.exit(1);
});

================
File: backend/src/scripts/apply_org_migrations.ts
================
#!/usr/bin/env bun

/**
 * Script to apply email unique constraint migration to all organization databases
 * 
 * Usage: 
 * - Apply to all orgs: bun run scripts/apply_org_migrations.ts
 * - Apply to specific org: bun run scripts/apply_org_migrations.ts 7
 */
import { Database } from '../database';
import { TursoService } from '../services/turso';
import { logger } from '../logger';
import fs from 'fs';
import path from 'path';

async function main() {
  try {
    // Check if we're targeting a specific org
    const targetOrgId = process.argv[2];
    
    // Initialize main database connection
    const mainDb = new Database();
    
    // Get organizations with their database URLs and tokens
    let orgs;
    if (targetOrgId) {
      // If targeting specific org
      orgs = await mainDb.fetchAll(`
        SELECT id, name, turso_db_url, turso_auth_token 
        FROM organizations 
        WHERE id = ? AND turso_db_url IS NOT NULL AND turso_auth_token IS NOT NULL
      `, [targetOrgId]);
      
      if (orgs.length === 0) {
        logger.error(`Organization with ID ${targetOrgId} not found or has no database configuration`);
        process.exit(1);
      }
      logger.info(`Targeting specific organization: ${targetOrgId}`);
    } else {
      // Get all orgs
      orgs = await mainDb.fetchAll(`
        SELECT id, name, turso_db_url, turso_auth_token 
        FROM organizations 
        WHERE turso_db_url IS NOT NULL AND turso_auth_token IS NOT NULL
      `);
    }
    
    logger.info(`Found ${orgs.length} organizations with databases`);
    
    // Get the migration SQL
    const migrationPath = path.join(process.cwd(), 'migrations', '20250329_fix_email_unique_constraint.sql');
    const migrationSql = fs.readFileSync(migrationPath, 'utf8');
    
    // Process each organization
    for (const org of orgs) {
      const orgId = org.id || org[0];
      const orgName = org.name || org[1];
      const dbUrl = org.turso_db_url || org[2];
      const authToken = org.turso_auth_token || org[3];
      
      try {
        logger.info(`Processing organization: ${orgName} (ID: ${orgId})`);
        
        // Get database connection for this organization
        const orgDb = new Database(dbUrl, authToken);
        
        // Check if contacts table exists and if updated_at column exists
        let tableCheck, hasUpdatedAtColumn;
        try {
          tableCheck = await orgDb.fetchOne(`
            SELECT name FROM sqlite_master WHERE type='table' AND name='contacts'
          `);
          
          if (tableCheck) {
            // Check if updated_at column exists
            const columnCheck = await orgDb.fetchOne(`
              SELECT COUNT(*) as count FROM pragma_table_info('contacts') WHERE name = 'updated_at'
            `);
            hasUpdatedAtColumn = columnCheck && 
              (typeof columnCheck === 'object' ? 
                ((columnCheck as any).count > 0 || (Array.isArray(columnCheck) && columnCheck[0] && Number(columnCheck[0]) > 0)) : 
                false);
            
            logger.info(`Table check: contacts table exists=${!!tableCheck}, has updated_at column=${hasUpdatedAtColumn}`);
          }
        } catch (checkError) {
          logger.warn(`Error checking table schema: ${checkError}`);
        }
        
        // Apply migration in separate chunks to handle potential errors
        
        // Start with dropping views that depend on contacts
        try {
          await orgDb.execute('DROP VIEW IF EXISTS v_contact_stats');
          logger.info('Dropped dependent views');
        } catch (viewError) {
          logger.warn(`Error dropping views: ${viewError}`);
        }
        
        // Check and backup eligibility_answers if it exists
        try {
          const eligibilityCheck = await orgDb.fetchOne(`
            SELECT name FROM sqlite_master WHERE type='table' AND name='eligibility_answers'
          `);
          
          if (eligibilityCheck) {
            // Create backup table and copy data
            await orgDb.execute(`
              CREATE TABLE IF NOT EXISTS eligibility_answers_backup AS 
              SELECT * FROM eligibility_answers
            `);
            
            // Drop the table to avoid foreign key issues
            await orgDb.execute('DROP TABLE IF EXISTS eligibility_answers');
            logger.info('Backed up and dropped eligibility_answers table');
          }
        } catch (backupError) {
          logger.warn(`Error handling eligibility_answers: ${backupError}`);
        }
        
        // Handle updated_at column if contacts table exists
        if (tableCheck) {
          try {
            if (!hasUpdatedAtColumn) {
              logger.info('Adding missing updated_at column');
              await orgDb.execute('ALTER TABLE contacts ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP');
            } else {
              logger.info('updated_at column already exists, skipping addition');
            }
          } catch (columnError) {
            // If error contains "duplicate column" we can ignore it
            if ((columnError as Error).toString().includes('duplicate column')) {
              logger.info('Ignoring duplicate column error for updated_at - column already exists');
            } else {
              logger.warn(`Error handling updated_at column: ${columnError}`);
            }
          }
        }
        
        // Apply the main migration script with error handling for each statement
        try {
          // Split migration SQL into individual statements
          const migrationStatements = migrationSql
            .split(';')
            .map(stmt => stmt.trim())
            .filter(stmt => stmt.length > 0 && !stmt.startsWith('--'));
          
          // Skip statements that add updated_at column since we've handled it above
          const filteredStatements = migrationStatements.filter(stmt => {
            // Skip the problematic statements
            return !stmt.includes('ADD COLUMN updated_at') && 
                   !stmt.includes('pragma_table_info') &&
                   !stmt.includes('_vars') &&
                   !stmt.includes('_commands');
          });
          
          logger.info(`Applying ${filteredStatements.length} migration statements`);
          
          // Execute each statement with individual error handling
          for (const statement of filteredStatements) {
            try {
              // Skip empty statements or diagnostic queries
              if (statement.trim().length === 0 || 
                  statement.includes('PRAGMA table_info') ||
                  statement.includes('SELECT name, sql FROM sqlite_master')) {
                continue;
              }
              
              await orgDb.execute(statement);
            } catch (stmtError) {
              const errorString = (stmtError as Error).toString();
              
              // Handle specific errors gracefully
              if (errorString.includes('duplicate column name: updated_at')) {
                logger.info('Ignoring duplicate updated_at column error');
              } else if (errorString.includes('no such table: contacts_temp')) {
                logger.warn('Contacts temporary table not found, may have already been renamed');
              } else {
                logger.error(`Error executing statement: ${stmtError}`);
                logger.error(`Failed statement: ${statement.substring(0, 100)}...`);
              }
              // Continue with next statement, errors shouldn't fail the whole migration
            }
          }
          
          // Verify the migration results
          try {
            // Check if email unique constraint exists
            const uniqueCheck = await orgDb.fetchOne(`
              SELECT COUNT(*) as count FROM sqlite_master 
              WHERE type='index' AND name='contact_email_unique'
            `);
            
            const hasUniqueConstraint = uniqueCheck && 
              (typeof uniqueCheck === 'object' ? 
                ((uniqueCheck as any).count > 0 || (Array.isArray(uniqueCheck) && uniqueCheck[0] && Number(uniqueCheck[0]) > 0)) : 
                false);
                
            if (hasUniqueConstraint) {
              logger.info('Email unique constraint created successfully');
            } else {
              logger.warn('Email unique constraint may not have been created');
              
              // Try to create it if missing
              try {
                await orgDb.execute(`
                  CREATE UNIQUE INDEX IF NOT EXISTS contact_email_unique ON contacts(email)
                `);
                logger.info('Created missing email unique constraint');
              } catch (createError) {
                logger.error(`Error creating missing constraint: ${createError}`);
              }
            }
            
            // Test if ON CONFLICT works
            try {
              await orgDb.execute(`
                INSERT OR IGNORE INTO contacts (
                  first_name, last_name, email, current_carrier, plan_type, 
                  effective_date, birth_date, tobacco_user, gender, state, zip_code, phone_number
                ) 
                VALUES ('Test', 'Migration', 'test.migration@example.com', 'Test', 'Test', 
                  '2025-01-01', '1970-01-01', 0, 'M', 'TX', '12345', '123-456-7890')
                ON CONFLICT(email) DO NOTHING
              `);
              logger.info('ON CONFLICT query test successful');
            } catch (testError) {
              logger.error(`ON CONFLICT test failed: ${testError}`);
            }
            
          } catch (verifyError) {
            logger.warn(`Error verifying migration results: ${verifyError}`);
          }
          
          logger.info(`Successfully migrated organization ${orgName} (ID: ${orgId})`);
        } catch (migrationError) {
          logger.error(`Migration failed for organization ${orgName} (ID: ${orgId}): ${migrationError}`);
        }
      } catch (orgError) {
        logger.error(`Error processing organization ${orgName} (ID: ${orgId}): ${orgError}`);
      }
    }
    
    logger.info('Migration process completed');
  } catch (error) {
    logger.error(`Script error: ${error}`);
    process.exit(1);
  }
}

main().catch(error => {
  logger.error(`Unhandled error: ${error}`);
  process.exit(1);
});

================
File: backend/src/scripts/migrate-add-aep-columns.ts
================
import { Database } from '../database';
import { logger } from '../logger';

async function migrateAddAepColumns() {
  try {
    logger.info('Starting migration to add AEP request columns to all org databases');
    
    // Connect to main database
    const mainDb = new Database();
    
    // Get all organization IDs, database URLs and tokens
    const orgs = await mainDb.fetchAll(
      'SELECT id, turso_db_url, turso_auth_token FROM organizations WHERE turso_db_url IS NOT NULL'
    );
    
    logger.info(`Found ${orgs.length} organizations with databases to migrate`);
    
    for (const org of orgs) {
      const orgId = org.id || org[0];
      const dbUrl = org.turso_db_url || org[1];
      const authToken = org.turso_auth_token || org[2];
      
      if (!dbUrl || !authToken) {
        logger.warn(`Skipping org ${orgId} due to missing database credentials`);
        continue;
      }
      
      logger.info(`Migrating org ${orgId} with database URL ${dbUrl}`);
      
      try {
        // Connect to org database
        const orgDb = new Database(dbUrl, authToken);
        
        // Check if columns already exist
        const tableInfo = await orgDb.fetchAll("PRAGMA table_info(contacts)");
        const columns = tableInfo.map((col: any) => col.name || col[1]);
        
        if (!columns.includes('aep_request')) {
          logger.info(`Adding aep_request column to contacts table for org ${orgId}`);
          await orgDb.execute('ALTER TABLE contacts ADD COLUMN aep_request BOOLEAN DEFAULT FALSE');
        } else {
          logger.info(`aep_request column already exists for org ${orgId}`);
        }
        
        if (!columns.includes('aep_request_date')) {
          logger.info(`Adding aep_request_date column to contacts table for org ${orgId}`);
          await orgDb.execute('ALTER TABLE contacts ADD COLUMN aep_request_date DATETIME');
        } else {
          logger.info(`aep_request_date column already exists for org ${orgId}`);
        }
        
        logger.info(`Successfully migrated org ${orgId}`);
      } catch (error) {
        logger.error(`Error migrating org ${orgId}: ${error}`);
      }
    }
    
    logger.info('Migration completed');
  } catch (error) {
    logger.error(`Migration failed: ${error}`);
    throw error;
  }
}

// Execute migration if this file is run directly
if (import.meta.main) {
  migrateAddAepColumns()
    .then(() => {
      logger.info('Migration script completed successfully');
      process.exit(0);
    })
    .catch((error) => {
      logger.error(`Migration script failed: ${error}`);
      process.exit(1);
    });
}

export { migrateAddAepColumns };

================
File: backend/src/services/agentSettings.ts
================
import { db } from '../database';
import { NotFoundError } from '../errors';
import { logger } from '../logger';

export interface StateCarrierSetting {
  active: boolean;
  targetGI: boolean;
}

export interface AgentSettings {
  id: number;
  agentId: number;
  stateLicenses: string[];
  carrierContracts: string[];
  stateCarrierSettings: {
    [state: string]: {
      [carrier: string]: StateCarrierSetting;
    };
  };
  emailSendBirthday: boolean;
  emailSendPolicyAnniversary: boolean;
  emailSendAep: boolean;
  smartSendEnabled: boolean;
}

export async function getAgentSettings(agentId: number): Promise<AgentSettings> {
  try {
    const result = await db.oneOrNone(
      'SELECT * FROM agent_settings WHERE agent_id = $1',
      [agentId]
    )

    if (!result) {
      // Return default settings instead of creating them
      return {
        id: 0,
        agentId: agentId,
        stateLicenses: [],
        carrierContracts: [],
        stateCarrierSettings: {},
        emailSendBirthday: false,
        emailSendPolicyAnniversary: false,
        emailSendAep: false,
        smartSendEnabled: false
      }
    }

    return {
      id: result.id,
      agentId: result.agent_id,
      stateLicenses: result.state_licenses || [],
      carrierContracts: result.carrier_contracts || [],
      stateCarrierSettings: result.state_carrier_settings || {},
      emailSendBirthday: result.email_send_birthday || false,
      emailSendPolicyAnniversary: result.email_send_policy_anniversary || false,
      emailSendAep: result.email_send_aep || false,
      smartSendEnabled: result.smart_send_enabled || false,
    }
  } catch (error) {
    logger.error(`Error fetching agent settings: ${error}`)
    // Return default settings on error
    return {
      id: 0,
      agentId: agentId,
      stateLicenses: [],
      carrierContracts: [],
      stateCarrierSettings: {},
      emailSendBirthday: false,
      emailSendPolicyAnniversary: false,
      emailSendAep: false,
      smartSendEnabled: false
    }
  }
}

async function createDefaultSettings(agentId: number): Promise<AgentSettings> {
  const result = await db.one(
    `INSERT INTO agent_settings 
     (agent_id, state_licenses, carrier_contracts, state_carrier_settings)
     VALUES ($1, $2, $3, $4)
     RETURNING *`,
    [agentId, [], [], {}]
  );

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

export async function updateAgentSettings(
  agentId: number,
  settings: Partial<AgentSettings>
): Promise<AgentSettings> {
  const result = await db.oneOrNone(
    `UPDATE agent_settings
     SET state_licenses = COALESCE($1, state_licenses),
         carrier_contracts = COALESCE($2, carrier_contracts),
         state_carrier_settings = COALESCE($3, state_carrier_settings),
         email_send_birthday = COALESCE($4, email_send_birthday),
         email_send_policy_anniversary = COALESCE($5, email_send_policy_anniversary),
         email_send_aep = COALESCE($6, email_send_aep),
         smart_send_enabled = COALESCE($7, smart_send_enabled)
     WHERE agent_id = $8
     RETURNING *`,
    [
      settings.stateLicenses,
      settings.carrierContracts,
      settings.stateCarrierSettings,
      settings.emailSendBirthday,
      settings.emailSendPolicyAnniversary,
      settings.emailSendAep,
      settings.smartSendEnabled,
      agentId,
    ]
  );

  if (!result) {
    throw new NotFoundError('Agent settings not found');
  }

  return {
    id: result.id,
    agentId: result.agent_id,
    stateLicenses: result.state_licenses,
    carrierContracts: result.carrier_contracts,
    stateCarrierSettings: result.state_carrier_settings,
    emailSendBirthday: result.email_send_birthday,
    emailSendPolicyAnniversary: result.email_send_policy_anniversary,
    emailSendAep: result.email_send_aep,
    smartSendEnabled: result.smart_send_enabled,
  };
}

================
File: backend/src/services/auth.ts
================
import crypto from 'crypto';
import { logger } from '../logger';
import { db } from '../database';
import { Database } from '../database';
import type { User } from '../types';
import { config } from '../config';

const algorithm = "aes-256-gcm";
const IV_LENGTH = 12;
const UTF8 = "utf8";
const HEX = "hex";

// Initialize encryption key
let secret = process.env.MAGIC_LINK_SECRET;
if (!secret) {
  if (process.env.NODE_ENV === "production") {
    throw new Error("Must set MAGIC_LINK_SECRET in production");
  }
  secret = "dev-secret-key";
}

const ENCRYPTION_KEY = crypto.scryptSync(secret, "salt", 32);

interface MagicLinkPayload {
  email: string;
  organizationSlug: string;
  expiresAt: number;
  redirectUrl: string;
  orgId?: number;
  name?: string;
}

interface SignupLinkPayload {
  email: string;
  firstName: string;
  lastName: string;
  redirectUrl: string;
}

export class AuthService {
  constructor(private baseUrl?: string) {
    // If no baseUrl is provided, get it from config
    if (!baseUrl) {
      this.baseUrl = config.PUBLIC_URL;
    } else {
      // Ensure baseUrl doesn't end with a slash
      this.baseUrl = baseUrl.replace(/\/$/, '');
    }
    
    logger.info(`AuthService initialized with baseUrl: ${this.baseUrl}`);
  }

  async createSignupLink(
    email: string,
    options?: {
      redirectUrl?: string;
      firstName?: string;
      lastName?: string;
    }
  ): Promise<string> {
    const payload: SignupLinkPayload = {
      email,
      firstName: options?.firstName || '',
      lastName: options?.lastName || '',
      redirectUrl: options?.redirectUrl || '/onboarding'
    };

    logger.info(`Creating signup link with payload: ${JSON.stringify(payload)}`);
    logger.info(`redirectUrl: ${payload.redirectUrl}`);
    const token = this.encrypt(JSON.stringify(payload));
    // URL encode the entire token
    const encodedToken = encodeURIComponent(token);
    logger.info(`Generated magic link token: ${token}`);
    
    return `${this.baseUrl}/signup/verify/${encodedToken}`;
  }

  async verifySignupLink(token: string): Promise<{
    valid: boolean;
    email?: string;
    redirectUrl?: string;
  }> {
    try { 
      const decodedToken = decodeURIComponent(token);
      const decrypted = this.decrypt(decodedToken);
      const payload: SignupLinkPayload = JSON.parse(decrypted);

      if (!payload.email) {
        logger.warn('Missing email in signup link payload');
        return { valid: false };
      }

      if (!payload.redirectUrl) {
        logger.warn('Missing redirectUrl in signup link payload');
        return { valid: false };  
      }

      logger.info('Signup link verification successful, returning payload');
      return {
        valid: true,
        email: payload.email,
        redirectUrl: payload.redirectUrl
      };

    } catch (error) {
      logger.error(`Signup link verification failed: ${error}`);
      return { valid: false };  
    }
  }

  async createMagicLink(
    email: string, 
    organizationSlug: string, 
    options?: { 
      redirectUrl?: string;
      orgId?: number;
      name?: string;
    }
  ): Promise<string> {
    const payload: MagicLinkPayload = {
      email,
      organizationSlug,
      expiresAt: Date.now() + (30 * 60 * 1000), // 30 minutes
      redirectUrl: options?.redirectUrl || '/dashboard',
      ...(options?.orgId && { orgId: options.orgId }),
      ...(options?.name && { name: options.name })
    };

    logger.info(`Creating magic link with payload: ${JSON.stringify(payload)}`);
    logger.info(`redirectUrl: ${payload.redirectUrl}`);
    const token = this.encrypt(JSON.stringify(payload));
    // URL encode the entire token
    const encodedToken = encodeURIComponent(token);
    logger.info(`Generated magic link token: ${token}`);
    return `${this.baseUrl}/auth/verify/${organizationSlug}/${encodedToken}`;
  }

  async verifyMagicLink(token: string, organizationSlug: string): Promise<{
    valid: boolean;
    email?: string;
    redirectUrl?: string;
  }> {
    try {
      logger.info('Starting magic link verification');
      logger.info(`Organization slug: ${organizationSlug}`);

      const decodedToken = decodeURIComponent(token);
      const decrypted = this.decrypt(decodedToken);
      const payload: MagicLinkPayload = JSON.parse(decrypted);

      // Verify organization and expiration
      if (payload.organizationSlug !== organizationSlug) {
        logger.error(`Organization slug mismatch: ${payload.organizationSlug} !== ${organizationSlug}`);
        return { valid: false };
      }

      if (payload.expiresAt < Date.now()) {
        logger.error(`Token expired: ${new Date(payload.expiresAt)} < ${new Date()}`);
        return { valid: false };
      }

      // No need to check agent status here since we only send links to valid agents

      logger.info('Verification successful, returning payload');
      return {
        valid: true,
        email: payload.email,
        redirectUrl: payload.redirectUrl
      };

    } catch (error) {
      logger.error(`Magic link verification failed: ${error}`);
      return { valid: false };
    }
  }

  private encrypt(text: string): string {
    try {
      const iv = crypto.randomBytes(IV_LENGTH);
      const cipher = crypto.createCipheriv(algorithm, ENCRYPTION_KEY, iv);
      let encrypted = cipher.update(text, UTF8, HEX);
      encrypted += cipher.final(HEX);
      const authTag = cipher.getAuthTag();
      
      const token = `${iv.toString(HEX)}:${authTag.toString(HEX)}:${encrypted}`;
      return token;
    } catch (error) {
      logger.error(`Encryption failed: ${error}`);
      throw error;
    }
  }

  private decrypt(text: string): string {
    try {
      const [ivPart, authTagPart, encryptedText] = text.split(":");
      if (!ivPart || !authTagPart || !encryptedText) {
        throw new Error("Invalid token format - missing parts");
      }

      logger.info('Decrypting token parts:');
      logger.info(`IV length: ${ivPart.length}`);
      logger.info(`Auth tag length: ${authTagPart.length}`);
      logger.info(`Encrypted text length: ${encryptedText.length}`);

      const iv = Buffer.from(ivPart, HEX);
      const authTag = Buffer.from(authTagPart, HEX);
      const decipher = crypto.createDecipheriv(algorithm, ENCRYPTION_KEY, iv);
      decipher.setAuthTag(authTag);
      let decrypted = decipher.update(encryptedText, HEX, UTF8);
      decrypted += decipher.final(UTF8);
      return decrypted;
    } catch (error) {
      logger.error(`Decryption failed: ${error}`);
      throw error;
    }
  }

  async getUserFromSession(request: Request): Promise<Partial<User> | null> {
    // Check for bypass header for testing
    const bypassHeader = request.headers.get('X-Bypass-Auth');
    if (bypassHeader) {
      const bypassUserId = bypassHeader === 'true' ? 'test-user-id' : bypassHeader;
      logger.info(`Bypassing authentication with header for user ID: ${bypassUserId}`);
      return {
        id: bypassUserId,
        email: 'test@example.com',
        organization_id: 'test-org-id',
        is_admin: true,
        is_agent: true,
        first_name: 'Test',
        last_name: 'User',
        is_active: true,
        organization_name: 'Test Organization'
      };
    }
    
    // Check if this is a public endpoint that should bypass auth
    const url = new URL(request.url);
    const pathname = url.pathname;
    
    // Log all requested pathnames for debugging
    logger.info(`Auth check for pathname: ${pathname}`);
    
    // Skip auth for subscription/checkout endpoint
    if (pathname === '/api/subscription/checkout') {
      logger.info('Skipping auth check for subscription/checkout endpoint');
      return { skip_auth: true }; // Return a dummy user that won't trigger auth failures
    }
    
    // Skip auth for all self-service endpoints
    if (pathname.startsWith('/api/self-service/')) {
      logger.info(`Skipping auth check for self-service endpoint: ${pathname}`);
      
      return { skip_auth: true }; // Return a dummy user that won't trigger auth failures
    }

    // Test both regex patterns for debugging
    const comparePathTest1 = /^\/compare\/[^\/]+$/.test(pathname);
    const comparePathTest2 = pathname.startsWith('/compare/');
    
    logger.info(`Compare path tests: regex=${comparePathTest1}, startsWith=${comparePathTest2} for ${pathname}`);

    // Skip auth for compare pages with path parameters
    if (pathname.startsWith('/compare/')) {
      logger.info(`Skipping auth check for compare path parameter endpoint: ${pathname}`);
      return { skip_auth: true }; // Return a dummy user that won't trigger auth failures
    }
    
    // Skip auth check for static files
    if (
      pathname.endsWith('.js') || 
      pathname.endsWith('.css') || 
      pathname.endsWith('.png') || 
      pathname.endsWith('.jpg') || 
      pathname.endsWith('.svg') || 
      pathname.endsWith('.ico') ||
      pathname.endsWith('.ttf') ||
      pathname.endsWith('.woff') ||
      pathname.endsWith('.woff2')
    ) {
      logger.info(`Skipping auth check for static file: ${pathname}`);
      return { skip_auth: true };
    }

    const cookieHeader = request.headers.get('Cookie') || '';

    // Get session cookie
    const sessionId = cookieHeader.split('session=')[1]?.split(';')[0];
    
    if (!sessionId) {
      logger.warn('No session cookie found');
      return null;
    }

    // Initialize database
    const db = new Database();

    // Get session data
    const sessionResult = await db.fetchAll(
      'SELECT user_id FROM sessions WHERE id = ?',
      [sessionId]
    );

    if (!sessionResult || sessionResult.length === 0) {
      logger.warn(`No session found for ID: ${sessionId}`);
      return null;
    }

    const userId = sessionResult[0][0];

    // Updated query to use is_admin and is_agent
    const userResult = await db.fetchAll(
      `SELECT 
        u.id,
        u.email,
        u.organization_id,
        u.is_admin,
        u.is_agent,
        u.first_name,
        u.last_name,
        u.is_active,
        u.phone,
        u.signature,
        u.use_org_sender_details,
        u.booking_link,
        o.name as organization_name
       FROM users u
       JOIN organizations o ON u.organization_id = o.id 
       WHERE u.id = ?`,
      [userId]
    );

    if (!userResult || userResult.length === 0) {
      logger.warn('No user found for session');
      return null;
    }

    const user = {
      id: userResult[0][0],
      email: userResult[0][1],
      organization_id: userResult[0][2],
      is_admin: Boolean(userResult[0][3]),
      is_agent: Boolean(userResult[0][4]),
      first_name: userResult[0][5],
      last_name: userResult[0][6],
      is_active: userResult[0][7],
      phone: userResult[0][8],
      signature: userResult[0][9],
      use_org_sender_details: Boolean(userResult[0][10]),
      booking_link: userResult[0][11],
      organization_name: userResult[0][12]
    };

    return user;
  }
}

export async function validateSession(sessionId: string): Promise<User | null> {
  logger.info(`Validating session: ${sessionId}`);
  
  const db = new Database();

  // Get the session
  const session = await db.fetchOne<{
    id: string;
    user_id: number;
    expires_at: string;
  }>('SELECT * FROM sessions WHERE id = ?', [sessionId]);

  logger.info(`Session lookup result: ${session ? JSON.stringify(session) : 'not found'}`);

  if (!session) {
    logger.warn('No session found in database');
    return null;
  }

  // Check if session is expired
  const expiresAt = new Date(session.expires_at);
  const now = new Date();
  logger.info(`Session expires: ${expiresAt}, current time: ${now}`);

  if (expiresAt < now) {
    logger.warn('Session is expired');
    await db.execute('DELETE FROM sessions WHERE id = ?', [sessionId]);
    return null;
  }

  // Get the user associated with this session with updated columns
  const user = await db.fetchOne<User>(
    `SELECT 
      u.id,
      u.email,
      u.organization_id,
      u.is_admin,
      u.is_agent,
      u.first_name,
      u.last_name,
      u.is_active,
      u.phone,
      o.name as organization_name 
     FROM users u
     JOIN organizations o ON u.organization_id = o.id 
     WHERE u.id = ?`,
    [session.user_id]
  );

  logger.info(`User lookup result: ${user ? JSON.stringify(user) : 'not found'}`);

  return user;
}

export function generateToken(): string {
  return crypto.randomBytes(32).toString('hex');
}

export async function getUserFromSession(request: Request) {
  try {
    // Check for X-Bypass-Auth header
    const bypassAuth = request.headers.get('X-Bypass-Auth');
    if (bypassAuth) {
      logger.info(`Bypassing auth check due to X-Bypass-Auth header`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Check if this is a public endpoint that should bypass auth
    const url = new URL(request.url);
    const pathname = url.pathname;
    
    // Log all requested pathnames for debugging
    logger.info(`Auth check for pathname: ${pathname}`);
    
    // COMPREHENSIVE SPA ROUTES CHECK - any frontend route should bypass auth
    // Check for non-API paths with no file extension (SPA routes)
    if (!pathname.startsWith('/api/') && 
        !pathname.includes('.')) {
      logger.info(`[AUTH BYPASS] SPA route detected (non-API, no extension): ${pathname}`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Explicit checks for known SPA routes
    if (pathname.startsWith('/compare/') || 
        pathname.startsWith('/quote/') || 
        pathname.startsWith('/eligibility') ||
        pathname.startsWith('/schedule')) {
      logger.info(`[AUTH BYPASS] Known SPA route detected: ${pathname}`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Skip auth for subscription/checkout endpoint
    if (pathname === '/api/subscription/checkout') {
      logger.info('Skipping auth check for subscription/checkout endpoint');
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Skip auth for all self-service endpoints
    if (pathname.startsWith('/api/self-service/')) {
      logger.info(`Skipping auth check for self-service endpoint: ${pathname}`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }
    
    // Skip auth check for static files
    if (
      pathname.endsWith('.js') || 
      pathname.endsWith('.css') || 
      pathname.endsWith('.png') || 
      pathname.endsWith('.jpg') || 
      pathname.endsWith('.svg') || 
      pathname.endsWith('.ico') ||
      pathname.endsWith('.ttf') ||
      pathname.endsWith('.woff') ||
      pathname.endsWith('.woff2')
    ) {
      logger.info(`Skipping auth check for static file: ${pathname}`);
      return { 
        skip_auth: true,
        id: 1,
        email: 'bypass@example.com',
        organization_id: 1,
        is_admin: true,
        is_agent: true,
        first_name: 'Auth',
        last_name: 'Bypass',
        is_active: true,
        organization_name: 'Bypass Org'
      };
    }

    const cookieHeader = request.headers.get('Cookie') || '';

    // Get session cookie
    const sessionId = cookieHeader.split('session=')[1]?.split(';')[0];
    
    if (!sessionId) {
      logger.warn('No session cookie found');
      return null;
    }

    // Initialize database
    const db = new Database();

    // Get session data
    const sessionResult = await db.fetchAll(
      'SELECT user_id FROM sessions WHERE id = ?',
      [sessionId]
    );

    if (!sessionResult || sessionResult.length === 0) {
      logger.warn(`No session found for ID: ${sessionId}`);
      return null;
    }

    const userId = sessionResult[0][0];

    // Updated query to use is_admin and is_agent
    const userResult = await db.fetchAll(
      `SELECT 
        u.id,
        u.email,
        u.organization_id,
        u.is_admin,
        u.is_agent,
        u.first_name,
        u.last_name,
        u.is_active,
        u.phone,
        u.signature,
        u.use_org_sender_details,
        u.booking_link,
        o.name as organization_name
       FROM users u
       JOIN organizations o ON u.organization_id = o.id 
       WHERE u.id = ?`,
      [userId]
    );

    if (!userResult || userResult.length === 0) {
      logger.warn('No user found for session');
      return null;
    }

    const user = {
      id: userResult[0][0],
      email: userResult[0][1],
      organization_id: userResult[0][2],
      is_admin: Boolean(userResult[0][3]),
      is_agent: Boolean(userResult[0][4]),
      first_name: userResult[0][5],
      last_name: userResult[0][6],
      is_active: userResult[0][7],
      phone: userResult[0][8],
      signature: userResult[0][9],
      use_org_sender_details: Boolean(userResult[0][10]),
      booking_link: userResult[0][11],
      organization_name: userResult[0][12]
    };

    return user;

  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

================
File: backend/src/services/contactCount.ts
================
import { Database } from '../database';
import { logger } from '../logger';

/**
 * Updates the contact count for a user and handles subscription tier changes if needed
 */
export async function updateContactCount(userId: string, totalContacts: number): Promise<{
  success: boolean;
  error?: string;
}> {
  const db = new Database();
  
  try {
   
    // Update the contact count in the database
    await upsertContactCount(userId, totalContacts);

    // Check if auto-upgrade is enabled
    const user = await db.fetchOne<{ auto_upgrade_limit: number }>(
      'SELECT user_id FROM users WHERE id = ?',
      [userId]
    );
    
    if (!user) {
      return {
        success: false,
        error: 'User not found',
      };
    }
  } catch (error) {
    logger.error(`Error updating contact count for user ${userId}: ${error}`);
    return {
      success: false,
      error: 'Failed to update contact count',
    };
  }
  
  // Return success if no errors occurred
  return {
    success: true
  };
}

/**
 * Updates or inserts a contact count record for a user
 */
export async function upsertContactCount(userId: string, count: number): Promise<void> {
  const db = new Database();
  
  try {
    // Check if a record already exists
    const existingCount = await db.fetchOne<{ count: number }>(
      'SELECT count FROM contact_counts WHERE user_id = ?',
      [userId]
    );
    
    if (existingCount) {
      // Update existing record
      await db.execute(
        'UPDATE contact_counts SET count = ?, last_updated = CURRENT_TIMESTAMP WHERE user_id = ?',
        [count, userId]
      );
    } else {
      // Insert new record
      await db.execute(
        'INSERT INTO contact_counts (user_id, count, last_updated) VALUES (?, ?, CURRENT_TIMESTAMP)',
        [userId, count]
      );
    }
    
    logger.info(`Updated contact count for user ${userId} to ${count}`);
  } catch (error) {
    logger.error(`Error upserting contact count for user ${userId}:`, error);
    throw error;
  }
}

/**
 * Gets the current contact count for a user
 */
export async function getContactCount(userId: string): Promise<number> {
  const db = new Database();
  
  try {
    const countRecord = await db.fetchOne<{ count: number }>(
      'SELECT count FROM contact_counts WHERE user_id = ?',
      [userId]
    );
    
    return countRecord?.count || 0;
  } catch (error) {
    logger.error(`Error getting contact count for user ${userId}:`, error);
    throw error;
  }
}

/**
 * Gets the current subscription tier limit for a user
 */
export async function getContactLimit(userId: string): Promise<number> {
  const db = new Database();
  
  try {
    const subscription = await db.fetchOne<{ tier: number }>(
      'SELECT tier FROM subscriptions WHERE user_id = ? AND status = "active" ORDER BY created_at DESC LIMIT 1',
      [userId]
    );
    
    // Each tier represents 500 contacts
    return subscription ? subscription.tier * 500 : 0;
  } catch (error) {
    logger.error(`Error getting contact limit for user ${userId}:`, error);
    throw error;
  }
}

/**
 * Updates the auto-upgrade limit for a user
 */
export async function updateAutoUpgradeLimit(userId: string, limit: number): Promise<boolean> {
  const db = new Database();
  
  try {
    await db.execute(
      'UPDATE users SET auto_upgrade_limit = ? WHERE id = ?',
      [limit, userId]
    );
    
    logger.info(`Updated auto-upgrade limit for user ${userId} to ${limit}`);
    return true;
  } catch (error) {
    logger.error(`Error updating auto-upgrade limit for user ${userId}:`, error);
    return false;
  }
}

/**
 * Checks if adding a specified number of contacts would exceed the user's current tier
 */
export async function checkContactAddition(userId: string, additionalContacts: number): Promise<{
  canAdd: boolean;
  currentCount: number;
  limit: number;
  newTotal: number;
  requiredTier: number;
  currentTier: number;
}> {
  const db = new Database();
  
  try {
    // Get the current count
    const currentCount = await getContactCount(userId);
    
    // Get the current tier
    const subscription = await db.fetchOne<{ tier: number }>(
      'SELECT tier FROM subscriptions WHERE user_id = ? AND status = "active" ORDER BY created_at DESC LIMIT 1',
      [userId]
    );
    
    const currentTier = subscription?.tier || 0;
    const limit = currentTier * 500;
    const newTotal = currentCount + additionalContacts;
    const requiredTier = Math.ceil(newTotal / 500);
    
    return {
      canAdd: newTotal <= limit,
      currentCount,
      limit,
      newTotal,
      requiredTier,
      currentTier,
    };
  } catch (error) {
    logger.error(`Error checking contact addition for user ${userId}:`, error);
    throw error;
  }
}

================
File: backend/src/services/contactTracking.ts
================
/**
 * Contact Tracking Service
 * 
 * This service handles tracking unique contacts for usage-based billing.
 * It ensures that:
 * 1. Each unique contact is only counted once per billing cycle
 * 2. Contact counts are properly reported to Stripe
 * 3. Organizations can see their current usage
 */

import { Database } from '../database';
import { logger } from '../logger';
import { reportContactUsage } from './stripe';
import { v4 as uuidv4 } from 'uuid';

/**
 * Generate a unique ID for database records
 */
function generateId(): string {
  return uuidv4();
}

/**
 * Get the current billing cycle key for an organization
 * Format: YYYY-MM for monthly cycles
 */
export async function getCurrentBillingCycle(organizationId: string): Promise<string> {
  const db = new Database();
  
  try {
    // Check if organization has a current billing cycle
    const org = await db.fetchOne<{
      current_billing_cycle_key: string | null;
      contact_count_billing_date: string | null;
    }>('SELECT current_billing_cycle_key, contact_count_billing_date FROM organizations WHERE id = ?', [organizationId]);
    
    if (!org) {
      throw new Error(`Organization not found: ${organizationId}`);
    }
    
    // If organization has a current billing cycle, return it
    if (org.current_billing_cycle_key) {
      return org.current_billing_cycle_key;
    }
    
    // If not, create a new billing cycle
    const now = new Date();
    const cycleKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
    
    // Determine billing start date (default to 1st of month if not set)
    const billingDay = org.contact_count_billing_date || '01';
    const month = now.getMonth();
    const year = now.getFullYear();
    
    // Create start and end dates for the cycle
    const startDate = new Date(year, month, parseInt(billingDay, 10));
    const endDate = new Date(year, month + 1, parseInt(billingDay, 10));
    
    // Handle case where current date is before billing day in current month
    if (now.getDate() < parseInt(billingDay, 10)) {
      startDate.setMonth(startDate.getMonth() - 1);
      endDate.setMonth(endDate.getMonth() - 1);
    }
    
    // Create the billing cycle record
    await db.execute(`
      INSERT INTO billing_cycle_history (
        id, organization_id, cycle_key, start_date, end_date
      ) VALUES (?, ?, ?, ?, ?)
    `, [
      generateId(),
      organizationId,
      cycleKey,
      startDate.toISOString(),
      endDate.toISOString()
    ]);
    
    // Update the organization with the new billing cycle
    await db.execute(`
      UPDATE organizations 
      SET current_billing_cycle_key = ? 
      WHERE id = ?
    `, [cycleKey, organizationId]);
    
    logger.info(`Created new billing cycle ${cycleKey} for organization ${organizationId}`);
    
    return cycleKey;
  } catch (error) {
    logger.error(`Error getting current billing cycle: ${error}`);
    throw error;
  }
}

/**
 * Track a contact upload to ensure it's counted properly for billing
 */
export async function trackContact(
  organizationId: string, 
  userId: string, 
  contactEmail: string, 
  firstName?: string, 
  lastName?: string
): Promise<{ isNew: boolean; contactId: string }> {
  const db = new Database();
  
  try {
    // Validate inputs
    if (!organizationId || !userId || !contactEmail) {
      throw new Error('Missing required parameters for contact tracking');
    }
    
    // Normalize email for consistent lookups
    const normalizedEmail = contactEmail.trim().toLowerCase();
    
    // Get current billing cycle
    const billingCycle = await getCurrentBillingCycle(organizationId);
    
    // Check if contact already exists in this organization
    const existingContact = await db.fetchOne<{ id: string; billing_cycle_key: string | null }>(
      'SELECT id, billing_cycle_key FROM contact_history WHERE organization_id = ? AND email = ?',
      [organizationId, normalizedEmail]
    );
    
    let isNew = false;
    let contactId: string;
    
    if (existingContact) {
      // Contact exists - update last_uploaded timestamp
      contactId = existingContact.id;
      await db.execute(`
        UPDATE contact_history 
        SET last_uploaded = CURRENT_TIMESTAMP,
            first_name = COALESCE(?, first_name),
            last_name = COALESCE(?, last_name)
        WHERE id = ?
      `, [
        firstName || null,
        lastName || null,
        contactId
      ]);
      
      // If contact was from a different billing cycle, count it as new for this cycle
      if (existingContact.billing_cycle_key !== billingCycle) {
        isNew = true;
        await db.execute(`
          UPDATE contact_history 
          SET billing_cycle_key = ? 
          WHERE id = ?
        `, [billingCycle, contactId]);
      }
    } else {
      // New contact - insert into history
      isNew = true;
      contactId = generateId();
      
      await db.execute(`
        INSERT INTO contact_history (
          id, organization_id, user_id, email, first_name, last_name, billing_cycle_key
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `, [
        contactId,
        organizationId,
        userId,
        normalizedEmail,
        firstName || null,
        lastName || null,
        billingCycle
      ]);
    }
    
    // If this is a new contact for this billing cycle, increment the count
    if (isNew) {
      await incrementUniqueContactCount(organizationId);
    }
    
    return { isNew, contactId };
  } catch (error) {
    logger.error(`Error tracking contact: ${error}`);
    throw error;
  }
}

/**
 * Track a batch of contacts
 */
export async function trackContactBatch(
  organizationId: string,
  userId: string,
  contacts: Array<{ email: string; firstName?: string; lastName?: string }>
): Promise<{ newCount: number; totalProcessed: number }> {
  const db = new Database();
  
  try {
    let newCount = 0;
    const totalProcessed = contacts.length;
    
    // Process contacts in batches to avoid transaction timeouts
    const batchSize = 100;
    for (let i = 0; i < contacts.length; i += batchSize) {
      const batch = contacts.slice(i, i + batchSize);
      
      await db.transaction('write', async (tx) => {
        for (const contact of batch) {
          const result = await trackContact(
            organizationId,
            userId,
            contact.email,
            contact.firstName,
            contact.lastName
          );
          
          if (result.isNew) {
            newCount++;
          }
        }
      });
      
      logger.info(`Processed ${i + batch.length}/${totalProcessed} contacts for organization ${organizationId}`);
    }
    
    // Get total unique contacts in current billing cycle
    const uniqueCount = await getUniqueContactCount(organizationId);
    
    // Report usage to Stripe
    await updateStripeUsage(organizationId, uniqueCount);
    
    return { newCount, totalProcessed };
  } catch (error) {
    logger.error(`Error tracking contact batch: ${error}`);
    throw error;
  }
}

/**
 * Increment the unique contact count for an organization
 */
async function incrementUniqueContactCount(organizationId: string): Promise<number> {
  const db = new Database();
  
  try {
    // Get current unique contact count
    const org = await db.fetchOne<{ current_unique_contacts: number }>(
      'SELECT current_unique_contacts FROM organizations WHERE id = ?',
      [organizationId]
    );
    
    if (!org) {
      throw new Error(`Organization not found: ${organizationId}`);
    }
    
    // Increment the count
    const newCount = (org.current_unique_contacts || 0) + 1;
    
    // Update the organization
    await db.execute(`
      UPDATE organizations 
      SET current_unique_contacts = ? 
      WHERE id = ?
    `, [newCount, organizationId]);
    
    // Update the billing cycle history
    const billingCycle = await getCurrentBillingCycle(organizationId);
    await db.execute(`
      UPDATE billing_cycle_history 
      SET contact_count = ? 
      WHERE organization_id = ? AND cycle_key = ?
    `, [newCount, organizationId, billingCycle]);
    
    return newCount;
  } catch (error) {
    logger.error(`Error incrementing unique contact count: ${error}`);
    throw error;
  }
}

/**
 * Get the count of unique contacts in the current billing cycle
 */
export async function getUniqueContactCount(organizationId: string): Promise<number> {
  const db = new Database();
  
  try {
    // Get current billing cycle
    const billingCycle = await getCurrentBillingCycle(organizationId);
    
    // Get unique contact count for this cycle
    const result = await db.fetchOne<{ count: number }>(
      'SELECT COUNT(*) as count FROM contact_history WHERE organization_id = ? AND billing_cycle_key = ?',
      [organizationId, billingCycle]
    );
    
    return result ? result.count : 0;
  } catch (error) {
    logger.error(`Error getting unique contact count: ${error}`);
    throw error;
  }
}

/**
 * Get the subscription info and update Stripe usage
 */
async function updateStripeUsage(organizationId: string, contactCount: number): Promise<void> {
  const db = new Database();
  
  try {
    // Get the organization's Stripe subscription info
    const org = await db.fetchOne<{ 
      id: number;
      stripe_subscription_id: string;
    }>('SELECT id, stripe_subscription_id FROM organizations WHERE id = ?', [organizationId]);
    
    if (!org || !org.stripe_subscription_id) {
      logger.info(`Organization ${organizationId} has no Stripe subscription, skipping usage update`);
      return;
    }
    
    // Get the subscription item for usage reporting
    const subscriptionItem = await db.fetchOne<{ stripe_usage_item_id: string }>(
      'SELECT stripe_usage_item_id FROM subscriptions WHERE stripe_subscription_id = ? AND status = "active" LIMIT 1',
      [org.stripe_subscription_id]
    );
    
    if (!subscriptionItem || !subscriptionItem.stripe_usage_item_id) {
      logger.warn(`No active subscription item found for organization ${organizationId}`);
      return;
    }
    
    // Calculate the number of 500-contact blocks beyond the initial 500
    const additionalBlocks = Math.max(0, Math.ceil((contactCount - 500) / 500));
    
    // Report usage to Stripe
    await reportContactUsage(subscriptionItem.stripe_usage_item_id, additionalBlocks);
    
    logger.info(`Reported usage of ${additionalBlocks} additional contact blocks for organization ${organizationId}`);
    
    // Mark the billing cycle as reported
    const billingCycle = await getCurrentBillingCycle(organizationId);
    await db.execute(`
      UPDATE billing_cycle_history 
      SET usage_reported = TRUE 
      WHERE organization_id = ? AND cycle_key = ?
    `, [organizationId, billingCycle]);
  } catch (error) {
    logger.error(`Error updating Stripe usage: ${error}`);
    throw error;
  }
}

/**
 * Get contact usage stats for an organization
 */
export async function getContactUsageStats(organizationId: string): Promise<{
  currentCycle: string;
  uniqueContacts: number;
  billingCycleStart: string;
  billingCycleEnd: string;
  contactsRemaining: number;
  isOverLimit: boolean;
}> {
  const db = new Database();
  
  try {
    // Get current billing cycle
    const billingCycle = await getCurrentBillingCycle(organizationId);
    
    // Get billing cycle details
    const cycle = await db.fetchOne<{
      start_date: string;
      end_date: string;
      contact_count: number;
    }>(`
      SELECT start_date, end_date, contact_count 
      FROM billing_cycle_history 
      WHERE organization_id = ? AND cycle_key = ?
    `, [organizationId, billingCycle]);
    
    if (!cycle) {
      throw new Error(`Billing cycle not found for organization ${organizationId}`);
    }
    
    // Calculate remaining contacts in the base tier (500)
    const contactsRemaining = Math.max(0, 500 - cycle.contact_count);
    const isOverLimit = cycle.contact_count > 500;
    
    return {
      currentCycle: billingCycle,
      uniqueContacts: cycle.contact_count,
      billingCycleStart: cycle.start_date,
      billingCycleEnd: cycle.end_date,
      contactsRemaining,
      isOverLimit
    };
  } catch (error) {
    logger.error(`Error getting contact usage stats: ${error}`);
    throw error;
  }
}

/**
 * Reset contact count for a specific email (for admin/support use)
 */
export async function resetContactCount(
  organizationId: string,
  email: string,
  reason: string
): Promise<boolean> {
  const db = new Database();
  
  try {
    // Normalize email
    const normalizedEmail = email.trim().toLowerCase();
    
    // Find the contact
    const contact = await db.fetchOne<{ id: string }>(
      'SELECT id FROM contact_history WHERE organization_id = ? AND email = ?',
      [organizationId, normalizedEmail]
    );
    
    if (!contact) {
      logger.warn(`Contact not found for reset: ${email} in organization ${organizationId}`);
      return false;
    }
    
    // Set the status to deleted
    await db.execute(`
      UPDATE contact_history 
      SET status = 'deleted' 
      WHERE id = ?
    `, [contact.id]);
    
    // Log the operation for audit purposes
    await db.execute(`
      INSERT INTO admin_action_log (
        id, organization_id, action, details, reason
      ) VALUES (?, ?, ?, ?, ?)
    `, [
      generateId(),
      organizationId,
      'reset_contact',
      JSON.stringify({ email: normalizedEmail }),
      reason
    ]);
    
    // Recalculate the contact count
    await recalculateContactCount(organizationId);
    
    return true;
  } catch (error) {
    logger.error(`Error resetting contact count: ${error}`);
    throw error;
  }
}

/**
 * Recalculate contact count for an organization
 */
async function recalculateContactCount(organizationId: string): Promise<number> {
  const db = new Database();
  
  try {
    // Get current billing cycle
    const billingCycle = await getCurrentBillingCycle(organizationId);
    
    // Count active contacts in current billing cycle
    const result = await db.fetchOne<{ count: number }>(
      'SELECT COUNT(*) as count FROM contact_history WHERE organization_id = ? AND billing_cycle_key = ? AND status = "active"',
      [organizationId, billingCycle]
    );
    
    const count = result ? result.count : 0;
    
    // Update the organization
    await db.execute(`
      UPDATE organizations 
      SET current_unique_contacts = ? 
      WHERE id = ?
    `, [count, organizationId]);
    
    // Update the billing cycle history
    await db.execute(`
      UPDATE billing_cycle_history 
      SET contact_count = ? 
      WHERE organization_id = ? AND cycle_key = ?
    `, [count, organizationId, billingCycle]);
    
    // Update Stripe usage
    await updateStripeUsage(organizationId, count);
    
    return count;
  } catch (error) {
    logger.error(`Error recalculating contact count: ${error}`);
    throw error;
  }
}

================
File: backend/src/services/email.ts
================
import sgMail from '@sendgrid/mail';
import { logger } from '../logger';
import crypto from 'crypto';
import { Database } from '../database';
import { generateTrackingId, addTrackingToUrl } from '../utils/tracking';
import twilio from 'twilio';

interface MagicLinkEmailParams {
  email: string;
  token: string;
  orgId: number;
  name: string;
}

interface EmailTrackingRecord {
  orgId: number;
  contactId: string | number;
  emailType: string;
  sendStatus: 'pending' | 'processing' | 'accepted' | 'delivered' | 'sent' | 'deferred' | 'bounced' | 'dropped' | 'failed' | 'skipped';
  sendMode: 'test' | 'production';
  testEmail?: string;
  batchId: string;
  messageId?: string;
}

export class EmailService {
  constructor() {
    if (!process.env.SENDGRID_API_KEY) {
      throw new Error('Missing SENDGRID_API_KEY environment variable');
    }
    sgMail.setApiKey(process.env.SENDGRID_API_KEY);
  }

  /**
   * Generates a tracking ID for an email link
   * Format: tid-[orgId]-[contactId]-[timestamp]
   * @param orgId Organization ID
   * @param contactId Contact ID
   * @returns Tracking ID string
   */
  generateTrackingId(orgId: number | string, contactId: number | string): string {
    return generateTrackingId(orgId, contactId, 'em');
  }

  /**
   * Records an email send in the email_send_tracking table
   * @param orgDb Organization database instance
   * @param tracking Email tracking data
   * @returns Result of the database operation
   */
  async recordEmailSend(orgDb: Database, tracking: EmailTrackingRecord): Promise<any> {
    try {
      const now = new Date().toISOString();
      
      return await orgDb.execute(
        `INSERT INTO email_send_tracking (
          org_id, 
          contact_id, 
          email_type, 
          scheduled_date, 
          send_status,
          send_mode,
          test_email,
          batch_id,
          message_id,
          last_attempt_date
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          tracking.orgId,
          tracking.contactId.toString(),
          tracking.emailType,
          now,
          tracking.sendStatus,
          tracking.sendMode,
          tracking.testEmail || null,
          tracking.batchId,
          tracking.messageId || null,
          now
        ]
      );
    } catch (error) {
      logger.error(`Error recording email send: ${error}`);
      throw new Error(`Failed to record email send: ${error}`);
    }
  }

  async sendMagicLink(email: string, magicLink: string, organizationSlug: string) {
    try {
      const fromEmail = process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai';
      const msg = {
        to: email,
        from: {
          email: fromEmail,
          name: organizationSlug ? organizationSlug.charAt(0).toUpperCase() + organizationSlug.slice(1) : 'MedicareMax'
        },
        subject: 'Your Login Link',
        text: `Click this link to log in: ${magicLink}\n\nThis link will expire in 30 minutes.`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">Welcome to MedicareMax</h2>
            <p>Click the button below to log in to your account. This link will expire in 30 minutes.</p>
            <div style="margin: 30px 0;">
              <a href="${magicLink}" 
                 style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                        text-decoration: none; border-radius: 4px; display: inline-block;">
                Log In
              </a>
            </div>
            <p style="color: #666; font-size: 14px;">
              If the button doesn't work, copy and paste this link into your browser:
              <br>
              <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
            </p>
          </div>
        `
      };

      await sgMail.send(msg);
      logger.info(`Magic link email sent successfully to ${email}`);
    } catch (error) {
      logger.error(`Error sending magic link email: ${error}`);
      throw new Error('Failed to send magic link email');
    }
  }

  async sendQuoteEmail(params: {
    email: string;
    firstName: string;
    lastName: string;
    quoteUrl: string;
    planType: string;
    organization?: {
      id?: number;
      name?: string;
      logo_data?: string;
      primary_color?: string;
      phone?: string;
      website?: string;
    };
    phone?: string;
    contactId?: number | string;
  }) {
    try {
      const { email, firstName, lastName, quoteUrl, planType, organization } = params;
      const fullName = `${firstName} ${lastName}`;
      const orgName = organization?.name || '';
      const primaryColor = organization?.primary_color || '#4F46E5';
      const phone = organization?.phone || '';
      const website = organization?.website || '';
      const websiteUrl = website.startsWith('http') ? website : `https://${website}`;
      
      // Generate tracking ID if organization and contactId are available
      let trackedQuoteUrl = quoteUrl;
      if (organization?.id && params.contactId) {
        const trackingId = this.generateTrackingId(organization.id, params.contactId);
        
        // Add tracking ID to quote URL
        trackedQuoteUrl = addTrackingToUrl(quoteUrl, trackingId);
        
        logger.info(`Added tracking ID ${trackingId} to quote URL for contact ${params.contactId}`);
      }
      
      // Format phone number if present
      const formatPhoneNumber = (phoneStr: string): string => {
        // Remove any non-digit characters
        const digitsOnly = phoneStr.replace(/\D/g, '');
        if (digitsOnly.length === 10) {
          return `(${digitsOnly.substring(0, 3)}) ${digitsOnly.substring(3, 6)}-${digitsOnly.substring(6)}`;
        } else if (digitsOnly.length === 11 && digitsOnly.startsWith('1')) {
          return `(${digitsOnly.substring(1, 4)}) ${digitsOnly.substring(4, 7)}-${digitsOnly.substring(7)}`;
        }
        // Return original if not a standard format
        return phoneStr;
      };
      
      // Format phone number to E.164 format for Twilio
      const formatE164 = (phoneStr: string): string => {
        // Remove any non-digit characters
        const digitsOnly = phoneStr.replace(/\D/g, '');
        // Handle US numbers
        if (digitsOnly.length === 10) {
          return `+1${digitsOnly}`;
        } else if (digitsOnly.length === 11 && digitsOnly.startsWith('1')) {
          return `+${digitsOnly}`;
        }
        // Return with + prefix if not matching expected formats
        return `+${digitsOnly}`;
      };
      
      const formattedPhone = phone ? formatPhoneNumber(phone) : '';
      const e164Phone = phone ? formatE164(phone) : '';
      
      const fromEmail = process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai';
      
      // Prepare email message
      const msg: any = {
        to: email,
        from: {
          email: fromEmail,
          name: orgName || 'MedicareMax'
        },
        subject: 'Your Personalized Medicare Quote',
        text: `Hello ${fullName},\n\nWe recently reviewed Medigap premiums for your zip code and found some options that might interest you. These plans offer the same comprehensive benefits you currently enjoy, potentially at a better value. We've done the research to find plans that maintain your coverage while possibly reducing your costs.\n\nReview your options here: ${trackedQuoteUrl}\n\nMany Medicare beneficiaries don't realize they can be paying different rates for identical coverage. We'd be happy to show you your options and potential savings. If we don't find a better value now, we'll keep monitoring rates and reach out when we find something promising.\n\nIf you have any questions, please give me a call: ${formattedPhone}\n\nBest,\n${orgName}\nYour Medicare Specialist\n${formattedPhone}`,
        attachments: []
      };
      
      // Handle logo as attachment if present
      let logoHtml = '';
      if (organization?.logo_data) {
        // Extract the base64 content, removing data URL prefix if present
        let logoBase64 = organization.logo_data;
        if (logoBase64.startsWith('data:image/')) {
          const base64Parts = logoBase64.split(',');
          if (base64Parts.length > 1) {
            logoBase64 = base64Parts[1];
          }
        }
        
        // Add as attachment with content ID
        msg.attachments.push({
          content: logoBase64,
          filename: 'organization-logo.png',
          type: 'image/png',
          disposition: 'inline',
          content_id: 'organizationLogo'
        });
        
        // Reference the content ID in HTML
        logoHtml = `<div class="logo">
          <img src="cid:organizationLogo" alt="${orgName} Logo" width="160" 
               style="max-width: 250px; height: auto; margin-bottom: 25px; display: block; object-fit: contain; border: 0; outline: none;" />
        </div>`;
      } else {
        // Fallback if no logo
        logoHtml = `<div class="logo" style="margin-bottom: 25px;">
          <h1 style="font-size: 24px; font-weight: bold; color: ${primaryColor}; margin: 0;">${orgName}</h1>
        </div>`;
      }
      
      // Set HTML content
      msg.html = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
          <title>Your Medicare Coverage Update</title>
          <style type="text/css">
            /* GLOBAL RESETS */
            body {
              margin: 0;
              padding: 0;
              background-color: #f8f8f8;
              font-family: Arial, sans-serif;
            }
            table {
              border-collapse: collapse;
            }
            img {
              display: block;
              border: 0;
              outline: none;
              text-decoration: none;
              -ms-interpolation-mode: bicubic;
            }
            a {
              text-decoration: none;
              color: inherit;
            }
            h1, h2, h3, h4, h5, h6 {
              margin: 0;
              padding: 0;
              font-weight: bold;
            }

            /* CONTAINER STYLES */
            .email-container {
              width: 100%;
              max-width: 600px;
              background-color: #ffffff;
              border-radius: 8px;
              overflow: hidden;
            }

            /* CONTENT STYLES */
            .content {
              padding: 30px 40px;
              text-align: left;
              color: #333333;
              font-size: 16px;
              line-height: 24px;
            }
            .logo img {
              max-width: 100px;
              margin-bottom: 20px;
              display: block;
            }
            .message {
              margin: 0 0 30px 0;
            }
            /* BUTTON STYLES */
            .button-wrapper {
              text-align: left;
              margin-top: 20px;
              margin-bottom: 25px;
            }
            .cta-button {
              color: #ffffff !important;
              padding: 14px 28px;
              font-size: 16px;
              font-weight: bold;
              border-radius: 4px;
              display: inline-block;
              text-decoration: none;
              box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
          </style>
        </head>
        <body style="margin:0; padding:0; background-color:#f8f8f8;">
          <table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#f8f8f8">
            <tr>
              <td align="center" style="padding: 40px 0;">
                <table class="email-container" border="0" cellspacing="0" cellpadding="0">
                  <tr>
                    <td>
                      <div class="content">
                        ${logoHtml}
                        
                        <div class="message">
                          <p>Hi ${firstName},</p>
                          <p>We recently reviewed Medigap premiums for your zip code and found some options that might interest you.</p>
                          <p>These plans offer the same comprehensive benefits you currently enjoy, potentially at a better value. We've done the research to find plans that maintain your coverage while possibly reducing your costs.</p>
                        </div>
                        
                        <div class="button-wrapper">
                          <a href="${trackedQuoteUrl}" target="_blank" class="cta-button" style="background-color:rgb(3, 3, 20); color: #ffffff !important; text-decoration: none; font-weight: bold;">  
                            Review Your Medicare Options
                          </a>
                        </div>
                        
                        <div class="message" style="margin-top: 30px;">
                          <p>Many Medicare beneficiaries don't realize they can be paying different rates for identical coverage. We'd be happy to show you your options and potential savings. If we don't find a better value now, we'll keep monitoring rates and reach out when we find something promising.</p>
                          ${formattedPhone ? `<p>If you have any questions, give me a call: ${formattedPhone}</p>` : ''}
                          <p style="margin-top: 25px; margin-bottom: 5px;">
                            Best,<br>
                            <strong>${orgName}</strong><br>
                            Your Medicare Specialist<br>
                            ${formattedPhone ? `<span style="color: #444;">${formattedPhone}</span>` : ''}
                          </p>
                        </div>

                        <div style="font-size: 12px; color: #666666; margin-top: 30px; padding-top: 15px; border-top: 1px solid #eeeeee;">
                          <p style="margin: 5px 0;">
                            #${orgName ? orgName : ''}<br>
                            ${formattedPhone ? `Phone: <a href="tel:${phone}" style="color: #0066cc; text-decoration: none;">${formattedPhone}</a><br>` : ''}
                            ${website ? `Website: <a href="${websiteUrl}" target="_blank" style="color: #0066cc; text-decoration: underline;">${website}</a>` : ''}
                          </p>
                        </div>
                      </div>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </body>
        </html>
      `;
      
      const result = await sgMail.send(msg);
      logger.info(`Quote email sent successfully to ${email}`);

      // also send out text via twilio / mds endpoint
      
      
      // const tempRetoolEndpoint = "https://api.retool.com/v1/workflows/2dfd31e1-b979-4f4d-a572-ca92879a3c09/startTrigger?workflowApiKey=retool_wk_e06f6026e4be4854bce04b77c90ee4c3"
      const msgContent = `
        Hi ${firstName}, this is the team from ${orgName}. We recently reviewed Medigap premiums for your zip code and found some options that might interest you. Click the link below to review your options:
        ${trackedQuoteUrl}  
      `

      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const authToken = process.env.TWILIO_AUTH_TOKEN;
      const client = twilio(accountSid, authToken);
      // Get client's phone number from params
      const clientPhone = params.phone;
      const clientE164Phone = clientPhone ? formatE164(clientPhone) : null;

      if (clientE164Phone) {
        logger.info(`clientE164Phone: ${clientE164Phone}`);
        /*
        const bodyToSend = {
          phone: clientE164Phone,
          firstName: firstName,
          quoteUrl: trackedQuoteUrl,
          orgName: orgName
        }
        logger.info(JSON.stringify(bodyToSend));
        
        const twilioResponse = await fetch(tempRetoolEndpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(bodyToSend)
        });
        */


        const twilioResponse = await client.messages.create({
          body: msgContent,
          from: process.env.TWILIO_PHONE_NUMBER,
          to: clientE164Phone
        });
        logger.info(`Text sent successfully to ${clientE164Phone}`);
        logger.info(JSON.stringify(twilioResponse));
      } else {
        logger.info('No client phone number provided - skipping text message');
      }

      // Return the SendGrid response and message ID if available
      return { 
        success: true,
        messageId: result && result[0] && result[0].headers ? result[0].headers['x-message-id'] : undefined
      };
    } catch (error) {
      logger.error(`Error sending quote email: ${error}`);
      throw new Error('Failed to send quote email');
    }
  }
}

// For the organization signup flow
export async function sendMagicLink({ email, magicLink, name }: {
  email: string;
  magicLink: string;
  name: string;
}) {
  try {
    const fromEmail = process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai';
    const msg = {
      to: email,
      from: {
        email: fromEmail,
        name: 'MedicareMax'
      },
      subject: 'Verify Your MedicareMax Account',
      text: `Hi ${name},\n\nClick this link to verify your account: ${magicLink}\n\nThis link will expire in 30 minutes.`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Welcome to MedicareMax</h2>
          <p>Hi ${name},</p>
          <p>Click the button below to verify your account and complete your organization setup. This link will expire in 30 minutes.</p>
          <div style="margin: 30px 0;">
            <a href="${magicLink}" 
               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 4px; display: inline-block;">
              Verify Account
            </a>
          </div>
          <p style="color: #666; font-size: 14px;">
            If the button doesn't work, copy and paste this link into your browser:
            <br>
            <a href="${magicLink}" style="color: #4F46E5;">${magicLink}</a>
          </p>
        </div>
      `
    };

    await sgMail.send(msg);
    logger.info('Magic link email sent successfully');
  } catch (error) {
    logger.error(`Failed to send magic link email: ${error}`);
    throw error;
  }
}

// Generate a hash for onboarding link validation
function generateHash(orgId: string, email: string): string {
  const SECRET = process.env.HASH_SECRET || 'default-hash-secret'; // Ensure this is set in your environment
  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
}

/**
 * Sends an onboarding link that includes organizationId, and optionally email and hash
 * @param orgId Organization ID to include in the link
 * @param email Optional email to include in the link and use as recipient
 * @param orgName Optional organization name to use as sender name
 */
export async function sendOnboardingLink(orgId: string, email?: string, orgName?: string) {
  try {
    // Base onboarding URL with orgId
    const baseUrl = process.env.FRONTEND_URL || 'https://medicaremax.ai';
    let onboardingUrl = `${baseUrl}/onboard?orgId=${orgId}`;
    
    // If email is provided, add email and hash to the URL
    if (email) {
      const hash = generateHash(orgId, email);
      onboardingUrl += `&email=${encodeURIComponent(email)}&hash=${hash}`;
    }
    
    const fromEmail = process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai';
    // Create email message
    const msg = {
      to: email || process.env.FALLBACK_EMAIL || 'information@medicaremax.ai', // Fallback if no email provided
      from: {
        email: fromEmail,
        name: orgName || 'MedicareMax'
      },
      subject: 'Join MedicareMax',
      text: `Click this link to create or update your profile: ${onboardingUrl}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Welcome to MedicareMax</h2>
          <p>Click the button below to create or update your profile:</p>
          <div style="margin: 30px 0;">
            <a href="${onboardingUrl}" 
               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 4px; display: inline-block;">
              Get Started
            </a>
          </div>
          <p style="color: #666; font-size: 14px;">
            If the button doesn't work, copy and paste this link into your browser:
            <br>
            <a href="${onboardingUrl}" style="color: #4F46E5;">${onboardingUrl}</a>
          </p>
          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
            <p style="color: #888; font-size: 14px;">
              If you have any questions, please don't hesitate to contact us.
              <br>
              The MedicareMax Team
            </p>
          </div>
        </div>
      `
    };

    await sgMail.send(msg);
    logger.info(`Onboarding link email sent successfully${email ? ` to ${email}` : ''}`);
    return { success: true };
  } catch (error) {
    logger.error(`Error sending onboarding link email: ${error}`);
    throw new Error('Failed to send onboarding link email');
  }
}

================
File: backend/src/services/stripe.ts
================
import Stripe from 'stripe';
import { config } from '../config';
import { logger } from '../logger';
import { Database } from '../database';
import { Elysia, t } from 'elysia';
import type { UserContext } from '../types';
import { requireAuth } from '../middleware/auth';

const stripe = new Stripe(config.stripeSecretKey, {
  apiVersion: '2025-02-24.acacia'
});

export type SubscriptionStatus = {
  isActive: boolean;
  tier: string;
  currentPeriodEnd?: number;
  cancelAtPeriodEnd?: boolean;
  paymentStatus: 'paid' | 'unpaid' | 'no_subscription';
};

export async function checkPaymentStatus(db: Database, organizationId: number): Promise<SubscriptionStatus> {
  // First check local database
  const org = await db.fetchOne<{
    stripe_customer_id: string;
    stripe_subscription_id: string;
    subscription_status: string;
    payment_completed: number;
  }>(
    'SELECT stripe_customer_id, stripe_subscription_id, subscription_status, payment_completed FROM organizations WHERE id = ?',
    [organizationId]
  );

  if (!org) {
    throw new Error('Organization not found');
  }

  // If payment is already marked as completed locally, no need to check Stripe
  if (org.payment_completed === 1) {
    return {
      isActive: org.subscription_status === 'active',
      tier: 'paid',
      paymentStatus: 'paid'
    };
  }

  // If no Stripe subscription yet, return unpaid status0
  if (!org.stripe_subscription_id) {
    return {
      isActive: false,
      tier: 'basic',
      paymentStatus: 'no_subscription'
    };
  }

  // Check Stripe for current status
  try {
    const subscription = await stripe.subscriptions.retrieve(org.stripe_subscription_id);
    
    // Update local payment_completed status if paid
    if (subscription.status === 'active' && !subscription.cancel_at_period_end) {
      await db.execute(
        'UPDATE organizations SET payment_completed = 1 WHERE id = ?',
        [organizationId]
      );
    }

    return {
      isActive: subscription.status === 'active',
      tier: subscription.items.data[0].price.nickname || 'paid',
      currentPeriodEnd: subscription.current_period_end,
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
      paymentStatus: subscription.status === 'active' ? 'paid' : 'unpaid'
    };
  } catch (error) {
    logger.error(`Error checking Stripe subscription status: ${error}`);
    return {
      isActive: false,
      tier: 'basic',
      paymentStatus: 'unpaid'
    };
  }
}

export async function activateSubscription(db: Database, organizationId: number): Promise<void> {
  await db.execute(
    'UPDATE organizations SET payment_completed = 1, subscription_status = ? WHERE id = ?',
    ['active', organizationId]
  );
}

export async function reportContactUsage(db: Database, organizationId: number): Promise<void> {
  const org = await db.fetchOne<{
    stripe_subscription_id: string;
    contact_count: number;
  }>(
    'SELECT stripe_subscription_id, (SELECT COUNT(*) FROM contacts WHERE organization_id = organizations.id) as contact_count FROM organizations WHERE id = ?',
    [organizationId]
  );

  if (!org?.stripe_subscription_id) {
    logger.info(`No subscription found for organization ${organizationId}`);
    return;
  }

  try {
    // Get subscription items to find the metered price item
    const subscription = await stripe.subscriptions.retrieve(org.stripe_subscription_id);
    const meteredItem = subscription.items.data.find(item => 
      item.price.id === config.stripe.prices.additionalContacts
    );

    if (!meteredItem) {
      logger.info(`No metered item found for subscription ${org.stripe_subscription_id}`);
      return;
    }

    // Report current contact count as usage
    await stripe.subscriptionItems.createUsageRecord(
      meteredItem.id,
      {
        quantity: org.contact_count,
        timestamp: Math.floor(Date.now() / 1000),
        action: 'set'
      }
    );

    logger.info(`Successfully reported contact usage for organization ${organizationId} (${org.contact_count} contacts)`);
  } catch (error) {
    logger.error(`Error reporting contact usage to Stripe: ${error}`);
    throw error;
  }
}

================
File: backend/src/services/subscription.ts
================
import { Database } from '../database';
import { logger } from '../logger';
import Stripe from 'stripe';
import { config } from '../config';

// Define possible account statuses
export type AccountStatus = 
  | 'good_standing'           // Everything is fine
  | 'inactive'                // Subscription inactive (canceled, past_due, etc.)
  | 'agent_limit_exceeded'    // Too many agents for current plan
  | 'contact_limit_exceeded'; // Too many contacts for current plan

export interface AccountStatusDetails {
  status: AccountStatus;
  message: string;
  organizationId: number;
  organizationName: string;
  organizationSlug: string;
  subscriptionTier: string;
  subscriptionStatus: string;
  agentLimit: number;
  contactLimit: number;
  currentAgentCount: number;
  currentContactCount: number;
  billingCycleEnd?: Date;
  paymentFailureCount: number;
  paymentCompleted: boolean;
}

/**
 * Updates organization subscription status from Stripe
 */
export async function syncSubscriptionStatus(organizationId: number): Promise<void> {
  const db = new Database();
  
  try {
    // Get organization details
    const orgResult = await db.execute(
      'SELECT stripe_subscription_id, stripe_customer_id FROM organizations WHERE id = ?', 
      [organizationId]
    );
    
    if (!orgResult.rows || orgResult.rows.length === 0) {
      logger.error(`Organization not found: ${organizationId}`);
      return;
    }
    
    const org = orgResult.rows[0];
    
    // If no Stripe subscription ID, nothing to sync
    if (!org[0]) {
      logger.info(`No Stripe subscription for organization ${organizationId}`);
      return;
    }
    
    // Initialize Stripe client
    const stripe = new Stripe(config.stripe.secretKey, {
      apiVersion: '2025-02-24.acacia' as Stripe.LatestApiVersion,
    });
    
    // Fetch the subscription from Stripe
    const subscription = await stripe.subscriptions.retrieve(org[0]);
    
    // Map Stripe status to our status
    let subscriptionStatus = 'active';
    if (subscription.status === 'active' || subscription.status === 'trialing') {
      subscriptionStatus = 'active';
    } else if (subscription.status === 'past_due') {
      subscriptionStatus = 'past_due';
    } else {
      subscriptionStatus = 'inactive';
    }
    
    // Get the billing cycle end
    const billingCycleEnd = new Date(subscription.current_period_end * 1000);
    
    // Get trial end if applicable
    const trialEnd = subscription.trial_end 
      ? new Date(subscription.trial_end * 1000) 
      : null;
    
    // Get extra agents and contacts from subscription metadata
    const extraAgents = parseInt(subscription.metadata.extraAgents || '0', 10);
    const extraContacts = parseInt(subscription.metadata.extraContacts || '0', 10);
    
    // Update the organization with Stripe data
    await db.execute(`
      UPDATE organizations 
      SET 
        subscription_status = ?,
        billing_cycle_end = ?,
        trial_end_date = ?,
        extra_agents = ?,
        extra_contacts = ?
      WHERE id = ?
    `, [
      subscriptionStatus,
      billingCycleEnd.toISOString(),
      trialEnd?.toISOString() || null,
      extraAgents,
      extraContacts,
      organizationId
    ]);
    
    logger.info(`Updated subscription status for organization ${organizationId}: ${subscriptionStatus}`);
    
  } catch (error) {
    logger.error(`Error syncing subscription status for organization ${organizationId}:`, error);
    throw error;
  }
}

/**
 * Checks if an organization's account is in good standing
 */
export async function checkAccountStatus(organizationId: number): Promise<AccountStatusDetails> {
  const db = new Database();
  
  try {
    // Try to sync with Stripe first
    try {
      await syncSubscriptionStatus(organizationId);
    } catch (error) {
      logger.warn(`Could not sync with Stripe for organization ${organizationId}:`, error);
    }
    
    // Get basic organization info first (this should always work)
    const orgResult = await db.execute(
      'SELECT id, name, slug, subscription_tier, subscription_status, agent_limit, contact_limit, extra_agents, extra_contacts, billing_cycle_end, payment_failure_count, payment_completed FROM organizations WHERE id = ?', 
      [organizationId]
    );
    
    if (!orgResult.rows || orgResult.rows.length === 0) {
      throw new Error(`Organization not found: ${organizationId}`);
    }
    
    const org = orgResult.rows[0];
    
    try {
      // Try to query the organization_status view
      const statusResult = await db.execute(
        'SELECT * FROM organization_status WHERE id = ?', 
        [organizationId]
      );
      
      if (statusResult.rows && statusResult.rows.length > 0) {
        const status = statusResult.rows[0];
        const columns = statusResult.columns || [];
        
        // Create an object from the row array using column names
        const statusObj: any = {};
        columns.forEach((col, i) => {
          statusObj[col] = status[i];
        });
        
        // Prepare status details with appropriate message
        let message = '';
        switch (statusObj.account_status) {
          case 'inactive':
            message = `Your subscription is ${statusObj.subscription_status}. Please update your payment method.`;
            break;
            
          case 'agent_limit_exceeded':
            message = `Your account has ${statusObj.current_agent_count} agents, but your plan only allows for ${statusObj.agent_limit + statusObj.extra_agents}. Please remove some agents or upgrade your plan.`;
            break;
            
          case 'contact_limit_exceeded':
            message = `Your account has ${statusObj.current_contact_count} contacts, but your plan only allows for ${statusObj.contact_limit + statusObj.extra_contacts}. Please remove some contacts or upgrade your plan.`;
            break;
            
          case 'good_standing':
          default:
            message = 'Your account is in good standing.';
            break;
        }
        
        return {
          status: statusObj.account_status,
          message,
          organizationId: statusObj.id,
          organizationName: statusObj.name,
          organizationSlug: statusObj.slug,
          subscriptionTier: statusObj.subscription_tier,
          subscriptionStatus: statusObj.subscription_status,
          agentLimit: statusObj.agent_limit + statusObj.extra_agents,
          contactLimit: statusObj.contact_limit + statusObj.extra_contacts,
          currentAgentCount: statusObj.current_agent_count,
          currentContactCount: statusObj.current_contact_count,
          billingCycleEnd: statusObj.billing_cycle_end ? new Date(statusObj.billing_cycle_end) : undefined,
          paymentFailureCount: statusObj.payment_failure_count,
          paymentCompleted: statusObj.payment_completed
        };
      }
    } catch (viewError) {
      // If there's an error querying the view (e.g., it doesn't exist),
      // we'll fall through to the default implementation below
      logger.warn(`Error querying organization_status view: ${viewError}`);
    }
    
    // If we get here, either the view doesn't exist or there was no result
    // Provide default values based on the organization record
    
    // Default to good standing
    const accountStatus: AccountStatus = 'good_standing';
    const message = 'Your account is in good standing.';
    
    // Extract values from the row array
    const columns = orgResult.columns || [];
    const orgObj: any = {};
    columns.forEach((col, i) => {
      orgObj[col] = org[i];
    });
    
    // Use defaults for missing values
    const subscriptionStatus = orgObj.subscription_status || 'active';
    const agentLimit = orgObj.agent_limit || 5;
    const contactLimit = orgObj.contact_limit || 100;
    const extraAgents = orgObj.extra_agents || 0;
    const extraContacts = orgObj.extra_contacts || 0;
    
    return {
      status: accountStatus,
      message,
      organizationId: orgObj.id,
      organizationName: orgObj.name,
      organizationSlug: orgObj.slug,
      subscriptionTier: orgObj.subscription_tier,
      subscriptionStatus,
      agentLimit: agentLimit + extraAgents,
      contactLimit: contactLimit + extraContacts,
      currentAgentCount: 0, // Default to 0 since we can't query agents table
      currentContactCount: 0, // Default to 0 since we can't query contacts table
      billingCycleEnd: orgObj.billing_cycle_end ? new Date(orgObj.billing_cycle_end) : undefined,
      paymentFailureCount: orgObj.payment_failure_count || 0,
      paymentCompleted: orgObj.payment_completed || false
    };
    
  } catch (error) {
    logger.error(`Error checking account status for organization ${organizationId}:`, error);
    throw error;
  }
}

================
File: backend/src/services/turso.ts
================
import { createClient } from '@libsql/client';
import { TURSO_CONFIG } from '../config/turso';
import { logger } from '../logger';
import { config } from '../config'
import fetch from 'node-fetch'
import * as fs from 'fs';

// Use non-null assertion since we check these values immediately
const TURSO_DB_URL = config.TURSO_DATABASE_URL!;
const TURSO_AUTH_TOKEN = config.TURSO_AUTH_TOKEN!;

if (!config.TURSO_DATABASE_URL) {
  throw new Error('TURSO_DATABASE_URL is not set');
}

if (!config.TURSO_AUTH_TOKEN) {
  throw new Error('TURSO_AUTH_TOKEN is not set');
}

export const tursoClient = createClient({
  url: TURSO_DB_URL,
  authToken: TURSO_AUTH_TOKEN,
});

export async function getTursoClient() {
  try {
    await tursoClient.execute('SELECT 1');
    return tursoClient;
  } catch (error) {
    logger.error(`Error connecting to Turso: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// Export a function to check if the client is healthy
export async function checkTursoHealth(): Promise<boolean> {
  try {
    await tursoClient.execute('SELECT 1');
    return true;
  } catch (error) {
    logger.error(`Turso health check failed: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

interface TursoResponse {
  databases?: Array<{
    Name: string;
    DbId: string;
    Hostname: string;
    Region: string;
  }>;
  jwt?: string;
  [key: string]: unknown;
}

export class TursoService {
  private apiToken: string
  private client;

  constructor() {
    const token = config.TURSO_API_TOKEN;
    if (!token) {
      throw new Error('TURSO_API_TOKEN is not set');
    }
    this.apiToken = token;
    this.client = tursoClient;
    
    logger.info('TursoService initialized with API token')
  }

  async createDatabaseForImport(orgId: string): Promise<{dbName: string, url: string, token: string}> {
    const dbName = `org-${orgId}-${Date.now()}`

    try {
      // Create database
      logger.info(`Creating Turso database for org ${orgId} with name ${dbName}`)
      const createResponse = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: dbName,
          group: TURSO_CONFIG.GROUP_NAME,
          "seed": { "type": "database_upload" }
        }),
      })

      const newDbData = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
        },
      })

      const newDbDataJson = await newDbData.json() as any
      const newDbUrl = newDbDataJson.database.Hostname

      const tokenResponse = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}/auth/tokens`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
        },
      })

      const newTokenData = await tokenResponse.json() as any
      const newToken = newTokenData.jwt

      // Verify the database is available by checking the databases list
      let dbFound = false;
      let attempts = 0;
      const maxAttempts = 5;
      
      while (!dbFound && attempts < maxAttempts) {
        const listResponse = await fetch(`https://api.turso.tech/v1/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${this.apiToken}`,
          }
        });
        
        if (listResponse.ok) {
          const data = await listResponse.json();
          dbFound = data.databases.some((db: any) => db.Name === dbName);
          
          if (!dbFound) {
            logger.info(`Database ${dbName} not found in list, waiting 1 second before retry (attempt ${attempts + 1}/${maxAttempts})`);
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
          }
        } else {
          logger.warn(`Failed to list databases, status: ${listResponse.status}`);
          break;
        }
      }
      
      if (!dbFound) {
        logger.warn(`Database ${dbName} not found in databases list after ${maxAttempts} attempts, continuing anyway`);
      } else {
        logger.info(`Database ${dbName} confirmed in databases list`);
      }

      return {
        dbName: dbName,
        url: newDbUrl,
        token: newToken,
      }
    } catch (error) {
      logger.error(`Error creating database for import: ${error instanceof Error ? error.message : String(error)}`)
      throw error
    }
  }

  async uploadDatabase(dbName: string, authToken: string, filePath: string): Promise<any> {
    try {
      // Strip file: protocol if present
      const normalizedPath = filePath.replace(/^file:/, '');
      
      logger.info(`Attempting to upload database from file: ${normalizedPath}`);
      
      // Verify file exists before attempting upload
      if (!fs.existsSync(normalizedPath)) {
        const error = new Error(`File not found at path: ${normalizedPath}`);
        logger.error(`Upload failed - ${error.message}`);
        throw error;
      }

      const uploadUrl = `https://${dbName}-${TURSO_CONFIG.ORG_SLUG}.turso.io/v1/upload`;
      logger.info(`Uploading to URL: ${uploadUrl}`);

      const response = await fetch(uploadUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
        },
        body: fs.createReadStream(normalizedPath),
      });

      if (!response.ok) {
        const errorText = await response.text();
        logger.error(`Failed to upload database (status ${response.status}): ${errorText}`);
        
        // Log headers for debugging
        const headers: Record<string, string> = {};
        response.headers.forEach((value, key) => {
          headers[key] = value;
        });
        logger.error(`Response headers: ${JSON.stringify(headers)}`);
        
        throw new Error(`Failed to upload database: ${errorText}`);
      }
      
      const result = await response.json();
      logger.info(`Upload successful: ${JSON.stringify(result)}`);
      return result;
    } catch (error: unknown) {
      logger.error(`Error uploading database: ${error instanceof Error ? error.message : String(error)}`);
      if (error instanceof Error && error.stack) {
        logger.error(`Stack trace: ${error.stack}`);
      }
      throw error;
    }
  }

  async createOrganizationDatabase(orgId: string): Promise<{url: string, token: string}> {
    const dbName = `org-${orgId}-${Date.now()}`
    
    try {
      // Create database
      logger.info(`Creating Turso database for org ${orgId} with name ${dbName}`)
      const createResponse = await fetch('https://api.turso.tech/v1/databases', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: dbName,
          group: TURSO_CONFIG.GROUP_NAME,
        }),
      })

      if (!createResponse.ok) {
        const errorText = await createResponse.text()
        logger.error(`Failed to create database: ${errorText}`)
        throw new Error(`Failed to create database: ${errorText}`)
      }

      const createData = await createResponse.json() as any
      logger.info(`Database creation response: ${JSON.stringify(createData)}`)
      
      const hostname = createData.database?.Hostname
      if (!hostname) {
        logger.error(`Invalid database creation response - missing hostname: ${JSON.stringify(createData)}`)
        throw new Error('Failed to get database hostname')
      }
      logger.info(`Successfully created database with hostname: ${hostname}`)
      
      // Create access token
      logger.info(`Creating access token for database ${dbName}`)
      const tokenUrl = `https://api.turso.tech/v1/databases/${dbName}/auth/tokens`
      logger.info(`Token creation URL: ${tokenUrl}`)
      
      const tokenResponse = await fetch(tokenUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          expiration: 'never',
        }),
      })

      if (!tokenResponse.ok) {
        const errorText = await tokenResponse.text()
        logger.error(`Failed to create token (status ${tokenResponse.status}): ${errorText}`)
        // Log response headers for debugging
        const headers: Record<string, string> = {}
        tokenResponse.headers.forEach((value, key) => {
          headers[key] = value
        })
        logger.error(`Token response headers: ${JSON.stringify(headers)}`)
        throw new Error(`Failed to create token: ${errorText}`)
      }

      const tokenData = await tokenResponse.json() as any
      logger.info(`Token creation response: ${JSON.stringify(tokenData)}`)
      
      const token = tokenData.jwt
      if (!token) {
        logger.error(`Invalid token response - missing jwt: ${JSON.stringify(tokenData)}`)
        throw new Error('Failed to get database access token')
      }
      
      logger.info(`Successfully created token for database ${dbName}`)
      
      return {
        url: hostname,
        token,
      }
    } catch (error) {
      logger.error(`Error creating organization database: ${error instanceof Error ? error.message : String(error)}`)
      if (error instanceof Error && error.stack) {
        logger.error(`Stack trace: ${error.stack}`)
      }
      throw error
    }
  }

  async deleteOrganizationDatabase(dbName: string): Promise<void> {
    try {
      logger.info(`Deleting Turso database ${dbName}`)
      const response = await fetch(`https://api.turso.tech/v1/databases/${dbName}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${this.apiToken}`,
        },
      })

      if (!response.ok) {
        const errorText = await response.text()
        logger.error(`Failed to delete database: ${errorText}`)
        throw new Error(`Failed to delete database: ${errorText}`)
      }
      
      logger.info(`Successfully deleted database ${dbName}`)
    } catch (error) {
      logger.error(`Error deleting organization database: ${error}`)
      throw error
    }
  }

  // Helper function to normalize database URLs
  private normalizeDbUrl(url: string): { hostname: string, apiUrl: string, dbUrl: string } {
    // Strip any protocol prefix
    const hostname = url.replace(/(^https?:\/\/)|(^libsql:\/\/)/, '');
    return {
      hostname,  // Raw hostname without protocol
      apiUrl: `https://${hostname}`,  // For API calls
      dbUrl: `libsql://${hostname}`   // For database connections
    };
  }

  async downloadDatabaseDump(dbUrl: string, authToken: string): Promise<string> {
    try {
      const { apiUrl } = this.normalizeDbUrl(dbUrl);
      logger.info(`Downloading database dump from ${apiUrl}/dump`);
      
      const response = await fetch(`${apiUrl}/dump`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`,
        },
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to download dump: ${errorText}`);
      }

      return await response.text();
    } catch (error) {
      logger.error(`Error downloading database dump: ${error}`);
      throw error;
    }
  }

  async createDatabaseFromDump(orgId: string, suffix: string, dumpContent: string): Promise<{url: string, token: string}> {
    const dbName = `org-${orgId}-${suffix}`;

    try {
      logger.info(`Creating new database: ${dbName}`);
      
      // Step 1: Create the database with a unique name
      const createDbResponse = await fetch(
        `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases`, 
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: dbName,
            group: TURSO_CONFIG.GROUP_NAME
          })
        }
      );

      if (!createDbResponse.ok) {
        const errorText = await createDbResponse.text();
        throw new Error(`Failed to create database: ${errorText}`);
      }

      const dbData = await createDbResponse.json() as { database: { Hostname: string } };
      const { dbUrl, apiUrl } = this.normalizeDbUrl(dbData.database.Hostname);
      logger.info(`Database created: ${dbUrl}`);
      
      // Step 2: Generate an auth token for the database
      logger.info(`Generating auth token for database ${dbName}`);
      const tokenResponse = await fetch(
        `${TURSO_CONFIG.API_URL}/organizations/${TURSO_CONFIG.ORG_SLUG}/databases/${dbName}/auth/tokens`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      if (!tokenResponse.ok) {
        const errorText = await tokenResponse.text();
        // Try to clean up the created database
        try {
          await this.deleteOrganizationDatabase(dbName);
        } catch (cleanupError) {
          logger.warn(`Failed to delete database after token error: ${cleanupError}`);
        }
        throw new Error(`Failed to create auth token: ${errorText}`);
      }

      const tokenData = await tokenResponse.json() as { jwt: string };
      const token = tokenData.jwt;
      
      logger.info(`Successfully created database ${dbName} with auth token`);
      
      // Create client for the new database using libsql:// URL
      const client = createClient({
        url: dbUrl,
        authToken: token
      });
      
      // Split dump into logical statement groups for more reliable execution
      const statements = dumpContent
        .split(';')
        .map(stmt => stmt.trim())
        .filter(stmt => stmt.length > 0);
      
      logger.info(`Split SQL dump into ${statements.length} statements`);
      
      // Execute statements in phases - first schema statements, then data statements
      // Parse and categorize statements
      const schemaStatements = statements.filter(stmt => 
        stmt.toUpperCase().startsWith('CREATE TABLE')
      );
      
      const indexStatements = statements.filter(stmt => 
        stmt.toUpperCase().startsWith('CREATE INDEX') || 
        stmt.toUpperCase().startsWith('CREATE UNIQUE INDEX')
      );
      
      const insertStatements = statements.filter(stmt => 
        stmt.toUpperCase().startsWith('INSERT')
      );
      
      const otherStatements = statements.filter(stmt => 
        !schemaStatements.includes(stmt) && 
        !indexStatements.includes(stmt) && 
        !insertStatements.includes(stmt)
      );
      
      logger.info(`Processing ${schemaStatements.length} tables, ${indexStatements.length} indexes, ${insertStatements.length} data inserts, and ${otherStatements.length} other statements`);
      
      // Phase 1: Create tables
      for (const tableStatement of schemaStatements) {
        try {
          logger.info(`Creating table: ${tableStatement.substring(0, 60)}...`);
          await client.execute(tableStatement);
        } catch (error) {
          // If there's an error with the contacts table missing updated_at, add it
          if (tableStatement.includes('contacts') && 
              (error as Error).toString().includes('no column named updated_at')) {
            logger.warn('Error creating contacts table, attempting to fix missing updated_at column');
            
            // Add the updated_at column if it's missing
            try {
              // First create the table without the updated_at column
              await client.execute(tableStatement);
              
              // Then add the updated_at column
              await client.execute(`
                ALTER TABLE contacts
                ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
              `);
              
              logger.info('Successfully added missing updated_at column to contacts table');
            } catch (altError) {
              logger.error(`Failed to fix contacts table: ${altError}`);
              throw altError;
            }
          } else {
            // For other errors, just throw them
            throw error;
          }
        }
      }
      
      // Phase 2: Execute other statements (drops, alters, etc)
      for (const statement of otherStatements) {
        await client.execute(statement);
      }
      
      // Phase 3: Insert data
      logger.info(`Inserting data (${insertStatements.length} statements)...`);
      let successCount = 0;
      let errorCount = 0;
      
      // Check if we've already detected updated_at missing
      let updatedAtMissing = false;
      let checkedUpdatedAt = false;
      
      for (const insertStatement of insertStatements) {
        try {
          // Skip if we know the statement will fail due to updated_at missing
          if (updatedAtMissing && insertStatement.includes('updated_at')) {
            // Try to fix the insert statement by removing the updated_at column
            const fixedInsert = insertStatement
              .replace(/updated_at\s*,/i, '')  // Remove updated_at from column list
              .replace(/(\w+\s*,\s*)CURRENT_TIMESTAMP(\s*\))/gi, '$1$2')  // Remove corresponding value in VALUES
              .replace(/,\s*\)/g, ')');  // Fix any trailing commas
            
            try {
              await client.execute(fixedInsert);
              successCount++;
              
              // Log progress periodically
              if (successCount % 50 === 0) {
                logger.info(`Imported ${successCount}/${insertStatements.length} data statements (with fixes)`);
              }
            } catch (fixError) {
              errorCount++;
              logger.error(`Error executing fixed INSERT: ${fixError}`);
              // Continue with next statement
            }
            continue;
          }
          
          // Try the original statement
          await client.execute(insertStatement);
          successCount++;
          
          // Log progress periodically
          if (successCount % 50 === 0) {
            logger.info(`Imported ${successCount}/${insertStatements.length} data statements`);
          }
        } catch (error) {
          // Check if this is the updated_at missing error
          if (!checkedUpdatedAt && (error as Error).toString().includes('no column named updated_at')) {
            updatedAtMissing = true;
            checkedUpdatedAt = true;
            logger.warn('Detected missing updated_at column in contacts table, will attempt to fix INSERT statements');
            
            // Try to add the column if it's missing
            try {
              await client.execute(`
                ALTER TABLE contacts
                ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
              `);
              logger.info('Added missing updated_at column to contacts table');
              
              // Now we have the column, try the statement again
              try {
                await client.execute(insertStatement);
                successCount++;
                logger.info('Successfully executed INSERT after adding updated_at column');
                
                // We fixed the table, so we don't need to modify statements anymore
                updatedAtMissing = false;
              } catch (retryError) {
                errorCount++;
                logger.error(`Error retrying INSERT after adding column: ${retryError}`);
              }
            } catch (alterError) {
              logger.warn(`Could not add updated_at column: ${alterError}`);
              // Still mark as missing so we can fix the statements
            }
          } else {
            errorCount++;
            logger.error(`Error executing INSERT: ${error}`);
            // Continue with next statement - don't fail everything for one bad insert
          }
        }
      }
      
      // Phase 4: Create indexes (do this last for better performance)
      logger.info(`Creating ${indexStatements.length} indexes...`);
      for (const indexStatement of indexStatements) {
        try {
          await client.execute(indexStatement);
        } catch (error) {
          logger.warn(`Error creating index: ${error}`);
          // Continue with next index - not fatal
        }
      }
      
      // Log summary
      logger.info(`Database import complete: ${successCount} successful inserts, ${errorCount} errors`);
      
      // Verify the database
      try {
        const result = await client.execute('SELECT COUNT(*) as count FROM contacts');
        const count = result.rows?.[0]?.[0];
        logger.info(`Database verification: ${count} contacts found`);
      } catch (error) {
        logger.warn(`Error verifying database: ${error}`);
      }
      
      return { url: dbUrl, token };
    } catch (error) {
      logger.error(`Error creating database from dump: ${error}`);
      throw error;
    }
  }
  

  private handleError(error: unknown): never {
    logger.error(`Turso service error: ${error instanceof Error ? error.message : String(error)}`);
    throw error instanceof Error ? error : new Error(String(error));
  }

  private validateResponse(data: unknown): TursoResponse {
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid response from Turso API');
    }
    return data as TursoResponse;
  }
}

================
File: backend/src/services/unifiedDatabase.ts
================
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { logger } from '../logger';

// Type definitions for the result types
type OkResult<T> = { ok: true; value: T };
type ErrResult = { ok: false; error: any };
type Result<T> = OkResult<T> | ErrResult;

/**
 * Database client that uses @replit/database on Replit or falls back to JSON mock locally
 * API matches @replit/database exactly
 */
export default class Database {
  private client: any;
  private isMock: boolean = false;

  constructor(dbUrl?: string) {
    if (process.env.REPLIT_DB_URL || dbUrl) {
      try {
        // Try to use the real Replit database
        const ReplitDatabase = require('@replit/database').default;
        this.client = new ReplitDatabase(dbUrl);
        logger.info('Using Replit database');
      } catch (error) {
        logger.warn('Failed to load @replit/database, falling back to JSON mock');
        this.client = new MockReplitDatabase();
        this.isMock = true;
      }
    } else {
      this.client = new MockReplitDatabase();
      this.isMock = true;
      logger.info('Using local JSON mock database');
    }
  }

  async set(key: string, value: any): Promise<void> {
    if (this.isMock) {
      return this.client.set(key, value);
    }
    return this.client.set(key, value);
  }

  async get(key: string, options?: { raw?: boolean }): Promise<Result<any>> {
    if (this.isMock) {
      return this.client.get(key, options);
    }
    return this.client.get(key, options);
  }

  async delete(key: string): Promise<Result<null>> {
    if (this.isMock) {
      return this.client.delete(key);
    }
    return this.client.delete(key);
  }

  async list(prefix?: string): Promise<Result<string[]>> {
    if (this.isMock) {
      return this.client.list(prefix);
    }
    return this.client.list(prefix);
  }

  async empty(): Promise<void> {
    if (this.isMock) {
      return this.client.empty();
    }
    return this.client.empty();
  }

  async getAll(options?: { raw?: boolean }): Promise<Result<Record<string, any>>> {
    if (this.isMock) {
      return this.client.getAll(options);
    }
    return this.client.getAll(options);
  }

  async setMultiple(obj: Record<string, any>): Promise<void> {
    if (this.isMock) {
      return this.client.setMultiple(obj);
    }
    return this.client.setMultiple(obj);
  }

  async deleteMultiple(keys: string[]): Promise<void> {
    if (this.isMock) {
      return this.client.deleteMultiple(keys);
    }
    return this.client.deleteMultiple(keys);
  }
}

/**
 * Mock implementation that exactly matches @replit/database API
 */
class MockReplitDatabase {
  private data: Record<string, any> = {};
  private filePath: string;

  constructor(filename: string = 'replit_mock_db.json') {
    this.filePath = join(process.cwd(), 'data', filename);
    this.loadDb();
  }

  private loadDb() {
    if (existsSync(this.filePath)) {
      try {
        this.data = JSON.parse(readFileSync(this.filePath, 'utf-8'));
      } catch (error) {
        logger.error('Error loading mock database:', error);
        this.data = {};
      }
    }
  }

  private saveDb() {
    // Ensure data directory exists
    const dataDir = join(process.cwd(), 'data');
    if (!existsSync(dataDir)) {
      mkdirSync(dataDir, { recursive: true });
    }
    
    writeFileSync(this.filePath, JSON.stringify(this.data, null, 2));
  }

  async set(key: string, value: any): Promise<void> {
    this.data[key] = value;
    this.saveDb();
  }

  async get(key: string, options?: { raw?: boolean }): Promise<Result<any>> {
    const value = this.data[key];
    if (value === undefined) {
      return { ok: true, value: null };
    }
    
    if (options?.raw && typeof value !== 'string') {
      return { ok: true, value: JSON.stringify(value) };
    }
    
    return { ok: true, value };
  }

  async delete(key: string): Promise<Result<null>> {
    delete this.data[key];
    this.saveDb();
    return { ok: true, value: null };
  }

  async list(prefix?: string): Promise<Result<string[]>> {
    let keys = Object.keys(this.data);
    
    if (prefix) {
      keys = keys.filter(key => key.startsWith(prefix));
    }
    
    return { ok: true, value: keys };
  }

  async empty(): Promise<void> {
    this.data = {};
    this.saveDb();
  }

  async getAll(options?: { raw?: boolean }): Promise<Result<Record<string, any>>> {
    if (options?.raw) {
      const rawData: Record<string, string> = {};
      for (const [key, value] of Object.entries(this.data)) {
        rawData[key] = typeof value === 'string' ? value : JSON.stringify(value);
      }
      return { ok: true, value: rawData };
    }
    
    return { ok: true, value: { ...this.data } };
  }

  async setMultiple(obj: Record<string, any>): Promise<void> {
    Object.assign(this.data, obj);
    this.saveDb();
  }

  async deleteMultiple(keys: string[]): Promise<void> {
    for (const key of keys) {
      delete this.data[key];
    }
    this.saveDb();
  }
}

================
File: backend/src/utils/quoteId.ts
================
import { createHash } from 'crypto';

// Function to generate a unique quote ID from org ID and contact ID
export function generateQuoteId(orgId: number, contactId: number): string {
    // Create a string to hash that includes org, contact, and secret

    const secret = process.env.QUOTE_SECRET || 'your-default-secret-key';

    const dataToHash = `${orgId}-${contactId}-${secret}`;
    console.log('dataToHash', dataToHash);
    
    // Generate hash using crypto
    const hash = createHash('sha256')
        .update(dataToHash)
        .digest('hex')
        .slice(0, 8); // Take first 8 characters for brevity
    
    // Combine components into quote ID
    const finalQuoteId = `${orgId}-${contactId}-${hash}`;
    console.log('finalQuoteId', finalQuoteId);
    return finalQuoteId;
}

// Function to decode a quote ID back to org ID and contact ID
export function decodeQuoteId(quoteId: string): { orgId: number; contactId: number } | null {
    try {
        const parts = quoteId.split('-');
        if (parts.length !== 3) {
            return null;
        }

        const [orgId, contactId, providedHash] = parts;
        
        // Recreate hash to validate
        const secret = process.env.QUOTE_SECRET || 'your-default-secret-key';
        const dataToHash = `${orgId}-${contactId}-${secret}`;
        console.log('dataToHash', dataToHash);
        const expectedHash = createHash('sha256')
            .update(dataToHash)
            .digest('hex')
            .slice(0, 8);

        // Compare hashes
        if (providedHash !== expectedHash) {
            return null;
        }

        return {
            orgId: parseInt(orgId),
            contactId: parseInt(contactId)
        };
    } catch (e) {
        return null;
    }
}

================
File: backend/src/utils/tracking.ts
================
/**
 * Utilities for tracking URLs and link analytics
 */

/**
 * Generates a tracking ID for a particular URL
 * Format: tid-[orgId]-[contactId]-[timestamp]
 * @param orgId Organization ID
 * @param contactId Contact ID
 * @param prefix Optional prefix for the tracking ID (defaults to 'tid')
 * @returns Tracking ID string
 */
export const generateTrackingId = (orgId: number | string, contactId: number | string, prefix: string = 'tid'): string => {
  const timestamp = Date.now();
  return `${prefix}-${orgId}-${contactId}-${timestamp}`;
};

/**
 * Adds tracking parameters to a URL
 * @param url The original URL
 * @param trackingId The tracking ID to add
 * @returns URL with tracking parameters
 */
export const addTrackingToUrl = (url: string, trackingId: string): string => {
  try {
    const urlObj = new URL(url);
    urlObj.searchParams.append('tid', trackingId);
    return urlObj.toString();
  } catch (error) {
    // If URL parsing fails, append as a simple query parameter
    const separator = url.includes('?') ? '&' : '?';
    return `${url}${separator}tid=${trackingId}`;
  }
};

/**
 * Extracts information from a tracking ID
 * @param trackingId The tracking ID to parse
 * @returns Object with parsed tracking info or null if invalid
 */
export const parseTrackingId = (trackingId: string): { prefix: string, orgId: string, contactId: string, timestamp: number } | null => {
  const parts = trackingId.split('-');
  if (parts.length < 4) {
    return null;
  }
  
  const [prefix, orgId, contactId, timestampStr] = parts;
  const timestamp = parseInt(timestampStr, 10);
  
  if (isNaN(timestamp)) {
    return null;
  }
  
  return {
    prefix,
    orgId,
    contactId,
    timestamp
  };
};

================
File: backend/src/config.ts
================
import { config as dotenvConfig } from 'dotenv'
import { resolve } from 'path'
import { logger } from './logger'
import { existsSync } from 'fs'
import dotenv from 'dotenv'
import fs from 'fs'
import path from 'path'

// Get absolute path to .env file
const envPath = resolve(__dirname, '../.env')

// Check if .env file exists - but don't exit if using Replit Secrets
const envFileExists = existsSync(envPath)
if (!envFileExists) {
  console.log(`⚠️ .env file not found at: ${envPath}, will attempt to use Replit Secrets instead`)
} else {
  // Load .env file with override option only if it exists
  const result = dotenvConfig({ 
    path: envPath,
    override: true // This tells dotenv to override existing env vars
  })

  if (result.error) {
    console.warn('⚠️ Error loading .env file:', result.error)
  } else {
    console.log('📁 Loading .env from:', envPath)
  }
}

// Log environment variables (safely)
console.log('📝 Environment variables available:', {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL ? '[PRESENT]' : '[MISSING]',
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN ? '[PRESENT]' : '[MISSING]',
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH ? '[PRESENT]' : '[MISSING]'
})

// Load environment variables from .env file
if (fs.existsSync(path.join(process.cwd(), '.env'))) {
  dotenv.config()
}

// Look for mockStripe: true in the environment, if not found, default to true in development and false in production
const useMockStripe = process.env.USE_MOCK_STRIPE === 'true' || 
  (process.env.NODE_ENV === 'development' && process.env.USE_REAL_STRIPE !== 'true');

export const config = {
  TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
  TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
  TURSO_DATABASE_PATH: process.env.TURSO_DATABASE_PATH,
  TURSO_API_TOKEN: process.env.TURSO_API_TOKEN,
  TURSO_ORG_GROUP: process.env.TURSO_ORG_GROUP || 'maxretain',
  TURSO_ORG_SLUG: process.env.TURSO_ORG_SLUG || 'pyrex41',
  USE_LOCAL_SQLITE: process.env.USE_LOCAL_SQLITE === 'true',
  LOCAL_DB_PATH: process.env.LOCAL_DB_PATH || './.data',
  quoteApiKey: process.env.QUOTE_API_KEY,
  quoteSecret: process.env.QUOTE_SECRET,
  magicLinkSecret: process.env.MAGIC_LINK_SECRET,
  sendgridApiKey: process.env.SENDGRID_API_KEY,
  sendgridFromEmail: process.env.SENDGRID_FROM_EMAIL,
  PUBLIC_URL: process.env.PUBLIC_URL || (process.env.NODE_ENV === 'development' 
    ? 'http://localhost:5173'
    : 'http://localhost:3000'),
  stripe: {
    secretKey: process.env.STRIPE_SECRET_KEY,
    publishableKey: process.env.STRIPE_PUBLISHABLE_KEY,
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
    useMock: useMockStripe,
    pricingTableId: process.env.STRIPE_PRICING_TABLE_ID || 'prctbl_1RAfz9CBUPXAZKNG0EyV8bRU',
    prices: {
      basic: process.env.STRIPE_PRICE_BASIC || 'price_basic',
      pro: process.env.STRIPE_PRICE_PRO || 'price_pro',
      enterprise: process.env.STRIPE_PRICE_ENTERPRISE || 'price_enterprise',
      contactBaseTier: process.env.STRIPE_PRICE_CONTACT_BASE_TIER || 'price_contact_base',
      additionalContacts: process.env.STRIPE_PRICE_ADDITIONAL_CONTACTS || 'price_additional_contacts',
      // Optional price IDs for legacy support
      extraAgent: process.env.STRIPE_PRICE_EXTRA_AGENT,
      extraContact: process.env.STRIPE_PRICE_EXTRA_CONTACT,
    },
    publicKey: process.env.STRIPE_PUBLIC_KEY,
    connectAccount: process.env.STRIPE_CONNECT_ACCOUNT,
  },
  stripeApiKey: process.env.STRIPE_SECRET_KEY,
  stripeWebhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
  clientUrl: process.env.PUBLIC_URL || 'http://localhost:5173',
  stripeSecretKey: process.env.STRIPE_SECRET_KEY || '',
}

// Log loaded config (safely)
logger.info(`Config loaded ${envFileExists ? `from ${envPath}` : 'from environment'}`)

================
File: backend/src/database.ts
================
import { createClient } from '@libsql/client'
import { config } from './config'
import { logger } from './logger'
import { TursoService } from './services/turso'
import { Database as BunDatabase } from 'bun:sqlite'
import fs from 'fs'
import path from 'path'
import { parse } from 'csv-parse'
import { pipeline } from 'stream/promises'
import fetch, { Response } from 'node-fetch'
import type { RequestInit, RequestInfo, BodyInit } from 'node-fetch'
import type { ContactCreate } from './types'

import fsPromises from 'fs/promises'
import Bun from 'bun'
import { ZIP_DATA } from './index' // Import ZIP_DATA for state lookup

// Connection pool to reuse database connections
interface ConnectionInfo {
  client: any;
  url: string;
  lastUsed: number;
}

class ConnectionPool {
  private static instance: ConnectionPool;
  private connections: Map<string, ConnectionInfo> = new Map();
  private readonly MAX_IDLE_TIME = 60000; // 60 seconds max idle time
  private readonly MAX_POOL_SIZE = 20; // Maximum connections to keep in the pool
  private cleanupInterval: any;

  private constructor() {
    // Start the cleanup interval to remove idle connections
    this.cleanupInterval = setInterval(() => this.cleanupIdleConnections(), 30000);
  }

  public static getInstance(): ConnectionPool {
    if (!ConnectionPool.instance) {
      ConnectionPool.instance = new ConnectionPool();
    }
    return ConnectionPool.instance;
  }

  public getConnection(url: string, authToken: string): any {
    // Check if we have a connection for this URL
    if (this.connections.has(url)) {
      const conn = this.connections.get(url)!;
      conn.lastUsed = Date.now();
      return conn.client;
    }

    // If we've reached max pool size, remove the oldest connection
    if (this.connections.size >= this.MAX_POOL_SIZE) {
      let oldestTime = Infinity;
      let oldestUrl = '';
      
      for (const [connUrl, conn] of this.connections.entries()) {
        if (conn.lastUsed < oldestTime) {
          oldestTime = conn.lastUsed;
          oldestUrl = connUrl;
        }
      }
      
      if (oldestUrl) {
        logger.info(`Connection pool: removing oldest connection ${oldestUrl}`);
        this.connections.delete(oldestUrl);
      }
    }

    // Create a new connection
    logger.info(`Creating new Turso connection for ${url}`);
    const client = createClient({
      url,
      authToken,
      concurrency: 25, // Lower concurrency to prevent rate limits
      fetch: async (fetchUrl: RequestInfo, options: RequestInit) => {
        // Add custom fetch with retry for 429 errors
        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            const response = await fetch(fetchUrl, options);
            if (response.status === 429) {
              // Rate limited, wait with exponential backoff
              const delay = Math.pow(2, attempt) * 1000;
              logger.warn(`Rate limit hit in Turso API call, retry ${attempt+1}/${maxRetries} after ${delay}ms`);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue;
            }
            return response;
          } catch (error) {
            if (attempt === maxRetries - 1) throw error;
            const delay = Math.pow(2, attempt) * 1000;
            logger.warn(`Error in Turso API call, retry ${attempt+1}/${maxRetries} after ${delay}ms: ${error}`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
        throw new Error('Max retries reached for Turso API call');
      }
    });

    // Store in the pool
    this.connections.set(url, {
      client,
      url,
      lastUsed: Date.now()
    });

    return client;
  }

  private cleanupIdleConnections() {
    const now = Date.now();
    let cleanedCount = 0;
    
    for (const [url, conn] of this.connections.entries()) {
      if (now - conn.lastUsed > this.MAX_IDLE_TIME) {
        this.connections.delete(url);
        cleanedCount++;
      }
    }
    
    if (cleanedCount > 0) {
      logger.info(`Connection pool: cleaned up ${cleanedCount} idle connections, remaining: ${this.connections.size}`);
    }
  }

  public shutdown() {
    clearInterval(this.cleanupInterval);
    this.connections.clear();
  }
}

type ColumnMapping = {
  firstName: string;
  lastName: string;
  email: string;
  phoneNumber: string;
  state?: string; // Make state optional since we'll infer it from zip code
  currentCarrier: string;
  effectiveDate: string;
  birthDate: string;
  tobaccoUser: string;
  gender: string;
  zipCode: string;
  planType: string;
};

type CarrierMapping = {
  detectedCarriers: string[];
  mappings: Record<string, string>;
};

interface FetchOptions extends RequestInit {
  method?: string;
  headers?: Record<string, string>;
  body?: BodyInit;
}

export class Database {
  private client: any
  private url: string
  private isLocal: boolean
  private bunDb: BunDatabase | null = null

  public static normalizeDbUrl(url: string): { hostname: string, apiUrl: string, dbUrl: string, dbName: string } {
    // Strip any protocol prefix
    const hostname = url.replace(/(^https?:\/\/)|(^libsql:\/\/)/, '');
    const dbName = hostname.split('/').pop()?.split('.')[0] || '';
    return {
      hostname,  // Raw hostname without protocol
      apiUrl: `https://${hostname}`,  // For API calls
      dbUrl: `libsql://${hostname}`,   // For database connections
      dbName // For local SQLite files
    };
  }

  constructor(dbUrl?: string, authToken?: string) {
    const url = dbUrl || config.TURSO_DATABASE_URL
    const token = authToken || config.TURSO_AUTH_TOKEN

    if (!url) {
      logger.error('Missing database URL')
      throw new Error('Missing database URL')
    }

    const { dbUrl: normalizedUrl, dbName } = Database.normalizeDbUrl(url)
    this.url = normalizedUrl
    this.isLocal = config.USE_LOCAL_SQLITE

    if (this.isLocal) {
      const dbPath = path.join(process.cwd(), config.LOCAL_DB_PATH, `${dbName}.sqlite`)
      logger.info(`Using local SQLite database at: ${dbPath}`)
      
      // Create directory if it doesn't exist
      const dbDir = path.dirname(dbPath)
      if (!fs.existsSync(dbDir)) {
        fs.mkdirSync(dbDir, { recursive: true })
      }
      
      this.bunDb = new BunDatabase(dbPath)
      this.client = this.bunDb
      
      // Enable foreign keys
      this.bunDb.exec('PRAGMA foreign_keys = ON;')
    } else {
      if (!token) {
        logger.error('Missing database token')
        throw new Error('Missing database token')
      }
      this.client = createClient({
        url: normalizedUrl,
        authToken: token,
        concurrency: 25, // Reduced concurrency to prevent rate limits
        fetch: async (fetchUrl: RequestInfo, options: RequestInit) => {
          // Add custom fetch with retry for 429 errors
          const maxRetries = 3;
          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              const response = await fetch(fetchUrl, options);
              if (response.status === 429) {
                // Rate limited, wait with exponential backoff
                const delay = Math.pow(2, attempt) * 1000;
                logger.warn(`Rate limit hit in Turso API call, retry ${attempt+1}/${maxRetries} after ${delay}ms`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
              }
              return response;
            } catch (error) {
              if (attempt === maxRetries - 1) throw error;
              const delay = Math.pow(2, attempt) * 1000;
              logger.warn(`Error in Turso API call, retry ${attempt+1}/${maxRetries} after ${delay}ms: ${error}`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
          throw new Error('Max retries reached for Turso API call');
        }
      })
    }
    
    logger.info(`Database connected to: ${this.isLocal ? dbName : this.url}`)
  }

  static async getOrgDb(orgId: string): Promise<Database> {
    logger.info(`Getting org database for org ${orgId}`);
    const mainDb = new Database();
    
    try {
      const org = await mainDb.fetchOne<{ turso_db_url: string; turso_auth_token: string }>(
        'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
        [orgId]
      );
      logger.info(`[OrgDB] Organization record: ${JSON.stringify(org)}`);

      if (!org) {
        logger.warn(`[OrgDB] Organization record not found for orgId: ${orgId}`);
        throw new Error('Organization database not configured');
      }
      if (!org.turso_db_url) {
        logger.warn(`[OrgDB] No turso_db_url found in organization record for orgId: ${orgId}. Record: ${JSON.stringify(org)}`);
        throw new Error('Organization database not configured');
      }
      if (!org.turso_auth_token) {
        logger.warn(`[OrgDB] No turso_auth_token found in organization record for orgId: ${orgId}. Record: ${JSON.stringify(org)}`);
        // Depending on policy, you might still proceed or throw an error.
        // For now, let's assume a URL without a token is also a configuration issue.
        throw new Error('Organization database not configured (missing token)');
      }

      logger.info(`[OrgDB] Found credentials for org ${orgId}. URL: ${org.turso_db_url.substring(0, 20)}... Token: ${org.turso_auth_token ? 'present' : 'MISSING'}`);
      const db = new Database(org.turso_db_url, org.turso_auth_token);

      // Validate connection by running a simple query with timeout
      logger.info(`[OrgDB] Validating database connection for org ${orgId}...`);
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Database validation timed out after 5 seconds')), 5000);
        });
        
        const queryPromise = db.execute('SELECT 1');
        
        const result = await Promise.race([queryPromise, timeoutPromise]);
        logger.info(`Database connection validation successful for org ${orgId}. Result: ${JSON.stringify(result)}`);
        return db;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger.error(`Database connection validation failed for org ${orgId}. Error: ${errorMessage}`);
        if (error instanceof Error && error.stack) {
          logger.error(`Stack trace: ${error.stack}`);
        }
        throw new Error(`Failed to establish database connection: ${errorMessage}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Error getting org database for org ${orgId}: ${errorMessage}`);
      if (error instanceof Error && error.stack) {
        logger.error(`Stack trace: ${error.stack}`);
      }
      throw error;
    }
  }

  /**
   * Get organization's database or initialize it if it doesn't exist
   * This method is used as a fallback when the database needs to be created on the fly
   */
  static async getOrInitOrgDb(orgId: string): Promise<Database> {
    const mainDb = new Database();
    const MAX_RETRIES = 10;
    const RETRY_DELAY_MS = 500;
    let retries = 0;

    logger.info(`[GetOrInitOrgDb] Entered for orgId: ${orgId}`);

    while (true) {
      try {
        // Try to get the org DB as usual
        logger.info(`[GetOrInitOrgDb] Attempting to get OrgDB (attempt ${retries + 1}) for orgId: ${orgId}`);
        const db = await Database.getOrgDb(orgId)
        logger.info(`[GetOrInitOrgDb] Successfully got OrgDB for orgId: ${orgId}. Ensuring schema.`);
        await Database.ensureOrgSchema(db)
        logger.info(`[GetOrInitOrgDb] Schema ensured for orgId: ${orgId}. Returning DB.`);
        return db
      } catch (error) {
        logger.warn(`[GetOrInitOrgDb] Failed to get OrgDB for orgId: ${orgId}. Error: ${error instanceof Error ? error.message : String(error)}`);
        if (error instanceof Error && (error.message === 'Organization database not configured' || error.message === 'Organization database not configured (missing token)')) {
          logger.info(`[GetOrInitOrgDb] Database not configured for orgId: ${orgId}. Attempting to provision.`);
          // Try to atomically claim the right to provision the DB
          logger.info(`[GetOrInitOrgDb] Attempting to claim provisioning lock for orgId: ${orgId}`);
          const claimResult = await mainDb.execute(
            `UPDATE organizations
             SET is_db_provisioning = 1
             WHERE id = ? AND is_db_provisioning = 0 AND (turso_db_url IS NULL OR turso_db_url = '' OR turso_auth_token IS NULL OR turso_auth_token = '')`,
            [orgId]
          );

          logger.info(`[GetOrInitOrgDb] Claim lock result for orgId: ${orgId}: rowsAffected = ${claimResult.rowsAffected}`);
          if (claimResult.rowsAffected === 0) {
            // Someone else is provisioning, wait and retry
            logger.warn(`[GetOrInitOrgDb] Failed to claim lock for orgId: ${orgId} (possibly locked or already provisioned). Retrying...`);
            if (retries++ >= MAX_RETRIES) {
              logger.error(`[GetOrInitOrgDb] Timed out waiting for organization DB provisioning for orgId: ${orgId} after ${MAX_RETRIES} retries.`);
              throw new Error('Timed out waiting for organization DB provisioning');
            }
            await new Promise(res => setTimeout(res, RETRY_DELAY_MS));
            continue;
          }

          // We have the lock, proceed to provision
          logger.info(`[GetOrInitOrgDb] Successfully claimed provisioning lock for orgId: ${orgId}. Proceeding with provisioning.`);
          try {
            const orgExists = await mainDb.fetchOne<{ id: number }>(
              'SELECT id FROM organizations WHERE id = ?',
              [orgId]
            )
            if (!orgExists) {
              logger.error(`[GetOrInitOrgDb] Organization ${orgId} not found during provisioning.`);
              throw new Error('Organization not found')
            }

            const turso = new TursoService()
            logger.info(`[GetOrInitOrgDb] Creating new Turso database for org ${orgId} via TursoService.`);
            const { url, token } = await turso.createOrganizationDatabase(orgId)
            logger.info(`[GetOrInitOrgDb] TursoService returned new database URL: ${url} and token (length: ${token.length}) for org ${orgId}.`);

            // Verify we can connect with the new credentials
            try {
              logger.info(`[GetOrInitOrgDb] Verifying connection with new credentials for org ${orgId}...`)
              const testDb = new Database(url, token)
              await testDb.execute('SELECT 1')
              logger.info(`[GetOrInitOrgDb] Successfully verified connection with new credentials for org ${orgId}.`)
            } catch (connError) {
              logger.error(`[GetOrInitOrgDb] Failed to verify connection with new credentials for org ${orgId}: ${connError instanceof Error ? connError.message : String(connError)}`)
              throw new Error('Failed to verify connection with new database credentials')
            }

            // Update organization with new credentials and clear provisioning flag
            logger.info(`[GetOrInitOrgDb] Updating organization ${orgId} in main DB with new Turso credentials.`);
            await mainDb.execute(
              'UPDATE organizations SET turso_db_url = ?, turso_auth_token = ?, is_db_provisioning = 0 WHERE id = ?',
              [url, token, orgId]
            )
            logger.info(`[GetOrInitOrgDb] Successfully updated organization ${orgId} with new credentials. Clearing provisioning flag.`);

            // Verify the update
            const updatedOrg = await mainDb.fetchOne<{ turso_db_url: string, turso_auth_token: string }>(
              'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
              [orgId]
            )
            if (!updatedOrg) {
              logger.error('[GetOrInitOrgDb] Failed to fetch updated organization after credential update for org ${orgId}.')
              throw new Error('Failed to update organization credentials')
            }
            if (updatedOrg.turso_db_url !== url || updatedOrg.turso_auth_token !== token) {
              logger.error(`[GetOrInitOrgDb] Organization credentials mismatch after update for org ${orgId}.`);
              logger.error(`Expected URL: ${url}, got: ${updatedOrg.turso_db_url}`);
              logger.error(`Expected token length: ${token.length}, got: ${updatedOrg.turso_auth_token.length}`);
              throw new Error('Organization credentials mismatch after update')
            }

            logger.info(`[GetOrInitOrgDb] Successfully initialized and verified database for organization ${orgId}. URL: ${url}`);
            const newDb = new Database(url, token)
            logger.info(`[GetOrInitOrgDb] Ensuring schema for newly provisioned DB for org ${orgId}.`);
            await Database.ensureOrgSchema(newDb)
            logger.info(`[GetOrInitOrgDb] Schema ensured for newly provisioned DB for org ${orgId}. Returning DB.`);
            return newDb
          } catch (provisionError) {
            logger.error(`[GetOrInitOrgDb] Error during provisioning for orgId: ${orgId}. Error: ${provisionError instanceof Error ? provisionError.message : String(provisionError)}`);
            // On error, clear the provisioning flag so future attempts can retry
            logger.info(`[GetOrInitOrgDb] Clearing provisioning lock for orgId: ${orgId} due to provisioning error.`);
            await mainDb.execute(
              'UPDATE organizations SET is_db_provisioning = 0 WHERE id = ?',
              [orgId]
            )
            throw provisionError
          }
        }
        logger.error(`[GetOrInitOrgDb] Unhandled error in getOrInitOrgDb for orgId ${orgId}: ${error instanceof Error ? error.message : String(error)}`)
        if (error instanceof Error && error.stack) {
          logger.error(`Stack trace: ${error.stack}`)
        }
        throw error
      }
    }
  }

  /**
   * Ensure that the organization database has all required tables
   * This can be used to add new tables to existing databases when the schema changes
   */
  static async ensureDatabaseSchema(orgId: string): Promise<void> {
    const orgDb = await Database.getOrgDb(orgId);
    
    // Define tables and their schema
    const tables = [
      {
        name: 'contacts',
        createStatement: `
          CREATE TABLE IF NOT EXISTS contacts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            last_name TEXT NOT NULL,
            email TEXT NOT NULL,
            current_carrier TEXT NOT NULL,
            plan_type TEXT NOT NULL,
            effective_date TEXT NOT NULL,
            birth_date TEXT NOT NULL,
            tobacco_user INTEGER NOT NULL,
            gender TEXT NOT NULL,
            state TEXT NOT NULL,
            zip_code TEXT NOT NULL,
            agent_id INTEGER,
            last_emailed DATETIME,
            phone_number TEXT NOT NULL DEFAULT '',
            status TEXT NOT NULL DEFAULT '',
            aep_request BOOLEAN DEFAULT FALSE,
            aep_request_date DATETIME,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email)`,
          `CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))`,
        ],
      },
      {
        name: 'eligibility_answers',
        createStatement: `CREATE TABLE IF NOT EXISTS eligibility_answers (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          contact_id INTEGER NOT NULL,
          quote_id TEXT NOT NULL,
          answers TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id)
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_eligibility_answers_contact_id ON eligibility_answers(contact_id)`
        ]
      },
      {
        name: 'contact_events',
        createStatement: `CREATE TABLE IF NOT EXISTS contact_events (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          contact_id INTEGER,
          lead_id INTEGER,
          event_type TEXT NOT NULL,
          metadata TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE,
          FOREIGN KEY (lead_id) REFERENCES leads(id) ON DELETE CASCADE
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id)`,
          `CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id)`,
          `CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type)`
        ]
      },
      {
        name: 'tracking_clicks',
        createStatement: `CREATE TABLE IF NOT EXISTS tracking_clicks (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          tracking_id TEXT NOT NULL,
          path TEXT NOT NULL,
          query TEXT,
          contact_id INTEGER,
          ip_address TEXT,
          user_agent TEXT,
          referrer TEXT,
          clicked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_tracking_id ON tracking_clicks(tracking_id)`,
          `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_contact_id ON tracking_clicks(contact_id)`,
          `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_clicked_at ON tracking_clicks(clicked_at)`
        ]
      },
      {
        name: 'leads',
        createStatement: `CREATE TABLE IF NOT EXISTS leads (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          email TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          UNIQUE(email)
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email)`
        ]
      },
      {
        name: 'email_send_tracking',
        createStatement: `CREATE TABLE IF NOT EXISTS email_send_tracking (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          org_id INTEGER NOT NULL,
          contact_id INTEGER NOT NULL,
          email_type TEXT NOT NULL,
          scheduled_date TEXT NOT NULL,
          send_status TEXT NOT NULL CHECK(send_status IN ('pending', 'processing', 'accepted', 'delivered', 'sent', 'deferred', 'bounced', 'dropped', 'failed', 'skipped')) DEFAULT 'pending',
          send_mode TEXT NOT NULL CHECK(send_mode IN ('test', 'production')) DEFAULT 'test',
          test_email TEXT,
          send_attempt_count INTEGER NOT NULL DEFAULT 0,
          last_attempt_date TEXT,
          last_error TEXT,
          batch_id TEXT NOT NULL,
          message_id TEXT,
          delivery_status TEXT,
          status_checked_at TEXT,
          status_details TEXT,
          created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
          updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
        )`,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_batch_id ON email_send_tracking(batch_id)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_send_status ON email_send_tracking(send_status)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_send_mode ON email_send_tracking(send_mode)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_id ON email_send_tracking(contact_id)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_type ON email_send_tracking(contact_id, email_type)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_status_date ON email_send_tracking(send_status, scheduled_date)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_message_id ON email_send_tracking(message_id)`,
          `CREATE INDEX IF NOT EXISTS idx_email_tracking_delivery_status ON email_send_tracking(delivery_status)`,
          `CREATE TRIGGER IF NOT EXISTS update_email_tracking_timestamp AFTER UPDATE ON email_send_tracking BEGIN UPDATE email_send_tracking SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; END`
        ]
      },
      {
        name: 'email_schedules',
        createStatement: `
          CREATE TABLE IF NOT EXISTS email_schedules (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            org_id INTEGER NOT NULL,
            contact_id INTEGER NOT NULL,
            email_type TEXT NOT NULL,
            scheduled_send_date TEXT NOT NULL,
            scheduled_send_time TEXT NOT NULL DEFAULT '08:30:00',
            actual_send_datetime TEXT,
            batch_id TEXT,
            status TEXT NOT NULL DEFAULT 'pre-scheduled',
            skip_reason TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `,
        indexStatements: [
          `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_contact ON email_schedules (contact_id)`,
          `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_send_date ON email_schedules (scheduled_send_date)`,
          `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_send_time ON email_schedules (scheduled_send_time)`,
          `CREATE INDEX IF NOT EXISTS idx_email_schedules_status ON email_schedules (status)`,
          `CREATE TRIGGER IF NOT EXISTS update_email_schedules_updated_at
AFTER UPDATE ON email_schedules
FOR EACH ROW
BEGIN
    UPDATE email_schedules
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = OLD.id;
END;`
        ]
      },
      {
        name: 'deleted_contacts',
        createSql: `
          CREATE TABLE IF NOT EXISTS deleted_contacts (
              original_contact_id INTEGER NOT NULL, -- The ID from the original 'contacts' table
              first_name TEXT,
              last_name TEXT,
              email TEXT NOT NULL,        -- Must be normalized: lowercase, trimmed
              phone_number TEXT,
              current_carrier TEXT,       -- Optional: Include other relevant fields
              plan_type TEXT,             -- Optional
              effective_date TEXT,        -- Optional
              birth_date TEXT,            -- Optional
              tobacco_user INTEGER,       -- Optional
              gender TEXT,                -- Optional
              state TEXT,                 -- Optional
              zip_code TEXT,              -- Optional
              agent_id INTEGER,           -- Optional
              status TEXT,                -- Optional: Original status before deletion
              deleted_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL
          )
        `,
        indexSqls: [
          `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_email_org ON deleted_contacts (LOWER(TRIM(email)))`,
          `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_deleted_at ON deleted_contacts (deleted_at)`,
          `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_original_id ON deleted_contacts (original_contact_id)`
        ]
      }
    ];
    
    // Get all existing tables in one query for efficiency
    const existingTables = await orgDb.fetchAll(
      `SELECT name FROM sqlite_master WHERE type='table' AND name IN (${tables.map(t => `'${t.name}'`).join(', ')})`
    );
    
    // Create a set of existing table names for faster lookup
    const tableSet = new Set(existingTables.map((row: any) => row.name || row[0]));
    
    // Prepare batch operations
    const batchOperations = [];
    
    for (const table of tables) {
      if (!tableSet.has(table.name)) {
        logger.info(`Adding create table operation for ${table.name}`);
        if (table.createStatement) {
          batchOperations.push({
            sql: table.createStatement,
            args: []
          });
        }
      }
      
      // Always add index creation statements, even for existing tables
      // This ensures all necessary indexes exist in all databases
      if (table.indexStatements) {
        for (const indexStatement of table.indexStatements) {
          logger.info(`Ensuring index for ${table.name}: ${indexStatement}`);
          batchOperations.push({
            sql: indexStatement,
            args: []
          });
        }
      }
    }
    
    // Execute all schema operations in a single batch if there are any
    if (batchOperations.length > 0) {
      logger.info(`Executing ${batchOperations.length} schema operations in batch for org ${orgId}`);
      await orgDb.batch(batchOperations, 'write');
      logger.info(`Schema setup completed successfully for org ${orgId}`);
    } else {
      logger.info(`No schema changes needed for org ${orgId}`);
    }
  }

  getClient() {
    return this.client
  }

  async execute(sql: string, args: any[] = []) {
    try {
      if (this.isLocal && this.bunDb) {
        // For local SQLite
        const stmt = this.bunDb.prepare(sql)
        const result = stmt.run(...args)
        return {
          rows: Array.isArray(result) ? result : result.changes > 0 ? [result] : [],
          rowsAffected: result.changes
        }
      } else {
        // For Turso
        const result = await this.client.execute({
          sql,
          args
        })
        return result
      }
    } catch (error) {
      logger.error(`Database execute error: ${error}`)
      throw error
    }
  }
  
  /**
   * Execute a batch of SQL statements in an implicit transaction
   * @param statements Array of SQL statements with args
   * @param mode Transaction mode (read or write)
   * @returns Result of the batch operation
   */
  async batch(statements: { sql: string, args: any[] }[], mode: 'read' | 'write' = 'write') {
    try {
      if (this.isLocal && this.bunDb) {
        // For local SQLite, implement batch manually with transaction
        this.bunDb.exec('BEGIN TRANSACTION');
        const results = [];
        
        try {
          for (const { sql, args } of statements) {
            const stmt = this.bunDb.prepare(sql);
            const result = stmt.run(...args);
            results.push({
              rows: Array.isArray(result) ? result : result.changes > 0 ? [result] : [],
              rowsAffected: result.changes
            });
          }
          
          this.bunDb.exec('COMMIT');
          return results;
        } catch (error) {
          this.bunDb.exec('ROLLBACK');
          throw error;
        }
      } else {
        // For Turso, use native batch support
        const batchStatements = statements.map(({ sql, args }) => ({
          sql,
          args: args || []
        }));
        
        return await this.client.batch(batchStatements, mode);
      }
    } catch (error) {
      logger.error(`Database batch error: ${error}`);
      throw error;
    }
  }

  async fetchAll(sql: string, args: any[] = []) {
    try {
      if (this.isLocal && this.bunDb) {
        // For local SQLite
        const stmt = this.bunDb.prepare(sql)
        const rows = stmt.all(...args)
        return rows || []
      } else {
        // For Turso
        const result = await this.client.execute({
          sql,
          args
        })
        return result.rows || []
      }
    } catch (error) {
      logger.error(`Database fetchAll error: ${error}`)
      throw error
    }
  }

  async fetchOne<T>(sql: string, args: any[] = []): Promise<T | null> {
    if (this.isLocal && this.bunDb) {
      // For local SQLite
      const stmt = this.bunDb.prepare(sql)
      const row = stmt.get(...args)
      return row as T || null
    } else {
      // For Turso
      const result = await this.execute(sql, args)
      if (!result.rows || result.rows.length === 0) return null
      const row = result.rows[0]
      const columns = result.columns || []
      const obj: any = {}
      columns.forEach((col: string, i: number) => (obj[col] = row[i]))
      return obj as T
    }
  }

  // Compatibility method for old query interface
  async query<T = any>(sql: string, args: any[] = []): Promise<T[]> {
    return this.fetchAll(sql, args)
  }

  // Add transaction support for local SQLite
  async transaction<T>(callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(mode: 'read' | 'write', callback: (tx: Database) => Promise<T>): Promise<T>;
  async transaction<T>(
    callbackOrMode: ((tx: Database) => Promise<T>) | 'read' | 'write',
    callback?: (tx: Database) => Promise<T>
  ): Promise<T> {
    let mode: 'read' | 'write' = 'write'
    let fn: ((tx: Database) => Promise<T>) | null = null

    if (typeof callbackOrMode === 'string') {
      mode = callbackOrMode
      fn = callback || null
    } else {
      fn = callbackOrMode
    }
    
    if (!fn) {
      throw new Error('Transaction callback is required')
    }

    if (this.isLocal && this.bunDb) {
      // For local SQLite
      try {
        this.bunDb.exec('BEGIN TRANSACTION')
        const result = await fn(this)
        this.bunDb.exec('COMMIT')
        return result
      } catch (error) {
        this.bunDb.exec('ROLLBACK')
        throw error
      }
    } else {
      // For Turso
      const tx = await this.client.transaction(mode)
      try {
        const txWrapper = new Database()
        txWrapper.client = tx
        const result = await fn(txWrapper)
        await tx.commit()
        return result
      } catch (error) {
        await tx.rollback()
        throw error
      }
    }
  }

  /**
   * Bulk import contacts from CSV directly into the database
   */
  static async bulkImportContacts(
    orgId: string,
    csvFilePath: string,
    overwriteExisting: boolean = false,
    columnMapping?: ColumnMapping,
    carrierMapping?: CarrierMapping,
    agentId?: number | null
  ): Promise<string> {
    logger.info(`Starting bulk import for organization ${orgId} from ${csvFilePath}`);
    
    try {
      // get the main db
      const mainDb = new Database();
      
      // get the org db url / auth token
      const orgData = await mainDb.fetchOne<{ turso_db_url: string, turso_auth_token: string }>(
        'SELECT turso_db_url, turso_auth_token FROM organizations WHERE id = ?',
        [orgId]
      );

      if (!orgData) {
        throw new Error(`Organization ${orgId} not found`);
      }

      const { turso_db_url, turso_auth_token } = orgData;

      if (!turso_db_url || !turso_auth_token) {
        throw new Error(`Could not get database configuration for organization ${orgId}`);
      }

      // First, download the existing database from Turso
      const tursoService = new TursoService();
      logger.info(`Downloading existing database from Turso for org ${orgId}`);
      logger.info(`Turso DB URL: ${turso_db_url}`);
      logger.info(`Turso Auth Token: ${turso_auth_token}`);
      const dumpContent = await tursoService.downloadDatabaseDump(turso_db_url, turso_auth_token);
      logger.info(`Downloaded ${dumpContent.length} bytes of database dump`);

      // Create a temporary file for the dump
      const tempDumpFile = `dump-${Date.now()}.sql`;
      const tempDbFile = `temp-${Date.now()}.db`;
      let localDb: BunDatabase | null = null;
      
      try {
        // Write dump to temporary file
        await fsPromises.writeFile(tempDumpFile, dumpContent);

        // Use sqlite3 CLI to create and populate the database
        logger.info('Creating temporary database from dump...');
        await new Promise((resolve, reject) => {
          const sqlite = Bun.spawn(['sqlite3', tempDbFile], {
            stdin: Bun.file(tempDumpFile),
            onExit(proc, exitCode, signalCode, error) {
              if (exitCode === 0) {
                resolve(null);
              } else {
                reject(new Error(`SQLite process exited with code ${exitCode}: ${error}`));
              }
            }
          });
        });

        logger.info('Successfully created temporary database from dump');

        // Now connect to the temporary database using BunSQLite
        localDb = new BunDatabase(tempDbFile);

        // Use DELETE journal mode instead of WAL for direct file writes
        localDb.exec('PRAGMA journal_mode = DELETE');
        localDb.exec('PRAGMA foreign_keys = OFF');

        // Drop the unique index on email temporarily to allow the import
        logger.info('Dropping unique email index for import...');
        localDb.exec('DROP INDEX IF EXISTS idx_contacts_email_unique');

        // Verify the database state before CSV import
        const tables = ['contacts', 'contact_events', 'leads', 'eligibility_answers', 'email_send_tracking'];
        for (const table of tables) {
          try {
            const count = localDb.prepare(`SELECT COUNT(*) as count FROM ${table}`).get() as { count: number };
            logger.info(`Table ${table} before CSV import: ${count.count} rows`);
          } catch (error) {
            logger.error(`Error counting rows in ${table}: ${error}`);
          }
        }

        // Now process the new contacts from CSV
        logger.info(`Processing new contacts from CSV file`);
        
        // Read the CSV file
        const fileContents = await fsPromises.readFile(csvFilePath, 'utf8');
        const rows = await new Promise<any[]>((resolve, reject) => {
          const results: any[] = [];
          const parser = parse(fileContents, { columns: true });
          
          parser.on('readable', function() {
            let record;
            while ((record = parser.read()) !== null) {
              results.push(record);
            }
          });
          
          parser.on('error', function(err) {
            reject(err);
          });
          
          parser.on('end', function() {
            resolve(results);
          });
        });
        
        logger.info(`Processing ${rows.length} rows from CSV`);
        
        // Find the email column (required for deduplication)
        const emailColumn = columnMapping ? columnMapping.email : 'email';
        if (!rows[0]?.[emailColumn]) {
          throw new Error(`Email column "${emailColumn}" not found in CSV`);
        }
        
        // Map columns based on provided mapping or use default field names
        const processRow = (row: any) => {
          const mappedRow: any = {};
          
          // Apply column mappings if provided
          if (columnMapping) {
            // Map each field using the provided column mapping
            mappedRow.first_name = row[columnMapping.firstName] || '';
            mappedRow.last_name = row[columnMapping.lastName] || '';
            mappedRow.email = row[columnMapping.email] || '';
            mappedRow.phone_number = row[columnMapping.phoneNumber] || '';
            mappedRow.zip_code = row[columnMapping.zipCode] || '';
            
            // Infer state from zip code
            if (mappedRow.zip_code && ZIP_DATA[mappedRow.zip_code]) {
              mappedRow.state = ZIP_DATA[mappedRow.zip_code].state;
              logger.info(`Inferred state ${mappedRow.state} from zip code ${mappedRow.zip_code}`);
            } else if (columnMapping.state && row[columnMapping.state]) {
              // Fallback to provided state if zip code lookup fails
              mappedRow.state = row[columnMapping.state] || '';
              logger.info(`Using provided state ${mappedRow.state} (zip code lookup failed)`);
            } else {
              logger.warn(`No state found for zip code ${mappedRow.zip_code}, defaulting to empty string`);
              mappedRow.state = '';
            }
            
            // Apply carrier mapping if provided
            let carrierValue = '';
            if (columnMapping.currentCarrier && row[columnMapping.currentCarrier]) {
              const originalCarrier = row[columnMapping.currentCarrier];
              
              // Use carrier mapping if available
              if (carrierMapping && carrierMapping.mappings[originalCarrier]) {
                carrierValue = carrierMapping.mappings[originalCarrier];
                
                // If mapped to "Other", preserve original value
                if (carrierValue === 'Other') {
                  carrierValue = originalCarrier;
                }
              } else {
                carrierValue = originalCarrier;
              }
            }
            
            mappedRow.current_carrier = carrierValue;
            mappedRow.effective_date = row[columnMapping.effectiveDate] || '';
            mappedRow.birth_date = row[columnMapping.birthDate] || '';
            mappedRow.tobacco_user = row[columnMapping.tobaccoUser] === 'true' || row[columnMapping.tobaccoUser] === 'yes' || row[columnMapping.tobaccoUser] === '1';
            mappedRow.gender = row[columnMapping.gender] || '';
            mappedRow.plan_type = row[columnMapping.planType] || '';
          } else {
            // Use default field names if no mapping provided
            mappedRow.first_name = row.first_name || row.firstName || '';
            mappedRow.last_name = row.last_name || row.lastName || '';
            mappedRow.email = row.email || '';
            mappedRow.phone_number = row.phone_number || row.phoneNumber || '';
            mappedRow.zip_code = row.zip_code || row.zipCode || '';
            
            // Infer state from zip code
            if (mappedRow.zip_code && ZIP_DATA[mappedRow.zip_code]) {
              mappedRow.state = ZIP_DATA[mappedRow.zip_code].state;
              logger.info(`Inferred state ${mappedRow.state} from zip code ${mappedRow.zip_code}`);
            } else if (row.state) {
              // Fallback to provided state if zip code lookup fails
              mappedRow.state = row.state || '';
              logger.info(`Using provided state ${mappedRow.state} (zip code lookup failed)`);
            } else {
              logger.warn(`No state found for zip code ${mappedRow.zip_code}, defaulting to empty string`);
              mappedRow.state = '';
            }
            
            mappedRow.current_carrier = row.current_carrier || row.currentCarrier || '';
            mappedRow.effective_date = row.effective_date || row.effectiveDate || '';
            mappedRow.birth_date = row.birth_date || row.birthDate || '';
            mappedRow.tobacco_user = row.tobacco_user === 'true' || row.tobacco_user === 'yes' || row.tobacco_user === '1' ||
                                   row.tobaccoUser === 'true' || row.tobaccoUser === 'yes' || row.tobaccoUser === '1';
            mappedRow.gender = row.gender || '';
            mappedRow.plan_type = row.plan_type || row.planType || '';
          }
          
          // Add standard fields
          mappedRow.created_at = new Date().toISOString();
          mappedRow.updated_at = new Date().toISOString();
          
          // Add agent_id if provided
          if (agentId !== undefined && agentId !== null) {
            mappedRow.agent_id = agentId;
          }
          
          return mappedRow;
        };
        
        // Begin transaction for CSV import
        localDb.exec('BEGIN TRANSACTION');
        
        try {
          // First, get all existing emails (for manual deduplication)
          const existingEmails = new Set(
            localDb.prepare('SELECT LOWER(TRIM(email)) as email FROM contacts')
              .all()
              .map((row: any) => row.email || row[0])
          );

          logger.info(`Found ${existingEmails.size} existing emails in database`);

          // Prepare insert statement (without ON CONFLICT since we're handling it manually)
          const stmt = localDb.prepare(`
            INSERT INTO contacts (
              first_name, last_name, email, phone_number, state,
              current_carrier, effective_date, birth_date, tobacco_user,
              gender, zip_code, plan_type, agent_id, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `);

          let totalProcessed = 0;
          let totalAdded = 0;
          let totalSkipped = 0;

          // Process each row
          for (const row of rows) {
            totalProcessed++;
            const processedRow = processRow(row);
            const email = processedRow.email.toLowerCase().trim();
            
            if (!email) {
              logger.warn('Skipping row with no email address');
              totalSkipped++;
              continue;
            }

            try {
              if (existingEmails.has(email)) {
                if (overwriteExisting) {
                  // Update existing record
                  localDb.prepare(`
                    UPDATE contacts SET
                      first_name = ?, last_name = ?, phone_number = ?, state = ?,
                      current_carrier = ?, effective_date = ?, birth_date = ?,
                      tobacco_user = ?, gender = ?, zip_code = ?, plan_type = ?,
                      agent_id = ?, updated_at = ?
                    WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))
                  `).run(
                    processedRow.first_name,
                    processedRow.last_name,
                    processedRow.phone_number,
                    processedRow.state,
                    processedRow.current_carrier,
                    processedRow.effective_date,
                    processedRow.birth_date,
                    processedRow.tobacco_user ? 1 : 0,
                    processedRow.gender,
                    processedRow.zip_code,
                    processedRow.plan_type,
                    processedRow.agent_id || null,
                    processedRow.updated_at,
                    email
                  );
                  totalAdded++;
                } else {
                  totalSkipped++;
                }
              } else {
                stmt.run(
                  processedRow.first_name,
                  processedRow.last_name,
                  email,
                  processedRow.phone_number,
                  processedRow.state,
                  processedRow.current_carrier,
                  processedRow.effective_date,
                  processedRow.birth_date,
                  processedRow.tobacco_user ? 1 : 0,
                  processedRow.gender,
                  processedRow.zip_code,
                  processedRow.plan_type,
                  processedRow.agent_id || null,
                  processedRow.created_at,
                  processedRow.updated_at
                );
                existingEmails.add(email);
                totalAdded++;
              }
            } catch (err) {
              logger.error(`Error processing row with email ${email}: ${err}`);
              totalSkipped++;
            }
          }

          // Recreate the unique index after import
          logger.info('Recreating unique email index...');
          localDb.exec('CREATE UNIQUE INDEX idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))');

          // Commit CSV import transaction
          localDb.exec('COMMIT');
          
          // Force a checkpoint to ensure all changes are written to disk
          localDb.exec('PRAGMA wal_checkpoint(TRUNCATE)');
          
          logger.info(`Successfully processed all rows from CSV`);
          logger.info(`Total processed: ${totalProcessed}, added: ${totalAdded}, skipped: ${totalSkipped}`);

          // Verify final counts
          const finalCount = localDb.prepare('SELECT COUNT(*) as count FROM contacts').get() as { count: number };
          logger.info(`Final contact count in database: ${finalCount.count} (should be ${existingEmails.size} + new additions)`);

          // Close the database to ensure all changes are flushed
          localDb.close();
          localDb = null;

          try {
            // Create new database and upload data
            logger.info(`Creating new Turso database for import`);
            const { dbName: newOrgDbName, url: newOrgDbUrl, token: newOrgDbToken } = await tursoService.createDatabaseForImport(orgId);
            
            // Upload the local db to the new org db
            logger.info(`Uploading data to new Turso database at ${newOrgDbUrl}`);
            await tursoService.uploadDatabase(newOrgDbName, newOrgDbToken, `file:${tempDbFile}`);
            
            // Update main db with new org db url / auth token 
            logger.info(`Updating organization ${orgId} with new database credentials`);
            await mainDb.execute(`
              UPDATE organizations 
              SET turso_db_url = ?, turso_auth_token = ?
              WHERE id = ?
            `, [newOrgDbUrl, newOrgDbToken, orgId]);
            
            logger.info(`Successfully completed import for organization ${orgId}`);
            
            // Return success message with import stats
            return `Successfully imported ${totalAdded} contacts (${totalSkipped} skipped) to new database: ${newOrgDbUrl}`;
          } catch (importError) {
            logger.error(`Error during Turso database creation or upload: ${importError}`);
            throw importError;
          }
        } catch (error) {
          // Rollback transaction on error
          try {
            if (localDb) {
              localDb.exec('ROLLBACK');
            }
          } catch (rollbackError) {
            logger.error(`Error during transaction rollback: ${rollbackError}`);
          }
          throw error;
        }
      } finally {
        // Clean up temporary files
        try {
          if (localDb) {
            localDb.close();
          }
          await fsPromises.unlink(tempDumpFile);
          await fsPromises.unlink(tempDbFile);
          logger.info('Cleaned up temporary files');
        } catch (cleanupError) {
          logger.error(`Error cleaning up temporary files: ${cleanupError}`);
        }
      }
    } catch (error) {
      logger.error(`Error in bulk import for organization ${orgId}: ${error}`);
      throw error;
    }
  }

  static getUserFromSession = getUserFromSession;
  static getOrganizationById = getOrganizationById;

  static async ensureOrgSchema(orgDb: Database): Promise<void> {
    try {
      // Get all existing tables at once
      const existingTables = await orgDb.fetchAll(
        "SELECT name FROM sqlite_master WHERE type='table' AND name IN ('contacts', 'contact_events', 'tracking_clicks', 'leads', 'eligibility_answers', 'email_send_tracking', 'email_schedules', 'deleted_contacts')"
      );

      // Create a set of existing table names for faster lookup
      const tableSet = new Set(existingTables.map((row: any) => row.name || row[0]));
      
      // Define tables with their schema and indexes
      const tables = [
        {
          name: 'contacts',
          createSql: `
            CREATE TABLE IF NOT EXISTS contacts (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              first_name TEXT NOT NULL,
              last_name TEXT NOT NULL,
              email TEXT NOT NULL UNIQUE,
              current_carrier TEXT,
              plan_type TEXT,
              effective_date TEXT,
              birth_date TEXT,
              tobacco_user INTEGER NOT NULL,
              gender TEXT,
              state TEXT,
              zip_code TEXT,
              agent_id INTEGER,
              last_emailed DATETIME,
              phone_number TEXT,
              status TEXT NOT NULL DEFAULT '',
              aep_request BOOLEAN DEFAULT FALSE,
              aep_request_date DATETIME,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email)`,
            `CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)))`,
            `CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id)`,
            `CREATE INDEX IF NOT EXISTS idx_contacts_status ON contacts(status)`,
            `CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp AFTER UPDATE ON contacts BEGIN UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; END`
          ]
        },
        {
          name: 'contact_events',
          createSql: `
            CREATE TABLE IF NOT EXISTS contact_events (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              contact_id INTEGER,
              lead_id INTEGER,
              event_type TEXT NOT NULL,
              metadata TEXT,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE,
              FOREIGN KEY (lead_id) REFERENCES leads(id) ON DELETE CASCADE
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id)`,
            `CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id)`,
            `CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type)`
          ]
        },
        {
          name: 'tracking_clicks',
          createSql: `
            CREATE TABLE IF NOT EXISTS tracking_clicks (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              tracking_id TEXT NOT NULL,
              contact_id INTEGER,
              quote_id TEXT,
              clicked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_tracking_id ON tracking_clicks(tracking_id)`,
            `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_contact_id ON tracking_clicks(contact_id)`,
            `CREATE INDEX IF NOT EXISTS idx_tracking_clicks_clicked_at ON tracking_clicks(clicked_at)`,
          ]
        },
        {
          name: 'leads',
          createSql: `
            CREATE TABLE IF NOT EXISTS leads (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL,
              email TEXT NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              UNIQUE(email)
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email)`
          ]
        },
        {
          name: 'eligibility_answers',
          createSql: `
            CREATE TABLE IF NOT EXISTS eligibility_answers (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              contact_id INTEGER NOT NULL,
              quote_id TEXT NOT NULL,
              answers TEXT NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_eligibility_answers_contact_id ON eligibility_answers(contact_id)`
          ]
        },
        {
          name: 'email_send_tracking',
          createSql: `
            CREATE TABLE IF NOT EXISTS email_send_tracking (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              org_id INTEGER NOT NULL,
              contact_id INTEGER NOT NULL,
              email_type TEXT NOT NULL,
              scheduled_date TEXT NOT NULL,
              send_status TEXT NOT NULL CHECK(send_status IN ('pending', 'processing', 'accepted', 'delivered', 'sent', 'deferred', 'bounced', 'dropped', 'failed', 'skipped')) DEFAULT 'pending',
              send_mode TEXT NOT NULL CHECK(send_mode IN ('test', 'production')) DEFAULT 'test',
              test_email TEXT,
              send_attempt_count INTEGER NOT NULL DEFAULT 0,
              last_attempt_date TEXT,
              last_error TEXT,
              batch_id TEXT NOT NULL,
              message_id TEXT,
              delivery_status TEXT,
              status_checked_at TEXT,
              status_details TEXT,
              created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
              updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (contact_id) REFERENCES contacts(id) ON DELETE CASCADE
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_batch_id ON email_send_tracking(batch_id)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_send_status ON email_send_tracking(send_status)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_send_mode ON email_send_tracking(send_mode)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_id ON email_send_tracking(contact_id)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_contact_type ON email_send_tracking(contact_id, email_type)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_status_date ON email_send_tracking(send_status, scheduled_date)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_message_id ON email_send_tracking(message_id)`,
            `CREATE INDEX IF NOT EXISTS idx_email_tracking_delivery_status ON email_send_tracking(delivery_status)`,
            `CREATE TRIGGER IF NOT EXISTS update_email_tracking_timestamp AFTER UPDATE ON email_send_tracking BEGIN UPDATE email_send_tracking SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; END`
          ]
        },
        {
          name: 'email_schedules',
          createSql: `
            CREATE TABLE IF NOT EXISTS email_schedules (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              contact_id INTEGER NOT NULL,
              email_type TEXT NOT NULL,
              scheduled_send_date TEXT NOT NULL,
              scheduled_send_time TEXT NOT NULL DEFAULT '08:30:00',
              actual_send_datetime TEXT,
              batch_id TEXT,
              status TEXT NOT NULL DEFAULT 'pre-scheduled',
              skip_reason TEXT,
              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
              updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_contact ON email_schedules (contact_id)`,
            `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_send_date ON email_schedules (scheduled_send_date)`,
            `CREATE INDEX IF NOT EXISTS idx_email_schedules_org_send_time ON email_schedules (scheduled_send_time)`,
            `CREATE INDEX IF NOT EXISTS idx_email_schedules_status ON email_schedules (status)`,
            `CREATE TRIGGER IF NOT EXISTS update_email_schedules_updated_at
AFTER UPDATE ON email_schedules
FOR EACH ROW
BEGIN
    UPDATE email_schedules
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = OLD.id;
END;`
          ]
        },
        {
          name: 'deleted_contacts',
          createSql: `
            CREATE TABLE IF NOT EXISTS deleted_contacts (
                original_contact_id INTEGER NOT NULL, -- The ID from the original 'contacts' table
                first_name TEXT,
                last_name TEXT,
                email TEXT NOT NULL,        -- Must be normalized: lowercase, trimmed
                phone_number TEXT,
                current_carrier TEXT,       -- Optional: Include other relevant fields
                plan_type TEXT,             -- Optional
                effective_date TEXT,        -- Optional
                birth_date TEXT,            -- Optional
                tobacco_user INTEGER,       -- Optional
                gender TEXT,                -- Optional
                state TEXT,                 -- Optional
                zip_code TEXT,              -- Optional
                agent_id INTEGER,           -- Optional
                status TEXT,                -- Optional: Original status before deletion
                deleted_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL
            )
          `,
          indexSqls: [
            `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_email_org ON deleted_contacts (LOWER(TRIM(email)))`,
            `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_deleted_at ON deleted_contacts (deleted_at)`,
            `CREATE INDEX IF NOT EXISTS idx_deleted_contacts_original_id ON deleted_contacts (original_contact_id)`
          ]
        }
      ];
      
      // Prepare batch operations
      const schemaOperations = [];
      
      // Process each table
      for (const table of tables) {
        // Create table if it doesn't exist
        if (!tableSet.has(table.name)) {
          logger.info(`Creating ${table.name} table schema`);
          schemaOperations.push({
            sql: table.createSql,
            args: []
          });
        }
        
        // Always add indexes regardless of whether table existed before
        // This ensures all necessary indexes exist in all databases
        for (const indexSql of table.indexSqls) {
          logger.info(`Ensuring index for ${table.name}: ${indexSql}`);
          schemaOperations.push({
            sql: indexSql,
            args: []
          });
        }
      }
      
      // Execute all schema operations in a single batch if there are any
      if (schemaOperations.length > 0) {
        logger.info(`Executing ${schemaOperations.length} schema operations in batch`);
        await orgDb.batch(schemaOperations, 'write');
        logger.info('Schema setup completed successfully');
      } else {
        logger.info('All required tables exist, checking indexes...');
        
        // Even if all tables exist, we still need to ensure all indexes exist
        const indexOperations = [];
        for (const table of tables) {
          for (const indexSql of table.indexSqls) {
            indexOperations.push({
              sql: indexSql,
              args: []
            });
          }
        }
        
        if (indexOperations.length > 0) {
          logger.info(`Ensuring ${indexOperations.length} indexes exist`);
          await orgDb.batch(indexOperations, 'write');
          logger.info('Index verification completed');
        }
      }
    } catch (error) {
      logger.error(`Error ensuring org schema: ${error}`);
      throw error;
    }
  }

  close() {
    if (this.isLocal && this.bunDb) {
      this.bunDb.close()
    }
  }

  private async fetch(fetchUrl: RequestInfo, options: RequestInit | undefined = undefined): Promise<Response> {
    const response = await fetch(fetchUrl, options || {});
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response;
  }

  private async fetchWithRetry(fetchUrl: RequestInfo, options: RequestInit | undefined = undefined): Promise<Response> {
    const maxRetries = 3;
    let lastError: Error | null = null;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const response = await this.fetch(fetchUrl, options);
        if (response.status === 429) {
          // Rate limited, wait with exponential backoff
          const delay = Math.pow(2, attempt) * 1000;
          logger.warn(`Rate limit hit, retry ${attempt + 1}/${maxRetries} after ${delay}ms`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        return response;
      } catch (error) {
        lastError = error as Error;
        if (attempt < maxRetries - 1) {
          const delay = Math.pow(2, attempt) * 1000;
          logger.warn(`Request failed, retry ${attempt + 1}/${maxRetries} after ${delay}ms: ${error}`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError || new Error('Max retries reached');
  }
}

export const db = new Database() 

/**
 * Get user from session cookie
 */
export async function getUserFromSession(request: any): Promise<any> {
  try {
    const db = new Database();
    let sessionCookie: string | undefined;

    // Handle different request header formats
    if (request.headers) {
      if (typeof request.headers.get === 'function') {
        // Standard Request object
        sessionCookie = request.headers.get('cookie')?.split(';')
          .find((c: string) => c.trim().startsWith('session='))
          ?.split('=')[1];
      } else if (typeof request.headers === 'object') {
        // Raw headers object or Express request
        const cookieHeader = request.headers.cookie || request.headers['cookie'] || request.headers['Cookie'];
        if (typeof cookieHeader === 'string') {
          sessionCookie = cookieHeader.split(';')
            .find((c: string) => c.trim().startsWith('session='))
            ?.split('=')[1];
        }
      }
    }

    if (!sessionCookie) {
      logger.info('No session cookie found');
      return null;
    }

    // Log the session ID for debugging
    logger.info(`Session lookup result: ${JSON.stringify(await db.fetchOne('SELECT * FROM sessions WHERE id = ?', [sessionCookie]))}`);
    
    // Check if the session exists and hasn't expired
    const session = await db.fetchOne<{ id: string, user_id: number, expires_at: string, created_at: string }>(
      'SELECT * FROM sessions WHERE id = ?',
      [sessionCookie]
    );

    if (!session) {
      logger.info('No valid session found');
      return null;
    }

    // Check if session has expired
    const expiresAt = new Date(session.expires_at);
    const now = new Date();
    
    logger.info(`Session expires: ${expiresAt}, current time: ${now}`);
    
    if (expiresAt < now) {
      logger.info('Session has expired');
      return null;
    }

    // Get the user associated with the session
    const user = await db.fetchOne(
      'SELECT u.*, o.name as organization_name FROM users u JOIN organizations o ON u.organization_id = o.id WHERE u.id = ?',
      [session.user_id]
    );

    logger.info(`User lookup result: ${JSON.stringify(user)}`);

    if (!user) {
      logger.info('No user found for session');
      return null;
    }
    
    return user;
  } catch (error) {
    logger.error(`Error getting user from session: ${error}`);
    return null;
  }
}

/**
 * Get organization by ID
 */
export async function getOrganizationById(orgId: number): Promise<any> {
  try {
    const db = new Database();
    const org = await db.query('SELECT * FROM organizations WHERE id = ?', [orgId]);
    if (!org || org.length === 0) return null;
    return org[0];
  } catch (error) {
    logger.error(`Error getting organization: ${error}`);
    return null;
  }
}

// Function to split SQL dump into individual statements
function splitSqlStatements(sql: string): string[] {
  const statements: string[] = [];
  let currentStatement = "";
  let inString = false;
  let inComment = false;
  let inBlockComment = false;
  let stringQuote: string | null = null;

  for (let i = 0; i < sql.length; i++) {
    const char = sql[i];
    const nextChar = i + 1 < sql.length ? sql[i + 1] : null;

    // Handle comments
    if (!inString) {
      if (char === "-" && nextChar === "-" && !inBlockComment) {
        inComment = true;
        i++; // Skip next char
        continue;
      }
      if (char === "/" && nextChar === "*" && !inComment) {
        inBlockComment = true;
        i++;
        continue;
      }
      if (inComment && char === "\n") {
        inComment = false;
        continue;
      }
      if (inBlockComment && char === "*" && nextChar === "/") {
        inBlockComment = false;
        i++;
        continue;
      }
      if (inComment || inBlockComment) {
        continue;
      }
    }

    // Handle string literals
    if ((char === "'" || char === '"') && !inComment && !inBlockComment) {
      if (!inString) {
        inString = true;
        stringQuote = char;
      } else if (char === stringQuote) {
        // Check for escaped quotes
        if (sql[i - 1] !== "\\") {
          inString = false;
          stringQuote = null;
        }
      }
    }

    // Handle statement termination
    if (char === ";" && !inString && !inComment && !inBlockComment) {
      statements.push(currentStatement.trim());
      currentStatement = "";
      continue;
    }

    currentStatement += char;
  }

  // Add the last statement if it exists
  if (currentStatement.trim()) {
    statements.push(currentStatement.trim());
  }

  return statements.filter(stmt => stmt.length > 0);
}

================
File: backend/src/errors.ts
================
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'NotFoundError'
  }
}

export class UnauthorizedError extends Error {
  constructor(message: string = 'Unauthorized') {
    super(message)
    this.name = 'UnauthorizedError'
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'ValidationError'
  }
}

export class DatabaseError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'DatabaseError'
  }
}

================
File: backend/src/index.ts
================
import { Elysia, t } from 'elysia'
import { cors } from '@elysiajs/cors'
import { Database } from './database'
import { logger } from './logger'
import type { ContactCreate, ContactCreateTemp, AgentCreate } from './types'
import { readFileSync } from 'fs'
import { staticPlugin } from '@elysiajs/static'
import { parse as csvParse } from 'csv-parse/sync'
import { Readable } from 'stream'
import { Buffer } from 'buffer'
import { createAuthRoutes } from './routes/auth'
import { settingsRoutes } from './routes/settings'
import { organizationRoutes } from './routes/organizations'
import { createBrandRoutes } from './routes/brand'
import { quotesRoutes } from './routes/quotes'
import { createOnboardingRoutes } from './routes/onboarding'
import { createWaitlistRoutes } from './routes/waitlist'
import { createSignupRoutes, checkEmailHandler } from './routes/signup'
import { createStripeRoutes } from './routes/stripe'
import { createDashboardRoutes, createDashboardActivityRoutes } from './routes/dashboard'
import { errorHandler } from './middleware/error'
import { getUserFromSession } from './services/auth'
import { join } from 'path'
import { existsSync } from 'fs'
import { EmailService } from './services/email'
import * as cron from 'node-cron'
import { eligibilityRoutes } from './routes/eligibility'
import { generateQuoteId } from './utils/quoteId'
import { createSelfServiceRoutes } from './routes/self-service'
import { scheduleRoutes } from './routes/schedule'
import { contactsRoutes } from './routes/contacts'
import { contactUsRoutes } from './routes/contact'
import * as fs from 'fs/promises'
import * as path from 'path'
import * as os from 'os'
import { readdirSync } from 'fs'
import { parseTrackingId } from './utils/tracking'
import { createBillingRoutes } from './routes/billing'
import { createStageDemoRoutes } from './routes/stage-demo'


// At the top of the file, add interface for ZIP data
export interface ZipInfo {
  state: string;
  counties: string[];
}

// Update ZIP_DATA declaration
export let ZIP_DATA: Record<string, ZipInfo> = {}
try {
  const dataPath = path.join(process.cwd(), 'data', 'zipData.json');
  logger.info(`Loading ZIP data from: ${dataPath}`);
  ZIP_DATA = JSON.parse(readFileSync(dataPath, 'utf-8'))
  logger.info('Successfully loaded ZIP data');
} catch (e) {
  logger.error(`Error loading ZIP data: ${e}`)
}

// Add with the other type imports
type NewAgentRequest = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
}

type AgentUpdate = {
  firstName: string
  lastName: string
  email: string
  phone: string
  is_admin: boolean
  is_agent: boolean
  carriers: string[]
  stateLicenses: string[]
  bookingLink?: string
  signature?: string
}

interface DbRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  phone: string | null;
  is_admin: number;
  is_agent: number;
  settings: string | null;
}

// Add at the top with other interfaces
interface ContactRow {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  current_carrier: string;
  plan_type: string;
  effective_date: string;
  birth_date: string;
  tobacco_user: number;
  gender: string;
  state: string;
  zip_code: string;
  agent_id: number | null;
  last_emailed: string | null;
  phone_number: string;
}

interface CarrierRow {
  name: string;
  aliases: string | null;
}

// Add this helper function before startServer
function standardizePhoneNumber(phone: string): { isValid: boolean; standardized: string } {
  const digits = phone.replace(/\D/g, '').slice(0, 10);
  return {
    isValid: digits.length === 10,
    standardized: digits
  };
}

// Add this helper function near the other validation functions
function validateEmail(email: string): boolean {
  // RFC 5322 compliant email regex
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  return emailRegex.test(email.trim());
}

// Add this helper function near the other validation functions
function validateISODate(dateStr: string, allowFuture: boolean = false): { isValid: boolean; isoDate: string | null } {
  try {
    const trimmed = dateStr.trim();
    
    // Try to parse the date - will throw if invalid
    const date = new Date(trimmed);
    
    // Check if date is invalid
    if (isNaN(date.getTime())) {
      return { isValid: false, isoDate: null };
    }
    
    // Convert to ISO format (YYYY-MM-DD)
    const isoDate = date.toISOString().split('T')[0];
    
    // Verify the date is not in the future (unless allowed)
    if (!allowFuture && date > new Date()) {
      return { isValid: false, isoDate: null };
    }
    
    return { isValid: true, isoDate };
  } catch (e) {
    return { isValid: false, isoDate: null };
  }
}

// Add this helper function near the other validation functions
async function validateCarrier(carrier: string, db: Database): Promise<{ isValid: boolean; standardizedName: string; wasConverted: boolean }> {
  try {
    // Trim and standardize input
    const trimmedCarrier = carrier.trim();
    logger.info(`Validating carrier: "${trimmedCarrier}"`);
    
    // Create a new instance of the central database
    const centralDb = new Database();
    
    // Get all carriers with their aliases from the central database
    const result = await centralDb.execute(
      'SELECT name, aliases FROM carriers'
    );
    
    logger.info(`Found ${result.rows.length} carriers in database`);
    
    // Check each carrier and its aliases
    for (const row of result.rows) {
      logger.info(`Checking against carrier: "${row.name}", aliases: ${row.aliases || '[]'}`);
      
      // Check exact name match (case insensitive)
      if (row.name.toLowerCase() === trimmedCarrier.toLowerCase()) {
        logger.info(`Found exact match with carrier: ${row.name}`);
        return { isValid: true, standardizedName: row.name, wasConverted: false };
      }
      
      // Check aliases if they exist
      if (row.aliases) {
        const aliases = JSON.parse(row.aliases);
        logger.info(`Checking aliases for ${row.name}: ${JSON.stringify(aliases)}`);
        if (Array.isArray(aliases) && aliases.some(alias => alias.toLowerCase() === trimmedCarrier.toLowerCase())) {
          logger.info(`Found match in aliases for carrier: ${row.name}`);
          return { isValid: true, standardizedName: row.name, wasConverted: false };
        }
      }
    }
    
    // If no match found, keep the original carrier name but mark as converted
    logger.info(`No matching carrier found for: "${trimmedCarrier}", keeping original name`);
    return { isValid: true, standardizedName: trimmedCarrier, wasConverted: true };
  } catch (e) {
    logger.error(`Error validating carrier: ${e}`);
    return { isValid: true, standardizedName: carrier.trim(), wasConverted: true };
  }
}

// Interface for validation result
interface ValidationResult {
  isValid: boolean;
  error?: string;
  value?: any;
}

// Validation functions
const validateRow = async (row: any, rowNum: number, carrierMap: Map<string, string>): Promise<ValidationResult> => {
  try {
    logger.info(`Starting validation for row ${rowNum}:`)
    logger.info(`Row data: ${JSON.stringify(row)}`)

    // Required fields check with detailed logging
    const requiredFields = [
      'First Name', 'firstName',
      'Last Name', 'lastName', 
      'Email', 'email',
      'Current Carrier', 'currentCarrier',
      'Plan Type', 'planType',
      'Effective Date', 'effectiveDate',
      'Birth Date', 'birthDate',
      'Tobacco User', 'tobaccoUser',
      'Gender', 'gender',
      'ZIP Code', 'zipCode',
      'Phone Number', 'phoneNumber'
    ]

    logger.info(`Checking required fields: ${requiredFields.join(', ')}`)
    const missingValues = requiredFields.filter(field => {
      const value = row[field]?.trim()
      const isMissing = !value
      if (isMissing) {
        logger.warn(`Missing required field "${field}" in row ${rowNum}`)
      }
      return isMissing
    })

    // Group the missing fields by their base name (e.g. both "First Name" and "firstName" count as one missing field)
    const missingFieldGroups = new Set<string>()
    for (let i = 0; i < missingValues.length; i += 2) {
      if (missingValues[i] && missingValues[i+1]) {
        missingFieldGroups.add(missingValues[i])
      }
    }

    if (missingFieldGroups.size > 0) {
      logger.warn(`Row ${rowNum} missing required fields: ${Array.from(missingFieldGroups).join(', ')}`)
      return {
        isValid: false,
        error: `Missing values for: ${Array.from(missingFieldGroups).join(', ')}`
      }
    }

    // Email validation with logging
    const email = (row['Email'] || row['email'] || '').trim().toLowerCase()
    logger.info(`Validating email: "${email}"`)
    if (!validateEmail(email)) {
      logger.warn(`Row ${rowNum} has invalid email format: ${email}`)
      return {
        isValid: false,
        error: `Invalid email format: ${email}`
      }
    }

    // Phone validation with logging
    logger.info(`Validating phone number: "${row['Phone Number'] || row['phoneNumber']}"`)
    const phoneResult = standardizePhoneNumber(row['Phone Number'] || row['phoneNumber'])
    if (!phoneResult.isValid) {
      logger.warn(`Row ${rowNum} has invalid phone number: ${row['Phone Number'] || row['phoneNumber']}`)
      return {
        isValid: false,
        error: `Invalid phone number: ${row['Phone Number'] || row['phoneNumber']}. Must be exactly 10 digits.`
      }
    }

    // ZIP validation with logging
    const zipCode = (row['ZIP Code'] || row['zipCode'] || '').trim()
    logger.info(`Validating ZIP code: "${zipCode}"`)

    // First check if ZIP code exists and has the right format
    if (!zipCode) {
      logger.warn(`Row ${rowNum} is missing ZIP code`)
      return {
        isValid: false,
        error: `Missing ZIP code. This field is required for determining state coverage and eligibility.`
      }
    }

    // Check if ZIP code is in the correct format (5 digits)
    if (!/^\d{5}$/.test(zipCode)) {
      logger.warn(`Row ${rowNum} has invalid ZIP code format: ${zipCode}`)
      return {
        isValid: false,
        error: `Invalid ZIP code format: ${zipCode}. Must be exactly 5 digits.`
      }
    }

    // Check if ZIP code exists in our database
    const zipInfo = ZIP_DATA[zipCode]
    if (!zipInfo) {
      logger.warn(`Row ${rowNum} has invalid ZIP code: ${zipCode} (not found in database)`)
      return {
        isValid: false,
        error: `Invalid ZIP code: ${zipCode}. This ZIP code is not recognized in our database.`
      }
    }

    // If we get here, we have a valid ZIP code with state information
    logger.info(`Valid ZIP code ${zipCode} maps to state: ${zipInfo.state}`)

    // Gender validation with logging
    const gender = (row['Gender'] || row['gender'] || '').trim().toUpperCase()
    logger.info(`Validating gender: "${gender}"`)
    if (!['M', 'F'].includes(gender)) {
      logger.warn(`Row ${rowNum} has invalid gender: ${gender}`)
      return {
        isValid: false,
        error: `Invalid gender: ${gender}. Must be 'M' or 'F'`
      }
    }

    // Carrier validation with logging
    const carrierInput = (row['Current Carrier'] || row['currentCarrier'] || '').trim().toLowerCase()
    logger.info(`Validating carrier: "${carrierInput}"`)
    const standardizedCarrier = carrierMap.get(carrierInput) || carrierInput
    const wasCarrierConverted = !carrierMap.has(carrierInput)
    if (wasCarrierConverted) {
      logger.warn(`Row ${rowNum} has non-standard carrier: ${carrierInput} (will be kept as-is)`)
    }

    // Date validations with logging
    logger.info(`Validating effective date: "${row['Effective Date'] || row['effectiveDate']}"`)
    const effectiveDateResult = validateISODate(row['Effective Date'] || row['effectiveDate'], true)
    if (!effectiveDateResult.isValid) {
      logger.warn(`Row ${rowNum} has invalid effective date: ${row['Effective Date'] || row['effectiveDate']}`)
      return {
        isValid: false,
        error: `Invalid effective date format: ${row['Effective Date'] || row['effectiveDate']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
      }
    }

    logger.info(`Validating birth date: "${row['Birth Date'] || row['birthDate']}"`)
    const birthDateResult = validateISODate(row['Birth Date'] || row['birthDate'])
    if (!birthDateResult.isValid) {
      logger.warn(`Row ${rowNum} has invalid birth date: ${row['Birth Date'] || row['birthDate']}`)
      return {
        isValid: false,
        error: `Invalid birth date format: ${row['Birth Date'] || row['birthDate']}. Please use YYYY-MM-DD or MM-DD-YYYY format.`
      }
    }

    // If all validations pass, return processed data
    logger.info(`Row ${rowNum} passed all validations successfully`)
    return {
      isValid: true,
      value: {
        data: [
          (row['First Name'] || row['firstName'] || '').trim(),
          (row['Last Name'] || row['lastName'] || '').trim(),
          email,
          standardizedCarrier,
          (row['Plan Type'] || row['planType'] || '').trim(),
          effectiveDateResult.isoDate,
          birthDateResult.isoDate,
          ['yes', 'true', '1', 'y'].includes((row['Tobacco User'] || row['tobaccoUser'] || '').trim().toLowerCase()),
          gender,
          zipInfo.state,
          zipCode,
          phoneResult.standardized,
          null // agentId - will be set later
        ],
        carrierConverted: wasCarrierConverted ? {
          Row: rowNum,
          ...row,
          OriginalCarrier: row['Current Carrier'] || row['currentCarrier']
        } : null
      }
    }
  } catch (e) {
    // Log the full error details
    logger.error(`Unexpected error in row ${rowNum}:`)
    logger.error(`Error message: ${e instanceof Error ? e.message : String(e)}`)
    logger.error(`Row data: ${JSON.stringify(row)}`)
    if (e instanceof Error && e.stack) {
      logger.error(`Stack trace: ${e.stack}`)
    }
    return {
      isValid: false,
      error: `Unexpected error processing row ${rowNum}. Please check all fields are in the correct format. Error: ${e instanceof Error ? e.message : String(e)}`
    }
  }
};

const startServer = async () => {
  try {
    // Log environment information at startup
    logger.info(`Environment: NODE_ENV = "${process.env.NODE_ENV}"`)
    logger.info(`Current working directory: ${process.cwd()}`)
    logger.info(`Is production mode: ${process.env.NODE_ENV === 'production'}`)
    
    // Check for frontend files
    logger.info(`Checking for SPA files:`)
    const locations = [
      { name: 'public', path: join(process.cwd(), 'public') },
      { name: 'parent dist', path: join(process.cwd(), '..', 'dist') }
    ];
    
    for (const loc of locations) {
      const exists = existsSync(loc.path);
      logger.info(`${loc.name} directory (${loc.path}): ${exists ? 'EXISTS' : 'MISSING'}`);
      
      if (exists) {
        try {
          const files = readdirSync(loc.path);
          logger.info(`${loc.name} contents: ${files.join(', ')}`);
          
          const indexPath = join(loc.path, 'index.html');
          if (existsSync(indexPath)) {
            logger.info(`✅ Found SPA at: ${indexPath}`);
          }
        } catch (err) {
          logger.error(`Error reading ${loc.name} directory: ${err}`);
        }
      }
    }
    
    // Log available environment variables (without values for security)
    logger.info(`Available environment variables: ${Object.keys(process.env).join(', ')}`)
    
    // Try loading directly from process.env
    if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
      logger.warn('Critical environment variables missing. Check Replit Secrets are properly set:')
      logger.warn('Required: TURSO_DATABASE_URL, TURSO_AUTH_TOKEN')
      logger.warn('Available env vars: ' + Object.keys(process.env).join(', '))
    } else {
      logger.info('Required environment variables found')
    }
    
    const db = new Database()
    logger.info('Database initialized successfully')

    const app = new Elysia()
      // Add error handler
      .use(errorHandler)
      // Add CORS middleware
      .use(cors({
        // In development, allow the Vite dev server origin
        origin: process.env.NODE_ENV === 'development' 
          ? 'http://localhost:5173'
          : false, // Disable CORS in production
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Cookie'],  // Add Cookie to allowed headers
        credentials: true,
        preflight: true
      }))
      // Add static file serving
      .use(staticPlugin({
        assets: join(process.cwd(), 'public'), // Public static files
        prefix: '/'
      }))
      // Try parent dist directory if it exists
      .use(staticPlugin({
        assets: join(process.cwd(), '..', 'dist'), // Parent dist static files
        prefix: '/'
      }))
      // Add data directory for specific files
      .use(staticPlugin({
        assets: join(process.cwd(), 'data/public'), // Data files
        prefix: '/api/data/public'
      }))
      // Add SPA route auth bypass handler
      .onRequest(({ request }) => {
        const url = new URL(request.url);
        const path = url.pathname;
        
        // Log all requests (combined from the other handler)
        const method = request.method;
        logger.info(`⮕ ${method} ${path}`);
        
        // Bypass auth for all SPA routes (non-API paths with no file extension) and stage demo routes
        if ((!path.startsWith('/api/') && !path.includes('.')) || 
            path.startsWith('/compare/') ||
            path.startsWith('/quote/') ||
            path.startsWith('/eligibility') ||
            path.startsWith('/schedule') ||
            path.startsWith('/stage-demo') ||
            path.startsWith('/api/stage-demo/')) {
          
          logger.info(`[Auth Bypass] Setting bypass header for stage demo/SPA route: ${path}`);
          // Modify the request headers to include X-Bypass-Auth
          const newHeaders = new Headers(request.headers);
          newHeaders.set('X-Bypass-Auth', 'true');
          
          // Create a new request with the modified headers
          Object.defineProperty(request, 'headers', {
            value: newHeaders,
            writable: true
          });
        }
      })
      // Add explicit OPTIONS handler for preflight
      .options('/api/contacts/:id', ({ set }) => {
        set.headers = {
          'Access-Control-Allow-Origin': 'http://localhost:5173',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Allow-Credentials': 'true'
        }
        return new Response(null, { status: 204 })
      })
      // Log all responses
      .onResponse((context) => {
        const { request: { method }, path, set } = context
        logger.info(`⬅ ${method} ${path} ${set.status}`)
      })
      // Enhanced error handling
      .onError(({ code, error, request }: {
        code: string;
        error: Error;
        request: { url: string; method: string };
      }) => {
        const path = new URL(request.url).pathname
        const errorMessage = `❌ ${request.method} ${path} - ${error.message}`
        logger.error(errorMessage)

        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), { 
          status: code === 'NOT_FOUND' ? 404 : 500,
          headers: {
            'Content-Type': 'application/json'
          }
        })
      })
      // Add health check endpoint
      .get('/health', () => ({ status: 'OK' }))
      // Register public routes that shouldn't be auth-protected
      .get('/api/signup/check-email/:email', checkEmailHandler)
      // GET /api/contacts is now handled by the contactsRoutes module
      .get('/api/contacts/check-email/:email', async ({ params: { email }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          const result = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          return {
            exists: result !== null
          }
        } catch (e) {
          logger.error(`Error checking email existence: ${e}`)
          throw new Error(String(e))
        }
      })
      .get('/api/contacts/:id', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id} - Fetching contact for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Fetch the contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            logger.info(`GET /api/contacts/${id} - Contact not found`)
            return new Response('Contact not found', { status: 404 })
          }

          // Return the contact with mapped fields
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error fetching contact: ${e}`)
          throw new Error(String(e))
        }
      })
      .post('/api/contacts/create', async ({ body, request }) => {
        console.log('body', body)
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contact = body as ContactCreate // With an explicit schema, 'body' will be correctly typed
          logger.info(`Attempting to create contact for org ${user.organization_id}: ${contact.first_name} ${contact.last_name}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Check for existing email
          const existingContact = await orgDb.fetchOne(
            'SELECT 1 FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [contact.email]
          )

          if (existingContact) {
            throw new Error('A contact with this email already exists')
          }
          
          // Map contact_owner_id to agent_id if it exists and agent_id is not set
          if (contact.contact_owner_id && !contact.agent_id) {
            contact.agent_id = contact.contact_owner_id
            logger.info(`Mapped contact_owner_id: ${contact.contact_owner_id} to agent_id`)
          }
          
          const query = `
            INSERT INTO contacts (
              first_name, last_name, email, current_carrier, plan_type,
              effective_date, birth_date, tobacco_user, gender,
              state, zip_code, agent_id, phone_number
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `
          
          const params = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier || null,
            contact.plan_type || null,
            contact.effective_date || null,
            contact.birth_date || null,
            contact.tobacco_user ? 1 : 0, // Convert boolean to integer
            contact.gender || null,
            contact.state || null,
            contact.zip_code || null,
            contact.agent_id || null,
            contact.phone_number || null
          ]

          logger.info(`Executing query with params: ${JSON.stringify(params)}`)
          await orgDb.execute(query, params)

          // Fetch the newly created contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE email = ? ORDER BY id DESC LIMIT 1',
            [contact.email]
          )

          if (!result) {
            throw new Error('Failed to fetch created contact')
          }

          // Match response format to schema
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number || ''
          }
        } catch (e) {
          logger.error(`Error creating contact: ${e}`)
          throw new Error(String(e))
        }
      }, // End of handler function
      { // Start of schema object
        body: t.Object({
          first_name: t.String(),
          last_name: t.String(),
          email: t.String({ format: 'email' }),
          phone_number: t.String(),
          state: t.String(),
          contact_owner_id: t.Optional(t.Union([t.Number(), t.Null()])),
          current_carrier: t.Optional(t.Union([t.String(), t.Null()])),
          effective_date: t.String(),
          birth_date: t.String(),
          tobacco_user: t.Boolean(),
          gender: t.String(),
          zip_code: t.String(),
          plan_type: t.Optional(t.Union([t.String(), t.Null()])),
          agent_id: t.Optional(t.Union([t.Number(), t.Null()]))
        })
      }) // End of schema object and route definition
      .put('/api/contacts/:id', async ({ params: { id }, body, request }: { params: { id: string }, body: ContactCreate, request: Request }) => {
        try {
          // Get user and org info
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          const contact = body as ContactCreate
          logger.info(`PUT /api/contacts/${id} - Updating contact for org ${user.organization_id}`)

          // Get state from ZIP code
          const zipInfo = ZIP_DATA[contact.zip_code]
          if (!zipInfo) {
            throw new Error(`Invalid ZIP code: ${contact.zip_code}`)
          }

          // First update the contact
          const updateQuery = /* sql */ `
            UPDATE contacts SET 
              first_name = ?,
              last_name = ?,
              email = ?,
              current_carrier = ?,
              plan_type = ?,
              effective_date = ?,
              birth_date = ?,
              tobacco_user = ?,
              gender = ?,
              state = ?,
              zip_code = ?,
              phone_number = ?
            WHERE id = ?
          `

          const updateParams = [
            contact.first_name,
            contact.last_name,
            contact.email,
            contact.current_carrier,
            contact.plan_type,
            contact.effective_date,
            contact.birth_date,
            contact.tobacco_user,
            contact.gender,
            zipInfo.state, // Use state from ZIP code
            contact.zip_code,
            contact.phone_number || '',
            id
          ]

          // Execute the update
          await orgDb.execute(updateQuery, updateParams)

          // Then fetch the updated contact
          const result = await orgDb.fetchOne<ContactRow>(
            'SELECT * FROM contacts WHERE id = ?',
            [id]
          )

          if (!result) {
            throw new Error(`Contact ${id} not found after update`)
          }

          logger.info(`Successfully updated contact ${id} in org ${user.organization_id}`)

          // Return the updated contact
          return {
            id: result.id,
            first_name: result.first_name,
            last_name: result.last_name,
            email: result.email,
            current_carrier: result.current_carrier,
            plan_type: result.plan_type,
            effective_date: result.effective_date,
            birth_date: result.birth_date,
            tobacco_user: Boolean(result.tobacco_user),
            gender: result.gender,
            state: result.state,
            zip_code: result.zip_code,
            agent_id: result.agent_id,
            last_emailed: result.last_emailed,
            phone_number: result.phone_number
          }
        } catch (e) {
          logger.error(`Error updating contact: ${e}`)
          throw new Error(String(e))
        }
      },
      {
        body: t.Object({
          first_name: t.String(),
          last_name: t.String(),
          email: t.String({ format: 'email' }),
          phone_number: t.String(),
          state: t.String(),
          contact_owner_id: t.Optional(t.Union([t.Number(), t.Null()])),
          current_carrier: t.Optional(t.Union([t.String(), t.Null()])),
          effective_date: t.String(),
          birth_date: t.String(),
          tobacco_user: t.Boolean(),
          gender: t.String(),
          zip_code: t.String(),
          plan_type: t.Optional(t.Union([t.String(), t.Null()])),
          agent_id: t.Optional(t.Union([t.Number(), t.Null()]))
        })
      })
      // Add DELETE endpoint for contacts
      .delete('/api/contacts', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Parse contact IDs from the request
          const url = new URL(request.url)
          const ids = url.searchParams.get('ids')
          if (!ids) {
            throw new Error('No contact IDs provided')
          }

          const contactIds = ids.split(',').map(id => parseInt(id.trim(), 10))
          
          logger.info(`DELETE /api/contacts - Attempting to delete ${contactIds.length} contacts for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contactIds.map(() => '?').join(',')
          
          const query = `
            DELETE FROM contacts 
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const result = await orgDb.execute(query, contactIds)
          const deletedIds = result.rows?.map((row: { id: number }) => row.id) || []

          logger.info(`DELETE /api/contacts - Successfully deleted ${deletedIds.length} contacts from org ${user.organization_id}`)

          return {
            success: true,
            deleted_ids: deletedIds,
            message: `Successfully deleted ${deletedIds.length} contacts`
          }
        } catch (e) {
          logger.error(`Error deleting contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add endpoint for reassigning contacts to a different agent
      .put('/api/contacts/reassign', async ({ request, body }: { request: Request, body: { contact_ids: number[], agent_id: number | null } }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const { contact_ids, agent_id } = body
          if (!contact_ids || !Array.isArray(contact_ids) || contact_ids.length === 0) {
            throw new Error('Invalid or empty contact_ids array')
          }

          logger.info(`PUT /api/contacts/reassign - Reassigning ${contact_ids.length} contacts to agent ${agent_id} for org ${user.organization_id}`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Create placeholders for SQL IN clause
          const placeholders = contact_ids.map(() => '?').join(',')
          
          const query = `
            UPDATE contacts 
            SET agent_id = ?
            WHERE id IN (${placeholders})
            RETURNING id
          `

          const params = [agent_id, ...contact_ids]
          const result = await orgDb.execute(query, params)
          const updatedIds = result.rows?.map((row: { id: number }) => row.id) || []

          logger.info(`PUT /api/contacts/reassign - Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`)

            return {
            success: true,
            updated_ids: updatedIds,
            message: `Successfully reassigned ${updatedIds.length} contacts to agent ${agent_id}`
          }
        } catch (e) {
          logger.error(`Error reassigning contacts: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add file upload endpoint
      .post('/api/contacts/upload', async ({ request, body, set }: { request: Request, body: { file: File, overwrite_duplicates?: boolean | string, duplicateStrategy?: string, agent_id?: string }, set: any }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          // Extract file and overwrite flag from form data
          const formData = body
          const file = formData.file
          
          // Support both naming conventions - overwrite_duplicates (old) and duplicateStrategy (new)
          let overwriteDuplicates = false
          if (formData.overwrite_duplicates !== undefined) {
            // Convert string 'false'/'true' to boolean
            overwriteDuplicates = formData.overwrite_duplicates === 'true' || formData.overwrite_duplicates === true
          } else if (formData.duplicateStrategy !== undefined) {
            // Support the new 'duplicateStrategy' parameter
            overwriteDuplicates = formData.duplicateStrategy === 'overwrite'
          }

          logger.info(`Processing ${file.name} with overwriteDuplicates=${overwriteDuplicates}`)

          // Save file to temp directory
          const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'import-'));
          const tempFilePath = path.join(tempDir, 'contacts.csv');
          await fs.writeFile(tempFilePath, Buffer.from(await file.arrayBuffer()));

          logger.info(`CSV file saved to ${tempFilePath}, starting import`);

          // Start bulk import process
          const importPromise = Database.bulkImportContacts(
            user.organization_id.toString(),
            tempFilePath,
            overwriteDuplicates
          );

          importPromise
            .then(() => fs.rm(tempDir, { recursive: true, force: true }))
            .catch((error: Error) => {
              logger.error(`Background import failed: ${error}`);
              fs.rm(tempDir, { recursive: true, force: true }).catch(() => {});
            });

          return {
            success: true,
            message: 'Started import of contacts',
            errors: []
          };
        } catch (error) {
          const err = error as Error;
          logger.error(`Error processing CSV upload: ${err}`);
          throw err;
        }
      })
      // Add error handler
      .use(errorHandler)
      // Add explicit debug log for auth routes
      .use(app => {
        logger.info('Registering auth routes...')
        return app.use(createAuthRoutes())
      })
      // Add signup routes
      .use(app => {
        logger.info('Registering signup routes...')
        return app.use(createSignupRoutes())
      })
      // Add settings routes
      .use(settingsRoutes)
      // Add organization routes
      .use(organizationRoutes)
      // Add brand routes
      .use(createBrandRoutes())
      // Add quotes routes
      .use(quotesRoutes)
      // Add onboarding routes
      .use(createOnboardingRoutes())
      // Add eligibility routes
      .use(eligibilityRoutes)
      // Add self-service routes
      .use(createSelfServiceRoutes())
      // Add schedule routes
      .use(scheduleRoutes)
      // Add contacts routes
      .use(contactsRoutes)
      // Add contact us form routes
      .use(contactUsRoutes)
      // Add waitlist routes
      .use(createWaitlistRoutes())  // Waitlist routes use their own database connection
      // Add dashboard routes
      .use(createDashboardRoutes())
      // Add dashboard activity routes
      .use(createDashboardActivityRoutes())
      // Serve backend static files from public directory
      .use(createStripeRoutes)
      .use(createBillingRoutes)
      .use(createStageDemoRoutes())
      // Add this endpoint within the app definition
      .post('/api/agents', async ({ body, request, set }) => {
        try {
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent: ${newAgent.email} (org: ${currentUser.organization_id})`)

          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Check if the organization has reached its agent limit
          const orgLimitResult = await client.execute({
            sql: `
              SELECT 
                o.agent_limit, 
                COUNT(u.id) as current_agent_count
              FROM 
                organizations o
              LEFT JOIN 
                users u ON o.id = u.organization_id AND (u.is_agent = 1 OR u.is_admin = 1) AND u.is_active = 1
              WHERE 
                o.id = ?
              GROUP BY 
                o.id
            `,
            args: [currentUser.organization_id]
          })
          
          if (orgLimitResult.rows.length > 0) {
            const { agent_limit, current_agent_count } = orgLimitResult.rows[0]
            
            if (Number(current_agent_count) >= Number(agent_limit)) {
              logger.warn(`Organization ${currentUser.organization_id} has reached its agent limit (${agent_limit}). Cannot create new agent.`)
              set.status = 403
              return {
                success: false,
                error: `You have reached your plan's agent limit (${agent_limit}). Please upgrade your plan to add more agents.`
              }
            }
            
            logger.info(`Organization has ${current_agent_count}/${agent_limit} agents (before adding new agent)`)
          }
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add an alias endpoint for POST /api/agents/create to match frontend expectations
      .post('/api/agents/create', async ({ body, request, set }) => {
        try {
          // Log the request to the alias endpoint
          logger.info(`POST /api/agents/create - Using the same implementation as /api/agents`)
          
          // Get current user from session to determine their org
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Check if user is an admin
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can create new agents'
            }
          }

          const newAgent = body as NewAgentRequest
          logger.info(`Creating new agent via /api/agents/create: ${newAgent.email} (org: ${currentUser.organization_id})`)
          
          // Ensure that the new user has at least one role
          if (!newAgent.is_admin && !newAgent.is_agent) {
            logger.warn(`Agent created without any roles. Defaulting to is_agent=true for: ${newAgent.email}`)
            newAgent.is_agent = true
          }

          // Get the libSQL client
          const client = db.getClient()
          
          // Get organization settings to inherit carriers and state licenses
          const orgSettingsResult = await client.execute({
            sql: `SELECT org_settings FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          let orgSettings = {
            stateLicenses: [],
            carrierContracts: [],
            stateCarrierSettings: []
          }
          
          if (orgSettingsResult.rows.length > 0 && orgSettingsResult.rows[0].org_settings) {
            try {
              const parsedSettings = JSON.parse(orgSettingsResult.rows[0].org_settings as string)
              orgSettings = {
                stateLicenses: parsedSettings.stateLicenses || [],
                carrierContracts: parsedSettings.carrierContracts || [],
                stateCarrierSettings: parsedSettings.stateCarrierSettings || []
              }
              logger.info(`Inherited org settings: ${orgSettings.carrierContracts.length} carriers, ${orgSettings.stateLicenses.length} state licenses`)
            } catch (e) {
              logger.error(`Error parsing org settings: ${e}`)
            }
          }

          // First create the user
          const userResult = await client.execute({
            sql: `INSERT INTO users (
              email, 
              first_name, 
              last_name, 
              phone,
              organization_id,
              is_admin,
              is_agent,
              is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            RETURNING id`,
            args: [
              newAgent.email,
              newAgent.firstName,
              newAgent.lastName,
              newAgent.phone,
              currentUser.organization_id,
              newAgent.is_admin ? 1 : 0,
              newAgent.is_agent ? 1 : 0
            ]
          })

          const userId = userResult.rows[0].id
          logger.info(`Created new agent with ID: ${userId}`)

          // Then create agent settings - automatically inherit from organization
          await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)`,
            args: [
              userId,
              JSON.stringify({
                stateLicenses: orgSettings.stateLicenses,
                carrierContracts: orgSettings.carrierContracts,
                stateCarrierSettings: orgSettings.stateCarrierSettings,
                emailSendBirthday: false,
                emailSendPolicyAnniversary: false,
                emailSendAep: false,
                smartSendEnabled: false
              })
            ]
          })

          logger.info(`Initialized settings for agent: ${userId} with inherited org settings`)

          return {
            success: true,
            message: 'Agent created successfully',
            id: userId
          }

        } catch (e) {
          logger.error(`Error creating agent via /api/agents/create: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add this GET endpoint within the app definition, near the POST /api/agents endpoint
      .get('/api/agents', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Remove admin check - allow any authenticated user to fetch agents for their organization
          // All users should be able to see the agent list for assignment purposes
          logger.info(`GET /api/agents - Fetching agents for org ${currentUser.organization_id}`)

          // Get the libSQL client
          const client = db.getClient()

          // Fetch the default agent ID for this organization
          const orgResult = await client.execute({
            sql: `SELECT default_agent_id FROM organizations WHERE id = ?`,
            args: [currentUser.organization_id]
          })
          
          const defaultAgentId = orgResult.rows[0]?.default_agent_id ? String(orgResult.rows[0].default_agent_id) : null
          logger.info(`GET /api/agents - Default agent ID for org ${currentUser.organization_id} is ${defaultAgentId || 'not set'}`)

          // Fetch all agents (users) from the organization along with their settings
          const result = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.first_name,
                u.last_name,
                u.email,
                u.phone,
                u.booking_link,
                u.is_admin,
                u.is_agent,
                a.settings
              FROM users u
              LEFT JOIN agent_settings a ON u.id = a.agent_id
              WHERE u.organization_id = ?
              AND u.is_active = 1
              ORDER BY u.first_name, u.last_name
            `,
            args: [currentUser.organization_id]
          })

          logger.info(`GET /api/agents - Found ${result.rows.length} agents`)

          // Map the database results to the expected format with camelCase field names
          const agents = result.rows.map((row: any) => {
            const settings = row.settings ? JSON.parse(row.settings) : {
              stateLicenses: [],
              carrierContracts: [],
              stateCarrierSettings: [],
              signature: ''
            }
            
            // Check if this agent is the default agent
            const isDefault = defaultAgentId ? String(row.id) === defaultAgentId : false

            return {
              id: String(row.id),
              firstName: row.first_name,
              lastName: row.last_name,
              email: row.email,
              phone: row.phone || '',
              bookingLink: row.booking_link || '',
              signature: settings.signature || '',
              isAdmin: Boolean(row.is_admin),
              isAgent: Boolean(row.is_agent),
              isDefault: isDefault,
              carriers: settings.carrierContracts || [],
              stateLicenses: settings.stateLicenses || []
            }
          })

          logger.info(`GET /api/agents - Returning ${agents.length} agents`)
          // Return both agents and the default agent ID
          return {
            agents,
            defaultAgentId
          }

        } catch (e) {
          logger.error(`Error fetching agents: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .post('/api/agents/set_default_agent', async ({ body, request, set }: { body: { agentId: string | number }, request: Request, set: any }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          const { agentId } = body  
          logger.info(`Setting default agent to ${agentId} for user ${currentUser.id}`)

          // Get the libSQL client
          const client = db.getClient()

          // Update the default agent for the organization
          await client.execute({
            sql: `UPDATE organizations SET default_agent_id = ? WHERE id = ?`,
            args: [agentId, currentUser.organization_id]
          })

          logger.info(`Default agent set to ${agentId} for organization ${currentUser.organization_id}`)
          
          set.status = 200
          return {
            success: true,
            message: 'Default agent set successfully'
          }
        } catch (e) {
          logger.error(`Error setting default agent: ${e}`) 
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Update PUT endpoint for updating agent details - moved here to be with other agent endpoints
      .put('/api/agents/:id', async ({ params, body, request, set }: {
        params: { id: string },
        body: AgentUpdate,
        request: Request,
        set: any
      }) => {
        console.log('DEBUG: PUT handler hit', { params, path: request.url })
        logger.info(`Starting update for agent ${params.id}`)
        logger.info(`Request body: ${JSON.stringify(body, null, 2)}`)
        
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            logger.error('Authentication failed: No user in session')
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Allow users to update their own details or admins to update any agent
          if (!currentUser.is_admin && currentUser.id.toString() !== params.id) {
            logger.error(`Authorization failed: User ${currentUser.id} is not an admin and trying to update another user`)
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can update other agents'
            }
          }
          
          // Security protection: NEVER allow ANY user to remove their own admin status,
          // even if they are an admin themselves
          if (currentUser.id.toString() === params.id) {
            // If this is a self-update and user is trying to change admin status
            if (body.is_admin !== Boolean(currentUser.is_admin)) {
              // If they're trying to REMOVE admin status
              if (Boolean(currentUser.is_admin) && !body.is_admin) {
                logger.warn(`Security protection: Admin user ${currentUser.id} attempted to remove their own admin status`)
                // Prevent admin from removing their own admin status - keep it as is
                body.is_admin = true;
              }
              // Note: We still allow non-admins to be promoted by an admin
            }
          }

          const agent = body
          logger.info(`Updating agent ${params.id} - Name: ${agent.firstName} ${agent.lastName}, Phone: ${agent.phone}`)

          // Get the libSQL client
          const client = db.getClient()

          // Determine if this is a self-update by a non-admin
          const isSelfUpdate = currentUser.id.toString() === params.id && !currentUser.is_admin
          
          // Create dynamic SQL that excludes is_admin for self-updates
          let sql, args
          if (isSelfUpdate) {
            // For self-updates, exclude is_admin from the update
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      booking_link = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.bookingLink || '',
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
            logger.info(`Self-update detected: excluding admin status from update for user ${params.id}`)
          } else {
            // For admin updates or other users, include all fields
            sql = `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      email = ?, 
                      phone = ?,
                      booking_link = ?,
                      is_admin = ?,
                      is_agent = ?
                  WHERE id = ? AND organization_id = ?
                  RETURNING *`
            args = [
              agent.firstName,
              agent.lastName,
              agent.email,
              agent.phone,
              agent.bookingLink || '',
              agent.is_admin ? 1 : 0,
              agent.is_agent ? 1 : 0,
              params.id,
              currentUser.organization_id
            ]
          }

          // Execute the update with the appropriate SQL and args
          const userUpdateResult = await client.execute({
            sql,
            args
          })

          logger.info(`User update result: ${JSON.stringify(userUpdateResult.rows, null, 2)}`)

          if (!userUpdateResult.rows || userUpdateResult.rows.length === 0) {
            logger.error('User update failed: No rows affected')
            throw new Error('User update failed - no rows affected')
          }

          logger.info('User details updated successfully')

          // Update agent settings
          const settings = {
            stateLicenses: agent.stateLicenses,
            carrierContracts: agent.carriers,
            stateCarrierSettings: [],
            emailSendBirthday: false,
            emailSendPolicyAnniversary: false,
            emailSendAep: false,
            smartSendEnabled: false,
            signature: agent.signature || ''
          }

          logger.info(`Agent settings to update: ${JSON.stringify(settings, null, 2)}`)

          const settingsUpdateResult = await client.execute({
            sql: `INSERT INTO agent_settings (
              agent_id,
              settings
            ) VALUES (?, ?)
            ON CONFLICT (agent_id) 
            DO UPDATE SET settings = EXCLUDED.settings
            RETURNING *`,
            args: [
              params.id,
              JSON.stringify(settings)
            ]
          })

          logger.info(`Settings update result: ${JSON.stringify(settingsUpdateResult.rows, null, 2)}`)

          if (!settingsUpdateResult.rows || settingsUpdateResult.rows.length === 0) {
            logger.error('Settings update failed: No rows affected')
            throw new Error('Settings update failed - no rows affected')
          }

          logger.info('Settings updated successfully')

          const updatedUser = userUpdateResult.rows[0]
          const updatedSettings = JSON.parse(settingsUpdateResult.rows[0].settings)

          return {
            success: true,
            message: 'Agent updated successfully',
            agent: {
              id: updatedUser.id.toString(),
              firstName: updatedUser.first_name,
              lastName: updatedUser.last_name,
              email: updatedUser.email,
              phone: updatedUser.phone || '',
              booking_link: updatedUser.booking_link || '',
              signature: updatedSettings.signature || '',
              is_admin: Boolean(updatedUser.is_admin),
              is_agent: Boolean(updatedUser.is_agent),
              carriers: updatedSettings.carrierContracts,
              stateLicenses: updatedSettings.stateLicenses
            }
          }

        } catch (error: unknown) {
          const dbError = error as Error
          logger.error(`Database error: ${dbError.message}`)
          set.status = 500
          return {
            success: false,
            error: dbError.message
          }
        }
      })
      // Add DELETE endpoint for agent deletion with contact reassignment
      .delete('/api/agents/:id', async ({ params, request, set, query }: {
        params: { id: string },
        request: Request,
        set: any,
        query: { reassignTo?: string }
      }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'You must be logged in to perform this action'
            }
          }

          // Only admins can delete agents
          if (!currentUser.is_admin) {
            set.status = 403
            return {
              success: false,
              error: 'Only administrators can delete agents'
            }
          }

          const agentId = params.id
          
          // Prevent users from deleting themselves
          if (String(currentUser.id) === agentId) {
            set.status = 403
            return {
              success: false,
              error: 'You cannot delete your own account'
            }
          }
          
          const reassignToAgentId = query.reassignTo

          // Get the main database client for user/agent operations
          const client = db.getClient()

          // Also get the organization-specific database for contact operations
          const orgDb = await Database.getOrgDb(currentUser.organization_id.toString())

          // First handle contact operations in org database
          try {
            // Using the transaction method instead of direct SQL commands
            await orgDb.transaction(async (orgTx) => {
            // If reassignToAgentId is provided, reassign contacts to the new agent
            if (reassignToAgentId && reassignToAgentId !== agentId) {
              logger.info(`Reassigning contacts from agent ${agentId} to agent ${reassignToAgentId}`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = ?
                   WHERE agent_id = ?`,
                  [reassignToAgentId, agentId]
                )
            } else {
              // Set agent_id to NULL for contacts associated with this agent
              logger.info(`Setting contacts from agent ${agentId} to have no assigned agent`)
              
                // Update contacts in the org-specific database
                await orgTx.execute(
                  `UPDATE contacts
                  SET agent_id = NULL
                   WHERE agent_id = ?`,
                  [agentId]
                )
              }
            })
            
            logger.info(`Successfully updated contacts for agent ${agentId}`)
            
            // Now handle agent operations in the main database
            await db.transaction(async (tx) => {
              // First, check if the user has any other related records that need to be deleted

            // Delete agent's settings
              await tx.execute(
                `DELETE FROM agent_settings
                 WHERE agent_id = ?`,
                [agentId]
              )
              
              // Check for any related records in other tables that might reference this user
              // For example, delete from sessions table if it exists
              await tx.execute(
                `DELETE FROM sessions
                 WHERE user_id = ?`,
                [agentId]
              )
              
              // IMPORTANT: Add any other related tables that might have foreign keys to users
              
              // Finally, completely delete the user record instead of just marking as inactive
              await tx.execute(
                `DELETE FROM users
                 WHERE id = ?`,
                [agentId]
              )
            })
            
            logger.info(`Successfully deleted agent ${agentId}`)

            return {
              success: true,
              message: 'Agent deleted successfully'
            }
          } catch (error) {
            logger.error(`Error in agent deletion: ${error}`)
            throw error;
          }
        } catch (e) {
          logger.error(`Error deleting agent: ${e}`)
          set.status = 500
          return {
            success: false,
            error: 'An error occurred while deleting the agent'
          }
        }
      })
      // Add this endpoint within the app definition
      .get('/api/me', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          logger.info(`GET /api/me - Current user from session: ${JSON.stringify(currentUser)}`)
          
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          // Get user details including agent settings if they exist
          const client = db.getClient()
          const userDetails = await client.execute({
            sql: `
              SELECT 
                u.id,
                u.email,
                u.first_name as firstName,
                u.last_name as lastName,
                u.is_admin,
                u.is_agent,
                u.phone,
                u.booking_link,
                u.signature,
                u.use_org_sender_details,
                u.organization_id,
                u.has_completed_walkthrough,
                o.slug as organization_slug,
                o.subscription_tier,
                o.created_at as orgCreateDate,
                a.settings as agentSettings
              FROM users u
              JOIN organizations o ON u.organization_id = o.id
              LEFT JOIN agent_settings a ON a.agent_id = u.id
              WHERE u.id = ?
            `,
            args: [currentUser.id]
          })

          logger.info(`GET /api/me - Raw user details from DB: (omitted)`)

          if (!userDetails.rows[0]) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          const user = userDetails.rows[0]
          const response = {
            success: true,
            user: {
              id: user.id,
              email: user.email,
              firstName: user.firstName,
              lastName: user.lastName,
              is_admin: Boolean(user.is_admin),
              is_agent: Boolean(user.is_agent),
              phone: user.phone || '',
              booking_link: user.booking_link || '',
              signature: user.signature || '',
              useOrgSenderDetails: Boolean(user.use_org_sender_details),
              organization_id: user.organization_id,
              organization_slug: user.organization_slug,
              subscription_tier: user.subscription_tier,
              orgCreateDate: user.orgCreateDate.split(/[ T]/)[0],
              agentSettings: user.agentSettings ? JSON.parse(user.agentSettings) : null,
              hasCompletedWalkthrough: Boolean(user.has_completed_walkthrough)
            }
          }
          logger.info(`GET /api/me - Sending response ${JSON.stringify(response)}`)
          return response

        } catch (e) {
          logger.error(`Error fetching current user: ${e}`)
          set.status = 500
          return {
            success: false,
            error: String(e)
          }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/:redirect', async ({ params, set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for redirect to: ${params.redirect}`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`

          // Handle redirect
          const redirectPath = params.redirect === 'add-agent' ? 'agents/add' : params.redirect
          set.redirect = `/${redirectPath}`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add development endpoints for easy session management
      .get('/api/dev/session/login', async ({ set }) => {
        // Only allow in development
        if (process.env.NODE_ENV === 'production') {
          set.status = 404
          return { error: 'Not found' }
        }

        try {
          // Get most recent session from database
          const client = db.getClient()
          const result = await client.execute({
            sql: `
              SELECT s.id 
              FROM sessions s
              JOIN users u ON s.user_id = u.id
              WHERE u.is_active = 1
              ORDER BY s.created_at DESC 
              LIMIT 1
            `
          })

          if (!result.rows[0]) {
            set.status = 404
            return { error: 'No sessions found' }
          }

          // Convert the numeric ID to a string
          const sessionId = String(result.rows[0].id)
          logger.info(`Setting session cookie: ${sessionId} for login page`)

          // Set the session cookie
          set.headers['Set-Cookie'] = `session=${sessionId}; Path=/; HttpOnly; SameSite=Lax`
          return { success: true }
        } catch (e) {
          logger.error(`Error in dev session endpoint: ${e}`)
          set.status = 500
          return { error: String(e) }
        }
      })
      // Add ZIP lookup endpoint
      .get('/api/zip-lookup/:zipCode', ({ params: { zipCode } }) => {
        try {
          const zipInfo = ZIP_DATA[zipCode]
          if (!zipInfo) {
            return {
              success: false,
              error: `Invalid ZIP code: ${zipCode}`
            }
          }
          return {
            success: true,
            ...zipInfo
          }
        } catch (e) {
          logger.error(`Error looking up ZIP code ${zipCode}: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })

      .get('/api/contacts/email-tracking/:contactId', async ({ params, request }) => {
        try {
          logger.info(`Fetching email tracking records for contact ID: ${params.contactId}`);
          
          const user = await getUserFromSession(request);
          if (!user) {
            logger.warn(`Authentication failed when fetching email tracking for contact ID: ${params.contactId}`);
            return {
              success: false,
              message: 'Authentication required'
            };
          }

          const contactId = Number(params.contactId);
          if (isNaN(contactId)) {
            logger.warn(`Invalid contact ID provided: ${params.contactId}`);
            return {
              success: false,
              message: 'Invalid contact ID'
            };
          }

          logger.info(`User requesting email tracking for contact ID: ${contactId}`);
          const orgDb = await Database.getOrgDb(user.organization_id.toString());
          logger.info(`Fetching email tracking records from organization database`);

          const trackingRecords = await orgDb.fetchAll(
            `SELECT email_type,scheduled_date,send_status,send_mode FROM email_send_tracking 
             WHERE contact_id = ? 
             ORDER BY created_at DESC`,
            [contactId.toString()]
          );
          
          logger.info(`Found ${trackingRecords.length} email tracking records for contact ID: ${contactId}`);

          return {
            success: true,
            trackingRecords
          };
        } catch (error) {
          logger.error(`Error fetching email tracking records: ${error}`);
          return {
            success: false,
            message: 'Failed to fetch email tracking records',
            error: String(error)
          };
        }
      })
      // Add API endpoint for tracking clicks
      .post('/api/tracking/log-tracking-click', async ({ body, request }: { body: { tid: string, orgId: string, contactId?: string, quoteId?: string }, request: Request }) => {
        try {
          logger.info(`Received tracking click: ${JSON.stringify(body)}`);
          
          // Extract tracking data from request
          const { tid, orgId, contactId, quoteId } = body;
          
          if (!tid) {
            logger.warn('Missing tracking ID in click tracking request');
            return { success: false, message: 'Missing tracking ID' };
          }
          
          if (!orgId) {
            logger.warn('Missing organization ID in click tracking request');
            return { success: false, message: 'Missing organization ID' };
          }
          
          try {
            // Get organization database using the provided orgId
            const orgDb = await Database.getOrInitOrgDb(orgId);
            
            // Insert the tracking click record with the updated schema
            await orgDb.execute(
              `INSERT INTO tracking_clicks (
                tracking_id, contact_id, quote_id
              ) VALUES (?, ?, ?)`,
              [tid, contactId ? parseInt(contactId, 10) : null, quoteId || null]
            );
            
            logger.info(`Successfully logged tracking click with ID: ${tid} for organization ${orgId}`);
            
            return { success: true };
          } catch (dbError) {
            logger.error(`Error storing tracking data: ${dbError}`);
            return { 
              success: false, 
              message: 'Error recording tracking click', 
              error: 'Database error' 
            };
          }
        } catch (error) {
          logger.error(`Error processing tracking click: ${error}`);
          return { 
            success: false, 
            message: 'Failed to process tracking click', 
            error: 'Internal server error' 
          };
        }
      })
      // Send quote email to contact
      .post('/api/contacts/:contactId/send-quote-email', async ({ params, request, body }) => {
        try {
          const user = await getUserFromSession(request);
          if (!user) {
            return {
              success: false,
              message: 'Authentication required'
            };
          }

          const contactId = Number(params.contactId);
          if (isNaN(contactId)) {
            return {
              success: false,
              message: 'Invalid contact ID'
            };
          }

          // Get org-specific database
          const orgDb = await Database.getOrgDb(user.organization_id.toString());

          // Fetch contact details
          const contact = await orgDb.fetchOne<{id: number, first_name: string, last_name: string, email: string, plan_type: string, phone_number: string}>(
            'SELECT id, first_name, last_name, email, plan_type, phone_number FROM contacts WHERE id = ?',
            [contactId]
          );

          if (!contact) {
            return {
              success: false,
              message: 'Contact not found'
            };
          }

          logger.info(`Contact: ${JSON.stringify(contact)}`);

          // Use the proper generateQuoteId function
          const quoteId = generateQuoteId(user.organization_id, contactId);
          
          // Calculate base URL
          const baseUrl = process.env.PUBLIC_URL || 'http://localhost:5173';
          let quoteUrl = `${baseUrl}/compare?id=${quoteId}&planType=${contact.plan_type}`;

          // Add organization ID to URL
          quoteUrl += `&orgId=${user.organization_id}`;

          // Send the email via SendGrid
          const emailService = new EmailService();
          
          // Fetch organization data
          const organization = await db.fetchOne<{
            id: number;
            name: string;
            logo_data: string;
            primary_color: string;
            phone: string;
            website: string;
          }>(
            'SELECT id, name, logo_data, primary_color, phone, website FROM organizations WHERE id = ?',
            [user.organization_id]
          );
          
          // Log more details about the logo data
          if (organization?.logo_data) {
            const logoDataPrefix = organization.logo_data.substring(0, 50);
            logger.info(`Logo data prefix: ${logoDataPrefix}...`);
          }
          
          // Log the presence of logo data
          logger.info(`Sending quote email for org ${user.organization_id} with logo: ${organization?.logo_data ? 'Present' : 'Missing'}`);
          
          const result = await emailService.sendQuoteEmail({
            email: contact.email,
            firstName: contact.first_name,
            lastName: contact.last_name,
            quoteUrl,
            planType: contact.plan_type,
            organization: organization || undefined,
            phone: contact.phone_number,
            contactId: contactId
          });

          // Record in email tracking table
          const now = new Date().toISOString();
          const batchId = `manual-${Date.now()}-${contactId}`;
          
          await emailService.recordEmailSend(orgDb, {
            orgId: user.organization_id,
            contactId: contactId,
            emailType: 'quote_email',
            sendStatus: 'sent',
            sendMode: 'production',
            batchId: batchId,
            messageId: result.messageId
          });

          const trackingRecord = await orgDb.fetchOne<{id: number, email_type: string, scheduled_date: string, send_status: string, send_mode: string}>(
            'SELECT id, email_type, scheduled_date, send_status, send_mode FROM email_send_tracking WHERE batch_id = ?',
            [batchId]
          );

          // Update last_emailed timestamp
          await orgDb.execute(
            'UPDATE contacts SET last_emailed = CURRENT_TIMESTAMP WHERE id = ?',
            [contactId]
          );

          return {
            success: true,
            message: 'Quote email sent successfully',
            trackingRecords: trackingRecord ? {
              id: trackingRecord.id,
              email_type: trackingRecord.email_type,
              scheduled_date: trackingRecord.scheduled_date,
              send_status: trackingRecord.send_status,
              send_mode: trackingRecord.send_mode
            } : null
          };
        } catch (error) {
          logger.error(`Error sending quote email: ${error}`);
          return {
            success: false,
            message: 'Failed to send quote email',
            error: String(error)
          };
        }
      })
      
      .post('/api/contact-request', async ({ body, request }: { body: { name: string; email: string; type: string; quoteId?: string }, request: Request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          const contactRequest = body as { name: string, email: string, type: string, quoteId: string }
          const { name, email, type, quoteId } = contactRequest
          logger.info(`Processing contact request for ${email} (type: ${type})`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())

          // Check for existing contact
          const existingContact = await orgDb.fetchOne<{ id: number }>(
            'SELECT id FROM contacts WHERE LOWER(TRIM(email)) = LOWER(TRIM(?))',
            [email]
          )

          let eventTargetId: number
          let isLead = false

          if (existingContact) {
            // Use existing contact
            logger.info(`Found existing contact with ID ${existingContact.id}`)
            eventTargetId = existingContact.id
          } else {
            // Create new lead
            logger.info(`No existing contact found, creating lead for ${email}`)
            const leadResult = await orgDb.execute(
              `INSERT INTO leads (name, email) VALUES (?, ?) RETURNING id`,
              [name, email]
            )
            
            if (!leadResult.rows?.[0]?.id) {
              throw new Error('Failed to create lead')
            }
            
            eventTargetId = leadResult.rows[0].id
            isLead = true
          }

          // Record the event
          const metadata = {
            quoteId,
            requestType: type
          }

          const eventQuery = isLead
            ? `INSERT INTO contact_events (lead_id, event_type, metadata) VALUES (?, 'followup_request', ?)`
            : `INSERT INTO contact_events (contact_id, event_type, metadata) VALUES (?, 'followup_request', ?)`

          await orgDb.execute(eventQuery, [eventTargetId, JSON.stringify(metadata)])
          logger.info(`Recorded followup request event for ${isLead ? 'lead' : 'contact'} ${eventTargetId}`)

          // Return success response
          return {
            success: true,
            message: 'Contact request recorded successfully'
          }

        } catch (e: unknown) {
          logger.error(`Error processing contact request: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      .get('/api/contacts/:id/eligibility', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/eligibility - Fetching eligibility results`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get most recent eligibility answers for this contact
          const result = await orgDb.fetchOne(
            `SELECT answers 
             FROM eligibility_answers 
             WHERE contact_id = ? 
             ORDER BY created_at DESC 
             LIMIT 1`,
            [id]
          ) as { answers: string } | null

          if (!result) {
            return {
              status: "incomplete",
              answers: null
            }
          }

          // Parse answers JSON and determine status
          const answers = JSON.parse(result.answers)
          const allTrue = Object.values(answers).every(value => value === true)

          return {
            status: allTrue ? "pass" : "flagged",
            answers: result.answers  // Return the raw JSON string instead of the parsed object
          }

        } catch (e) {
          logger.error(`Error fetching eligibility results: ${e}`)
          throw new Error(String(e))
        }
      })
      // Add new endpoint to get follow-up requests
      .get('/api/contacts/:id/follow-ups', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/follow-ups - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get follow-up requests from contact_events table
          const result = await orgDb.execute(
            `SELECT 
              event_type,
              metadata,
              created_at
             FROM contact_events 
             WHERE contact_id = ? 
               AND event_type = 'followup_request'
             ORDER BY created_at DESC`,
            [id]
          )

          // Map results to a more friendly format
          const followUps = result.rows?.map((row: { metadata: string, created_at: string }) => {
            const metadata = JSON.parse(row.metadata)
            return {
              type: metadata.requestType,
              quoteId: metadata.quoteId,
              createdAt: row.created_at
            }
          }) || []

          return followUps

        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      // Add profile update endpoint
      .put('/api/profile', async ({ request, body, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          const { firstName, lastName, phone, signature, useOrgSenderDetails, booking_link } = body as { 
            firstName: string;
            lastName: string;
            phone: string;
            signature?: string;
            useOrgSenderDetails?: boolean;
            booking_link?: string;
          }

          // Get the libSQL client
          const client = db.getClient()

          // Update profile fields including sender settings
          const result = await client.execute({
            sql: `UPDATE users 
                  SET first_name = ?, 
                      last_name = ?, 
                      phone = ?,
                      signature = ?,
                      use_org_sender_details = ?,
                      booking_link = ?
                  WHERE id = ?
                  RETURNING *`,
            args: [
              firstName, 
              lastName, 
              phone, 
              signature || null,
              useOrgSenderDetails !== undefined ? (useOrgSenderDetails ? 1 : 0) : null,
              booking_link || null,
              currentUser.id
            ]
          })

          if (!result.rows || result.rows.length === 0) {
            set.status = 404
            return {
              success: false,
              error: 'User not found'
            }
          }

          return {
            success: true,
            message: 'Profile updated successfully'
          }

        } catch (error) {
          logger.error(`Error updating profile: ${error}`)
          set.status = 500
          return {
            success: false,
            error: String(error)
          }
        }
      })
      // Add endpoint to mark walkthrough as completed
      .post('/api/profile/complete-walkthrough', async ({ request, set }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser) {
            set.status = 401
            return {
              success: false,
              error: 'Not authenticated'
            }
          }

          // Get the libSQL client
          const client = db.getClient()

          // Update the has_completed_walkthrough flag
          const result = await client.execute({
            sql: `UPDATE users 
                  SET has_completed_walkthrough = 1
                  WHERE id = ?`,
            args: [currentUser.id]
          })

          logger.info(`Marked walkthrough as completed for user ${currentUser.id}`)

          return {
            success: true,
            message: 'Walkthrough marked as completed'
          }

        } catch (error) {
          logger.error(`Error marking walkthrough as completed: ${error}`)
          set.status = 500
          return {
            success: false,
            error: String(error)
          }
        }
      })
      .get('/api/agents/:id/contacts', async ({ params, request }) => {
        try {
          const currentUser = await getUserFromSession(request)
          if (!currentUser?.organization_id) {
            throw new Error('No organization ID found in session')
          }
          
          logger.info(`GET /api/agents/${params.id}/contacts - Fetching contacts for agent ${params.id}`)
          
          // Get organization-specific database
          const orgDb = await Database.getOrInitOrgDb(currentUser.organization_id.toString())
          
          // Fetch all contacts for the agent
          const result = await orgDb.fetchAll('SELECT * FROM contacts WHERE agent_id = ?', [params.id])
          
          logger.info(`GET /api/agents/${params.id}/contacts - Found ${result.length} contacts`)
          
          // Map the database results to the expected format with camelCase field names
          const contacts = result.map((contact: { 
            id: number;
            first_name: string;
            last_name: string;
            email: string;
            current_carrier: string;
            plan_type: string;
            effective_date: string;
            birth_date: string;
            tobacco_user: number;
            gender: string;
            state: string;
            zip_code: string;
            agent_id: number | null;
            last_emailed: string | null;
            phone_number: string;
          }) => ({
            id: contact.id,
            first_name: contact.first_name,
            last_name: contact.last_name,
            email: contact.email,
            current_carrier: contact.current_carrier,
            plan_type: contact.plan_type,
            effective_date: contact.effective_date,
            birth_date: contact.birth_date,
            tobacco_user: Boolean(contact.tobacco_user),
            gender: contact.gender,
            state: contact.state,
            zip_code: contact.zip_code,
            agent_id: contact.agent_id,
            last_emailed: contact.last_emailed,
            phone_number: contact.phone_number || ''
          }))
          
          return {
            success: true,
            contacts: contacts
          }
        } catch (e: unknown) {
          logger.error(`Error fetching contacts for agent ${params.id}: ${e instanceof Error ? e.message : String(e)}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .get('/api/contact-requests', async ({ request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contact-requests - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Fetch all follow-up requests
          const result = await orgDb.fetchAll('SELECT * FROM contact_events WHERE event_type = ?', ['followup_request'])
          
          logger.info(`GET /api/contact-requests - Found ${result.length} follow-up requests`)
          
          // Map the database results to the expected format with camelCase field names
          const followUps = result.map((followUp: { id: number, event_type: string, metadata: string, created_at: string }) => ({
            id: followUp.id,
            event_type: followUp.event_type,
            metadata: JSON.parse(followUp.metadata),
            created_at: followUp.created_at
          }))
          
          return {
            success: true,
            followUps: followUps
          }
        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e}`)
          return {
            success: false,
            error: String(e)
          }
        }
      })
      .get('/api/contacts/:id/follow-ups', async ({ params: { id }, request }) => {
        try {
          const user = await getUserFromSession(request)
          if (!user?.organization_id) {
            throw new Error('No organization ID found in session')
          }

          logger.info(`GET /api/contacts/${id}/follow-ups - Fetching follow-up requests`)
          
          // Get org-specific database
          const orgDb = await Database.getOrInitOrgDb(user.organization_id.toString())
          
          // Get follow-up requests from contact_events table
          const result = await orgDb.execute(
            `SELECT 
              event_type,
              metadata,
              created_at
             FROM contact_events 
             WHERE contact_id = ? 
               AND event_type = 'followup_request'
             ORDER BY created_at DESC`,
            [id]
          )

          // Map results to a more friendly format
          const followUps = result.rows?.map((row: { metadata: string, created_at: string }) => {
            const metadata = JSON.parse(row.metadata)
            return {
              type: metadata.requestType,
              quoteId: metadata.quoteId,
              createdAt: row.created_at
            }
          }) || []

          return followUps

        } catch (e) {
          logger.error(`Error fetching follow-up requests: ${e instanceof Error ? e.message : String(e)}`)
          throw new Error(e instanceof Error ? e.message : String(e))
        }
      })
      // Add a catch-all route handler for SPA routes
      .all('*', async ({ request, set }) => {
        const url = new URL(request.url);
        const path = url.pathname;
        
        // Skip API routes
        if (path.startsWith('/api/')) {
          set.status = 404;
          return { error: 'API endpoint not found' };
        }
        
        // Skip files with extensions (static assets)
        if (path.includes('.') && !path.endsWith('/')) {
          set.status = 404;
          return { error: 'File not found' };
        }
        
        // For all other routes, serve the SPA index.html
        logger.info(`Serving SPA for route: ${path}`);
        
        // Determine the path to index.html based on environment
        let indexPath = '';
        
        // Check multiple possible locations for the index.html file
        const possiblePaths = [
          join(process.cwd(), 'dist', 'index.html'),  // Main dist directory
          join(process.cwd(), '..', 'dist', 'index.html'), // Parent dist directory
          join(process.cwd(), 'public', 'index.html'), // Public directory
          join(process.cwd(), '..', 'frontend', 'dist', 'index.html') // Frontend dist directory
        ];
        
        // Try each path until we find one that exists
        for (const possiblePath of possiblePaths) {
          logger.info(`Checking for SPA at: ${possiblePath}`);
          if (existsSync(possiblePath)) {
            indexPath = possiblePath;
            logger.info(`Found SPA at: ${indexPath}`);
            break;
          }
        }
        
        if (!indexPath || !existsSync(indexPath)) {
          logger.error(`Cannot find SPA index.html file to serve for route: ${path}`);
          set.status = 404;
          return { error: 'SPA file not found' };
        }
        
        // Read and serve the index.html file
        try {
          const content = readFileSync(indexPath, 'utf-8');
          set.headers['Content-Type'] = 'text/html';
          return content;
        } catch (error) {
          logger.error(`Error reading SPA index.html: ${error}`);
          set.status = 500;
          return { error: 'Error serving SPA' };
        }
      })
      .listen(8000)

    logger.info('Server started on port 8000')

    // Schedule the cleanup job to run daily at midnight
    cron.schedule('0 0 * * *', () => {
      logger.info('Running scheduled cleanup job for old organizations');
      // cleanupOldOrganizations().catch(error => {
      //   logger.error(`Error in scheduled cleanup job: ${error}`);
      // });
    });
    
    logger.info('Scheduled daily cleanup job for old organizations');

    return app
  } catch (error) {
    logger.error(`Error starting server: ${error}`)
    throw error
  }
}

startServer()

================
File: backend/src/logger.ts
================
export const logger = {
  info: (message: string) => {
    const timestamp = new Date().toISOString()
    console.log(`[${timestamp}] [INFO] ${message}`)
  },
  error: (message: string) => {
    const timestamp = new Date().toISOString()
    console.error(`[${timestamp}] [ERROR] ${message}`)
  },
  warn: (message: string) => {
    const timestamp = new Date().toISOString()
    console.warn(`[${timestamp}] [WARN] ${message}`)
  }
}

================
File: backend/src/types.ts
================
import { Database } from './database';
import { cookie } from '@elysiajs/cookie';

export interface ContactCreate {
  first_name: string
  last_name: string
  email: string
  phone_number: string
  state: string
  contact_owner_id?: number | null
  current_carrier?: string | null
  effective_date: string
  birth_date: string
  tobacco_user: boolean
  gender: string
  zip_code: string
  plan_type?: string | null
  agent_id?: number | null
}

export interface ContactCreateTemp {
  first_name: string
  last_name: string
  email: string
  phone_number: string
  state: string
  effective_date: string
  birth_date: string
  tobacco_user: boolean
  gender: string
  zip_code: string
  contact_owner_id?: number | null
}

export interface AgentCreate {
  first_name: string
  last_name: string
  email: string
  phone: string
}

export interface User {
  id: number;
  email: string;
  organization_id: number;
  organizationId?: number;
  is_admin: boolean;
  is_agent: boolean;
  is_active: boolean;
  first_name: string;
  last_name: string;
  phone: string;
  organization_name?: string;
}

export interface BaseSettings {
  stateLicenses: string[];
  carrierContracts: string[];
  stateCarrierSettings: any[];
  allowAgentSettings: boolean;
  emailSendBirthday: boolean;
  emailSendPolicyAnniversary: boolean;
  emailSendAep: boolean;
  smartSendEnabled: boolean;
  brandName?: string;
  logo?: string | null;
  orgSignature?: boolean;
  phone?: string;
  redirectUrl?: string;
  signature?: string;
}

export interface UserContext {
  store: {
    db: Database;
  };
  user: User;
  set: {
    status?: number;
    headers?: Record<string, string>;
  };
  cookie: ReturnType<typeof cookie>;
  query: Record<string, string | undefined>;
  body: unknown;
}

================
File: backend/.env.example
================
# Database connection
TURSO_URL=
TURSO_AUTH_TOKEN=

# Authentication
JWT_SECRET=your-very-long-jwt-secret-at-least-32-characters
COOKIE_SECRET=your-cookie-secret

# Server
PORT=3001
HOST=0.0.0.0
PUBLIC_URL=http://localhost:5173

# Email
EMAIL_FROM=support@yourcompany.com
SENDGRID_API_KEY=

# Stripe Integration
STRIPE_SECRET_KEY=sk_test_51XXXXXXXXXXXXXXXXXXXXXXXX
STRIPE_PUBLISHABLE_KEY=pk_test_51XXXXXXXXXXXXXXXXXXXXXXXX
STRIPE_WEBHOOK_SECRET=whsec_XXXXXXXXXXXXXXXXXXXXXXXX

# Stripe Products and Prices
STRIPE_PRICE_BASIC=price_XXXXXXXXXXXXX
STRIPE_PRICE_PRO=price_XXXXXXXXXXXXX
STRIPE_PRICE_ENTERPRISE=price_XXXXXXXXXXXXX

# Contact-based Pricing
STRIPE_PRICE_CONTACT_BASE_TIER=price_XXXXXXXXXXXXX
STRIPE_PRICE_ADDITIONAL_CONTACTS=price_XXXXXXXXXXXXX

# For example mode in local development (uncomment to enable)
# USE_MOCK_STRIPE=true

================
File: backend/.gitignore
================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

# Mock database files
data/replit_mock_db.json
data/stage_demo_db.json

================
File: backend/BULK-IMPORT-IMPLEMENTATION.md
================
# Bulk Contact Import Implementation Summary

## Overview

This document provides a summary of the bulk contact import implementation.

## Core Components

1. **Database Class Enhancement**:
   - Added a streamlined `bulkImportContacts` method
   - Handles contact validation, deduplication, and SQL generation
   - Creates timestamped database names to avoid conflicts

2. **TursoService Enhancement**:
   - Improved `createDatabaseFromDump` method
   - Added phased SQL execution (schema → data → indexes)
   - Enhanced error handling and cleanup operations

3. **API Integration**:
   - Created a new `POST /api/contacts/bulk-import` endpoint
   - Handles CSV file upload with form data multipart processing
   - Launches the import process asynchronously

4. **Command Line Tools**:
   - Created `test-bulk-import.ts` for command line importing
   - Added `generate-test-data.ts` for sample data generation
   - Both accessible through npm scripts

5. **Web Interface**:
   - Created a simple test form at `/test-bulk-import.html`
   - Provides visual feedback on import process

## Technical Implementation

### Efficient Data Processing

The implementation features several optimizations:

1. **Multi-row INSERT statements**:
   ```sql
   INSERT INTO contacts (...) VALUES (...), (...), (...) ...
   ```

2. **Transaction management**:
   - Batches operations into groups of 500 records
   - Uses proper transaction boundaries

3. **Index optimization**:
   - Schema created first
   - Data loaded next
   - Indexes created last for best performance

4. **Asynchronous processing**:
   - API returns immediately while import runs in background
   - Client doesn't need to maintain an open connection

### Error Handling

The implementation includes comprehensive error handling:

1. **Input validation**:
   - Validates CSV fields
   - Normalizes property names (camelCase and snake_case)
   - Reports validation errors

2. **Database operations**:
   - Handles database creation failures
   - Manages SQL execution errors
   - Cleans up resources on failure

3. **Logging**:
   - Detailed logging throughout the process
   - Verification steps to confirm successful operations

## Testing

The implementation includes tools for testing:

1. **Small-scale testing**:
   - Sample CSV with 10 contacts for basic testing
   - Command-line testing script

2. **Large-scale testing**:
   - Data generator for performance testing
   - Support for testing 35,000+ contacts

## Usage

See [README-bulk-import.md](./README-bulk-import.md) for detailed usage instructions.

================
File: backend/out.txt
================
migrations/show_org.sql db shell medicare-portal

================
File: backend/package.json
================
{
  "name": "backend",
  "module": "index.ts",
  "type": "module",
  "scripts": {
    "dev": "bun run --watch --env-file .env src/index.ts",
    "add-agent": "bun run scripts/add-agent.ts",
    "manage-recommendations": "bun run scripts/manage-recommendations.ts",
    "manage-turso": "bun run scripts/manage-turso.ts",
    "test-import": "bun run scripts/test-bulk-import.ts",
    "generate-data": "bun run scripts/generate-test-data.ts",
    "fix-contacts": "bun run scripts/apply-contact-migration.ts",
    "start": "NODE_ENV=production bun run --no-env-file src/index.ts"
  },
  "dependencies": {
    "@clack/prompts": "^0.7.0",
    "@elysiajs/cookie": "^0.8.0",
    "@elysiajs/cors": "^0.8.0",
    "@elysiajs/static": "^1.2.0",
    "@libsql/client": "^0.15.0-pre.1",
    "@sendgrid/mail": "^8.1.4",
    "@types/bun": "latest",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/multer": "^1.4.12",
    "chalk": "^5.4.1",
    "csv-parse": "^5.6.0",
    "csv-stringify": "^6.5.2",
    "dotenv": "^16.3.1",
    "elysia": "^0.8.9",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.2",
    "node-cron": "^3.0.3",
    "openai": "^4.90.0",
    "prompts": "^2.4.2",
    "sqlite3": "^5.1.7",
    "stripe": "^17.7.0",
    "twilio": "^5.6.1",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/node-cron": "^3.0.11",
    "bun-types": "latest"
  }
}

================
File: backend/README-bulk-import.md
================
# Bulk Contact Import Functionality

This document describes the bulk contact import feature that allows importing large numbers of contacts (35,000+) into organizational databases efficiently.

## Overview

The bulk import process works by:
1. Processing and validating input contacts
2. Getting the schema from the existing organization database 
3. Creating a new database with a timestamp-based name
4. Generating optimized SQL with multi-row INSERT statements
5. Uploading the SQL to the new database
6. Updating the organization to point to the new database
7. Cleaning up the old database

## Duplicate Email Handling

The system now handles duplicate emails in three ways:

1. **During Import**: The email field has a unique index that enforces case-insensitive uniqueness.
   - With `overwriteExisting = false`, duplicates are skipped (using `INSERT OR IGNORE`)
   - With `overwriteExisting = true`, existing records are updated (using `INSERT OR REPLACE`) 

2. **Deduplicate Existing Data**: A migration script (`bun run fix-contacts`) can be run to:
   - Find all organization databases with duplicate email entries
   - Keep only the most recently updated record for each email
   - Create the necessary unique index to prevent future duplicates

3. **Schema Protection**: The database schema setup now always creates the unique index on email, regardless of whether the table is being created or already exists.

## Usage

Three options are provided for using the bulk import functionality:

### 1. Web Interface

A simple HTML form is provided for testing the bulk import API:

```bash
# Start the backend server
cd backend && bun run dev

# Access the test page in your browser
open http://localhost:8000/test-bulk-import.html

# Log in as an admin user first (required for the import API)
# You can use the development login helper:
open http://localhost:8000/api/dev/session/login
```

### 2. Generate Test Data

Generate test data for performance testing with:

```bash
# Generate 1,000 test contacts
bun run generate-data 1000

# Generate 50,000 test contacts in a specific file
bun run generate-data 50000 path/to/output.csv
```

### 3. Command Line Import

Import contacts directly from the command line with:

```bash
# Import contacts for organization ID 1
bun run test-import 1 ./scripts/sample-contacts.csv

# Import and overwrite existing contacts with the same email
bun run test-import 1 ./scripts/sample-contacts.csv --overwrite
```

### 4. API Endpoint

The API endpoint for bulk imports can be accessed programmatically:

```javascript
// Example fetch request
const formData = new FormData();
formData.append('file', csvFile); // File object
formData.append('overwriteExisting', true); // Optional, defaults to false

const response = await fetch('/api/contacts/bulk-import', {
  method: 'POST',
  body: formData,
  credentials: 'include'
});

const result = await response.json();

// To check import status:
const statusResponse = await fetch(`/api/contacts/import-status/${organizationId}`, {
  method: 'GET',
  credentials: 'include'
});

const statusResult = await statusResponse.json();
```

## CSV Format

The CSV file should have headers that match the contact fields. Both camelCase and snake_case property names are supported:

```csv
first_name,last_name,email,current_carrier,plan_type,effective_date,birth_date,tobacco_user,gender,state,zip_code,phone_number
John,Doe,john.doe@example.com,Aetna,F,2023-01-01,1955-08-21,0,Male,FL,33101,123-456-7890
```

## Monitoring Import Progress

You can monitor the progress of an import using the import status endpoint:

```bash
# Get import status for organization 123
curl http://localhost:8000/api/contacts/import-status/123
```

The status endpoint returns:

```json
{
  "status": "in progress" | "completed" | "error" | "none",
  "message": "Description of the current status",
  "timestamp": "ISO date when the import was started",
  "age": 5 // Age in minutes
}
```

This endpoint is also available through the web interface at `/test-bulk-import.html` for easy testing.

## Performance Considerations

- The implementation is optimized for large datasets with:
  - Transaction batching (500 contacts per INSERT statement)
  - Index manipulation (drop before bulk insert, recreate after)
  - Property name normalization for CSV flexibility
  - In-memory validation and deduplication
  - Asynchronous processing with status monitoring

## Implementation Details

The core implementation is in two main files:

1. `/backend/src/database.ts` - Contains the `bulkImportContacts` method and email uniqueness enforcement
2. `/backend/src/services/turso.ts` - Contains the `createDatabaseFromDump` method

The process works by:
- Using timestamped database names to avoid conflicts
- Maintaining schema consistency by copying existing table structure
- Processing SQL in phases (schema, data, indexes) for reliability
- Using detailed logging for troubleshooting

## Error Handling

The implementation includes robust error handling:
- Database connection failures
- SQL execution errors
- Validation errors for malformed contacts
- Cleanup operations for partial failures

## Fixing Duplicate Contacts

If you're experiencing duplicate contacts in your database, run the contact fix script:

```bash
# In the backend directory
bun run fix-contacts
```

This script will:
1. Check all organization databases for duplicate email addresses
2. For each database with duplicates:
   - Create a backup of the contacts table
   - Deduplicate contacts by keeping the most recently updated record for each email
   - Create the necessary unique index to prevent future duplicates
3. For databases without duplicates:
   - Only create the unique index if it doesn't exist

The script is safe to run multiple times and will only make changes where needed.

================
File: backend/README.md
================
# backend

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.1.45. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.

================
File: backend/tsconfig.json
================
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}

================
File: docs/contact-tracking.md
================
# Contact Tracking for Usage-Based Billing

This document explains how the contact tracking system works for usage-based billing.

## Overview

The system tracks unique contacts across billing cycles to ensure accurate billing based on the number of unique contacts processed, rather than the current count in the database at any given time.

## Key Concepts

### Unique Contact Tracking

- Each unique email address is counted only once per billing cycle
- Contacts are tracked even if they are later deleted from the main contacts table
- Re-uploading the same contact multiple times in the same billing cycle counts only once

### Billing Cycles

- Billing cycles are monthly periods starting on a configurable day (defaults to 1st of month)
- Usage is reset at the start of each new billing cycle
- The system automatically creates new billing cycles as needed

### Usage-Based Billing

- Base subscription includes 500 contacts ($60/month)
- Additional contacts are billed at $40 per 500 contacts
- Usage is reported to Stripe automatically when contacts are tracked

## Database Schema

The system uses the following tables:

### contact_history

Tracks every unique contact processed by the system:

```sql
CREATE TABLE contact_history (
  id TEXT PRIMARY KEY,
  organization_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  email TEXT NOT NULL,
  first_name TEXT,
  last_name TEXT,
  first_uploaded TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_uploaded TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  status TEXT DEFAULT 'active',
  billing_cycle_key TEXT,
  UNIQUE(organization_id, email)
);
```

### billing_cycle_history

Tracks billing cycles and their contact counts:

```sql
CREATE TABLE billing_cycle_history (
  id TEXT PRIMARY KEY,
  organization_id TEXT NOT NULL,
  cycle_key TEXT NOT NULL,
  start_date TIMESTAMP NOT NULL,
  end_date TIMESTAMP NOT NULL,
  contact_count INTEGER DEFAULT 0,
  usage_reported BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(organization_id, cycle_key)
);
```

### organizations (new columns)

Additional columns on the organizations table:

```sql
ALTER TABLE organizations ADD COLUMN contact_count_billing_date TEXT;
ALTER TABLE organizations ADD COLUMN current_billing_cycle_key TEXT;
ALTER TABLE organizations ADD COLUMN current_unique_contacts INTEGER DEFAULT 0;
```

## API Endpoints

The system provides the following API endpoints:

### Track Individual Contact

```
POST /api/contact-tracking/track
```

**Request Body:**
```json
{
  "email": "contact@example.com",
  "firstName": "John",
  "lastName": "Doe"
}
```

**Response:**
```json
{
  "success": true,
  "isNew": true,
  "contactId": "contact-uuid",
  "stats": {
    "currentCycle": "2024-04",
    "uniqueContacts": 42,
    "billingCycleStart": "2024-04-01T00:00:00.000Z",
    "billingCycleEnd": "2024-05-01T00:00:00.000Z",
    "contactsRemaining": 458,
    "isOverLimit": false
  }
}
```

### Track Contact Batch

```
POST /api/contact-tracking/batch
```

**Request Body:**
```json
{
  "contacts": [
    {
      "email": "contact1@example.com",
      "firstName": "John",
      "lastName": "Doe"
    },
    {
      "email": "contact2@example.com",
      "firstName": "Jane",
      "lastName": "Smith"
    }
  ]
}
```

**Response:**
```json
{
  "success": true,
  "newCount": 2,
  "totalProcessed": 2,
  "stats": {
    "currentCycle": "2024-04",
    "uniqueContacts": 44,
    "billingCycleStart": "2024-04-01T00:00:00.000Z",
    "billingCycleEnd": "2024-05-01T00:00:00.000Z",
    "contactsRemaining": 456,
    "isOverLimit": false
  }
}
```

### Get Usage Stats

```
GET /api/contact-tracking/usage-stats
```

**Response:**
```json
{
  "success": true,
  "stats": {
    "currentCycle": "2024-04",
    "uniqueContacts": 44,
    "billingCycleStart": "2024-04-01T00:00:00.000Z",
    "billingCycleEnd": "2024-05-01T00:00:00.000Z",
    "contactsRemaining": 456,
    "isOverLimit": false
  }
}
```

### Reset Contact Count (Admin Only)

```
POST /api/contact-tracking/reset
```

**Request Body:**
```json
{
  "email": "contact@example.com",
  "reason": "Duplicate upload"
}
```

**Response:**
```json
{
  "success": true,
  "stats": {
    "currentCycle": "2024-04",
    "uniqueContacts": 43,
    "billingCycleStart": "2024-04-01T00:00:00.000Z",
    "billingCycleEnd": "2024-05-01T00:00:00.000Z",
    "contactsRemaining": 457,
    "isOverLimit": false
  }
}
```

## Implementation Details

### Contact Tracking Flow

1. When a contact is added to the system:
   - Check if it already exists in the contact_history table
   - If it's new or from a different billing cycle, count it as a new contact
   - Update the organization's unique contact count

2. When reporting to Stripe:
   - Calculate the number of 500-contact blocks beyond the initial 500
   - Report the updated usage to Stripe via the Stripe API
   - Update the billing cycle record to track that usage has been reported

3. When a billing cycle ends:
   - A new billing cycle is automatically created on the next contact upload
   - The contact count is reset for the new cycle
   - Each unique contact is counted again in the new cycle

### Edge Cases

**Deleted Contacts:**
- Contacts deleted from the main contacts table are still counted for billing
- The contact_history table maintains the record for billing purposes

**Data Errors:**
- If contacts need to be removed from billing due to errors, use the reset endpoint
- Only admins can reset contact counts

**Bulk Changes:**
- The system processes contacts in batches to handle large uploads
- Each unique email is still tracked properly

## Setup and Maintenance

To set up the contact tracking system:

1. Run the migration:
   ```
   cd backend
   ./scripts/setup-contact-tracking.sh
   ```

2. Make sure UUID package is installed:
   ```
   npm install uuid
   npm install --save-dev @types/uuid
   ```

3. Restart the backend server

## Integration with Stripe

The system automatically reports usage to Stripe:

1. Each organization has a Stripe subscription with:
   - Base tier (fixed price for first 500 contacts)
   - Usage-based price for additional contacts

2. Usage reporting:
   - When contact count changes, the system calculates blocks of 500 contacts
   - Reports the updated quantity to Stripe using the usage_record API
   - Stripe will bill accordingly at the end of the billing cycle

================
File: docs/stripe-setup.md
================
# Stripe Integration Setup Guide

This guide covers how to set up our contact-based pricing model in Stripe.

## Overview

Our contact-based pricing uses a tiered model with the following structure:
- Base tier: $60/month for 500 contacts
- Additional tiers: $40/month for each additional 500 contacts

## Development Mode

During development, the application uses a mock Stripe implementation by default. This allows you to test the subscription flow without needing real Stripe credentials.

To use the mock implementation:
- Ensure `USE_MOCK_STRIPE=true` in your `.env` file (or just omit it)
- Or omit Stripe credentials entirely

To use real Stripe in development:
- Set `USE_REAL_STRIPE=true` in your `.env` file
- Provide valid Stripe API keys

## Production Setup

### 1. Stripe Account Setup

1. Create a Stripe account at [stripe.com](https://stripe.com)
2. Get your API keys from the Stripe Dashboard (Developers → API keys)

### 2. Create Products and Prices

#### Create the Base Product

1. In the Stripe Dashboard, go to Products → Add Product
2. Set details:
   - Name: "Contact-Based Subscription"
   - Description: "Subscription with contact-based pricing"

#### Create the Base Tier Price

1. On the product page, add a price:
   - Pricing model: Standard pricing
   - Price: $60.00
   - Billing period: Monthly
   - Name: "Base Tier (500 Contacts)"
2. Save the price and copy the Price ID (starts with `price_`)

#### Create the Additional Contacts Price

1. On the same product, add another price:
   - Pricing model: Standard pricing  
   - Price: $40.00
   - Billing period: Monthly
   - Name: "Additional 500 Contacts"
2. Save the price and copy the Price ID

### 3. Configure Webhook Endpoint

1. Go to Developers → Webhooks → Add Endpoint
2. Set URL to `https://your-domain.com/api/stripe-webhook`
3. Select these events:
   - `customer.subscription.updated`
   - `customer.subscription.created`
   - `invoice.payment_succeeded`
   - `invoice.payment_failed`
   - `customer.subscription.deleted`
4. Save and copy the Webhook Signing Secret

### 4. Environment Variables

Add these variables to your environment:

```
# Stripe API Keys
STRIPE_SECRET_KEY=sk_live_XXXXXXXXXXXXXXXXXX
STRIPE_PUBLISHABLE_KEY=pk_live_XXXXXXXXXXXXXXXXXX
STRIPE_WEBHOOK_SECRET=whsec_XXXXXXXXXXXXXXXXXX

# Stripe Price IDs
STRIPE_PRICE_CONTACT_BASE_TIER=price_XXXXXXXXXXXXXXXXXX
STRIPE_PRICE_ADDITIONAL_CONTACTS=price_XXXXXXXXXXXXXXXXXX
```

### 5. Testing the Integration

1. Start your application with the proper environment variables
2. Use Stripe's test mode (test API keys) for initial testing
3. Verify webhook delivery in the Stripe Dashboard
4. Test the full subscription flow including upgrades and downgrades

## Monitoring

In the Stripe Dashboard, you can monitor:

1. Customers: View all your customers and their subscription details
2. Subscriptions: Monitor active subscriptions and their status
3. Invoices: View all generated invoices and payment history
4. Events: Track webhook events and their delivery status

## Troubleshooting

- Check the server logs for errors when creating or updating subscriptions
- Verify webhook delivery in the Stripe Dashboard
- Use Stripe CLI to test webhook delivery locally

## Subscription Data Format

When a subscription is created, the following metadata is stored:

- `userId`: User ID in your system
- `contactTier`: Numeric tier value (1 = 500 contacts, 2 = 1000 contacts, etc.)
- `contactLimit`: Total contact limit for this subscription
- `organizationId`: Organization ID if applicable
- `tierId`: Original tier ID if applicable

## Contact-Based Pricing Formula

The pricing is calculated as:
- Base price: $60 for the first 500 contacts
- $40 for each additional 500 contacts

For example:
- 500 contacts = $60/month
- 1,000 contacts = $100/month
- 2,500 contacts = $220/month
- 5,000 contacts = $420/month
- 10,000 contacts = $820/month

================
File: frontend/src/assets/checkbox.svg
================
<svg width="16" height="12" viewBox="0 0 16 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.1549 1.72758L5.61008 10.2724L1.72606 6.3884" stroke="#7F56D9" stroke-width="1.6666" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: frontend/src/Components/AccountStatusBanner.elm
================
module Components.AccountStatusBanner exposing (AccountStatusDetails, view)

import Html exposing (Html, a, button, div, h3, p, span, text)
import Html.Attributes exposing (attribute, class, href)
import Html.Events exposing (onClick)
import Json.Decode as Decode exposing (Decoder, bool, int, string)
import Json.Decode.Pipeline as Pipeline
import Svg exposing (path, svg)
import Svg.Attributes as SvgAttr exposing (clipRule, d, fill, fillRule, viewBox)



-- Account status types


type alias AccountStatus =
    String


type alias AccountStatusDetails =
    { status : AccountStatus
    , message : String
    , organizationId : Int
    , organizationName : String
    , organizationSlug : String
    , subscriptionTier : String
    , subscriptionStatus : String
    , agentLimit : Int
    , contactLimit : Int
    , currentAgentCount : Int
    , currentContactCount : Int
    , billingCycleEnd : Maybe String
    , paymentFailureCount : Int
    , paymentCompleted : Bool
    }



-- Decoder for account status details


accountStatusDetailsDecoder : Decoder AccountStatusDetails
accountStatusDetailsDecoder =
    Decode.succeed AccountStatusDetails
        |> Pipeline.required "status" string
        |> Pipeline.required "message" string
        |> Pipeline.required "organizationId" int
        |> Pipeline.required "organizationName" string
        |> Pipeline.required "organizationSlug" string
        |> Pipeline.required "subscriptionTier" string
        |> Pipeline.required "subscriptionStatus" string
        |> Pipeline.required "agentLimit" int
        |> Pipeline.required "contactLimit" int
        |> Pipeline.required "currentAgentCount" int
        |> Pipeline.required "currentContactCount" int
        |> Pipeline.optional "billingCycleEnd" (Decode.nullable string) Nothing
        |> Pipeline.required "paymentFailureCount" int
        |> Pipeline.required "paymentCompleted" bool



-- Function to determine banner color class based on status


getBannerColorClass : AccountStatus -> String
getBannerColorClass status =
    case status of
        "warning" ->
            "bg-yellow-50 border-yellow-200 text-yellow-800"

        "error" ->
            "bg-red-50 border-red-200 text-red-800"

        "success" ->
            "bg-green-50 border-green-200 text-green-800"

        "info" ->
            "bg-blue-50 border-blue-200 text-blue-800"

        _ ->
            "bg-gray-50 border-gray-200 text-gray-800"



-- Function to determine icon color class based on status


getIconColorClass : AccountStatus -> String
getIconColorClass status =
    case status of
        "warning" ->
            "text-yellow-600"

        "error" ->
            "text-red-600"

        "success" ->
            "text-green-600"

        "info" ->
            "text-blue-600"

        _ ->
            "text-gray-600"



-- Function to determine button color class based on status


getButtonColorClass : AccountStatus -> String
getButtonColorClass status =
    case status of
        "warning" ->
            "bg-yellow-100 hover:bg-yellow-200 text-yellow-700"

        "error" ->
            "bg-red-100 hover:bg-red-200 text-red-700"

        "success" ->
            "bg-green-100 hover:bg-green-200 text-green-700"

        "info" ->
            "bg-blue-100 hover:bg-blue-200 text-blue-700"

        _ ->
            "bg-gray-100 hover:bg-gray-200 text-gray-700"



-- Main view function for the account status banner


view : Maybe AccountStatusDetails -> msg -> Html msg
view maybeStatus closeMsg =
    case maybeStatus of
        Just status ->
            div
                [ class ("p-3 sm:p-4 mb-3 sm:mb-4 border rounded-lg flex flex-col sm:flex-row sm:items-start sm:justify-between " ++ getBannerColorClass status.status)
                , attribute "role" "alert"
                ]
                [ div [ class "flex items-start" ]
                    [ div [ class "flex-shrink-0" ]
                        [ div [ class ("p-1 rounded-full mr-2 sm:mr-3 " ++ getIconColorClass status.status) ]
                            [ svg
                                [ SvgAttr.class "w-4 h-4 sm:w-5 sm:h-5"
                                , SvgAttr.fill "currentColor"
                                , SvgAttr.viewBox "0 0 20 20"
                                ]
                                [ path
                                    [ SvgAttr.fillRule "evenodd"
                                    , SvgAttr.d "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                                    , SvgAttr.clipRule "evenodd"
                                    ]
                                    []
                                ]
                            ]
                        ]
                    , div [ class "flex-grow pr-8 sm:pr-0" ]
                        [ div [ class "font-medium text-sm sm:text-base" ] [ text (getStatusTitle status.status) ]
                        , p [ class "text-xs sm:text-sm" ] [ text status.message ]
                        , viewLimitsInfo status
                        ]
                    ]
                , button
                    [ class ("p-1.5 rounded-lg absolute top-2 right-2 sm:static " ++ getButtonColorClass status.status)
                    , onClick closeMsg
                    ]
                    [ svg
                        [ SvgAttr.class "w-4 h-4"
                        , SvgAttr.fill "currentColor"
                        , SvgAttr.viewBox "0 0 20 20"
                        ]
                        [ path
                            [ SvgAttr.fillRule "evenodd"
                            , SvgAttr.d "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                            , SvgAttr.clipRule "evenodd"
                            ]
                            []
                        ]
                    ]
                ]

        Nothing ->
            div [] []



-- Helper function to display resource limits information


viewLimitsInfo : AccountStatusDetails -> Html msg
viewLimitsInfo status =
    if status.currentAgentCount >= status.agentLimit || status.currentContactCount >= status.contactLimit then
        div [ class "mt-1 sm:mt-2 text-xs sm:text-sm" ]
            [ if status.currentAgentCount >= status.agentLimit then
                div [ class "mb-1" ]
                    [ text ("Agents: " ++ String.fromInt status.currentAgentCount ++ "/" ++ String.fromInt status.agentLimit ++ " ")
                    , a [ href "/change-plan", class "underline" ] [ text "Upgrade" ]
                    ]

              else
                text ""
            , if status.currentContactCount >= status.contactLimit then
                div []
                    [ text ("Contacts: " ++ String.fromInt status.currentContactCount ++ "/" ++ String.fromInt status.contactLimit ++ " ")
                    , a [ href "/change-plan", class "underline" ] [ text "Upgrade" ]
                    ]

              else
                text ""
            ]

    else
        text ""



-- Helper function to get a human-readable status title


getStatusTitle : AccountStatus -> String
getStatusTitle status =
    case status of
        "warning" ->
            "Warning"

        "error" ->
            "Error"

        "success" ->
            "Success"

        "info" ->
            "Information"

        "limit_reached" ->
            "Resource Limit Reached"

        "payment_failed" ->
            "Payment Failed"

        "subscription_expiring" ->
            "Subscription Expiring"

        _ ->
            "Notice"

================
File: frontend/src/Components/DemoModeBanner.elm
================
module Components.DemoModeBanner exposing (Model, Msg(..), init, update, view)

import Date exposing (Date, Unit(..))
import Html exposing (Html, button, div, h3, p, span, text)
import Html.Attributes exposing (class)
import Html.Events exposing (onClick)
import Http
import Json.Decode as Decode
import Json.Encode as Encode
import MyIcon
import Task
import Time exposing (Posix)



-- MODEL


type alias Model =
    { demoMode : Bool
    , orgCreateDate : Maybe Date
    , today : Maybe Date
    , showConfirmModal : Bool
    , isSubmitting : Bool
    , error : Maybe String
    }


init : Bool -> Maybe Date -> ( Model, Cmd Msg )
init demoMode orgCreateDate =
    ( { demoMode = demoMode
      , orgCreateDate = orgCreateDate
      , today = Nothing
      , showConfirmModal = False
      , isSubmitting = False
      , error = Nothing
      }
    , now
    )


now : Cmd Msg
now =
    Task.perform (Just >> SetTime) Time.now



-- UPDATE


type Msg
    = ClickExitDemo
    | CancelExitDemo
    | ConfirmExitDemo
    | DemoModeUpdated (Result Http.Error { success : Bool })
    | SetTime (Maybe Posix)
    | NoOp


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        ClickExitDemo ->
            ( { model | showConfirmModal = True, error = Nothing }, Cmd.none )

        CancelExitDemo ->
            ( { model | showConfirmModal = False }, Cmd.none )

        ConfirmExitDemo ->
            ( { model | isSubmitting = True, error = Nothing }
            , exitDemoMode
            )

        DemoModeUpdated (Ok response) ->
            if response.success then
                ( { model | demoMode = False, isSubmitting = False, showConfirmModal = False }, Cmd.none )

            else
                ( { model | isSubmitting = False, error = Just "Failed to exit demo mode. Please try again." }, Cmd.none )

        DemoModeUpdated (Err error) ->
            let
                errorMsg =
                    case error of
                        Http.BadUrl _ ->
                            "Invalid URL"

                        Http.Timeout ->
                            "Request timed out"

                        Http.NetworkError ->
                            "Network error"

                        Http.BadStatus statusCode ->
                            if statusCode == 403 then
                                "Only administrators can exit demo mode"

                            else
                                "Server error: " ++ String.fromInt statusCode

                        Http.BadBody message ->
                            "Failed to parse response: " ++ message
            in
            ( { model | isSubmitting = False, error = Just errorMsg }, Cmd.none )

        SetTime (Just posix) ->
            let
                today =
                    Date.fromPosix Time.utc posix
            in
            ( { model | today = Just today }, Cmd.none )

        SetTime Nothing ->
            ( { model | today = Nothing }, Cmd.none )

        NoOp ->
            ( model, Cmd.none )



-- HTTP


exitDemoMode : Cmd Msg
exitDemoMode =
    Http.request
        { method = "POST"
        , headers = []
        , url = "/api/organizations/exit-demo-mode"
        , body = Http.emptyBody
        , expect = Http.expectJson DemoModeUpdated responseDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


responseDecoder : Decode.Decoder { success : Bool }
responseDecoder =
    Decode.map (\success -> { success = success })
        (Decode.field "success" Decode.bool)



-- VIEW


view : Model -> Html Msg
view model =
    if model.demoMode then
        Html.div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
            [ viewBanner model
            , if model.showConfirmModal then
                viewConfirmModal model

              else
                Html.text ""
            ]

    else
        Html.text ""


viewBanner : Model -> Html Msg
viewBanner model =
    let
        daysLeft =
            daysLeftInTrial model.orgCreateDate model.today
    in
    div [ class "p-3 sm:p-4 border rounded-lg bg-[#F6F1FF] border-[#E9D7FE] text-[#53389E] flex items-center justify-between" ]
        [ div [ class "flex items-start" ]
            [ Html.span [ class "inline-flex items-center justify-center h-6 w-6 rounded-full text-[#7F56D9] mt-0.5 mr-3" ]
                [ MyIcon.purpleIcon 18 "#53389E" ]
            , div []
                [ Html.span [ class "font-semibold text-sm leading-tight" ]
                    [ text ("Trial Period - " ++ String.fromInt daysLeft ++ " days remaining") ]
                , Html.div [ class "mt-1 text-xs leading-tight" ]
                    [ text "Your account is currently in a trial period. You can upload contacts, add agents, and see scheduled quote sends." ]
                , Html.div [ class "mt-1 text-xs leading-tight font-semibold" ]
                    [ text "Please note: emails will not be sent during your trial period. To start sending quotes click \"Go Live\"." ]
                ]
            ]
        , button
            [ class "ml-6 px-4 py-2 bg-[#1C1361] hover:bg-[#53389E] text-white rounded-md text-xs font-medium transition-colors"
            , onClick ClickExitDemo
            ]
            [ text "Go Live" ]
        ]


viewConfirmModal : Model -> Html Msg
viewConfirmModal model =
    div [ class "fixed inset-0 bg-black/50 flex items-center justify-center z-50" ]
        [ div [ class "bg-white rounded-lg p-6 max-w-md w-full mx-4" ]
            [ h3 [ class "text-lg font-medium text-gray-900 mb-3" ]
                [ text "Go Live?" ]
            , p [ class "text-sm text-gray-600 mb-5" ]
                [ text "Once you go live, your emails will be delivered to actual recipients and you will be charged based on usage for all contacts in your organization. This action cannot be undone." ]
            , if model.error /= Nothing then
                div [ class "mb-4 p-2 bg-red-50 border border-red-200 rounded text-red-700 text-sm" ]
                    [ text (Maybe.withDefault "An error occurred" model.error) ]

              else
                text ""
            , div [ class "flex justify-end space-x-3" ]
                [ button
                    [ class "px-4 py-2 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md text-sm font-medium transition-colors"
                    , onClick CancelExitDemo
                    , Html.Attributes.disabled model.isSubmitting
                    ]
                    [ text "Cancel" ]
                , if model.isSubmitting then
                    button
                        [ class "px-4 py-2 text-white bg-blue-600 rounded-md text-sm font-medium transition-colors flex items-center"
                        , Html.Attributes.disabled True
                        ]
                        [ div [ class "mr-2 animate-spin h-4 w-4 border-2 border-white border-t-transparent rounded-full" ] []
                        , text "Processing..."
                        ]

                  else
                    button
                        [ class "px-4 py-2 text-white bg-blue-600 hover:bg-blue-700 rounded-md text-sm font-medium transition-colors"
                        , onClick ConfirmExitDemo
                        ]
                        [ text "Go Live" ]
                ]
            ]
        ]



-- HELPERS


daysLeftInTrial : Maybe Date -> Maybe Date -> Int



-- Calculates the number of days left in the 30-day trial.


daysLeftInTrial maybeOrgCreateDate maybeToday =
    case ( maybeOrgCreateDate, maybeToday ) of
        ( Just orgCreate, Just today ) ->
            let
                daysElapsed =
                    Date.diff Days orgCreate today

                daysLeft =
                    30 - daysElapsed
            in
            if daysLeft < 0 then
                0

            else
                daysLeft

        _ ->
            30

================
File: frontend/src/Components/LimitBanner.elm
================
module Components.LimitBanner exposing (LimitWarning(..), Model, Msg, init, update, view, viewLimitBanner)

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick)
import Http
import Json.Decode as Decode exposing (Decoder, int, string)
import Json.Decode.Pipeline as Pipeline
import Svg exposing (path, svg)
import Svg.Attributes exposing (clipRule, d, fill, fillRule, viewBox)


type LimitWarning
    = AgentLimit Int Int -- currentCount, maxAllowed
    | ContactLimit Int Int -- currentCount, maxAllowed
    | TrialEnding String -- date when trial ends
    | CustomWarning String String -- title, message


type alias Model =
    { warning : Maybe LimitWarning
    , limits : Maybe LimitInfo
    , error : Maybe String
    }


type alias LimitInfo =
    { tierId : String
    , tierName : String
    , agentLimit : Int
    , contactLimit : Int
    }


type Msg
    = GotLimits (Result Http.Error LimitInfo)
    | CloseBanner


init : ( Model, Cmd Msg )
init =
    ( { warning = Nothing
      , limits = Nothing
      , error = Nothing
      }
    , fetchLimits GotLimits
    )


fetchLimits : (Result Http.Error LimitInfo -> msg) -> Cmd msg
fetchLimits toMsg =
    Http.request
        { method = "GET"
        , url = "/api/organizations/my-subscription"
        , headers = []
        , body = Http.emptyBody
        , expect = Http.expectJson toMsg limitInfoDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


limitInfoDecoder : Decoder LimitInfo
limitInfoDecoder =
    Decode.succeed LimitInfo
        |> Pipeline.required "tierId" string
        |> Pipeline.required "tierName" string
        |> Pipeline.required "agentLimit" int
        |> Pipeline.required "contactLimit" int


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GotLimits (Ok limitInfo) ->
            ( { model | limits = Just limitInfo }, Cmd.none )

        GotLimits (Err error) ->
            ( { model | error = Just (httpErrorToString error) }, Cmd.none )

        CloseBanner ->
            ( { model | warning = Nothing }, Cmd.none )


httpErrorToString : Http.Error -> String
httpErrorToString error =
    case error of
        Http.BadUrl url ->
            "Bad URL: " ++ url

        Http.Timeout ->
            "Request timed out"

        Http.NetworkError ->
            "Network error"

        Http.BadStatus statusCode ->
            "Bad status: " ++ String.fromInt statusCode

        Http.BadBody message ->
            "Bad body: " ++ message


view : Model -> Html Msg
view model =
    case model.warning of
        Nothing ->
            text ""

        Just warning ->
            viewLimitBanner warning CloseBanner


viewLimitBanner : LimitWarning -> msg -> Html msg
viewLimitBanner warning closeMsg =
    let
        ( title, message, upgradeText ) =
            case warning of
                AgentLimit current max ->
                    ( "Notice"
                    , "Your account has " ++ String.fromInt current ++ " agents, but your plan only allows for " ++ String.fromInt max ++ ". Please remove some agents or upgrade your plan."
                    , "Upgrade"
                    )

                ContactLimit current max ->
                    ( "Notice"
                    , "Your account has " ++ String.fromInt current ++ " contacts, but your plan only allows for " ++ String.fromInt max ++ ". Please upgrade your plan to add more contacts."
                    , "Upgrade"
                    )

                TrialEnding date ->
                    ( "Trial Ending Soon"
                    , "Your trial will end on " ++ date ++ ". Please upgrade your plan to continue using all features."
                    , "Upgrade"
                    )

                CustomWarning customTitle customMessage ->
                    ( customTitle
                    , customMessage
                    , "Upgrade"
                    )
    in
    div [ class "bg-amber-50 border-l-4 border-amber-400 p-4 mb-6" ]
        [ div [ class "flex justify-between" ]
            [ div [ class "flex" ]
                [ div [ class "flex-shrink-0" ]
                    [ div [ class "h-5 w-5 text-amber-400" ]
                        [ svg [ viewBox "0 0 20 20", fill "currentColor" ]
                            [ path [ fillRule "evenodd", d "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z", clipRule "evenodd" ] []
                            ]
                        ]
                    ]
                , div [ class "ml-3" ]
                    [ p [ class "text-sm text-amber-700 font-medium" ]
                        [ text title ]
                    , p [ class "text-sm text-amber-700 mt-1" ]
                        [ text message ]
                    ]
                ]
            , div [ class "flex items-center" ]
                [ a [ href "/change-plan", class "mr-4 text-sm font-medium text-amber-700 underline hover:text-amber-600" ]
                    [ text upgradeText ]
                , button
                    [ class "rounded-md text-amber-500 hover:bg-amber-100 focus:outline-none focus:ring-2 focus:ring-amber-500"
                    , onClick closeMsg
                    ]
                    [ span [ class "sr-only" ] [ text "Dismiss" ]
                    , div [ class "h-5 w-5" ]
                        [ svg [ viewBox "0 0 20 20", fill "currentColor" ]
                            [ path [ fillRule "evenodd", d "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z", clipRule "evenodd" ] []
                            ]
                        ]
                    ]
                ]
            ]
        ]

================
File: frontend/src/Components/ProgressIndicator.elm
================
module Components.ProgressIndicator exposing (Step, view)

import Html exposing (..)
import Html.Attributes exposing (..)


type alias Step =
    { icon : String
    , title : String
    , description : String
    , isCompleted : Bool
    , isActive : Bool
    }


view : List Step -> Html msg
view steps =
    div 
        [ class "md:fixed hidden md:block left-0 top-0 bottom-0 w-[280px] bg-white border-r border-[#eaecf0] overflow-y-auto" ]
        [ div [ class "flex flex-col h-full px-4 sm:px-8 py-6 sm:py-8" ]
            [ -- Logo
              div [ class "mb-6 sm:mb-14" ]
                [ div [ class "flex items-center" ]
                    [ a
                        [ href "/"
                        , class "cursor-pointer"
                        ]
                        [ img
                            [ src "/images/medicare-max-logo.png"
                            , class "h-6 sm:h-8 w-auto"
                            , alt "Medicare Max logo"
                            ]
                            []
                        ]
                    ]
                ]

            -- Steps
            , div [ class "flex-1" ]
                [ div [ class "space-y-4 sm:space-y-7" ] (List.map viewStep steps)
                ]

            -- Help email
            , div [ class "text-xs sm:text-sm text-[#667085] flex items-center mt-6 sm:mt-8" ]
                [ span [ class "mr-2" ] [ text "✉️" ]
                , text "help@medicaremax.com"
                ]
            ]
        ]


viewStep : Step -> Html msg
viewStep step =
    div
        [ class "flex items-start"
        , classList [ ( "opacity-60", not step.isActive && not step.isCompleted ) ]
        ]
        [ div
            [ class "shrink-0 w-8 h-8 rounded-full flex items-center justify-center mr-3 transition-all duration-300"
            , classList
                [ ( "bg-[#03045e] text-white", step.isActive )
                , ( "bg-[#03045e]/90 text-white", step.isCompleted )
                , ( "bg-[#f9fafb] text-[#667085] border border-[#eaecf0]", not step.isActive && not step.isCompleted )
                ]
            ]
            [ span [ class "text-base" ] [ text step.icon ]
            ]
        , div [ class "flex-1" ]
            [ h3
                [ class "text-sm font-medium transition-colors duration-300"
                , classList
                    [ ( "text-[#101828]", step.isActive )
                    , ( "text-[#101828]/90", step.isCompleted )
                    , ( "text-[#667085]", not step.isActive && not step.isCompleted )
                    ]
                ]
                [ text step.title ]
            , p [ class "text-sm text-[#667085] mt-1 leading-relaxed" ]
                [ text step.description ]
            ]
        ]

================
File: frontend/src/Components/SetupLayout.elm
================
module Components.SetupLayout exposing (SetupStep(..), view)

import Components.ProgressIndicator as ProgressIndicator
import Html exposing (..)
import Html.Attributes exposing (alt, class, src, style)


type SetupStep
    = PlanSelection
    | OrganizationSetup
    | AgentSetup


type alias StepInfo =
    { step : SetupStep
    , icon : String
    , title : String
    , description : String
    }


view : SetupStep -> Bool -> Int -> List (Html msg) -> Html msg
view currentStep isBasicPlan stepNumber content =
    div [ class "min-h-screen bg-gray-50 flex" ]
        [ viewProgressIndicator currentStep isBasicPlan stepNumber
        , div [ class "flex-1 md:ml-[280px] pb-16 sm:pb-24" ]
            [ div [ class "max-w-3xl mx-auto py-4 sm:py-6 px-4 sm:px-6 lg:px-8" ]
                (viewMobileProgressSteps currentStep isBasicPlan stepNumber :: content)
            ]
        ]

-- Mobile progress steps shown at the top of the content area on small screens
viewMobileProgressSteps : SetupStep -> Bool -> Int -> Html msg
viewMobileProgressSteps currentStep isBasicPlan stepNumber =
    let
        steps = 
            if isBasicPlan then
                5 -- Basic plan has 5 steps
            else
                6 -- Multi-agent plan has 6 steps
                
        currentStepIndex =
            case currentStep of
                PlanSelection ->
                    0
                    
                OrganizationSetup ->
                    stepNumber
                    
                AgentSetup ->
                    stepNumber
                    
        -- Calculate progress percentage
        progressPercentage =
            String.fromInt (min 100 (ceiling (toFloat (currentStepIndex * 100) / toFloat (steps - 1))))
            
        -- Get current step number and title
        stepTitle =
            case (currentStep, stepNumber) of
                (PlanSelection, _) ->
                    "Choose Plan"
                    
                (OrganizationSetup, 2) ->
                    "Personal Details"
                    
                (OrganizationSetup, 3) ->
                    "Company Details"
                    
                (OrganizationSetup, 4) ->
                    "Licensing Settings"
                    
                (AgentSetup, 5) ->
                    "Add Team Members"
                    
                (OrganizationSetup, 5) ->
                    if isBasicPlan then
                        "Payment"
                    else
                        "Licensing Settings"
                    
                (OrganizationSetup, 6) ->
                    "Payment"
                    
                _ ->
                    "Setup"
    in
    div [ class "md:hidden mb-6 pb-4 border-b border-gray-200" ]
        [ div [ class "flex justify-between items-center mb-4" ]
            [ img
                [ src "/images/medicare-max-logo.png"
                , class "h-6 w-auto"
                , alt "Medicare Max logo"
                ]
                []
            , div [ class "text-xs text-gray-500" ]
                [ text "Step "
                , text (String.fromInt (currentStepIndex + 1))
                , text " of "
                , text (String.fromInt steps)
                ]
            ]
        , h1 [ class "text-xl font-semibold text-gray-900 mb-2" ]
            [ text stepTitle ]
        , div [ class "h-1 w-full bg-gray-200 rounded overflow-hidden" ]
            [ div
                [ class "h-full bg-[#03045e] transition-all duration-300"
                , style "width" (progressPercentage ++ "%")
                ]
                []
            ]
        ]


viewProgressIndicator : SetupStep -> Bool -> Int -> Html msg
viewProgressIndicator currentStep isBasicPlan stepNumber =
    let
        basicSteps =
            [ { step = PlanSelection
              , icon = "1"
              , title = "Choose Plan"
              , description = "Select your subscription"
              }
            , { step = OrganizationSetup
              , icon = "2"
              , title = "Personal Details"
              , description = "Enter your information"
              }
            , { step = OrganizationSetup
              , icon = "3"
              , title = "Company Details"
              , description = "Agency information"
              }
            , { step = OrganizationSetup
              , icon = "4"
              , title = "Licensing Settings"
              , description = "States and carriers"
              }
            , { step = OrganizationSetup
              , icon = "5"
              , title = "Payment"
              , description = "Complete setup"
              }
            ]

        multiAgentSteps =
            [ { step = PlanSelection
              , icon = "1"
              , title = "Choose Plan"
              , description = "Select your subscription"
              }
            , { step = OrganizationSetup
              , icon = "2"
              , title = "Personal Details"
              , description = "Enter your information"
              }
            , { step = OrganizationSetup
              , icon = "3"
              , title = "Company Details"
              , description = "Agency information"
              }
            , { step = OrganizationSetup
              , icon = "4"
              , title = "Licensing Settings"
              , description = "States and carriers"
              }
            , { step = AgentSetup
              , icon = "5"
              , title = "Add Team Members"
              , description = "Invite your team"
              }
            , { step = OrganizationSetup
              , icon = "6"
              , title = "Payment"
              , description = "Complete setup"
              }
            ]

        steps =
            if isBasicPlan then
                basicSteps

            else
                multiAgentSteps

        makeStep index info =
            { icon = info.icon
            , title = info.title
            , description = info.description
            , isCompleted = isStepComplete currentStep info.step index stepNumber
            , isActive = info.step == currentStep && index == stepNumber
            }

        -- Calculate progress percentage for the progress bar
        totalSteps =
            List.length steps

        currentStepIndex =
            case currentStep of
                PlanSelection ->
                    0

                OrganizationSetup ->
                    stepNumber

                AgentSetup ->
                    stepNumber

        progressPercentage =
            String.fromInt (min 100 (ceiling (toFloat (currentStepIndex * 100) / toFloat (totalSteps - 1))))

        progressBar =
            div [ class "px-8 mt-4" ]
                [ div [ class "h-1 w-full bg-gray-200 rounded overflow-hidden" ]
                    [ div
                        [ class "h-full bg-[#03045e] transition-all duration-300"
                        , style "width" (progressPercentage ++ "%")
                        ]
                        []
                    ]
                , div [ class "mt-2 text-xs text-gray-500 flex justify-between" ]
                    [ span [] [ text "Setup Progress" ]
                    , span [] [ text (progressPercentage ++ "%") ]
                    ]
                ]
    in
    div []
        [ ProgressIndicator.view (List.indexedMap makeStep steps)
        , progressBar
        ]


isStepComplete : SetupStep -> SetupStep -> Int -> Int -> Bool
isStepComplete currentStep step stepIndex currentStepNumber =
    case ( currentStep, step ) of
        ( PlanSelection, _ ) ->
            -- When on plan selection, no steps are completed
            False

        ( OrganizationSetup, PlanSelection ) ->
            -- When on org settings, plan selection is completed
            True

        ( OrganizationSetup, OrganizationSetup ) ->
            -- For org setup steps, complete those before the current one
            stepIndex < currentStepNumber

        ( OrganizationSetup, _ ) ->
            -- Other steps aren't completed yet
            False

        ( AgentSetup, AgentSetup ) ->
            -- The current step isn't completed
            False

        ( AgentSetup, _ ) ->
            -- When on agent setup, all previous steps are completed
            True

================
File: frontend/src/Utils/DiscountDescription.elm
================
module Utils.DiscountDescription exposing (..)

import CarrierNaic exposing (Carrier(..))
import Csv.Decode as Decode exposing (Decoder)


isAchieve : Carrier -> String -> String -> Bool
isAchieve carrier naic state =
    case carrier of
        Humana ->
            case naic of
                "60052" ->
                    List.member state [ "CA", "NJ", "SC" ]

                "60219" ->
                    List.member state [ "PA", "TX" ]

                "88595" ->
                    List.member state [ "DE", "MT", "NH", "SD", "WY", "WI" ]

                "73288" ->
                    List.member state [ "GA" ]

                "60984" ->
                    List.member state stateListMost

                _ ->
                    False

        _ ->
            False


stateListMost : List String
stateListMost =
    [ "AL"
    , "AZ"
    , "AR"
    , "FL"
    , "IL"
    , "IA"
    , "IN"
    , "KS"
    , "KY"
    , "LA"
    , "MI"
    , "MS"
    , "NE"
    , "NC"
    , "ND"
    , "OH"
    , "OK"
    , "PA"
    , "TN"
    , "WV"
    ]


type alias DiscountInfo =
    { state : String
    , aceChubb : Maybe String
    , aetna : Maybe String
    , aflac : Maybe String
    , allstate : Maybe String
    , anthem : Maybe String
    , cigna : Maybe String
    , mutualOfOmaha : Maybe String
    , humana : Maybe String
    , humanaAchieve : Maybe String
    , uhc : Maybe String
    }


discountInfoDecoder : Decoder DiscountInfo
discountInfoDecoder =
    Decode.into DiscountInfo
        |> Decode.pipeline (Decode.column 0 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 1 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 2 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 3 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 4 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 5 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 6 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 7 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 8 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 9 Decode.string)
        |> Decode.pipeline (Decode.optionalColumn 10 Decode.string)



{--| In a real application, this would load the CSV file using HTTP or ports.
For now, we'll use a hardcoded string since Elm doesn't directly support
file system operations. In a production app, this would be loaded from
a file during build time or fetched via HTTP.
--}
{--| Parse the CSV data and convert it to a list of DiscountInfo records.
In a real application, error handling would be more robust.
--}


getDiscountInfos : String -> Result String (List DiscountInfo)
getDiscountInfos csvData =
    Decode.decodeCsv Decode.NoFieldNames discountInfoDecoder csvData
        |> Result.mapError Decode.errorToString



{--| Get the household discount description for a specific carrier, NAIC, and state.
Returns a Maybe String wrapped in a Result to handle both the case of successful
parsing with no discount (Nothing) and the case of parsing errors (Err).
--}


discountDescription : String -> Carrier -> String -> String -> Result String (Maybe String)
discountDescription csvString carrier naic state =
    getDiscountInfos csvString
        |> Result.andThen
            (\discountInfos ->
                -- Find the discount info for the given state
                case List.filter (\info -> info.state == state) discountInfos of
                    [] ->
                        Err ("No discount information found for state: " ++ state)

                    stateInfo :: _ ->
                        -- Clean up "NA" values to be Nothing
                        let
                            cleanNA : Maybe String -> Maybe String
                            cleanNA maybeStr =
                                maybeStr
                                    |> Maybe.andThen
                                        (\str ->
                                            if str == "NA" then
                                                Nothing

                                            else
                                                Just str
                                        )
                        in
                        case carrier of
                            AceChubb ->
                                Ok (cleanNA stateInfo.aceChubb)

                            Aetna ->
                                Ok (cleanNA stateInfo.aetna)

                            Aflac ->
                                Ok (cleanNA stateInfo.aflac)

                            Allstate ->
                                Ok (cleanNA stateInfo.allstate)

                            Cigna ->
                                Ok (cleanNA stateInfo.cigna)

                            MutualOfOmaha ->
                                Ok (cleanNA stateInfo.mutualOfOmaha)

                            UnitedHealthcare ->
                                Ok (cleanNA stateInfo.uhc)

                            Humana ->
                                if isAchieve carrier naic state then
                                    Ok (cleanNA stateInfo.humanaAchieve)

                                else
                                    Ok (cleanNA stateInfo.humana)
            )

================
File: frontend/src/Utils/DiscountDescription.md
================
# Household Discount Description Module

This module fetches and parses household discount information from a CSV file.

## Usage

Here's how to use the updated module with HTTP fetching:

```elm
import Utils.DiscountDescription as HHD

-- In your model:
type alias Model =
    { hhdModel : HHD.HhdModel
      -- your other model fields
    }

-- Initialize with the model
init : Model
init =
    { hhdModel = HHD.init
      -- your other model initialization
    }

-- Add the HHD message to your messages
type Msg
    = HhdMsg HHD.HhdMsg
      -- your other messages

-- In your update function, handle the HHD messages
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        HhdMsg hhdMsg ->
            let
                ( updatedHhdModel, hhdCmd ) =
                    HHD.update hhdMsg model.hhdModel
            in
            ( { model | hhdModel = updatedHhdModel }
            , Cmd.map HhdMsg hhdCmd
            )
        -- your other message handlers

-- In your init function or when you need to load the data
initCommands : Cmd Msg
initCommands =
    Cmd.batch
        [ Cmd.map HhdMsg HHD.fetchHhdData
          -- your other init commands
        ]

-- When you need to get a household discount description:
getDiscountInfo : Model -> Carrier -> String -> String -> Result String (Maybe String)
getDiscountInfo model carrier naic state =
    HHD.discountDescription model.hhdModel carrier naic state
```

## API

- `init` - Initialize the HHD model
- `fetchHhdData` - Command to fetch the CSV data from the server
- `update` - Update function to handle HTTP responses
- `discountDescription` - Get the household discount description for a specific carrier, NAIC, and state

## CSV Format

The CSV file should have the following format:

```
,ACE/Chubb,AETNA,AFLAC,Allstate,Anthem,CIGNA,Mutual of Omaha,Humana (MIPPA),Humana (Achieve),UHIC
AL,Description,Description,Description,...
AK,Description,Description,Description,...
...
```

The first column is the state code, and each subsequent column contains the discount description for a specific carrier.

================
File: frontend/src/Utils/Formatters.elm
================
module Utils.Formatters exposing (formatPhoneNumber)


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    if String.isEmpty phone then
        ""

    else
        let
            digits =
                String.filter Char.isDigit phone

            len =
                String.length digits
        in
        if len == 0 then
            ""

        else if len == 11 && String.left 1 digits == "1" then
            let
                area =
                    String.slice 1 4 digits

                prefix =
                    String.slice 4 7 digits

                line =
                    String.slice 7 11 digits
            in
            "+1 (" ++ area ++ ") " ++ prefix ++ "-" ++ line

        else if len <= 3 then
            "(" ++ String.left len digits

        else if len <= 6 then
            "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

        else
            "(" ++ String.left 3 digits ++ ") " ++ String.slice 3 6 digits ++ "-" ++ String.dropLeft 6 digits

================
File: frontend/src/Utils/MyDate.elm
================
module Utils.MyDate exposing (dateFromMonthDayYear)

import Date exposing (Date)
import List.Extra


dateFromMonthDayYear : String -> Result String Date
dateFromMonthDayYear dateString =
    let
        monthDayYear =
            String.split "/" dateString

        has3 =
            List.length monthDayYear == 3

        year =
            List.Extra.last monthDayYear

        month =
            List.head monthDayYear

        day =
            List.tail monthDayYear
                |> Maybe.withDefault []
                |> List.head
    in
    if has3 then
        case ( year, month, day ) of
            ( Just y, Just m, Just d ) ->
                let
                    mm =
                        if String.length m == 1 then
                            "0" ++ m

                        else
                            m

                    dd =
                        if String.length d == 1 then
                            "0" ++ d

                        else
                            d
                in
                Date.fromIsoString (String.join "-" [ y, mm, dd ])

            _ ->
                Err "Invalid date format 1"

    else
        Err "Invalid date format 2"

================
File: frontend/src/Utils/QuoteHeader.elm
================
module Utils.QuoteHeader exposing (..)

import Html exposing (..)
import Html.Attributes exposing (..)


viewHeader : Maybe String -> Maybe String -> Html msg
viewHeader maybeImage maybeName =
    div [ class "flex justify-center items-center mt-4 mb-6" ]
        [ case ( maybeImage, maybeName ) of
            ( Just logo, _ ) ->
                img [ src logo, alt "Organization Logo", class "h-16 max-w-[240px] md:max-w-[300px] object-contain px-4" ] []

            ( _, Just name ) ->
                div [ class "text-4xl font-bold text-[#101828] leading-[1.2]" ] [ text name ]

            _ ->
                text ""
        ]

================
File: frontend/src/Utils/RandomOrgName.elm
================
module Utils.RandomOrgName exposing (generateOrgName)

import Random


chars : List Char
chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890"
        |> String.toList


generateOrgName : Random.Generator String
generateOrgName =
    Random.list 10 (Random.int 0 (List.length chars - 1))
        |> Random.map
            (\indices ->
                indices
                    |> List.map
                        (\i ->
                            chars
                                |> List.drop i
                                |> List.head
                                |> Maybe.withDefault ' '
                        )
                    |> String.fromList
            )

================
File: frontend/src/Utils/UrlStuff.elm
================
module Utils.UrlStuff exposing (getQueryParams)

import Dict exposing (Dict)
import Url exposing (Url)


getQueryParams : Url -> Dict String String
getQueryParams url =
    url.query
        |> Maybe.map (\q -> String.split "&" q)
        |> Maybe.withDefault []
        |> List.filterMap
            (\param ->
                case String.split "=" param of
                    key :: value :: [] ->
                        Just ( key, value )

                    _ ->
                        Nothing
            )
        |> Dict.fromList

================
File: frontend/src/Accept.elm
================
module Accept exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onInput, onSubmit)
import Http
import Json.Decode as D
import Json.Encode as E
import Url.Parser.Query as Query


type alias Model =
    { name : String
    , email : String
    , isSubmitting : Bool
    , error : Maybe String
    , success : Bool
    , quoteId : Maybe String
    , key : Nav.Key
    }


type Msg
    = UpdateName String
    | UpdateEmail String
    | SubmitForm
    | GotSubmitResponse (Result Http.Error ())
    | GotContactInfo (Result Http.Error ContactInfo)


type alias ContactInfo =
    { email : String
    , firstName : String
    , lastName : String
    }


init : Nav.Key -> Maybe String -> ( Model, Cmd Msg )
init key maybeQuoteId =
    ( { name = ""
      , email = ""
      , isSubmitting = False
      , error = Nothing
      , success = False
      , quoteId = maybeQuoteId
      , key = key
      }
    , case maybeQuoteId of
        Just quoteId ->
            Http.get
                { url = "/api/quotes/decode/" ++ quoteId
                , expect = Http.expectJson GotContactInfo contactInfoDecoder
                }

        Nothing ->
            Cmd.none
    )


contactInfoDecoder : D.Decoder ContactInfo
contactInfoDecoder =
    D.field "contact"
        (D.map3 ContactInfo
            (D.field "email" D.string)
            (D.field "firstName" D.string)
            (D.field "lastName" D.string)
        )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateName name ->
            ( { model | name = name }, Cmd.none )

        UpdateEmail email ->
            ( { model | email = email }, Cmd.none )

        SubmitForm ->
            ( { model | isSubmitting = True }
            , Http.post
                { url = "/api/contact-request"
                , body = Http.jsonBody (encodeForm model)
                , expect = Http.expectWhatever GotSubmitResponse
                }
            )

        GotSubmitResponse result ->
            case result of
                Ok _ ->
                    ( { model | isSubmitting = False, success = True }, Cmd.none )

                Err _ ->
                    ( { model | isSubmitting = False, error = Just "Failed to submit form. Please try again." }, Cmd.none )

        GotContactInfo result ->
            case result of
                Ok info ->
                    ( { model
                        | email = info.email
                        , name = info.firstName ++ " " ++ info.lastName
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( model, Cmd.none )


encodeForm : Model -> E.Value
encodeForm model =
    E.object
        [ ( "name", E.string model.name )
        , ( "email", E.string model.email )
        , ( "type", E.string "accept" )
        , ( "quoteId", Maybe.map E.string model.quoteId |> Maybe.withDefault E.null )
        ]


view : Model -> Browser.Document Msg
view model =
    { title = "Good News! - Medicare Max"
    , body =
        [ div [ class "min-h-screen bg-white" ]
            [ nav [ class "bg-white border-b border-gray-200" ]
                [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
                    [ div [ class "flex justify-between h-16 items-center" ]
                        [ div [ class "flex-shrink-0" ]
                            [ img [ src "/images/medicare-max-logo.png", class "h-8 w-auto", alt "Medicare Max" ] [] ]
                        ]
                    ]
                ]
            , div [ class "max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-12" ]
                [ if model.success then
                    div [ class "text-center" ]
                        [ h1 [ class "text-3xl font-bold text-gray-900 mb-4" ]
                            [ text "Thank You" ]
                        , p [ class "text-gray-600" ]
                            [ text "We'll be in touch soon to schedule your follow-up." ]
                        ]

                  else
                    div []
                        [ h1 [ class "text-3xl font-bold text-center text-gray-900 mb-4" ]
                            [ text "Great News!" ]
                        , p [ class "text-gray-600 text-center mb-8" ]
                            [ text "Based on your answers, you look like a good candidate to switch plans. Let's schedule a follow-up to discuss your options." ]
                        , case model.error of
                            Just error ->
                                div [ class "bg-red-50 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" ]
                                    [ text error ]

                            Nothing ->
                                text ""
                        , Html.form [ onSubmit SubmitForm, class "space-y-6 max-w-lg mx-auto" ]
                            [ div []
                                [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
                                    [ text "Name" ]
                                , input
                                    [ type_ "text"
                                    , class "w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-purple-500 focus:border-purple-500"
                                    , value model.name
                                    , onInput UpdateName
                                    , required True
                                    ]
                                    []
                                ]
                            , div []
                                [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
                                    [ text "Email" ]
                                , input
                                    [ type_ "email"
                                    , class "w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-purple-500 focus:border-purple-500"
                                    , value model.email
                                    , onInput UpdateEmail
                                    , required True
                                    ]
                                    []
                                ]
                            , button
                                [ class "w-full bg-purple-600 text-white py-3 px-4 rounded-lg hover:bg-purple-700 transition-colors duration-200 disabled:opacity-50"
                                , type_ "submit"
                                , disabled model.isSubmitting
                                ]
                                [ if model.isSubmitting then
                                    text "Submitting..."

                                  else
                                    text "Schedule Follow-up"
                                ]
                            ]
                        ]
                ]
            ]
        ]
    }


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/AddAgent.elm
================
module AddAgent exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Components.ProgressIndicator
import Components.SetupLayout as SetupLayout
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Parser exposing ((|.), (|=), Parser, chompIf, chompWhile, end, succeed, symbol)
import Ports
import StateRegions exposing (Region(..), getRegionStates, regionToString)
import Svg exposing (path, svg)
import Svg.Attributes exposing (d, fill, stroke, strokeLinecap, strokeLinejoin, strokeWidth, viewBox)
import Time
import Url



-- Constants


allStates : List String
allStates =
    [ "AL"
    , "AK"
    , "AZ"
    , "AR"
    , "CA"
    , "CO"
    , "CT"
    , "DE"
    , "FL"
    , "GA"
    , "HI"
    , "ID"
    , "IL"
    , "IN"
    , "IA"
    , "KS"
    , "KY"
    , "LA"
    , "ME"
    , "MD"
    , "MA"
    , "MI"
    , "MN"
    , "MS"
    , "MO"
    , "MT"
    , "NE"
    , "NV"
    , "NH"
    , "NJ"
    , "NM"
    , "NY"
    , "NC"
    , "ND"
    , "OH"
    , "OK"
    , "OR"
    , "PA"
    , "RI"
    , "SC"
    , "SD"
    , "TN"
    , "TX"
    , "UT"
    , "VT"
    , "VA"
    , "WA"
    , "WV"
    , "WI"
    , "WY"
    , "DC"
    ]


allCarriers : List String
allCarriers =
    [ "Aetna"
    , "Humana"
    , "UnitedHealthcare"
    , "Cigna"
    , "Aflac"
    , "Allstate"
    , "Mutual of Omaha"
    , "Ace Chubb"
    ]


type alias Settings =
    { carrierContracts : List String
    , stateLicenses : List String
    , forceOrgSenderDetails : Bool
    }


settingsObjectDecoder : Decoder Settings
settingsObjectDecoder =
    Decode.map3 Settings
        (Decode.field "carrierContracts" (Decode.list Decode.string))
        (Decode.field "stateLicenses" (Decode.list Decode.string))
        (Decode.oneOf
            [ Decode.field "forceOrgSenderDetails" Decode.bool
            , Decode.succeed False
            ]
        )


type alias Model =
    { email : String
    , firstName : String
    , lastName : String
    , rawPhone : String
    , displayPhone : String
    , carriers : List String
    , stateLicenses : List String
    , error : Maybe String
    , isSetup : Bool
    , key : Nav.Key
    , isLoading : Bool
    , agents : List Agent
    , showAddForm : Bool
    , currentUser : Maybe CurrentUser
    , isLoadingForAgent : Maybe String
    , orgSettings : Maybe Settings
    , pendingSave : Maybe String
    , planType : String
    , showDeleteConfirm : Maybe String
    , reassignAgentId : Maybe String
    , contacts : List ContactSummary
    , emailStatus : EmailStatus
    , defaultAgentId : Maybe String
    , forceOrgSenderDetails : Bool
    , copiedAgentLinks : List String -- Track which agent IDs have had their links copied
    , currentlyCopyingAgent : Maybe String -- Track which agent's link is currently being copied
    , orgSlug : String -- ADDED
    }


type alias User =
    { id : String
    , email : String
    , firstName : String
    , lastName : String
    , phone : String
    , orgSlug : String -- ADDED
    }


type alias Agent =
    { id : String
    , firstName : String
    , lastName : String
    , email : String
    , phone : String
    , carriers : List String
    , stateLicenses : List String
    , expanded : Bool
    , calendarLink : String
    , signature : String
    }


type alias CurrentUser =
    { id : String
    , email : String
    , firstName : String
    , lastName : String
    , phone : String
    , orgSlug : String -- ADDED
    }


type alias ContactSummary =
    { id : Int
    , agentId : Maybe String
    }


type EmailStatus
    = NotChecked
    | Checking
    | Valid
    | Invalid String


type Msg
    = NoOp
    | UpdateEmail String
    | UpdateFirstName String
    | UpdateLastName String
    | UpdatePhone String
    | UpdateField String String
    | SaveAgent
    | AgentSaved (Result Http.Error ())
    | NavigateTo String
    | CloseModal
    | ShowModal
    | ToggleCarrier String Bool
    | ToggleState String Bool
    | SelectAllCarriers Bool
    | SelectAllStates Bool
    | DeleteAgent String
    | ConfirmDeleteAgent String (Maybe String)
    | CloseDeleteConfirmModal
    | AgentDeleted (Result Http.Error ())
    | FinishSetup
    | SelectCommonStates Region
    | LoadFromOrg
    | GotOrgSettings (Result Http.Error Settings)
    | AddAnotherAgent
    | CancelAddAgent
    | RemoveAgent String
    | FetchAgents
    | GotAgents (Result Http.Error AgentsResponse)
    | GotCurrentUser (Result Http.Error CurrentUserResponse)
    | UpdateAgentField String String String
    | ToggleAgentExpanded String
    | UpdateAgentCarrier String String Bool
    | UpdateAgentState String String Bool
    | SelectAllStatesForAgent String Bool
    | SelectCommonStatesForAgent String Region
    | LoadFromOrgForAgent String
    | GotOrgSettingsForAgent String (Result Http.Error Settings)
    | SelectAllCarriersForAgent String Bool
    | SaveAgentDetails String
    | AgentDetailsSaved String (Result Http.Error ())
    | DebounceSaveAgent String
    | EditAgent Agent
    | CheckAgentEmail
    | GotEmailResponse (Result Http.Error EmailResponse)
    | SetDefaultAgent String
    | SetDefaultAgentResult (Result Http.Error ())
    | CopyAgentSelfOnboardingLink String
    | LinkCopied Bool


type alias CurrentUserResponse =
    { success : Bool
    , user : Maybe User
    }


type alias EmailResponse =
    { available : Bool
    , message : String
    }


type alias AgentsResponse =
    { agents : List Agent
    , defaultAgentId : Maybe String
    }


init : Bool -> Nav.Key -> Maybe { id : String, email : String, firstName : String, lastName : String, phone : String, isAdmin : Bool, isAgent : Bool, orgSlug : String } -> String -> ( Model, Cmd Msg )
init isSetup key currentUser planType =
    let
        initialAgents =
            case currentUser of
                Just user ->
                    -- Create an initial agent from the current user for setup mode
                    let
                        initialAgent =
                            { id = user.id
                            , firstName = user.firstName
                            , lastName = user.lastName
                            , email = user.email
                            , phone = user.phone
                            , carriers = []
                            , stateLicenses = []
                            , expanded = False
                            , calendarLink = ""
                            , signature = ""
                            }

                        -- Convert old user type to new CurrentUser type
                        convertedUser =
                            { id = user.id
                            , email = user.email
                            , firstName = user.firstName
                            , lastName = user.lastName
                            , phone = user.phone
                            , orgSlug = user.orgSlug
                            }
                    in
                    if isSetup then
                        [ initialAgent ]

                    else
                        []

                Nothing ->
                    []

        -- Convert old user type to new CurrentUser type
        convertedCurrentUser =
            currentUser
                |> Maybe.map
                    (\user ->
                        { id = user.id
                        , email = user.email
                        , firstName = user.firstName
                        , lastName = user.lastName
                        , phone = user.phone
                        , orgSlug = user.orgSlug
                        }
                    )
    in
    ( { email = ""
      , firstName = ""
      , lastName = ""
      , rawPhone = ""
      , displayPhone = ""
      , carriers = []
      , stateLicenses = []
      , error = Nothing
      , isSetup = isSetup
      , key = key
      , isLoading = True
      , agents = initialAgents
      , showAddForm = False
      , currentUser = convertedCurrentUser
      , isLoadingForAgent = Nothing
      , orgSettings = Nothing
      , pendingSave = Nothing
      , planType = planType
      , showDeleteConfirm = Nothing
      , reassignAgentId = Nothing
      , contacts = []
      , emailStatus = NotChecked
      , defaultAgentId = Nothing
      , forceOrgSenderDetails = False
      , copiedAgentLinks = []
      , currentlyCopyingAgent = Nothing
      , orgSlug = Maybe.map .orgSlug convertedCurrentUser |> Maybe.withDefault ""
      }
    , fetchAgents
    )


view : Model -> Browser.Document Msg
view model =
    { title =
        if model.isSetup then
            "Add Team Members"

        else
            "Manage Agents"
    , body =
        [ if model.isSetup then
            -- Show setup UI with sidebar
            SetupLayout.view SetupLayout.AgentSetup
                (model.planType == "basic")
                4
                -- Using 4 for AddAgent as it's typically the 5th step (0-indexed)
                [ div [ class "max-w-3xl mx-auto pb-24" ]
                    [ viewSetupHeader model
                    , viewAgentsList model
                    ]
                , viewBottomBar model
                ]

          else
            -- Show regular UI without sidebar
            div [ class "min-h-screen bg-gray-50 pb-24" ]
                [ div [ class "max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
                    [ viewNormalHeader
                    , div [ class "bg-white shadow rounded-lg p-6" ]
                        [ viewAgentsList model
                        ]
                    ]
                , text "" -- No bottom bar in regular mode
                ]
        , viewDeleteConfirmationModal model
        ]
    }


viewSetupHeader : Model -> Html Msg
viewSetupHeader model =
    div [ class "mb-8 flex justify-between items-center" ]
        [ div []
            [ h1 [ class "text-3xl font-bold text-gray-900" ]
                [ text "Add Your First Agent" ]
            , p [ class "mt-2 text-gray-600" ]
                [ text "Set up your first agent to get started" ]
            ]
        , if not model.showAddForm then
            button
                [ class "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
                , onClick AddAnotherAgent
                ]
                [ span [ class "mr-2" ] [ text "+" ]
                , text "Add Agent"
                ]

          else
            text ""
        ]


viewNormalHeader : Html Msg
viewNormalHeader =
    div [ class "mb-8 flex justify-left items-center" ]
        [ h1 [ class "text-2xl font-semibold text-gray-900" ]
            [ text "Manage Agents" ]
        ]


viewBasicInfo : Model -> Html Msg
viewBasicInfo model =
    div [ class "space-y-4" ]
        [ div [ class "grid grid-cols-2 gap-4" ]
            [ div []
                [ label [ class "block text-sm font-medium text-gray-700" ]
                    [ text "First Name" ]
                , input
                    ([ type_ "text"
                     , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500 text-base"
                     , value
                        (if isAdminBecomingAgent model then
                            case model.currentUser of
                                Just user ->
                                    user.firstName

                                Nothing ->
                                    model.firstName

                         else
                            model.firstName
                        )
                     , placeholder "Enter first name"
                     ]
                        ++ (if isAdminBecomingAgent model then
                                [ disabled True ]

                            else
                                [ onInput UpdateFirstName ]
                           )
                    )
                    []
                ]
            , div []
                [ label [ class "block text-sm font-medium text-gray-700" ]
                    [ text "Last Name" ]
                , input
                    ([ type_ "text"
                     , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500 text-base"
                     , value
                        (if isAdminBecomingAgent model then
                            case model.currentUser of
                                Just user ->
                                    user.lastName

                                Nothing ->
                                    model.lastName

                         else
                            model.lastName
                        )
                     , placeholder "Enter last name"
                     ]
                        ++ (if isAdminBecomingAgent model then
                                [ disabled True ]

                            else
                                [ onInput UpdateLastName ]
                           )
                    )
                    []
                ]
            ]
        , div [ class "grid grid-cols-2 gap-4" ]
            [ div []
                [ label [ class "block text-sm font-medium text-gray-700" ]
                    [ text "Email" ]
                , input
                    ([ type_ "email"
                     , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500 text-base"
                     , value
                        (if isAdminBecomingAgent model then
                            Maybe.map .email model.currentUser |> Maybe.withDefault ""

                         else
                            model.email
                        )
                     , placeholder "name@example.com"
                     ]
                        ++ (if isAdminBecomingAgent model then
                                [ disabled True ]

                            else
                                [ onInput UpdateEmail, onBlur CheckAgentEmail ]
                           )
                    )
                    []
                , viewEmailStatus model.emailStatus
                ]
            , div []
                [ label [ class "block text-sm font-medium text-gray-700" ]
                    [ text "Phone" ]
                , input
                    [ type_ "tel"
                    , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base"
                    , value model.displayPhone
                    , onInput UpdatePhone
                    , placeholder "(555) 555-5555"
                    ]
                    []
                ]
            ]
        ]


viewAgentsList : Model -> Html Msg
viewAgentsList model =
    div [ class "space-y-6" ]
        [ if model.error /= Nothing then
            div [ class "bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-6" ]
                [ text (Maybe.withDefault "" model.error) ]

          else
            text ""
        , div [ class "bg-blue-50 border border-blue-200 text-blue-700 px-4 py-3 rounded mb-6" ]
            [ div [ class "font-medium" ] [ text "Default Agent" ]
            , p [ class "text-sm mt-1" ]
                [ text "The default agent is automatically assigned to contacts who don't have an agent assigned. They also become the fallback when an agent is deleted, if another agent is not selected." ]
            ]
        , if model.isLoading then
            div [ class "flex justify-center items-center py-12" ]
                [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-blue-500 border-t-transparent" ] []
                , p [ class "ml-4 text-gray-500" ] [ text "Loading agents..." ]
                ]

          else
            div [ class "grid grid-cols-1 gap-6" ]
                (List.map
                    (\agent ->
                        let
                            isSelfUser =
                                case model.currentUser of
                                    Just user ->
                                        user.id == agent.id

                                    Nothing ->
                                        False

                            isDefault =
                                model.defaultAgentId == Just agent.id

                            cardBackgroundClass =
                                if isDefault then
                                    "bg-blue-50"

                                else
                                    "bg-white"
                        in
                        div [ class (cardBackgroundClass ++ " shadow rounded-lg p-6") ]
                            [ div
                                [ class "flex items-center justify-between cursor-pointer hover:bg-gray-50 -m-2 p-2 rounded-md"
                                , onClick (ToggleAgentExpanded agent.id)
                                ]
                                [ div [ class "flex items-center" ]
                                    [ -- Expand/Collapse Icon
                                      div [ class "mr-2" ]
                                        [ svg
                                            [ Svg.Attributes.class "h-5 w-5 text-gray-400 transform transition-transform duration-200"
                                            , Svg.Attributes.class
                                                (if agent.expanded then
                                                    "rotate-90"

                                                 else
                                                    ""
                                                )
                                            , Svg.Attributes.viewBox "0 0 20 20"
                                            , Svg.Attributes.fill "currentColor"
                                            ]
                                            [ path
                                                [ Svg.Attributes.fillRule "evenodd"
                                                , Svg.Attributes.d "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                                                , Svg.Attributes.clipRule "evenodd"
                                                ]
                                                []
                                            ]
                                        ]
                                    , div [ class "ml-2" ]
                                        [ div [ class "text-lg font-medium text-gray-900" ]
                                            [ text (agent.firstName ++ " " ++ agent.lastName) ]
                                        , div [ class "text-sm text-gray-500" ]
                                            [ text agent.email ]
                                        ]
                                    ]
                                , div [ class "flex items-center space-x-4" ]
                                    [ if not isDefault then
                                        button
                                            [ class "px-3 py-1 text-sm text-blue-600 hover:text-blue-800 font-medium border border-blue-600 rounded-md hover:bg-blue-50"
                                            , stopPropagationOn "click" (Decode.succeed ( SetDefaultAgent agent.id, True ))
                                            ]
                                            [ text "Set as Default" ]

                                      else
                                        div [ class "px-3 py-1 text-sm text-blue-600 font-medium" ]
                                            [ text "Default Agent" ]
                                    , button
                                        [ class "text-blue-600 hover:text-blue-800 font-medium"
                                        , stopPropagationOn "click" (Decode.succeed ( ToggleAgentExpanded agent.id, True ))
                                        ]
                                        [ text "Edit" ]
                                    , button
                                        [ class
                                            ("text-red-400 "
                                                ++ (if isSelfUser || isDefault then
                                                        "opacity-50 cursor-not-allowed"

                                                    else
                                                        "hover:text-red-500"
                                                   )
                                            )
                                        , stopPropagationOn "click" (Decode.succeed ( DeleteAgent agent.id, True ))
                                        , disabled (isSelfUser || isDefault)
                                        , title
                                            (if isSelfUser then
                                                "You cannot delete your own account"

                                             else if isDefault then
                                                "You cannot delete the default agent"

                                             else
                                                "Delete"
                                            )
                                        ]
                                        [ text "Delete" ]
                                    ]
                                ]
                            , if agent.expanded then
                                div [ class "border-t border-gray-200 mt-4 pt-4" ]
                                    [ viewAgentDetails model agent ]

                              else
                                text ""
                            ]
                    )
                    model.agents
                )
        , div [ class "mt-8 bg-white shadow rounded-lg p-6" ]
            [ if model.showAddForm then
                div [ class "space-y-6" ]
                    [ div [ class "border-b border-gray-200 pb-4" ]
                        [ h2 [ class "text-lg font-medium text-gray-900" ]
                            [ text "Add New Agent" ]
                        , p [ class "mt-1 text-sm text-gray-500" ]
                            [ text "Fill in the agent's information below" ]
                        ]
                    , viewBasicInfo model
                    , div [ class "flex justify-end space-x-4 mt-6" ]
                        [ button
                            [ class "px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
                            , onClick CancelAddAgent
                            ]
                            [ text "Cancel" ]
                        , button
                            [ class "px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                            , onClick SaveAgent
                            , disabled (not (isFormValid model))
                            ]
                            [ text "Add Agent" ]
                        ]
                    ]

              else
                div [ class "flex justify-between items-center" ]
                    [ div []
                        [ h3 [ class "text-lg font-medium text-gray-900" ]
                            [ text "Add New Agent" ]
                        , p [ class "text-sm text-gray-500" ]
                            [ text "Add a team member to your organization" ]
                        ]
                    , button
                        [ class "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
                        , onClick AddAnotherAgent
                        ]
                        [ span [ class "mr-2" ] [ text "+" ]
                        , text "Add Agent"
                        ]
                    ]
            ]
        ]


viewAgentDetails : Model -> Agent -> Html Msg
viewAgentDetails model agent =
    let
        fieldError field =
            case field of
                "phone" ->
                    String.isEmpty agent.phone

                "firstName" ->
                    String.isEmpty agent.firstName

                "lastName" ->
                    String.isEmpty agent.lastName

                "email" ->
                    String.isEmpty agent.email

                _ ->
                    False

        errorIndicator field =
            if fieldError field then
                span [ class "text-red-500 ml-1" ] [ text "*" ]

            else
                text ""

        isCurrentUserAgent =
            case model.currentUser of
                Just user ->
                    user.id == agent.id

                Nothing ->
                    False

        formattedPhone =
            formatPhoneNumber (String.filter Char.isDigit agent.phone)

        isLoading =
            model.isLoadingForAgent == Just agent.id

        canEdit =
            canModifySettings model agent.id

        -- Allow current user to edit their own details
        canEditField =
            isCurrentUserAgent || canEdit

        hasChanges =
            model.pendingSave == Just agent.id

        isSaving =
            model.isLoadingForAgent == Just agent.id

        onFieldInput : String -> String -> Msg
        onFieldInput field value =
            UpdateAgentField agent.id field value

        -- Check if organization forces org sender details
        fieldsDisabled =
            model.forceOrgSenderDetails

        agentSelfOnboardingUrl =
            "https://" ++ "medicaremax.ai/self-onboarding/" ++ model.orgSlug ++ "?agentId=" ++ agent.id
    in
    div [ class "space-y-6" ]
        [ -- Basic Information Section
          div [ class "space-y-4" ]
            [ div [ class "grid grid-cols-2 gap-4" ]
                [ div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "First Name"
                        , errorIndicator "firstName"
                        ]
                    , input
                        [ type_ "text"
                        , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500 text-base"
                        , value agent.firstName
                        , onInput (onFieldInput "firstName")
                        , disabled (not canEditField)
                        ]
                        []
                    ]
                , div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Last Name"
                        , errorIndicator "lastName"
                        ]
                    , input
                        [ type_ "text"
                        , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500 text-base"
                        , value agent.lastName
                        , onInput (onFieldInput "lastName")
                        , disabled (not canEditField)
                        ]
                        []
                    ]
                ]
            , div [ class "grid grid-cols-2 gap-4" ]
                [ div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Email Address"
                        , errorIndicator "email"
                        ]
                    , input
                        [ type_ "email"
                        , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500 text-base"
                        , value agent.email
                        , onInput (onFieldInput "email")
                        , disabled (not canEditField)
                        ]
                        []
                    ]
                , div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Phone number"
                        , errorIndicator "phone"
                        ]
                    , div [ class "flex" ]
                        [ span [ class "inline-flex items-center px-3 py-2 rounded-l-md border border-r-0 border-gray-300 bg-gray-50 text-gray-500 shadow-sm" ]
                            [ text "US" ]
                        , input
                            [ type_ "tel"
                            , class "flex-1 px-3 py-2 rounded-r-md border border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base focus:z-10"
                            , value formattedPhone
                            , onInput (onFieldInput "phone")
                            , placeholder "+1 (555) 000-0000"
                            , disabled (not canEditField)
                            ]
                            []
                        ]
                    ]
                ]
            , div []
                [ label [ class "block text-sm font-medium text-gray-700" ]
                    [ text "Calendar Booking Link (optional)" ]
                , input
                    [ type_ "text"
                    , class
                        ("mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base "
                            ++ (if fieldsDisabled then
                                    "disabled:bg-gray-100 disabled:text-gray-500"

                                else
                                    ""
                               )
                        )
                    , value agent.calendarLink
                    , onInput (onFieldInput "calendarLink")
                    , placeholder "example.biz"
                    , disabled (fieldsDisabled || not canEditField)
                    ]
                    []
                , p [ class "text-gray-500 text-xs mt-1" ]
                    [ text "If provided, this link will be used as one of the options a client may select to connect with your agency. Traditionally this would be a Calendly link, Acuity link, etc." ]
                ]
            ]
        , -- Agent Self-Onboarding Link Section
          div []
            [ label [ class "block text-sm font-medium text-gray-700 mb-2" ]
                [ text "Agent Self-Onboarding Link" ]
            , div [ class "flex items-center space-x-2" ]
                [ svg [ Svg.Attributes.class "h-5 w-5 text-gray-400", Svg.Attributes.viewBox "0 0 20 20", Svg.Attributes.fill "currentColor" ]
                    [ path [ Svg.Attributes.fillRule "evenodd", Svg.Attributes.d "M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z", Svg.Attributes.clipRule "evenodd" ] []
                    ]
                , input
                    [ type_ "text"
                    , class "flex-1 px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-gray-50 text-gray-500"
                    , value agentSelfOnboardingUrl
                    , readonly True
                    ]
                    []
                , button
                    [ class "px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                    , onClick (CopyAgentSelfOnboardingLink agent.id)
                    ]
                    [ text
                        (if List.member agent.id model.copiedAgentLinks then
                            "Copied!"

                         else
                            "Copy Link"
                        )
                    ]
                ]
            , p [ class "text-gray-500 text-xs mt-1" ]
                [ text "Share this link with clients or non-clients to gather missing information or capture new leads to your book of business. New leads created in this way will be assigned to the agent associated with this link." ]
            ]
        , if hasChanges then
            div [ class "mt-4 flex justify-end" ]
                [ button
                    [ class "px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                    , onClick (SaveAgentDetails agent.id)
                    , disabled isSaving
                    ]
                    [ if isSaving then
                        text "Saving..."

                      else
                        text "Save Changes"
                    ]
                ]

          else
            text ""
        ]


viewAddAgentButton : Html Msg
viewAddAgentButton =
    div [ class "text-center mt-8" ]
        [ button
            [ class "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
            , onClick AddAnotherAgent
            ]
            [ span [ class "mr-2" ] [ text "+" ]
            , text "Add Agent"
            ]
        ]


viewBottomBar : Model -> Html Msg
viewBottomBar model =
    let
        allAgentsValid =
            List.all
                (\agent ->
                    not (String.isEmpty agent.phone)
                        && not (String.isEmpty agent.firstName)
                        && not (String.isEmpty agent.lastName)
                        && not (String.isEmpty agent.email)
                )
                model.agents

        canAdd =
            not (String.isEmpty (String.trim model.firstName))
                && not (String.isEmpty (String.trim model.lastName))
                && model.emailStatus
                == Valid
                && isValidPhone model.displayPhone
    in
    div [ class "fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-4 sm:px-6 z-10" ]
        [ div [ class "max-w-3xl mx-auto" ]
            [ if model.error /= Nothing then
                div [ class "mb-4" ]
                    [ p [ class "text-red-600" ]
                        [ text (Maybe.withDefault "" model.error) ]
                    ]

              else
                text ""
            , if model.isSetup then
                div [ class "flex justify-center" ]
                    [ button
                        [ class "px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
                        , onClick FinishSetup
                        , disabled (not allAgentsValid || List.isEmpty model.agents)
                        ]
                        [ text "Continue to Dashboard" ]
                    ]

              else
                text ""
            ]
        ]


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        UpdateEmail email ->
            ( { model | email = email, emailStatus = NotChecked }, Cmd.none )

        UpdateFirstName name ->
            ( { model | firstName = name }, Cmd.none )

        UpdateLastName name ->
            ( { model | lastName = name }, Cmd.none )

        UpdatePhone input ->
            let
                rawDigits =
                    String.filter Char.isDigit input
                        |> String.left 10

                formattedPhone =
                    formatPhoneNumber rawDigits
            in
            ( { model
                | rawPhone = rawDigits
                , displayPhone = formattedPhone
                , pendingSave = Just "main" -- Add pending save for main agent
              }
            , Cmd.none
            )

        UpdateField field value ->
            case model.currentUser of
                Just user ->
                    let
                        updatedUser =
                            case field of
                                "firstName" ->
                                    { user | firstName = value }

                                "lastName" ->
                                    { user | lastName = value }

                                "phone" ->
                                    { user | phone = String.filter Char.isDigit value }

                                _ ->
                                    user
                    in
                    ( { model | currentUser = Just updatedUser }
                    , Cmd.none
                    )

                Nothing ->
                    ( model, Cmd.none )

        SaveAgent ->
            if isFormValid model then
                ( { model | isLoading = True }
                , submitNewAgent model
                )

            else
                ( { model | error = Just "Please fill out all fields, ensure email is valid, and select at least one role (admin or agent)" }
                , Cmd.none
                )

        AgentSaved (Ok ()) ->
            if model.isSetup then
                ( { model
                    | showAddForm = False
                    , firstName = ""
                    , lastName = ""
                    , email = ""
                    , rawPhone = ""
                    , displayPhone = ""
                    , carriers = []
                    , stateLicenses = []
                  }
                , Cmd.batch
                    [ fetchAgents -- Refresh the agents list
                    , fetchCurrentUser -- Refresh current user to get updated role
                    ]
                )

            else
                ( { model | error = Nothing }
                , Cmd.batch
                    [ Nav.pushUrl model.key "/add-agents"
                    , fetchAgents -- Also refresh agents list when not in setup mode
                    ]
                )

        AgentSaved (Err _) ->
            ( { model | error = Just "Failed to save agent" }
            , Cmd.none
            )

        CheckAgentEmail ->
            if String.isEmpty (String.trim model.email) then
                ( { model | emailStatus = NotChecked }
                , Cmd.none
                )

            else if model.emailStatus == Checking then
                ( model, Cmd.none )

            else
                ( { model | emailStatus = Checking }
                , checkAgentEmail model.email
                )

        FinishSetup ->
            ( model
            , Nav.pushUrl model.key "/dashboard"
            )

        LoadFromOrg ->
            ( { model | isLoading = True }
            , Http.get
                { url = "/api/settings"
                , expect = Http.expectJson GotOrgSettings settingsObjectDecoder
                }
            )

        GotOrgSettings (Ok settings) ->
            ( { model
                | carriers = settings.carrierContracts
                , stateLicenses = settings.stateLicenses
                , isLoading = False
                , orgSettings = Just settings
                , forceOrgSenderDetails = settings.forceOrgSenderDetails
              }
            , Cmd.none
            )

        GotOrgSettings (Err _) ->
            ( { model
                | error = Just "Failed to load organization settings"
                , isLoading = False
              }
            , Cmd.none
            )

        AddAnotherAgent ->
            ( { model
                | showAddForm = True
                , firstName = ""
                , lastName = ""
                , email = ""
                , rawPhone = ""
                , displayPhone = ""
                , carriers = []
                , stateLicenses = []
              }
            , Cmd.none
            )

        CancelAddAgent ->
            ( { model | showAddForm = False }, Cmd.none )

        RemoveAgent id ->
            ( { model | agents = List.filter (\agent -> agent.id /= id) model.agents }, Cmd.none )

        FetchAgents ->
            ( model, fetchAgents )

        GotAgents result ->
            case result of
                Ok response ->
                    let
                        agents =
                            response.agents

                        finalAgents =
                            if model.isSetup then
                                -- In setup mode, make sure we have at least the current user as an agent
                                case model.currentUser of
                                    Just user ->
                                        -- Check if the current user is already in the agents list
                                        if List.any (\a -> a.id == user.id) agents then
                                            -- Current user is already in the list, use the API result
                                            agents

                                        else
                                            -- Add the current user to the agents list
                                            { id = user.id
                                            , firstName = user.firstName
                                            , lastName = user.lastName
                                            , email = user.email
                                            , phone = user.phone
                                            , carriers = []
                                            , stateLicenses = []
                                            , expanded = False
                                            , calendarLink = ""
                                            , signature = ""
                                            }
                                                :: agents

                                    Nothing ->
                                        agents

                            else
                                -- In normal mode, use the API result
                                agents
                    in
                    ( { model
                        | agents = finalAgents
                        , defaultAgentId = response.defaultAgentId
                        , isLoading = False
                      }
                    , Cmd.none
                    )

                Err error ->
                    case error of
                        Http.BadStatus 403 ->
                            -- For 403, keep the current user in the agents list
                            -- Don't show an error since this is expected for non-admin users
                            ( { model | isLoading = False }, Cmd.none )

                        _ ->
                            let
                                errorMessage =
                                    case error of
                                        Http.BadUrl url ->
                                            "Invalid URL: " ++ url

                                        Http.Timeout ->
                                            "Request timed out"

                                        Http.NetworkError ->
                                            "Network error occurred"

                                        Http.BadStatus status ->
                                            "Server error: " ++ String.fromInt status

                                        Http.BadBody message ->
                                            "Data error: " ++ message
                            in
                            ( { model | error = Just errorMessage, isLoading = False }, Cmd.none )

        GotCurrentUser result ->
            case result of
                Ok response ->
                    case response.user of
                        Just user ->
                            let
                                -- Create agent from current user
                                initialAgent =
                                    { id = user.id
                                    , firstName = user.firstName
                                    , lastName = user.lastName
                                    , email = user.email
                                    , phone = user.phone
                                    , carriers = []
                                    , stateLicenses = []
                                    , expanded = False
                                    , calendarLink = ""
                                    , signature = ""
                                    }

                                -- Include the current user in agents list for setup mode
                                updatedAgents =
                                    if model.isSetup then
                                        -- In setup mode, always have current user as the first agent
                                        if List.any (\a -> a.id == user.id) model.agents then
                                            -- If current user is already in the list, keep existing agents
                                            model.agents

                                        else
                                            -- Add current user to the list
                                            initialAgent :: model.agents

                                    else
                                        -- In normal mode, keep the existing agents
                                        model.agents
                            in
                            ( { model
                                | currentUser = Just user
                                , agents = updatedAgents
                                , error = Nothing -- Clear any previous errors
                              }
                            , Cmd.none
                            )

                        Nothing ->
                            ( { model | currentUser = Nothing }, Cmd.none )

                Err _ ->
                    ( { model | error = Just "Failed to load current user" }
                    , Cmd.none
                    )

        ToggleAgentExpanded agentId ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent | expanded = not agent.expanded }

                    else
                        agent
            in
            ( { model | agents = List.map updateAgent model.agents }, Cmd.none )

        UpdateAgentCarrier agentId carrier isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | carriers =
                                if isSelected then
                                    agent.carriers ++ [ carrier ]

                                else
                                    List.filter ((/=) carrier) agent.carriers
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        UpdateAgentState agentId state isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | stateLicenses =
                                if isSelected then
                                    agent.stateLicenses ++ [ state ]

                                else
                                    List.filter ((/=) state) agent.stateLicenses
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        SelectAllStatesForAgent agentId isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | stateLicenses =
                                if isSelected then
                                    allStates

                                else
                                    []
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        SelectCommonStatesForAgent agentId region ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | stateLicenses = agent.stateLicenses ++ getRegionStates region
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        LoadFromOrgForAgent agentId ->
            ( { model | isLoadingForAgent = Just agentId }
            , Http.get
                { url = "/api/settings"
                , expect = Http.expectJson (GotOrgSettingsForAgent agentId) settingsObjectDecoder
                }
            )

        GotOrgSettingsForAgent agentId (Ok settings) ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | carriers = settings.carrierContracts
                            , stateLicenses = settings.stateLicenses
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , isLoadingForAgent = Nothing -- Clear the Loading state
              }
            , Cmd.none
            )

        GotOrgSettingsForAgent agentId (Err _) ->
            ( { model
                | error = Just "Failed to load organization settings"
                , isLoadingForAgent = Nothing -- Clear the Loading state
              }
            , Cmd.none
            )

        SelectAllCarriers isSelected ->
            ( { model
                | carriers =
                    if isSelected then
                        allCarriers

                    else
                        []
              }
            , Cmd.none
            )

        SelectAllStates isSelected ->
            ( { model
                | stateLicenses =
                    if isSelected then
                        allStates

                    else
                        []
              }
            , Cmd.none
            )

        DeleteAgent agentId ->
            ( { model | showDeleteConfirm = Just agentId, reassignAgentId = Nothing }, Cmd.none )

        ConfirmDeleteAgent agentId reassignToAgentId ->
            ( { model | showDeleteConfirm = Nothing, reassignAgentId = reassignToAgentId, isLoading = True }
            , deleteAgent agentId reassignToAgentId
            )

        CloseDeleteConfirmModal ->
            ( { model | showDeleteConfirm = Nothing, error = Nothing }, Cmd.none )

        SelectCommonStates region ->
            ( { model | stateLicenses = model.stateLicenses ++ getRegionStates region }
            , Cmd.none
            )

        NavigateTo path ->
            ( model, Nav.pushUrl model.key path )

        ShowModal ->
            ( { model | showAddForm = True }, Cmd.none )

        CloseModal ->
            ( { model | showAddForm = False }, Cmd.none )

        ToggleCarrier agentId isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | carriers =
                                if isSelected then
                                    agent.carriers ++ [ agentId ]

                                else
                                    List.filter ((/=) agentId) agent.carriers
                        }

                    else
                        agent
            in
            ( { model | agents = List.map updateAgent model.agents }
            , Cmd.none
            )

        ToggleState agentId isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | stateLicenses =
                                if isSelected then
                                    agent.stateLicenses ++ [ agentId ]

                                else
                                    List.filter ((/=) agentId) agent.stateLicenses
                        }

                    else
                        agent
            in
            ( { model | agents = List.map updateAgent model.agents }
            , Cmd.none
            )

        SelectAllCarriersForAgent agentId isSelected ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        { agent
                            | carriers =
                                if isSelected then
                                    allCarriers

                                else
                                    []
                        }

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        SaveAgentDetails agentId ->
            ( { model
                | pendingSave = Nothing
                , isLoadingForAgent = Just agentId
              }
            , case List.filter (\a -> a.id == agentId) model.agents of
                agent :: _ ->
                    saveAgentDetails agent

                [] ->
                    Cmd.none
            )

        AgentDetailsSaved agentId result ->
            case result of
                Ok _ ->
                    let
                        updateAgent agent =
                            if agent.id == agentId then
                                { agent | expanded = False }

                            else
                                agent
                    in
                    ( { model
                        | agents = List.map updateAgent model.agents
                        , isLoadingForAgent = Nothing
                        , error = Nothing
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model
                        | error = Just "Failed to save agent details"
                        , isLoadingForAgent = Nothing
                      }
                    , Cmd.none
                    )

        AgentDeleted result ->
            case result of
                Ok _ ->
                    ( { model | isLoading = False, error = Nothing }
                    , fetchAgents
                    )

                Err _ ->
                    ( { model
                        | error = Just "Failed to delete agent -- cannot delete default agent or current user"
                        , isLoading = False
                      }
                    , Cmd.none
                    )

        DebounceSaveAgent agentId ->
            if agentId == "main" then
                -- Handle main agent save
                case model.currentUser of
                    Just user ->
                        let
                            agent =
                                { id = user.id
                                , firstName = user.firstName
                                , lastName = user.lastName
                                , email = user.email
                                , phone = user.phone
                                , carriers = []
                                , stateLicenses = []
                                , expanded = False
                                , calendarLink = ""
                                , signature = ""
                                }
                        in
                        ( { model | pendingSave = Nothing }
                        , saveAgentDetails agent
                        )

                    Nothing ->
                        ( model, Cmd.none )

            else
                -- Handle sub-agent save
                ( { model | pendingSave = Nothing }
                , case List.filter (\a -> a.id == agentId) model.agents of
                    agent :: _ ->
                        saveAgentDetails agent

                    [] ->
                        Cmd.none
                )

        EditAgent agent ->
            ( { model
                | agents =
                    List.map
                        (\a ->
                            if a.id == agent.id then
                                { a | expanded = not a.expanded }

                            else
                                a
                        )
                        model.agents
              }
            , Cmd.none
            )

        GotEmailResponse result ->
            case result of
                Ok response ->
                    ( { model
                        | emailStatus =
                            if response.available then
                                Valid

                            else
                                Invalid response.message
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model
                        | emailStatus = Invalid "Failed to check email availability"
                      }
                    , Cmd.none
                    )

        UpdateAgentField agentId field value ->
            let
                updateAgent agent =
                    if agent.id == agentId then
                        case field of
                            "firstName" ->
                                { agent | firstName = value }

                            "lastName" ->
                                { agent | lastName = value }

                            "phone" ->
                                { agent | phone = formatPhoneNumber (String.filter Char.isDigit value) }

                            "calendarLink" ->
                                { agent | calendarLink = value }

                            "signature" ->
                                { agent | signature = value }

                            _ ->
                                agent

                    else
                        agent
            in
            ( { model
                | agents = List.map updateAgent model.agents
                , pendingSave = Just agentId
              }
            , Cmd.none
            )

        SetDefaultAgent agentId ->
            ( { model
                | defaultAgentId = Just agentId
                , isLoading = True
              }
            , Http.request
                { method = "POST"
                , url = "/api/agents/set_default_agent"
                , body = Http.jsonBody (Encode.object [ ( "agentId", Encode.string agentId ) ])
                , expect = Http.expectWhatever SetDefaultAgentResult
                , timeout = Nothing
                , tracker = Nothing
                , headers = []
                }
            )

        SetDefaultAgentResult result ->
            case result of
                Ok _ ->
                    ( { model | isLoading = False }, fetchAgents )

                Err _ ->
                    ( { model | isLoading = False, error = Just "Failed to set default agent" }, Cmd.none )

        CopyAgentSelfOnboardingLink agentId ->
            let
                agentSelfOnboardingUrl =
                    "https://" ++ "medicaremax.ai/self-onboarding/" ++ model.orgSlug ++ "?agentId=" ++ agentId
            in
            ( { model
                | copiedAgentLinks = List.filter ((/=) agentId) model.copiedAgentLinks
                , currentlyCopyingAgent = Just agentId
              }
            , Ports.copyToClipboard agentSelfOnboardingUrl
            )

        LinkCopied success ->
            case model.currentlyCopyingAgent of
                Just agentId ->
                    if success then
                        ( { model
                            | copiedAgentLinks = agentId :: model.copiedAgentLinks
                            , currentlyCopyingAgent = Nothing
                          }
                        , Cmd.none
                        )

                    else
                        ( { model
                            | error = Just "Failed to copy link to clipboard"
                            , currentlyCopyingAgent = Nothing
                          }
                        , Cmd.none
                        )

                Nothing ->
                    ( model, Cmd.none )



-- Helper functions


formatPhoneNumber : String -> String
formatPhoneNumber rawPhone =
    let
        digits =
            String.filter Char.isDigit rawPhone
                |> String.left 10

        len =
            String.length digits
    in
    if len == 0 then
        ""

    else if len <= 3 then
        "(" ++ digits

    else if len <= 6 then
        "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

    else
        "("
            ++ String.left 3 digits
            ++ ") "
            ++ String.slice 3 6 digits
            ++ "-"
            ++ String.dropLeft 6 digits


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        timeSub =
            case model.pendingSave of
                Just agentId ->
                    Time.every 2000 (\_ -> DebounceSaveAgent agentId)

                Nothing ->
                    Sub.none

        copyResultSub =
            Ports.onCopyResult LinkCopied
    in
    Sub.batch [ timeSub, copyResultSub ]


isValidEmail : String -> Bool
isValidEmail email =
    let
        containsAtSign =
            String.contains "@" email

        containsDot =
            String.contains "." email

        hasValidLength =
            String.length email >= 5
    in
    containsAtSign && containsDot && hasValidLength


isValidPhone : String -> Bool
isValidPhone phone =
    let
        -- Remove all non-digit characters
        digits =
            String.filter Char.isDigit phone
    in
    String.length digits == 10


fetchAgents : Cmd Msg
fetchAgents =
    Http.get
        { url = "/api/agents"
        , expect =
            Http.expectStringResponse GotAgents
                (\response ->
                    case response of
                        Http.BadUrl_ url ->
                            Err (Http.BadUrl url)

                        Http.Timeout_ ->
                            Err Http.Timeout

                        Http.NetworkError_ ->
                            Err Http.NetworkError

                        Http.BadStatus_ metadata body ->
                            Err (Http.BadStatus metadata.statusCode)

                        Http.GoodStatus_ metadata body ->
                            case Decode.decodeString agentsResponseDecoder body of
                                Ok value ->
                                    Ok value

                                Err err ->
                                    Err (Http.BadBody (Decode.errorToString err))
                )
        }


agentsResponseDecoder : Decoder AgentsResponse
agentsResponseDecoder =
    Decode.map2 AgentsResponse
        (Decode.field "agents" (Decode.list agentDecoder))
        (Decode.field "defaultAgentId" (Decode.nullable Decode.string))


agentDecoder : Decoder Agent
agentDecoder =
    Decode.succeed Agent
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "firstName" Decode.string
        |> Pipeline.required "lastName" Decode.string
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "phone" Decode.string
        |> Pipeline.required "carriers" (Decode.list Decode.string)
        |> Pipeline.required "stateLicenses" (Decode.list Decode.string)
        |> Pipeline.hardcoded False
        |> Pipeline.optional "bookingLink" Decode.string ""
        |> Pipeline.optional "signature" Decode.string ""


encodeAgent : Agent -> Encode.Value
encodeAgent agent =
    Encode.object
        [ ( "firstName", Encode.string agent.firstName )
        , ( "lastName", Encode.string agent.lastName )
        , ( "email", Encode.string agent.email )
        , ( "phone", Encode.string agent.phone )
        , ( "carriers", Encode.list Encode.string agent.carriers )
        , ( "stateLicenses", Encode.list Encode.string agent.stateLicenses )
        , ( "bookingLink", Encode.string agent.calendarLink )
        , ( "signature", Encode.string agent.signature )
        ]


isAdminBecomingAgent : Model -> Bool
isAdminBecomingAgent model =
    False



-- This check is no longer needed since all users are both admin and agent


fetchCurrentUser : Cmd Msg
fetchCurrentUser =
    Http.get
        { url = "/api/me"
        , expect = Http.expectJson GotCurrentUser currentUserResponseDecoder
        }


currentUserResponseDecoder : Decoder CurrentUserResponse
currentUserResponseDecoder =
    Decode.map2 CurrentUserResponse
        (Decode.field "success" Decode.bool)
        (Decode.maybe (Decode.field "user" userDecoder))


userDecoder : Decoder User
userDecoder =
    let
        idDecoder =
            Decode.oneOf
                [ Decode.field "id" Decode.string
                , Decode.field "id" (Decode.map String.fromInt Decode.int)
                ]
    in
    Decode.map6 User
        idDecoder
        (Decode.field "email" Decode.string)
        (Decode.field "firstName" Decode.string)
        (Decode.field "lastName" Decode.string)
        (Decode.oneOf
            [ Decode.field "phone" Decode.string
            , Decode.succeed ""
            ]
        )
        (Decode.field "org_slug" Decode.string)


saveAgentDetails : Agent -> Cmd Msg
saveAgentDetails agent =
    Http.request
        { method = "PUT"
        , headers = []
        , url = "/api/agents/" ++ agent.id
        , body = Http.jsonBody (encodeAgent agent)
        , expect = Http.expectWhatever (AgentDetailsSaved agent.id)
        , timeout = Nothing
        , tracker = Nothing
        }


isCurrentUser : Agent -> Model -> Bool
isCurrentUser agent model =
    case model.currentUser of
        Just user ->
            user.id == agent.id

        Nothing ->
            False


canModifySettings : Model -> String -> Bool
canModifySettings model agentId =
    case model.currentUser of
        Just user ->
            True

        -- All users can modify settings now
        Nothing ->
            False


deleteAgent : String -> Maybe String -> Cmd Msg
deleteAgent agentId maybeReassignToAgentId =
    let
        url =
            case maybeReassignToAgentId of
                Just reassignToAgentId ->
                    "/api/agents/" ++ agentId ++ "?reassignTo=" ++ reassignToAgentId

                Nothing ->
                    "/api/agents/" ++ agentId
    in
    Http.request
        { method = "DELETE"
        , headers = []
        , url = url
        , body = Http.emptyBody
        , expect = Http.expectWhatever AgentDeleted
        , timeout = Nothing
        , tracker = Nothing
        }


viewDeleteConfirmationModal : Model -> Html Msg
viewDeleteConfirmationModal model =
    case model.showDeleteConfirm of
        Just agentId ->
            let
                targetAgent =
                    List.filter (\a -> a.id == agentId) model.agents
                        |> List.head

                otherAgents =
                    List.filter (\a -> a.id /= agentId) model.agents

                agentName =
                    case targetAgent of
                        Just agent ->
                            agent.firstName ++ " " ++ agent.lastName

                        Nothing ->
                            "this agent"

                errorMessageBlock =
                    if model.error /= Nothing && model.showDeleteConfirm /= Nothing then
                        div [ class "mb-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded" ]
                            [ text (Maybe.withDefault "" model.error) ]

                    else
                        text ""
            in
            div [ class "fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center p-4 z-50" ]
                [ div [ class "bg-white rounded-lg max-w-lg w-full p-6" ]
                    [ h3 [ class "text-lg font-medium text-gray-900 mb-4" ]
                        [ text ("Delete " ++ agentName ++ "?") ]
                    , p [ class "text-sm text-gray-500 mb-4" ]
                        [ text "This will permanently remove this agent from your organization and cannot be undone." ]
                    , errorMessageBlock
                    , if not (List.isEmpty model.contacts) then
                        div [ class "mb-6" ]
                            [ p [ class "text-sm text-gray-500 mb-2" ]
                                [ text "This agent has contacts assigned to them. What would you like to do with these contacts?" ]
                            , div [ class "mt-4" ]
                                [ select
                                    [ class "mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                                    , onInput
                                        (\val ->
                                            if val == "" then
                                                NoOp

                                            else
                                                ConfirmDeleteAgent agentId (Just val)
                                        )
                                    ]
                                    (option [ value "" ] [ text "Select an agent to reassign contacts" ]
                                        :: List.map
                                            (\agent ->
                                                option [ value agent.id ]
                                                    [ text (agent.firstName ++ " " ++ agent.lastName) ]
                                            )
                                            otherAgents
                                    )
                                ]
                            ]

                      else
                        text ""
                    , div [ class "flex justify-end space-x-3" ]
                        [ button
                            [ class "px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
                            , onClick (ConfirmDeleteAgent agentId Nothing)
                            ]
                            [ text "Delete Without Reassigning" ]
                        , button
                            [ class "px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700"
                            , onClick (ConfirmDeleteAgent agentId model.reassignAgentId)
                            ]
                            [ text "Delete" ]
                        , button
                            [ class "px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
                            , onClick CloseDeleteConfirmModal
                            ]
                            [ text "Cancel" ]
                        ]
                    ]
                ]

        Nothing ->
            text ""


viewEmailStatus : EmailStatus -> Html Msg
viewEmailStatus status =
    div [ class "mt-1 transition-all duration-200" ]
        [ case status of
            NotChecked ->
                text ""

            Checking ->
                div [ class "text-blue-600 text-sm flex items-center" ]
                    [ div [ class "animate-spin h-4 w-4 mr-2 border-2 border-blue-600 border-t-transparent rounded-full" ] []
                    , text "Checking availability..."
                    ]

            Valid ->
                div [ class "text-green-600 text-sm flex items-center" ]
                    [ -- Checkmark icon
                      svg
                        [ Svg.Attributes.class "h-4 w-4 mr-1"
                        , Svg.Attributes.fill "none"
                        , Svg.Attributes.viewBox "0 0 24 24"
                        , Svg.Attributes.stroke "currentColor"
                        ]
                        [ path
                            [ Svg.Attributes.strokeLinecap "round"
                            , Svg.Attributes.strokeLinejoin "round"
                            , Svg.Attributes.strokeWidth "2"
                            , Svg.Attributes.d "M5 13l4 4L19 7"
                            ]
                            []
                        ]
                    , text "Email is available"
                    ]

            Invalid message ->
                div [ class "text-red-600 text-sm flex items-center" ]
                    [ -- X icon
                      svg
                        [ Svg.Attributes.class "h-4 w-4 mr-1"
                        , Svg.Attributes.fill "none"
                        , Svg.Attributes.viewBox "0 0 24 24"
                        , Svg.Attributes.stroke "currentColor"
                        ]
                        [ path
                            [ Svg.Attributes.strokeLinecap "round"
                            , Svg.Attributes.strokeLinejoin "round"
                            , Svg.Attributes.strokeWidth "2"
                            , Svg.Attributes.d "M6 18L18 6M6 6l12 12"
                            ]
                            []
                        ]
                    , text message
                    ]
        ]


checkAgentEmail : String -> Cmd Msg
checkAgentEmail email =
    Http.get
        { url = "/api/organizations/check-email/" ++ Url.percentEncode email
        , expect = Http.expectJson GotEmailResponse emailResponseDecoder
        }


emailResponseDecoder : Decode.Decoder EmailResponse
emailResponseDecoder =
    Decode.map2 EmailResponse
        (Decode.field "available" Decode.bool)
        (Decode.field "message" Decode.string)


isFormValid : Model -> Bool
isFormValid model =
    let
        isEmailValid =
            model.emailStatus == Valid

        areNamesValid =
            not (String.isEmpty (String.trim model.firstName))
                && not (String.isEmpty (String.trim model.lastName))

        isPhoneValid =
            not (String.isEmpty (String.trim model.displayPhone))
    in
    isEmailValid && areNamesValid && isPhoneValid


submitNewAgent : Model -> Cmd Msg
submitNewAgent model =
    Http.post
        { url = "/api/agents/create"
        , body =
            Http.jsonBody
                (Encode.object
                    [ ( "firstName", Encode.string model.firstName )
                    , ( "lastName", Encode.string model.lastName )
                    , ( "email", Encode.string model.email )
                    , ( "phone", Encode.string model.rawPhone )
                    , ( "carriers", Encode.list Encode.string model.carriers )
                    , ( "stateLicenses", Encode.list Encode.string model.stateLicenses )
                    ]
                )
        , expect = Http.expectWhatever AgentSaved
        }

================
File: frontend/src/AgeCalc.elm
================
module AgeCalc exposing (getAgeNextMonth)

import Date exposing (Date, Interval(..), Unit(..), add, fromIsoString, toIsoString)
import Time exposing (Month(..))


getAgeNextMonth : String -> Date -> Int
getAgeNextMonth birthDateStr currentDate =
    case fromIsoString birthDateStr of
        Ok birthDate ->
            let
                -- Get first of next month
                nextMonth =
                    currentDate
                        |> add Months 1
                        |> Date.floor Month

                -- Calculate years between birth date and first of next month
                years =
                    Date.diff Years birthDate nextMonth
            in
            years

        Err _ ->
            0

================
File: frontend/src/BirthdayRules.elm
================
module BirthdayRules exposing
    ( BirthdayRuleType(..)
    , StateRule
    , canPresentDifferentPlanOnly
    , getDelayedEmailDate
    , getStateRule
    , isInBirthdayRuleWindow
    , isInContinuousOpenEnrollment
    )

{-| This module handles birthday rules for different states.
It provides functionality to check if a contact is in a birthday rule window,
if they are in a continuous open enrollment state, and if they can only be
presented with different plan types during their birthday window.
-}

import Date exposing (Date)
import Time exposing (Month(..))


{-| Represents the type of birthday rule for a state.
-}
type BirthdayRuleType
    = BirthdayRule
    | AnniversaryRule
    | ContinuousOpenEnrollment
    | NoSpecialRule


{-| Represents a state's birthday rule configuration.
-}
type alias StateRule =
    { state : String
    , ruleType : BirthdayRuleType
    , daysBeforeBirthday : Int
    , totalDays : Int
    , canPresentDifferentPlan : Bool
    , notes : String
    }


{-| List of states with their birthday rules.
-}
stateRules : List StateRule
stateRules =
    [ { state = "CA"
      , ruleType = BirthdayRule
      , daysBeforeBirthday = 30
      , totalDays = 60
      , canPresentDifferentPlan = False
      , notes = "60-day period starting 30 days before your birthday"
      }
    , { state = "ID"
      , ruleType = BirthdayRule
      , daysBeforeBirthday = 0
      , totalDays = 63
      , canPresentDifferentPlan = False
      , notes = "63-day period starting on your birthday"
      }
    , { state = "IL"
      , ruleType = BirthdayRule
      , daysBeforeBirthday = 0
      , totalDays = 45
      , canPresentDifferentPlan = False
      , notes = "45-day period starting on your birthday; 76+ no special GI right"
      }
    , { state = "KY"
      , ruleType = BirthdayRule
      , daysBeforeBirthday = 0
      , totalDays = 60
      , canPresentDifferentPlan = True
      , notes = "60-day period following your birthday; Can switch sideways and get GI right; Only present different plans."
      }
    , { state = "LA"
      , ruleType = BirthdayRule
      , daysBeforeBirthday = 30
      , totalDays = 93
      , canPresentDifferentPlan = False
      , notes = "93-day period starting 30 days before your birthday"
      }
    , { state = "MD"
      , ruleType = BirthdayRule
      , daysBeforeBirthday = 0
      , totalDays = 31
      , canPresentDifferentPlan = False
      , notes = "31-day period starting on your birthday"
      }
    , { state = "NV"
      , ruleType = BirthdayRule
      , daysBeforeBirthday = 0
      , totalDays = 60
      , canPresentDifferentPlan = False
      , notes = "60-day period starting on the first day of your birth month"
      }
    , { state = "OK"
      , ruleType = BirthdayRule
      , daysBeforeBirthday = 0
      , totalDays = 60
      , canPresentDifferentPlan = False
      , notes = "60-day period starting on your birthday"
      }
    , { state = "OR"
      , ruleType = BirthdayRule
      , daysBeforeBirthday = 0
      , totalDays = 31
      , canPresentDifferentPlan = False
      , notes = "31-day period starting on your birthday"
      }
    , { state = "MO"
      , ruleType = AnniversaryRule
      , daysBeforeBirthday = 30
      , totalDays = 63
      , canPresentDifferentPlan = True
      , notes = "63-day period starting 30 days before your policy anniversary date; Can switch sideways and get GI right; Only present different plans."
      }
    , { state = "CT"
      , ruleType = ContinuousOpenEnrollment
      , daysBeforeBirthday = 0
      , totalDays = 0
      , canPresentDifferentPlan = False
      , notes = "Continuous"
      }
    , { state = "MA"
      , ruleType = ContinuousOpenEnrollment
      , daysBeforeBirthday = 0
      , totalDays = 0
      , canPresentDifferentPlan = False
      , notes = "Continuous"
      }
    , { state = "NY"
      , ruleType = ContinuousOpenEnrollment
      , daysBeforeBirthday = 0
      , totalDays = 0
      , canPresentDifferentPlan = False
      , notes = "Continuous"
      }
    , { state = "WA"
      , ruleType = ContinuousOpenEnrollment
      , daysBeforeBirthday = 0
      , totalDays = 0
      , canPresentDifferentPlan = False
      , notes = "Continuous"
      }
    ]


{-| Get the birthday rule for a specific state.
-}
getStateRule : String -> Maybe StateRule
getStateRule state =
    let
        normalizedState =
            String.toUpper state
    in
    List.filter (\rule -> rule.state == normalizedState) stateRules
        |> List.head


{-| Check if a state has continuous open enrollment.
-}
isInContinuousOpenEnrollment : String -> Bool
isInContinuousOpenEnrollment state =
    case getStateRule state of
        Just rule ->
            rule.ruleType == ContinuousOpenEnrollment

        Nothing ->
            False


{-| Check if a contact can only be presented with different plan types during their birthday window.
-}
canPresentDifferentPlanOnly : String -> Bool
canPresentDifferentPlanOnly state =
    case getStateRule state of
        Just rule ->
            rule.canPresentDifferentPlan

        Nothing ->
            False


{-| Calculate the start date of a birthday rule window.
-}
getBirthdayRuleStartDate : StateRule -> Date -> Date
getBirthdayRuleStartDate rule birthDate =
    let
        currentYear =
            Date.year (Date.fromCalendarDate 2024 Jan 1)

        -- This is just a placeholder, will be replaced with actual current date
        -- For Nevada, the window starts on the first day of the birth month
        startDate =
            if rule.state == "NV" then
                Date.fromCalendarDate currentYear (Date.month birthDate) 1

            else
                -- For other states, subtract the days before birthday from the birthday
                Date.add Date.Days -rule.daysBeforeBirthday (Date.fromCalendarDate currentYear (Date.month birthDate) (Date.day birthDate))
    in
    startDate


{-| Calculate the end date of a birthday rule window.
-}
getBirthdayRuleEndDate : StateRule -> Date -> Date
getBirthdayRuleEndDate rule birthDate =
    let
        startDate =
            getBirthdayRuleStartDate rule birthDate
    in
    Date.add Date.Days rule.totalDays startDate


{-| Check if a date is within a birthday rule window.
For Anniversary rules (Missouri), pass the effectiveDate as the second parameter.
For Birthday rules, pass the birthDate as the second parameter.
-}
isInBirthdayRuleWindow : String -> Date -> Date -> Bool
isInBirthdayRuleWindow state baseDate currentDate =
    case getStateRule state of
        Just rule ->
            let
                currentYear =
                    Date.year currentDate

                -- Adjust base date to current year
                adjustedBaseDate =
                    Date.fromCalendarDate currentYear (Date.month baseDate) (Date.day baseDate)

                startDate =
                    getBirthdayRuleStartDate rule adjustedBaseDate

                endDate =
                    getBirthdayRuleEndDate rule adjustedBaseDate
            in
            -- Only check window for Birthday and Anniversary rules
            case rule.ruleType of
                BirthdayRule ->
                    Date.compare currentDate startDate /= LT && Date.compare currentDate endDate /= GT

                AnniversaryRule ->
                    Date.compare currentDate startDate /= LT && Date.compare currentDate endDate /= GT

                ContinuousOpenEnrollment ->
                    -- For continuous open enrollment states, they're always in an "open enrollment window"
                    True

                NoSpecialRule ->
                    False

        Nothing ->
            False


{-| Calculate the date when an email should be sent after a birthday rule window.
For Anniversary rules (Missouri), pass the effectiveDate as the second parameter.
For Birthday rules, pass the birthDate as the second parameter.
The third parameter should be the scheduled date that needs to be delayed.
-}
getDelayedEmailDate : String -> Date -> Date -> Date
getDelayedEmailDate state baseDate scheduledDate =
    case getStateRule state of
        Just rule ->
            let
                -- Use the year from the scheduled date
                scheduledYear =
                    Date.year scheduledDate

                -- Adjust base date to scheduled year
                adjustedBaseDate =
                    Date.fromCalendarDate scheduledYear (Date.month baseDate) (Date.day baseDate)

                -- For Nevada, the window starts on the first day of the birth month
                windowStartDate =
                    if rule.state == "NV" then
                        Date.fromCalendarDate scheduledYear (Date.month baseDate) 1

                    else
                        -- For other states, subtract the days before birthday from the birthday
                        Date.add Date.Days -rule.daysBeforeBirthday adjustedBaseDate

                -- Calculate the end date of the window
                windowEndDate =
                    Date.add Date.Days rule.totalDays windowStartDate

                -- Add one month to the end date
                delayedDate =
                    Date.add Date.Months 1 windowEndDate
            in
            delayedDate

        Nothing ->
            -- If no rule exists, just return the scheduled date
            scheduledDate

================
File: frontend/src/Calculator.elm
================
module Calculator exposing (main)

import Browser
import Html exposing (Html, div, h3, input, li, p, text, ul)
import Html.Attributes exposing (max, min, step, type_, value)
import Html.Events exposing (onInput)



-- Model Definition


type alias Model =
    { totalContacts : String -- Total book of business size as string input
    , yearWeights : List Float -- Weights for distribution over 6 years
    , responseRate : String -- Response rate as percentage (e.g., "5" for 5%)
    }



-- Initial State


init : Model
init =
    { totalContacts = ""
    , yearWeights = [ 10.0, 20.0, 30.0, 40.0, 50.0, 60.0 ] -- Initial weights, heavier toward recent years
    , responseRate = "5" -- Default response rate of 5%
    }



-- Messages


type Msg
    = SetTotalContacts String -- Update total contacts
    | SetYearWeight Int String -- Update weight for a specific year (index, value)
    | SetResponseRate String -- Update response rate



-- Update Function


update : Msg -> Model -> Model
update msg model =
    case msg of
        SetTotalContacts s ->
            { model | totalContacts = s }

        SetYearWeight i s ->
            case String.toFloat s of
                Just f ->
                    let
                        yearWeights =
                            List.indexedMap
                                (\j w ->
                                    if j == i then
                                        f

                                    else
                                        w
                                )
                                model.yearWeights
                    in
                    { model | yearWeights = yearWeights }

                Nothing ->
                    model

        -- Ignore invalid slider input (shouldn’t happen with range)
        SetResponseRate s ->
            { model | responseRate = s }



-- View Function


view : Model -> Html Msg
view model =
    div []
        [ -- Input for Total Contacts
          p [] [ text "Total Book of Business Size:" ]
        , input [ type_ "text", value model.totalContacts, onInput SetTotalContacts ] []

        -- Sliders for Year Distribution
        , h3 [] [ text "Adjust Distribution Over Years:" ]
        , div []
            (List.indexedMap
                (\i weight ->
                    div []
                        [ text ("Policies started " ++ String.fromInt (5 - i) ++ " years ago: ")
                        , input
                            [ type_ "range"
                            , min "0"
                            , max "100"
                            , step "1"
                            , value (String.fromFloat weight)
                            , onInput (SetYearWeight i)
                            ]
                            []
                        ]
                )
                model.yearWeights
            )

        -- Input for Response Rate
        , p [] [ text "Response Rate (%):" ]
        , input [ type_ "text", value model.responseRate, onInput SetResponseRate ] []

        -- Calculated Outputs
        , case ( String.toFloat model.totalContacts, String.toFloat model.responseRate ) of
            ( Ok n, Ok r ) ->
                let
                    -- Distribution Calculation
                    sumWeights =
                        List.sum model.yearWeights

                    contactsPerYear =
                        if sumWeights > 0 then
                            List.map (\w -> (w / sumWeights) * n) model.yearWeights

                        else
                            List.repeat 6 0.0

                    -- Core Calculations
                    weeklyCalls =
                        (n / 52) * (r / 100)

                    -- Calls based on one event per contact per year
                    monthlyCost =
                        (n / 10000) * 100

                    -- $100 per 10,000 contacts
                    annualCost =
                        12 * monthlyCost

                    -- Yearly cost
                    totalCallsPerYear =
                        n * (r / 100)

                    -- Total calls in a year
                    numberOfSales =
                        totalCallsPerYear * 0.5

                    -- 50% close rate
                    totalRevenue =
                        numberOfSales * 500

                    -- $500 increased LTV
                    roi =
                        if annualCost > 0 then
                            ((totalRevenue - annualCost) / annualCost) * 100
                            -- ROI as percentage

                        else
                            0
                in
                div []
                    [ -- Distribution Display (Placeholder for Chart)
                      h3 [] [ text "Distribution of Contacts:" ]
                    , ul []
                        (List.indexedMap
                            (\i c ->
                                li [] [ text ("Year -" ++ String.fromInt (5 - i) ++ ": " ++ String.fromFloat c ++ " contacts") ]
                            )
                            contactsPerYear
                        )

                    -- Calculated Metrics
                    , h3 [] [ text "Results:" ]
                    , p [] [ text ("Weekly Calls: " ++ String.fromFloat weeklyCalls) ]
                    , p [] [ text ("Monthly Cost: $" ++ String.fromFloat monthlyCost) ]
                    , p [] [ text ("Annual Cost: $" ++ String.fromFloat annualCost) ]
                    , p [] [ text ("Total Calls per Year: " ++ String.fromFloat totalCallsPerYear) ]
                    , p [] [ text ("Number of Sales: " ++ String.fromFloat numberOfSales) ]
                    , p [] [ text ("Total Revenue: $" ++ String.fromFloat totalRevenue) ]
                    , p [] [ text ("ROI: " ++ String.fromFloat roi ++ "%") ]
                    ]

            _ ->
                p [] [ text "Please enter valid numbers for total contacts and response rate." ]
        ]



-- Main Program


main : Program () Model Msg
main =
    Browser.sandbox { init = init, update = update, view = view }

================
File: frontend/src/CarrierNaic.elm
================
module CarrierNaic exposing
    ( Carrier(..)
    , allCarriers
    , carrierDecoder
    , carrierToNaics
    , carrierToString
    , naicToCarrier
    , stringToCarrier
    )

import Json.Decode as Decode exposing (Decoder)


type Carrier
    = Aetna
    | Humana
    | UnitedHealthcare
    | Cigna
    | Aflac
    | Allstate
    | MutualOfOmaha
    | AceChubb


allCarriers : List Carrier
allCarriers =
    [ Aetna
    , Humana
    , UnitedHealthcare
    , Cigna
    , Aflac
    , Allstate
    , MutualOfOmaha
    , AceChubb
    ]


carrierToString : Carrier -> String
carrierToString carrier =
    case carrier of
        Aetna ->
            "Aetna"

        Humana ->
            "Humana"

        UnitedHealthcare ->
            "UnitedHealthcare"

        Cigna ->
            "Cigna"

        Aflac ->
            "Aflac"

        Allstate ->
            "Allstate"

        MutualOfOmaha ->
            "Mutual of Omaha"

        AceChubb ->
            "Ace Chubb"


stringToCarrier : String -> Maybe Carrier
stringToCarrier str =
    case String.toLower str of
        "aetna" ->
            Just Aetna

        "humana" ->
            Just Humana

        "unitedhealthcare" ->
            Just UnitedHealthcare

        "uhc" ->
            Just UnitedHealthcare

        "united healthcare" ->
            Just UnitedHealthcare

        "cigna" ->
            Just Cigna

        "aflac" ->
            Just Aflac

        "allstate" ->
            Just Allstate

        "mutual of omaha" ->
            Just MutualOfOmaha

        "ace chubb" ->
            Just AceChubb

        "ace" ->
            Just AceChubb

        "chubb" ->
            Just AceChubb

        _ ->
            Nothing


carrierToNaics : Carrier -> List String
carrierToNaics carrier =
    case carrier of
        Aetna ->
            [ "72052" -- Aetna Hlth Ins Co
            , "78700" -- Aetna Hlth & Life Ins Co
            , "68500" -- Continental Life Ins Co Brentwood
            ]

        Humana ->
            [ "12634" -- Humana Ins Co of NY
            , "60052" -- Humana Insurance Company -- Achieve in CA, NJ, SC
            , "60219" -- Humana Insurance Company -- Achieve in PA, TX
            , "60984" -- Humana Insurance Company -- Achieve in many states
            , "69671" -- Humana Insurance Company
            , "70580" -- Humana Insurance Company -- Value in AR, ID, MT, NJ
            , "73288" -- Humana Ins Co -- Achieve in GA
            , "88595" -- Humana Insurance Company -- Achieve in DE, MT, NH, SD, WY, WI
            , "95158" -- Humana Insurance Company
            ]

        UnitedHealthcare ->
            [ "60093" -- United Hlthcare Ins Co Of NY
            , "79413" -- UnitedHealthcare Ins Co
            ]

        Cigna ->
            [ "61727" -- Cigna National Health Ins Co
            , "65269" -- Cigna Ins Co
            , "65722" -- Loyal Amer Life Ins Co (CIGNA)
            , "67369" -- Cigna Hlth & Life Ins Co
            , "88366" -- American Retirement Life Ins Co (CIGNA)
            ]

        Aflac ->
            [ "60380" -- AFLAC
            ]

        Allstate ->
            [ "60534" -- Allstate Health Solutions (AHL)
            , "82538" -- Allstate Health Solutions
            ]

        MutualOfOmaha ->
            [ "13100" -- Omaha Ins Co
            , "71412" -- Mutual Of Omaha Ins Co
            , "72850" -- United World Life Ins Co
            ]

        AceChubb ->
            [ "20699" -- Ace Prop & Cas Ins Co
            ]


naicToCarrier : String -> Maybe Carrier
naicToCarrier naic =
    case naic of
        -- Aetna
        "72052" ->
            Just Aetna

        "78700" ->
            Just Aetna

        "68500" ->
            Just Aetna

        -- Humana
        "12634" ->
            Just Humana

        "60052" ->
            Just Humana

        "60219" ->
            Just Humana

        "60984" ->
            Just Humana

        "69671" ->
            Just Humana

        "70580" ->
            Just Humana

        "73288" ->
            Just Humana

        "88595" ->
            Just Humana

        "95158" ->
            Just Humana

        -- UnitedHealthcare
        "60093" ->
            Just UnitedHealthcare

        "79413" ->
            Just UnitedHealthcare

        -- Cigna
        "61727" ->
            Just Cigna

        "65269" ->
            Just Cigna

        "65722" ->
            Just Cigna

        "67369" ->
            Just Cigna

        "88366" ->
            Just Cigna

        -- Aflac
        "60380" ->
            Just Aflac

        -- Allstate
        "60534" ->
            Just Allstate

        "82538" ->
            Just Allstate

        -- Mutual of Omaha
        "13100" ->
            Just MutualOfOmaha

        "71412" ->
            Just MutualOfOmaha

        "72850" ->
            Just MutualOfOmaha

        -- Ace Chubb
        "20699" ->
            Just AceChubb

        _ ->
            Nothing


carrierDecoder : Decoder Carrier
carrierDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case stringToCarrier str of
                    Just carrier ->
                        Decode.succeed carrier

                    Nothing ->
                        Decode.fail "Invalid carrier"
            )

================
File: frontend/src/ChangePlan.elm
================
module ChangePlan exposing (Model, Msg, init, subscriptions, update, view)

import Browser exposing (Document)
import Browser.Navigation as Nav
import ChoosePlan
import Components.LimitBanner as LimitBanner
import Html exposing (Html, div, text)
import Html.Attributes exposing (class)
import Json.Decode as Decode


type alias Model =
    { choosePlanModel : ChoosePlan.Model
    , limitBanner : LimitBanner.Model
    }


type Msg
    = ChoosePlanMsg ChoosePlan.Msg
    | ChooseBannerMsg LimitBanner.Msg


init : { key : Nav.Key, session : String, orgSlug : String } -> ( Model, Cmd Msg )
init { key, session, orgSlug } =
    let
        ( choosePlanModel, choosePlanCmd ) =
            ChoosePlan.init orgSlug session key True

        ( limitBannerModel, limitBannerCmd ) =
            LimitBanner.init
    in
    ( { choosePlanModel = choosePlanModel
      , limitBanner = limitBannerModel
      }
    , Cmd.batch
        [ Cmd.map ChoosePlanMsg choosePlanCmd
        , Cmd.map ChooseBannerMsg limitBannerCmd
        ]
    )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        ChoosePlanMsg choosePlanMsg ->
            let
                ( updatedChoosePlanModel, choosePlanCmd ) =
                    ChoosePlan.update choosePlanMsg model.choosePlanModel
            in
            ( { model | choosePlanModel = updatedChoosePlanModel }
            , Cmd.map ChoosePlanMsg choosePlanCmd
            )

        ChooseBannerMsg chooseBannerMsg ->
            let
                ( updatedChooseBannerModel, chooseBannerCmd ) =
                    LimitBanner.update chooseBannerMsg model.limitBanner
            in
            ( { model | limitBanner = updatedChooseBannerModel }
            , Cmd.map ChooseBannerMsg chooseBannerCmd
            )


view : Model -> Document Msg
view model =
    { title = "Change Plan - Medicare Max"
    , body =
        [ LimitBanner.view model.limitBanner
            |> Html.map ChooseBannerMsg
        , ChoosePlan.viewChangePlan model.choosePlanModel
            |> Html.map ChoosePlanMsg
        ]
    }


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.map ChoosePlanMsg (ChoosePlan.subscriptions model.choosePlanModel)

================
File: frontend/src/chart-animations.ts
================
/**
 * Adds animation to charts
 * This module contains functions to animate different chart types
 */

/**
 * Configure animations for line charts
 * @param chart - The Chartist.js line chart instance
 */
export function setupLineChartAnimations(chart: any) {
  if (!chart || typeof chart.on !== 'function') {
    console.error('Invalid chart instance provided to setupLineChartAnimations');
    return;
  }

  // Define a simpler animation approach
  chart.on('draw', function(data: any) {
    if (!data || !data.element) return;

    try {
      if (data.type === 'line') {
        // Simple fade in and slide for lines
        data.element.animate({
          opacity: {
            begin: 0,
            dur: 1000,
            from: 0,
            to: 1,
            easing: 'ease'
          }
        });
      } else if (data.type === 'point') {
        // Simple fade in for points with slight delay based on index
        data.element.animate({
          opacity: {
            begin: data.index * 80,
            dur: 500,
            from: 0,
            to: 1,
            easing: 'ease'
          }
        });
      }
    } catch (error) {
      console.error('Error in line chart animation:', error);
    }
  });
}

/**
 * Configure animations for bar charts
 * @param chart - The Chartist.js bar chart instance
 */
export function setupBarChartAnimations(chart: any) {
  if (!chart || typeof chart.on !== 'function') {
    console.error('Invalid chart instance provided to setupBarChartAnimations');
    return;
  }

  // Apply animations on draw
  chart.on('draw', function(data: any) {
    if (!data || !data.element) return;
    
    try {
      if (data.type === 'bar') {
        // Animate the bar with a simple grow from bottom effect
        data.element.animate({
          opacity: {
            begin: data.index * 80,
            dur: 500,
            from: 0,
            to: 1,
            easing: 'ease'
          },
          y1: {
            begin: data.index * 80,
            dur: 500,
            from: data.y2,
            to: data.y1,
            easing: 'ease'
          }
        });
      } else if (data.type === 'label') {
        // Fade in labels
        data.element.animate({
          opacity: {
            begin: 0,
            dur: 400,
            from: 0,
            to: 1
          }
        });
      }
    } catch (error) {
      console.error('Error in bar chart animation:', error);
    }
  });
}

/**
 * Configure animations for funnel charts
 * @param element - The DOM element containing the funnel chart
 */
export function animateFunnelChart(element: HTMLElement) {
  // Select all bars in the funnel chart
  const bars = element.querySelectorAll<HTMLElement>('.funnel-bar');
  const labels = element.querySelectorAll<HTMLElement>('.funnel-bar-label');
  const values = element.querySelectorAll<HTMLElement>('.funnel-bar-value');
  
  // Animate each bar with proper staggering
  bars.forEach((bar: HTMLElement, index: number) => {
    const targetWidth = bar.getAttribute('data-original-width') || '0%';
    
    setTimeout(() => {
      bar.style.transition = 'width 0.8s cubic-bezier(0.22, 0.61, 0.36, 1), opacity 0.6s ease';
      bar.style.width = targetWidth;
      bar.style.opacity = '1';
    }, 150 * index);
  });
  
  // Animate labels with a slight delay after bars
  labels.forEach((label: HTMLElement, index: number) => {
    label.style.opacity = '0';
    label.style.transform = 'translateY(10px)';
    
    setTimeout(() => {
      label.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
      label.style.opacity = '1';
      label.style.transform = 'translateY(0)';
    }, 300 + 80 * index);
  });
  
  // Animate values with a slightly longer delay than labels
  values.forEach((value: HTMLElement, index: number) => {
    value.style.opacity = '0';
    value.style.transform = 'translateY(10px)';
    
    setTimeout(() => {
      value.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
      value.style.opacity = '1';
      value.style.transform = 'translateY(0)';
    }, 450 + 80 * index);
  });
  
  // Add a subtle pulse animation to the largest bar (last one)
  setTimeout(() => {
    if (bars.length > 0) {
      const largestBar = bars[bars.length - 1];
      largestBar.style.animation = 'pulse 2s infinite';
      
      // Add keyframes for pulse animation if not already present
      if (!document.querySelector('#pulse-animation')) {
        const style = document.createElement('style');
        style.id = 'pulse-animation';
        style.textContent = `
          @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(3, 4, 94, 0.4); }
            70% { box-shadow: 0 0 0 6px rgba(3, 4, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(3, 4, 94, 0); }
          }
        `;
        document.head.appendChild(style);
      }
    }
  }, 1500);
}

================
File: frontend/src/ChoosePlan.elm
================
port module ChoosePlan exposing (Model, Msg(..), init, subscriptions, update, view, viewChangePlan)

import Browser exposing (Document)
import Browser.Navigation as Nav
import Components.LimitBanner as LimitBanner exposing (LimitWarning(..))
import Components.SetupLayout as SetupLayout
import Html exposing (Html, button, div, h1, h2, h3, h4, input, label, li, node, p, span, text, ul)
import Html.Attributes exposing (attribute, class, disabled, type_, value)
import Html.Events exposing (onClick, onInput)
import Http
import Json.Decode as Decode exposing (Decoder, field, int, list, string)
import Json.Encode as Encode
import Svg exposing (path, svg)
import Svg.Attributes exposing (clipRule, d, fill, fillRule, viewBox)


type SetupStep
    = PlanSelection
    | Payment
    | Complete


type alias SubscriptionTier =
    { id : String
    , name : String
    , price : String
    , agentLimit : Int
    , contactLimit : Int
    , features : List String
    }


type alias CustomTierPricing =
    { price : String
    , agentLimit : Int
    , tierName : String
    , contactLimit : Int
    , features : List String
    }


type alias Model =
    { session : Maybe String
    , orgSlug : String
    , currentStep : SetupStep
    , selectedPlan : Maybe String
    , extraAgents : Int
    , extraContacts : Int
    , error : Maybe String
    , tiers : List SubscriptionTier
    , isLoading : Bool
    , key : Nav.Key
    , isProcessingPayment : Bool
    , showChangePlan : Bool
    , currentTier : Maybe String
    , currentAgentLimit : Int
    , currentContactLimit : Int
    , showTrialBanner : Bool
    , customContactCount : String
    , isLoadingCustomTier : Bool
    , customTierPricing : Maybe CustomTierPricing
    }


type Msg
    = NextStep
    | SelectPlan String
    | SubmitPayment
    | CompleteSetup
    | GotTiers (Result Http.Error (List SubscriptionTier))
    | SubscriptionSaved (Result Http.Error ())
    | NavigateToTempLanding
    | GotSaveResponse (Result Http.Error ())
    | SetExtraAgents String
    | SetExtraContacts String
    | StripeCheckoutReady (Result Http.Error String)
    | ProcessPayment
    | CancelPayment
    | GotCurrentSubscription (Result Http.Error { tierId : String, agentLimit : Int, contactLimit : Int })
    | ConfirmPlan
    | GotConfirmation (Result Http.Error { success : Bool, redirectUrl : String })
    | NoOp
    | NavigateTo String
    | CloseBanner
    | SetCustomContactCount String
    | CalculateCustomTier
    | GotCustomTierPricing (Result Http.Error CustomTierPricing)
    | SelectCustomTier
    | StripeTableSelection String


init : String -> String -> Nav.Key -> Bool -> ( Model, Cmd Msg )
init orgSlug session key showChangePlan =
    ( { session = Just session
      , orgSlug = orgSlug
      , currentStep = PlanSelection
      , selectedPlan = Nothing
      , extraAgents = 0
      , extraContacts = 0
      , error = Nothing
      , tiers = []
      , isLoading = True
      , key = key
      , isProcessingPayment = False
      , showChangePlan = showChangePlan
      , currentTier = Nothing
      , currentAgentLimit = 0
      , currentContactLimit = 0
      , showTrialBanner = True
      , customContactCount = ""
      , isLoadingCustomTier = False
      , customTierPricing = Nothing
      }
    , Cmd.batch
        [ fetchSubscriptionTiers
        , if showChangePlan then
            fetchCurrentSubscription orgSlug

          else
            Cmd.none
        ]
    )


fetchCurrentSubscription : String -> Cmd Msg
fetchCurrentSubscription orgSlug =
    let
        url =
            "/api/organizations/" ++ orgSlug ++ "/subscription"
    in
    Http.get
        { url = url
        , expect = Http.expectJson GotCurrentSubscription currentSubscriptionDecoder
        }


fetchSubscriptionTiers : Cmd Msg
fetchSubscriptionTiers =
    Http.get
        { url = "/api/organizations/subscription-tiers"
        , expect = Http.expectJson GotTiers subscriptionTiersDecoder
        }


saveSubscription : String -> String -> Int -> Int -> Cmd Msg
saveSubscription orgSlug tierId extraAgents extraContacts =
    let
        url =
            "/api/organizations/" ++ orgSlug ++ "/subscription"
    in
    Http.post
        { url = url
        , body = Http.jsonBody (encodeSubscriptionUpdate tierId extraAgents extraContacts)
        , expect = Http.expectWhatever SubscriptionSaved
        }


createStripeCheckoutSession : String -> String -> Int -> Int -> Cmd Msg
createStripeCheckoutSession orgSlug tierId extraAgents extraContacts =
    let
        url =
            "/api/stripe/create-checkout-session"
    in
    Http.post
        { url = url
        , body = Http.jsonBody (encodeStripeCheckoutRequest orgSlug tierId extraAgents extraContacts)
        , expect = Http.expectJson StripeCheckoutReady (field "sessionId" string)
        }


redirectToStripeCheckout : String -> Cmd Msg
redirectToStripeCheckout sessionId =
    -- Use the session ID to redirect to Stripe Checkout
    -- In a real implementation, this would likely be a port to JavaScript
    -- For this demo, we're just simulating with a navigation
    Nav.load ("/api/stripe/redirect-to-checkout?session_id=" ++ sessionId)


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SubscriptionSaved result ->
            case result of
                Ok _ ->
                    ( { model | error = Nothing }
                    , if model.showChangePlan then
                        -- For change plan, just reload the current page to show updated info
                        Nav.reload

                      else
                        -- For initial setup, continue to next step
                        case model.selectedPlan of
                            Just planId ->
                                Nav.pushUrl model.key ("/setup/settings?plan=" ++ planId)

                            Nothing ->
                                Nav.pushUrl model.key "/setup/settings"
                    )

                Err error ->
                    ( { model | error = Just "Failed to save subscription", isProcessingPayment = False }
                    , Cmd.none
                    )

        NextStep ->
            case model.currentStep of
                PlanSelection ->
                    case model.selectedPlan of
                        Just planId ->
                            if model.showChangePlan then
                                -- For change plan, we go directly to payment
                                ( { model | currentStep = Payment, isProcessingPayment = True }
                                , createStripeCheckoutSession model.orgSlug planId model.extraAgents model.extraContacts
                                )

                            else
                                -- For initial setup, save subscription then go to next page
                                ( { model | currentStep = Payment }
                                , saveSubscription model.orgSlug planId model.extraAgents model.extraContacts
                                )

                        Nothing ->
                            ( { model | error = Just "Please select a plan" }
                            , Cmd.none
                            )

                Payment ->
                    ( { model | currentStep = Complete }
                    , if model.showChangePlan then
                        Nav.pushUrl model.key "/dashboard"

                      else
                        Nav.pushUrl model.key "/templanding"
                    )

                Complete ->
                    ( model
                    , if model.showChangePlan then
                        Nav.pushUrl model.key "/dashboard"

                      else
                        Nav.pushUrl model.key "/templanding"
                    )

        SelectPlan plan ->
            ( { model | selectedPlan = Just plan }
            , Cmd.none
            )

        SetExtraAgents value ->
            let
                extraAgents =
                    String.toInt value |> Maybe.withDefault 0
            in
            ( { model | extraAgents = extraAgents }, Cmd.none )

        SetExtraContacts value ->
            let
                extraContacts =
                    String.toInt value |> Maybe.withDefault 0
            in
            ( { model | extraContacts = extraContacts }, Cmd.none )

        GotTiers result ->
            case result of
                Ok tiers ->
                    let
                        -- Look for Pro plans specifically
                        proPlans =
                            List.filter (\t -> t.id == "pro") tiers

                        -- Look for $99 Pro plan
                        proPlans99 =
                            List.filter (\t -> t.id == "pro" && t.price == "$99/mo") tiers

                        -- Apply filter
                        filteredTiers =
                            filterTiers tiers
                    in
                    ( { model
                        | tiers = filteredTiers
                        , isLoading = False
                      }
                    , Cmd.none
                    )

                Err error ->
                    let
                        errorString =
                            case error of
                                Http.BadUrl url ->
                                    "Bad URL: " ++ url

                                Http.Timeout ->
                                    "Request timed out"

                                Http.NetworkError ->
                                    "Network error"

                                Http.BadStatus statusCode ->
                                    "Bad status: " ++ String.fromInt statusCode

                                Http.BadBody message ->
                                    "Bad body: " ++ message
                    in
                    ( { model | error = Just "Failed to load subscription tiers", isLoading = False }
                    , Cmd.none
                    )

        GotCurrentSubscription result ->
            case result of
                Ok subscription ->
                    ( { model
                        | currentTier = Just subscription.tierId
                        , currentAgentLimit = subscription.agentLimit
                        , currentContactLimit = subscription.contactLimit
                        , isLoading = False
                      }
                    , Cmd.none
                    )

                Err error ->
                    -- Log the error in console using Debug.log
                    let
                        errorString =
                            case error of
                                Http.BadUrl url ->
                                    "Bad URL: " ++ url

                                Http.Timeout ->
                                    "Request timed out"

                                Http.NetworkError ->
                                    "Network error"

                                Http.BadStatus statusCode ->
                                    "Bad status: " ++ String.fromInt statusCode

                                Http.BadBody message ->
                                    "Bad body: " ++ message
                    in
                    ( { model | error = Just "Failed to load current subscription", isLoading = False }
                    , Cmd.none
                    )

        StripeCheckoutReady result ->
            case result of
                Ok sessionId ->
                    ( model
                    , redirectToStripeCheckout sessionId
                    )

                Err error ->
                    ( { model | error = Just "Failed to create payment session", isProcessingPayment = False }
                    , Cmd.none
                    )

        ProcessPayment ->
            case model.selectedPlan of
                Just planId ->
                    if model.showChangePlan && not (hasChanges model) then
                        -- No changes, show an error
                        ( { model | error = Just "No changes made to your subscription." }
                        , Cmd.none
                        )

                    else
                        -- Process payment for changes
                        ( { model | isProcessingPayment = True }
                        , createStripeCheckoutSession model.orgSlug planId model.extraAgents model.extraContacts
                        )

                Nothing ->
                    ( { model | error = Just "Please select a plan" }
                    , Cmd.none
                    )

        CancelPayment ->
            ( { model | isProcessingPayment = False }
            , Cmd.none
            )

        GotSaveResponse result ->
            case result of
                Ok _ ->
                    ( { model | error = Nothing }
                    , Nav.pushUrl model.key "/brand-settings"
                    )

                Err error ->
                    ( { model
                        | error = Just "Failed to save subscription. Please try again."
                        , isLoading = False
                      }
                    , Cmd.none
                    )

        ConfirmPlan ->
            let
                plan =
                    model.selectedPlan |> Maybe.withDefault "basic"
            in
            ( { model | isLoading = True }
            , Http.post
                { url = "/api/choose-plan"
                , body =
                    Http.jsonBody
                        (Encode.object
                            [ ( "plan", Encode.string plan )
                            , ( "orgSlug", Encode.string model.orgSlug )
                            ]
                        )
                , expect = Http.expectJson GotConfirmation confirmationDecoder
                }
            )

        GotConfirmation (Ok response) ->
            if response.success then
                ( model
                , Nav.pushUrl model.key response.redirectUrl
                )

            else
                ( { model | isLoading = False, error = Just "Failed to update plan. Please try again." }
                , Cmd.none
                )

        GotConfirmation (Err _) ->
            ( { model | isLoading = False, error = Just "Failed to connect to server. Please try again." }
            , Cmd.none
            )

        NavigateTo url ->
            ( model
            , Nav.pushUrl model.key url
            )

        CloseBanner ->
            ( { model | showTrialBanner = False }, Cmd.none )

        SetCustomContactCount value ->
            ( { model | customContactCount = value }, Cmd.none )

        CalculateCustomTier ->
            ( { model | isLoadingCustomTier = True }, calculateCustomTier model )

        GotCustomTierPricing result ->
            case result of
                Ok pricing ->
                    ( { model | customTierPricing = Just pricing, isLoadingCustomTier = False }, Cmd.none )

                Err error ->
                    ( { model | error = Just "Failed to calculate custom tier pricing", isLoadingCustomTier = False }, Cmd.none )

        SelectCustomTier ->
            ( model, selectCustomTier model )

        StripeTableSelection priceId ->
            ( { model | selectedPlan = Just priceId, error = Nothing }
            , Cmd.none
            )

        _ ->
            ( model, Cmd.none )


view : Model -> Browser.Document Msg
view model =
    { title =
        if model.showChangePlan then
            "Change Plan - Medicare Max"

        else
            "Choose Plan - Medicare Max"
    , body =
        [ if model.showTrialBanner then
            getPlanLimitBanner model

          else
            text ""
        , if model.showChangePlan then
            -- Change Plan is not part of setup flow, but a standalone page
            -- Return just the content portion which will be wrapped by Main.elm
            viewChangePlan model

          else
            -- This is the setup flow which uses a different layout
            SetupLayout.view SetupLayout.PlanSelection
                -- For plan selection, we determine basic vs pro based on what the user has selected
                (case model.selectedPlan of
                    Just "basic" ->
                        True

                    _ ->
                        False
                )
                0
                -- Using 0 for PlanSelection as it's the first step
                [ if model.isLoading then
                    viewLoading

                  else
                    viewPlanSelection model
                ]
        ]
    }


viewChangePlan : Model -> Html Msg
viewChangePlan model =
    div [ class "container mx-auto py-8 px-4" ]
        [ div [ class "space-y-8" ]
            [ div [ class "mb-8" ]
                [ h1 [ class "text-2xl font-semibold text-gray-900" ]
                    [ text "Change Your Plan" ]
                , p [ class "text-gray-600 mt-2" ]
                    [ text "Modify your subscription to better fit your organization's needs" ]
                ]
            , case model.currentTier of
                Just currentTierId ->
                    div [ class "p-4 bg-blue-50 rounded-lg border border-blue-200 mb-8" ]
                        [ h3 [ class "text-lg font-semibold text-gray-900" ]
                            [ text "Current Plan" ]
                        , p [ class "text-sm text-gray-600" ]
                            [ text
                                ("You are currently on the "
                                    ++ (model.tiers
                                            |> List.filter (\t -> t.id == currentTierId)
                                            |> List.head
                                            |> Maybe.map .name
                                            |> Maybe.withDefault currentTierId
                                       )
                                    ++ " plan with "
                                    ++ String.fromInt model.currentAgentLimit
                                    ++ " agent seats and "
                                    ++ String.fromInt model.currentContactLimit
                                    ++ " clients."
                                )
                            ]
                        ]

                Nothing ->
                    text ""
            , if model.isProcessingPayment then
                div [ class "text-center py-8" ]
                    [ div [ class "animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500 mx-auto" ] []
                    , p [ class "mt-4 text-gray-500" ]
                        [ text "Preparing payment session..." ]
                    , button
                        [ class "mt-4 px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded"
                        , onClick CancelPayment
                        ]
                        [ text "Cancel" ]
                    ]

              else
                div []
                    [ div [ class "grid grid-cols-1 md:grid-cols-3 gap-4" ]
                        (List.map
                            (\tier ->
                                viewPlanOption
                                    tier.id
                                    tier.name
                                    tier.price
                                    tier.features
                                    tier.agentLimit
                                    tier.contactLimit
                                    model.selectedPlan
                            )
                            model.tiers
                        )

                    -- Add custom tier calculator section
                    , div [ class "mt-8 p-6 bg-gray-50 rounded-lg border border-gray-200" ]
                        [ h3 [ class "text-lg font-semibold text-gray-900 mb-4" ]
                            [ text "Need a custom plan?" ]
                        , p [ class "text-gray-600 mb-4" ]
                            [ text "Enter your expected number of contacts to calculate a custom tier." ]
                        , div [ class "flex items-end space-x-4" ]
                            [ div [ class "flex-grow" ]
                                [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
                                    [ text "Number of Contacts" ]
                                , input
                                    [ type_ "number"
                                    , class "w-full px-4 py-2 border border-gray-300 rounded-md"
                                    , value model.customContactCount
                                    , onInput SetCustomContactCount
                                    , Html.Attributes.placeholder "Enter contact count (e.g. 15000)"
                                    ]
                                    []
                                ]
                            , button
                                [ class "px-4 py-2 rounded-md bg-blue-600 text-white hover:bg-blue-700"
                                , onClick CalculateCustomTier
                                ]
                                [ if model.isLoadingCustomTier then
                                    text "Calculating..."

                                  else
                                    text "Calculate"
                                ]
                            ]

                        -- Display custom tier result if available
                        , case model.customTierPricing of
                            Just pricing ->
                                div [ class "mt-6 p-4 bg-white rounded-lg border border-blue-200" ]
                                    [ div [ class "flex items-center justify-between mb-3" ]
                                        [ h4 [ class "text-lg font-semibold text-gray-900" ]
                                            [ text pricing.tierName ]
                                        , div [ class "rounded-full px-3 py-1 text-sm font-medium bg-blue-50 text-blue-700" ]
                                            [ text pricing.price ]
                                        ]
                                    , p [ class "text-gray-600 mb-3" ]
                                        [ text ("Up to " ++ String.fromInt pricing.contactLimit ++ " contacts with " ++ String.fromInt pricing.agentLimit ++ " agent accounts") ]
                                    , div [ class "mt-3" ]
                                        [ ul [ class "space-y-2" ]
                                            (List.map viewFeature pricing.features)
                                        ]
                                    , div [ class "mt-4" ]
                                        [ button
                                            [ class "px-4 py-2 rounded-md bg-blue-600 text-white hover:bg-blue-700 w-full"
                                            , onClick (SelectPlan ("tier-custom-" ++ String.fromInt pricing.contactLimit))
                                            ]
                                            [ text "Select This Plan" ]
                                        ]
                                    ]

                            Nothing ->
                                text ""
                        ]
                    , if canAddExtraResources model.selectedPlan then
                        div [ class "mt-8 p-4 bg-gray-50 rounded-lg border border-gray-200" ]
                            [ h3 [ class "text-lg font-semibold text-gray-900 mb-4" ]
                                [ text "Additional Resources" ]
                            , div [ class "grid grid-cols-1 md:grid-cols-2 gap-6" ]
                                [ div [ class "space-y-2" ]
                                    [ label [ class "block text-sm font-medium text-gray-700" ]
                                        [ text "Extra Agents" ]
                                    , p [ class "text-xs text-gray-500" ]
                                        [ text "Add more agent seats beyond your plan's included limit ($20/agent seat/month)" ]
                                    , div [ class "flex items-center" ]
                                        [ button
                                            [ class "bg-gray-200 px-3 py-1 rounded-l-md hover:bg-gray-300"
                                            , onClick (SetExtraAgents (String.fromInt (max 0 (model.extraAgents - 1))))
                                            ]
                                            [ text "-" ]
                                        , input
                                            [ type_ "number"
                                            , class "w-16 text-center border-y border-gray-200 py-1"
                                            , value (String.fromInt model.extraAgents)
                                            , onInput SetExtraAgents
                                            ]
                                            []
                                        , button
                                            [ class "bg-gray-200 px-3 py-1 rounded-r-md hover:bg-gray-300"
                                            , onClick (SetExtraAgents (String.fromInt (model.extraAgents + 1)))
                                            ]
                                            [ text "+" ]
                                        , span [ class "ml-2 text-sm font-medium" ]
                                            [ text ("$" ++ String.fromInt (model.extraAgents * 20) ++ "/mo") ]
                                        ]
                                    ]
                                , div [ class "space-y-2" ]
                                    [ label [ class "block text-sm font-medium text-gray-700" ]
                                        [ text "Extra Clients" ]
                                    , p [ class "text-xs text-gray-500" ]
                                        [ text "Add more clients beyond your plan's included limit ($50/5,000 clients/month)" ]
                                    , div [ class "flex items-center" ]
                                        [ button
                                            [ class "bg-gray-200 px-3 py-1 rounded-l-md hover:bg-gray-300"
                                            , onClick (SetExtraContacts (String.fromInt (max 0 (model.extraContacts - 5000))))
                                            ]
                                            [ text "-" ]
                                        , input
                                            [ type_ "number"
                                            , class "w-20 text-center border-y border-gray-200 py-1"
                                            , value (String.fromInt model.extraContacts)
                                            , onInput SetExtraContacts
                                            , Html.Attributes.step "5000"
                                            ]
                                            []
                                        , button
                                            [ class "bg-gray-200 px-3 py-1 rounded-r-md hover:bg-gray-300"
                                            , onClick (SetExtraContacts (String.fromInt (model.extraContacts + 5000)))
                                            ]
                                            [ text "+" ]
                                        , span [ class "ml-2 text-sm font-medium" ]
                                            [ text ("$" ++ String.fromInt (model.extraContacts // 5000 * 50) ++ "/mo") ]
                                        ]
                                    ]
                                ]
                            ]

                      else
                        text ""
                    , if model.error /= Nothing then
                        div [ class "mt-4 text-red-500" ]
                            [ text (Maybe.withDefault "" model.error) ]

                      else
                        text ""
                    , div [ class "mt-8 flex justify-center space-x-4" ]
                        [ button
                            [ class
                                ("px-6 py-3 rounded-lg transition-colors duration-200 "
                                    ++ (if model.selectedPlan == Nothing || (model.showChangePlan && not (hasChanges model)) then
                                            "bg-[#2563EB]/50 cursor-not-allowed text-white"

                                        else
                                            "bg-[#2563EB] hover:bg-[#1D4ED8] text-white"
                                       )
                                )
                            , onClick
                                (if model.showChangePlan then
                                    ProcessPayment

                                 else
                                    NextStep
                                )
                            , Html.Attributes.disabled (model.selectedPlan == Nothing || (model.showChangePlan && not (hasChanges model)))
                            ]
                            [ text
                                (if model.showChangePlan then
                                    "Change Plan"

                                 else
                                    "Select"
                                )
                            ]
                        , if model.showChangePlan then
                            button
                                [ class "px-6 py-3 rounded-lg bg-gray-200 hover:bg-gray-300 text-gray-800"
                                , onClick NavigateToTempLanding
                                ]
                                [ text "Cancel" ]

                          else
                            text ""
                        ]
                    ]
            ]
        ]


viewLoading : Html Msg
viewLoading =
    div [ class "text-center" ]
        [ div [ class "animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500 mx-auto" ] []
        , p [ class "mt-4 text-gray-500" ]
            [ text "Loading subscription tiers..." ]
        ]


viewPlanSelection : Model -> Html Msg
viewPlanSelection model =
    div [ class "space-y-8" ]
        [ div [ class "mb-8" ]
            [ h1 [ class "text-2xl font-semibold text-gray-900" ]
                [ text "Choose your plan" ]
            , p [ class "text-gray-600 mt-2" ]
                [ text "Select a plan that fits your organization's needs" ]
            ]
        , div [ class "w-full" ]
            [ -- Embedded Stripe pricing table
              node "stripe-pricing-table"
                [ attribute "pricing-table-id" "prctbl_1RAfz9CBUPXAZKNG0EyV8bRU"
                , attribute "publishable-key" "pk_test_51Qyh7RCBUPXAZKNGAvsWikdxCCaV1R9Vc79IgPqCul8AJsln69ABDQZE0zzOtOlH5rqrlw2maRebndvPl8xDaIVl00Nn2OOBCX"
                ]
                []
            , div [ class "mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200" ]
                [ h3 [ class "text-lg font-semibold text-gray-900 mb-2" ]
                    [ text "Usage-Based Pricing" ]
                , p [ class "text-gray-600" ]
                    [ text "Our subscription includes the following:" ]
                , ul [ class "list-disc list-inside mt-2 space-y-1 text-gray-600" ]
                    [ li [] [ text "Base plan includes 500 contacts" ]
                    , li [] [ text "$40 for each additional 500 contacts used" ]
                    , li [] [ text "You will only be billed for the contacts you actually have" ]
                    , li [] [ text "We'll automatically adjust your billing as your contact count changes" ]
                    ]
                ]
            ]

        -- Add a button to continue after selection
        , div [ class "mt-8 flex justify-center" ]
            [ button
                [ class
                    ("px-6 py-3 rounded-lg transition-colors duration-200 "
                        ++ (if model.selectedPlan == Nothing then
                                "bg-blue-400 cursor-not-allowed text-white"

                            else
                                "bg-blue-600 hover:bg-blue-700 text-white"
                           )
                    )
                , onClick NextStep
                , disabled (model.selectedPlan == Nothing)
                ]
                [ text "Continue" ]
            ]
        ]


viewPlanOption : String -> String -> String -> List String -> Int -> Int -> Maybe String -> Html Msg
viewPlanOption id name price features agentLimit contactLimit selectedPlan =
    div
        [ class
            ("p-6 rounded-lg cursor-pointer transition-all "
                ++ (if Just id == selectedPlan then
                        "bg-[#2563EB]/10 ring-2 ring-[#2563EB]"

                    else
                        "bg-gray-50 hover:bg-gray-100"
                   )
            )
        , onClick (SelectPlan id)
        ]
        [ div [ class "space-y-4" ]
            [ div []
                [ h3 [ class "text-xl font-semibold text-gray-900" ] [ text name ]
                , p [ class "text-3xl font-bold text-gray-900 mt-2" ]
                    [ text
                        (if id == "enterprise" then
                            "Contact Us"

                         else
                            price
                        )
                    ]
                ]
            , div [ class "space-y-2 py-4 border-t border-b border-gray-200" ]
                [ if id /= "enterprise" then
                    div [ class "text-gray-600" ]
                        [ text
                            (if id == "pro" then
                                "Starts with up to " ++ String.fromInt agentLimit ++ " agent seats"

                             else if agentLimit == -1 then
                                "Unlimited agent seats"

                             else
                                "Up to " ++ String.fromInt agentLimit ++ " agent seats"
                            )
                        ]

                  else
                    text ""
                , if id /= "enterprise" then
                    div [ class "text-gray-600" ]
                        [ text
                            (if id == "pro" then
                                "Starts with up to " ++ String.fromInt contactLimit ++ " clients"

                             else if contactLimit == -1 then
                                "Unlimited clients"

                             else
                                "Up to " ++ String.fromInt contactLimit ++ " clients"
                            )
                        ]

                  else
                    text ""
                ]
            , div [ class "mt-4" ]
                [ p [ class "text-sm font-medium text-gray-900 mb-2" ] [ text "Features:" ]
                , ul [ class "space-y-2" ]
                    (List.map
                        (\feature ->
                            li [ class "flex items-start" ]
                                [ span [ class "text-[#059669] mr-2" ] [ text "✓" ]
                                , text feature
                                ]
                        )
                        features
                    )
                ]
            ]
        ]


viewFeature : String -> Html Msg
viewFeature feature =
    li [ class "flex items-start" ]
        [ div [ class "flex-shrink-0 h-5 w-5 text-green-500" ]
            [ viewSmallCheckIcon ]
        , div [ class "ml-3 text-sm text-gray-500" ]
            [ text feature ]
        ]


viewCheckIcon : Html Msg
viewCheckIcon =
    svg
        [ Svg.Attributes.class "h-5 w-5"
        , viewBox "0 0 20 20"
        , fill "currentColor"
        ]
        [ path
            [ fillRule "evenodd"
            , clipRule "evenodd"
            , d "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
            ]
            []
        ]


viewSmallCheckIcon : Html Msg
viewSmallCheckIcon =
    svg
        [ Svg.Attributes.class "h-4 w-4"
        , viewBox "0 0 20 20"
        , fill "currentColor"
        ]
        [ path
            [ fillRule "evenodd"
            , clipRule "evenodd"
            , d "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
            ]
            []
        ]


calculateCustomTier : Model -> Cmd Msg
calculateCustomTier model =
    case String.toInt model.customContactCount of
        Just contactCount ->
            if contactCount > 0 then
                Http.get
                    { url = "/api/subscription/calculate-tier/" ++ String.fromInt contactCount
                    , expect = Http.expectJson GotCustomTierPricing customTierPricingDecoder
                    }

            else
                Cmd.none

        Nothing ->
            Cmd.none


customTierPricingDecoder : Decoder CustomTierPricing
customTierPricingDecoder =
    field "success" Decode.bool
        |> Decode.andThen
            (\success ->
                if success then
                    field "pricing"
                        (Decode.map5 CustomTierPricing
                            (field "price" string)
                            (field "agentLimit" int)
                            (field "tierName" string)
                            (field "contactLimit" int)
                            (field "features" (list string))
                        )

                else
                    Decode.fail "API returned error"
            )


selectCustomTier : Model -> Cmd Msg
selectCustomTier model =
    case model.customTierPricing of
        Just pricing ->
            -- Create a custom tier ID based on the contact limit
            let
                customTierId =
                    "tier-custom-" ++ String.fromInt pricing.contactLimit
            in
            -- Simulate selecting this plan
            Cmd.none

        Nothing ->
            Cmd.none


subscriptions : Model -> Sub Msg
subscriptions _ =
    stripeTableSelected StripeTableSelection


subscriptionTiersDecoder : Decoder (List SubscriptionTier)
subscriptionTiersDecoder =
    field "tiers"
        (list
            (Decode.map6 SubscriptionTier
                (field "id" string)
                (field "name" string)
                (field "price" string)
                (field "agentLimit" int)
                (field "contactLimit" int)
                (field "features" (list string))
            )
        )


currentSubscriptionDecoder : Decoder { tierId : String, agentLimit : Int, contactLimit : Int }
currentSubscriptionDecoder =
    let
        -- Try to decode from a success field first (for API format consistency)
        successDecoder =
            field "success" Decode.bool
                |> Decode.andThen
                    (\success ->
                        if success then
                            -- If success is true, look for the fields at the top level
                            Decode.map3
                                (\tierId agentLimit contactLimit ->
                                    { tierId = tierId
                                    , agentLimit = agentLimit
                                    , contactLimit = contactLimit
                                    }
                                )
                                (field "tierId" string)
                                (field "agentLimit" int)
                                (field "contactLimit" int)

                        else
                            -- If success is false, fail with the error message
                            field "error" string
                                |> Decode.andThen (\err -> Decode.fail err)
                    )

        -- Try the direct decoder as a fallback
        directDecoder =
            Decode.map3
                (\tierId agentLimit contactLimit ->
                    { tierId = tierId
                    , agentLimit = agentLimit
                    , contactLimit = contactLimit
                    }
                )
                (field "tierId" string)
                (field "agentLimit" int)
                (field "contactLimit" int)
    in
    -- Try to use the success wrapper first, fall back to direct decoder
    Decode.oneOf [ successDecoder, directDecoder ]


encodeSubscriptionUpdate : String -> Int -> Int -> Encode.Value
encodeSubscriptionUpdate tierId extraAgents extraContacts =
    Encode.object
        [ ( "tierId", Encode.string tierId )
        , ( "extraAgents", Encode.int extraAgents )
        , ( "extraContacts", Encode.int extraContacts )
        ]


encodeStripeCheckoutRequest : String -> String -> Int -> Int -> Encode.Value
encodeStripeCheckoutRequest orgSlug tierId extraAgents extraContacts =
    Encode.object
        [ ( "orgSlug", Encode.string orgSlug )
        , ( "tierId", Encode.string tierId )
        , ( "extraAgents", Encode.int extraAgents )
        , ( "extraContacts", Encode.int extraContacts )
        ]


filterTiers : List SubscriptionTier -> List SubscriptionTier
filterTiers tiers =
    -- No need to filter out enterprise options with the new contact-based pricing model
    tiers


canAddExtraResources : Maybe String -> Bool
canAddExtraResources selectedPlan =
    case selectedPlan of
        Just plan ->
            plan == "pro"

        -- Only Pro plan can add extra resources
        Nothing ->
            False


hasChanges : Model -> Bool
hasChanges model =
    let
        -- Check if the plan has changed
        planChanged =
            case ( model.currentTier, model.selectedPlan ) of
                ( Just currentTier, Just selectedTier ) ->
                    currentTier /= selectedTier

                _ ->
                    False

        -- Check if resources have changed
        resourcesChanged =
            model.extraAgents > 0 || model.extraContacts > 0
    in
    planChanged || resourcesChanged


confirmationDecoder : Decoder { success : Bool, redirectUrl : String }
confirmationDecoder =
    Decode.map2 (\success redirectUrl -> { success = success, redirectUrl = redirectUrl })
        (Decode.field "success" Decode.bool)
        (Decode.field "redirectUrl" Decode.string)


getPlanLimitBanner : Model -> Html Msg
getPlanLimitBanner model =
    -- When user is on trial plan
    if model.currentAgentLimit > 0 && model.extraAgents > model.currentAgentLimit then
        LimitBanner.viewLimitBanner
            (AgentLimit (model.currentAgentLimit + model.extraAgents) model.currentAgentLimit)
            CloseBanner
        -- When user is on basic plan (which only allows 1 agent)

    else if model.currentTier == Just "basic" then
        LimitBanner.viewLimitBanner
            (CustomWarning
                "Basic Plan Limitations"
                "Your current Basic plan only supports 1 agent. Please upgrade to a higher tier plan to add more agents."
            )
            CloseBanner
        -- When approaching contact limit (subscription data from API)

    else if model.currentContactLimit > 0 && model.extraContacts >= (model.currentContactLimit * 1 // 10) then
        LimitBanner.viewLimitBanner
            (ContactLimit (model.currentContactLimit + model.extraContacts) model.currentContactLimit)
            CloseBanner
        -- Default for new users or when no specific warning is needed

    else
        LimitBanner.viewLimitBanner
            (TrialEnding "June 15, 2024")
            CloseBanner


viewPlan : Maybe String -> SubscriptionTier -> Html Msg
viewPlan selectedPlan tier =
    let
        isSelected =
            selectedPlan == Just tier.id

        selectedClass =
            if isSelected then
                "border-[#03045E] ring-2 ring-[#03045E]"

            else
                "border-gray-200 hover:border-gray-300"
    in
    div
        [ class ("border rounded-lg p-6 cursor-pointer " ++ selectedClass)
        , onClick (SelectPlan tier.id)
        ]
        [ -- Plan header with tier name
          div [ class "flex items-center justify-between" ]
            [ div [ class "flex items-center" ]
                [ h3 [ class "text-lg font-semibold text-gray-900" ]
                    [ text tier.name ]
                , if isSelected then
                    -- Checkmark for selected plan
                    div [ class "ml-2 text-[#03045E]" ]
                        [ viewCheckIcon ]

                  else
                    text ""
                ]
            , div [ class "rounded-full px-3 py-1 text-sm font-medium bg-blue-50 text-blue-700" ]
                [ text tier.price ]
            ]

        -- Limits
        , div [ class "mt-4 space-y-3" ]
            [ div [ class "flex items-start" ]
                [ div [ class "flex-shrink-0 h-5 w-5 text-green-500" ]
                    [ viewSmallCheckIcon ]
                , div [ class "ml-3 text-sm text-gray-500" ]
                    [ text ("Up to " ++ String.fromInt tier.contactLimit ++ " contacts") ]
                ]
            , div [ class "flex items-start" ]
                [ div [ class "flex-shrink-0 h-5 w-5 text-green-500" ]
                    [ viewSmallCheckIcon ]
                , div [ class "ml-3 text-sm text-gray-500" ]
                    [ text ("Up to " ++ String.fromInt tier.agentLimit ++ " agents") ]
                ]
            ]

        -- Features
        , div [ class "mt-6" ]
            [ h4 [ class "text-sm font-medium text-gray-900" ]
                [ text "Includes:" ]
            , ul [ class "mt-2 space-y-2" ]
                (List.map viewFeature tier.features)
            ]
        ]



-- Add this port for the embedded Stripe pricing table


port stripeTableSelected : (String -> msg) -> Sub msg

================
File: frontend/src/Compare.elm
================
module Compare exposing
    ( CompareParams
    , Model
    , Msg(..)
    , PlanType(..)
    , fetchPlans
    , init
    , subscriptions
    , update
    , view
    )

import BirthdayRules exposing (isInBirthdayRuleWindow)
import Browser
import Browser.Dom as Dom
import Browser.Events
import Browser.Navigation as Nav
import CarrierNaic exposing (Carrier(..), carrierDecoder, carrierToNaics, carrierToString, naicToCarrier, stringToCarrier)
import Date exposing (Date)
import Dict
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput)
import Http
import Json.Decode as D exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as E
import List.Extra
import Svg exposing (path, svg)
import Svg.Attributes exposing (clipRule, d, fill, fillRule, height, stroke, strokeLinecap, viewBox, width)
import Task
import Time
import Url exposing (Url)
import Url.Parser as UrlParser
import Url.Parser.Query as Query
import Utils.DiscountDescription exposing (discountDescription)
import Utils.QuoteHeader exposing (viewHeader)



-- TYPES


type PlanType
    = PlanG
    | PlanN


type alias CompareParams =
    { quoteId : Maybe String
    , orgId : Maybe String
    , tid : Maybe String
    }


type alias ContactResponse =
    { contact : Maybe Contact
    , agent : Agent
    , orgSlug : String
    , orgName : String
    , orgLogo : Maybe String
    , orgPhone : Maybe String
    , orgSignature : Bool
    , orgSignatureText : Maybe String
    , carrierContracts : List Carrier
    , forceOrgSenderDetails : Bool
    }


type alias Agent =
    { firstName : String
    , lastName : String
    , email : String
    , phone : String
    , signature : String
    , useOrgSenderDetails : Bool
    , bookingLink : String
    }


type alias Contact =
    { id : Int
    , firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , age : Int
    , gender : String
    , tobacco : Bool
    , state : String
    , zipCode : String
    , county : Maybe String
    , currentCarrier : Maybe String
    , planType : Maybe String
    }


type alias CoverageItem =
    { name : String
    , percentageCovered : Int
    , note : Maybe String
    }


type alias CoverageList =
    List CoverageItem


type alias Plan =
    { price : Float
    , priceDiscount : Float
    , flag : Maybe String
    , age : Int
    , description : String
    , gender : String
    , id : Int
    , image : String
    , naic : String
    , name : String
    , planType : String
    , premiumStability : String
    , ratingCategory : String
    , score : Int
    , select : Bool
    , state : String
    , tobacco : Bool
    , coverageSummary : CoverageList
    , discountDescription : Maybe String
    , originalPlanName : Maybe String
    }


isPlanExcluded : Plan -> Bool
isPlanExcluded plan =
    case plan.naic of
        "60380" ->
            case plan.state of
                "CA" ->
                    True

                "OR" ->
                    True

                "WA" ->
                    True

                "OK" ->
                    True

                "ID" ->
                    True

                "MD" ->
                    True

                "VA" ->
                    True

                "NV" ->
                    True

                "MO" ->
                    True

                _ ->
                    False

        _ ->
            False


type alias Plans =
    { planG : List Plan
    , planN : List Plan
    }


type alias LocationUpdateResponse =
    { success : Bool
    , zipCode : String
    , state : String
    , counties : List String
    }


type alias Model =
    { isLoading : Bool
    , error : Maybe String
    , plans : Plans
    , state : Maybe String
    , county : Maybe String
    , zip : Maybe String
    , age : Maybe Int
    , gender : Maybe String
    , tobacco : Maybe Bool
    , selectedPlanType : PlanType
    , selectedPlan : Maybe Plan
    , showReviewVideo : Bool
    , showQualificationVideo : Bool
    , showGvsNVideo : Bool
    , showFAQ : Bool
    , currentCardIndex : Int
    , showRatesVideo : Bool
    , key : Nav.Key
    , showDiscount : Bool
    , currentCarrier : Maybe String
    , planType : Maybe String
    , dateOfBirth : Maybe String
    , quoteId : Maybe String
    , carrierContracts : List Carrier
    , currentDate : Maybe Date
    , effectiveDate : Maybe Date
    , discountCsvString : Maybe String
    , orgId : Maybe String
    , orgName : Maybe String
    , orgLogo : Maybe String
    , orgPhone : Maybe String
    , useOrg : Bool
    , orgSignatureText : Maybe String
    , name : Maybe String
    , contact : Maybe Contact
    , agent : Maybe Agent
    , orgSlug : Maybe String
    , loadingContact : Bool
    , showDiscountInfo : Bool
    , showLocationModal : Bool
    , editingZipCode : Maybe String
    , editingCounty : Maybe String
    , availableCounties : List String
    , locationUpdateError : Maybe String
    , submittingLocation : Bool
    , editingEffectiveDate : Maybe String
    , fetchNewPlans : Bool
    , activeTooltipPlan : Maybe Plan
    , forceOrgSenderDetails : Bool
    }


type Msg
    = GotPlans (Result Http.Error Plans)
    | GotDiscountCsvString (Result Http.Error String)
    | TogglePlanType
    | SelectPlan Plan
    | SelectPlanCard Plan
    | ScrollDown Dom.Viewport
    | CloseReviewVideo
    | OpenGvsNVideo
    | CloseGvsNVideo
    | ShowQualificationVideo
    | CloseQualificationVideo
    | ShowFAQ
    | CloseFAQ
    | NextCard
    | PreviousCard
    | CloseRatesVideo
    | NavigateTo String
    | ToggleDiscount
    | ToggleDiscountInfo
    | GotCarrierContracts (Result Http.Error (List Carrier))
    | GotCurrentDate Date
    | GotContactData (Result Http.Error ContactResponse)
    | ShowLocationModal
    | CloseEditModal
    | CloseEditModalAndFetchPlans
    | UpdateZipCode String
    | UpdateCounty String
    | UpdateEffectiveDate String
    | SubmitLocationUpdate
    | GotLocationUpdate (Result Http.Error LocationUpdateResponse)
    | ToggleMobileTooltip (Maybe Plan)
    | NoOp
    | LogTrackingClickResult (Result Http.Error ())


type alias Flags =
    { state : String
    , zip : String
    , county : String
    , gender : String
    , tobacco : Bool
    , age : Int
    , planType : String
    , currentCarrier : Maybe String
    , dateOfBirth : String
    , quoteId : Maybe String
    }



-- INIT


logTrackingClick : CompareParams -> Cmd Msg
logTrackingClick params =
    let
        ss =
            case params.quoteId of
                Just quoteId ->
                    String.split "-" quoteId

                Nothing ->
                    []

        orgId =
            List.head ss |> Maybe.withDefault ""

        contactId =
            case List.tail ss of
                Just ssTail ->
                    List.head ssTail |> Maybe.withDefault ""

                Nothing ->
                    ""
    in
    case ( params.tid, params.quoteId ) of
        ( Just tid, Just quoteId ) ->
            Http.post
                { url = "/api/tracking/log-tracking-click"
                , body =
                    Http.jsonBody
                        (E.object
                            [ ( "tid", E.string (Maybe.withDefault "" params.tid) )
                            , ( "quoteId", E.string quoteId )
                            , ( "orgId", E.string orgId )
                            , ( "contactId", E.string contactId )
                            ]
                        )
                , expect = Http.expectJson (\result -> LogTrackingClickResult result) (D.succeed ())
                }

        _ ->
            Cmd.none


init : Nav.Key -> Maybe CompareParams -> ( Model, Cmd Msg )
init key maybeParams =
    let
        -- Empty model with loading state
        emptyModel =
            { isLoading = True
            , error = Nothing
            , plans = { planG = [], planN = [] }
            , state = Nothing
            , county = Nothing
            , zip = Nothing
            , age = Nothing
            , gender = Nothing
            , tobacco = Nothing
            , selectedPlanType = PlanG
            , selectedPlan = Nothing
            , showReviewVideo = False
            , showQualificationVideo = False
            , showGvsNVideo = False
            , showFAQ = False
            , currentCardIndex = 0
            , showRatesVideo = False
            , key = key
            , showDiscount = False
            , currentCarrier = Nothing
            , planType = Nothing
            , dateOfBirth = Nothing
            , quoteId = Nothing
            , carrierContracts = []
            , currentDate = Nothing
            , effectiveDate = Nothing
            , discountCsvString = Nothing
            , orgId = Nothing
            , orgName = Nothing
            , orgLogo = Nothing
            , orgPhone = Nothing
            , useOrg = False
            , orgSignatureText = Nothing
            , name = Nothing
            , contact = Nothing
            , agent = Nothing
            , orgSlug = Nothing
            , loadingContact = True
            , showDiscountInfo = False
            , showLocationModal = False
            , editingZipCode = Nothing
            , editingCounty = Nothing
            , availableCounties = []
            , locationUpdateError = Nothing
            , submittingLocation = False
            , editingEffectiveDate = Nothing
            , fetchNewPlans = False
            , activeTooltipPlan = Nothing
            , forceOrgSenderDetails = False
            }
    in
    case maybeParams of
        Just params ->
            case params.quoteId of
                Just quoteId ->
                    -- We have a quote ID, fetch contact data
                    ( { emptyModel | quoteId = Just quoteId, orgId = params.orgId }
                    , Cmd.batch
                        [ fetchContactData quoteId
                        , Task.perform GotCurrentDate Date.today
                        , fetchDiscountCsvString
                        , logTrackingClick params
                        ]
                    )

                Nothing ->
                    -- No quote ID, check if we have an org ID
                    case params.orgId of
                        Just orgId ->
                            -- Redirect to self-service onboarding
                            ( emptyModel
                            , Nav.pushUrl key ("/self-onboarding/" ++ orgId)
                            )

                        Nothing ->
                            -- No valid parameters
                            ( { emptyModel
                                | isLoading = False
                                , error = Just "Missing required parameters. Please provide either a quote ID or organization ID."
                              }
                            , Cmd.none
                            )

        Nothing ->
            -- No parameters provided
            ( { emptyModel
                | isLoading = False
                , error = Just "No parameters provided. Please provide either a quote ID or organization ID."
              }
            , Cmd.none
            )



-- HTTP


fetchContactData : String -> Cmd Msg
fetchContactData quoteId =
    Http.get
        { url = "/api/quotes/decode/" ++ quoteId
        , expect = Http.expectJson GotContactData contactResponseDecoder
        }


fetchDiscountCsvString : Cmd Msg
fetchDiscountCsvString =
    Http.get
        { url = "/api/data/public/hhd.csv"
        , expect = Http.expectString GotDiscountCsvString
        }


fetchPlans : Model -> Cmd Msg
fetchPlans model =
    case model.contact of
        Just contact ->
            Http.request
                { method = "POST"
                , headers = []
                , url = "/api/quotes"
                , body = Http.jsonBody (buildPlansBody contact model.effectiveDate)
                , expect = Http.expectJson GotPlans (plansDecoder model)
                , timeout = Nothing
                , tracker = Nothing
                }

        Nothing ->
            -- Don't fetch plans until we have contact data
            Cmd.none


getEffectiveDate : Date -> String
getEffectiveDate date =
    date
        |> Date.add Date.Months 1
        |> Date.floor Date.Month
        |> Date.toIsoString


buildPlansBody : Contact -> Maybe Date -> E.Value
buildPlansBody contact currentDate =
    let
        ed =
            case currentDate of
                Just date ->
                    [ ( "effective_date", E.string (Date.toIsoString date) ) ]

                Nothing ->
                    []
    in
    [ ( "zip_code", E.string contact.zipCode )
    , ( "state", E.string contact.state )
    , ( "county", E.string (Maybe.withDefault "" contact.county) )
    , ( "age", E.int contact.age )
    , ( "gender"
      , E.string
            (if String.contains "f" (String.toLower contact.gender) then
                "F"

             else
                "M"
            )
      )
    , ( "tobacco", E.bool contact.tobacco )
    , ( "carriers", E.string "supported" )
    ]
        ++ ed
        |> E.object



-- DECODERS


plansDecoder : Model -> Decoder Plans
plansDecoder model =
    D.oneOf
        [ D.list quoteResponseDecoder
            |> D.map (\responses -> groupQuotesByPlan responses model)
        , D.succeed { planG = [], planN = [] }
        ]


type alias QuoteResponse =
    { naic : String
    , group : Int
    , companyName : String
    , quotes : List QuoteData
    }


type alias QuoteData =
    { rate : Float
    , discountRate : Float
    , discountCategory : Maybe String
    , age : Int
    , gender : String
    , plan : String
    , tobacco : Int
    , originalPlanName : Maybe String
    }


quoteResponseDecoder : Decoder QuoteResponse
quoteResponseDecoder =
    D.map4 QuoteResponse
        (D.field "naic" D.string)
        (D.field "group" D.int)
        (D.field "company_name" D.string)
        (D.field "quotes" (D.list quoteDataDecoder))


quoteDataDecoder : Decoder QuoteData
quoteDataDecoder =
    D.succeed QuoteData
        |> Pipeline.required "rate" D.float
        |> Pipeline.required "discount_rate" D.float
        |> Pipeline.required "discount_category" (D.nullable D.string)
        |> Pipeline.required "age" D.int
        |> Pipeline.required "gender" D.string
        |> Pipeline.required "plan" D.string
        |> Pipeline.required "tobacco" D.int
        |> Pipeline.optional "original_plan_name" (D.nullable D.string) Nothing


blacklistCarriers : List Carrier
blacklistCarriers =
    [ Allstate ]


isCarrierSupported : String -> List Carrier -> Bool
isCarrierSupported naic carrierContracts =
    case naicToCarrier naic of
        Just carrierName ->
            List.member carrierName carrierContracts
                && not (List.member carrierName blacklistCarriers)

        Nothing ->
            False


filterPlansByCarrier : Plans -> List Carrier -> Plans
filterPlansByCarrier plans carrierContracts =
    { planG = List.filter (\plan -> isCarrierSupported plan.naic carrierContracts) plans.planG |> List.Extra.unique
    , planN = List.filter (\plan -> isCarrierSupported plan.naic carrierContracts) plans.planN |> List.Extra.unique
    }


groupQuotesByPlan : List QuoteResponse -> Model -> Plans
groupQuotesByPlan responses model =
    let
        convertToPlan : QuoteResponse -> QuoteData -> Plan
        convertToPlan response quote =
            let
                carrierImagePath =
                    case naicToCarrier response.naic of
                        Just carrier ->
                            "/images/" ++ (carrier |> carrierToString |> String.filter (\c -> c /= ' ')) ++ ".svg"

                        Nothing ->
                            -- Fallback to png if we can't match the carrier
                            "/images/medicare-max-logo.png"
            in
            { price = quote.rate / 100
            , priceDiscount = quote.discountRate / 100
            , flag = quote.discountCategory
            , age = quote.age
            , description = ""
            , gender = quote.gender
            , id = 0
            , image = carrierImagePath
            , naic = response.naic
            , name = response.companyName
            , planType = quote.plan
            , premiumStability = ""
            , ratingCategory = ""
            , score = 0
            , select = False
            , state = Maybe.withDefault "" model.state
            , tobacco = quote.tobacco == 1
            , coverageSummary =
                if String.toUpper quote.plan == "G" then
                    planGCoverageList

                else
                    planNCoverageList
            , discountDescription = Nothing
            , originalPlanName = quote.originalPlanName
            }

        allQuotes =
            List.concatMap
                (\response ->
                    List.concatMap
                        (\quote ->
                            let
                                upperPlan =
                                    String.toUpper quote.plan
                            in
                            if List.member upperPlan [ "G", "N" ] then
                                [ convertToPlan response quote ]

                            else
                                []
                        )
                        response.quotes
                )
                responses

        planG =
            List.filter (\q -> String.toUpper q.planType == "G") allQuotes
                |> List.sortBy .price

        planN =
            List.filter (\q -> String.toUpper q.planType == "N") allQuotes
                |> List.sortBy .price

        result =
            { planG = planG
            , planN = planN
            }
    in
    result



-- COVERAGE LISTS


planGCoverageList : CoverageList
planGCoverageList =
    [ { name = "Part A Deductible", percentageCovered = 100, note = Nothing }
    , { name = "Hospital Co-Pays", percentageCovered = 100, note = Nothing }
    , { name = "Skilled Nursing Facility Co-Pays", percentageCovered = 100, note = Nothing }
    , { name = "Part B Annual Deductible", percentageCovered = 0, note = Just "$240 annual deductible" }
    , { name = "Part B Coinsurance", percentageCovered = 100, note = Nothing }
    , { name = "Excess Charges", percentageCovered = 100, note = Nothing }
    , { name = "Foreign Travel Emergency", percentageCovered = 80, note = Nothing }
    ]


planNCoverageList : CoverageList
planNCoverageList =
    [ { name = "Part A Deductible", percentageCovered = 100, note = Nothing }
    , { name = "Hospital Co-Pays", percentageCovered = 100, note = Nothing }
    , { name = "Skilled Nursing Facility Co-Pays", percentageCovered = 100, note = Nothing }
    , { name = "Part B Annual Deductible", percentageCovered = 0, note = Just "$240 annual deductible" }
    , { name = "Part B Coinsurance", percentageCovered = 100, note = Just "w/ some copayments" }
    , { name = "Excess Charges", percentageCovered = 0, note = Nothing }
    , { name = "Foreign Travel Emergency", percentageCovered = 80, note = Nothing }
    ]



-- UPDATE


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        LogTrackingClickResult result ->
            case result of
                Ok _ ->
                    ( model, Cmd.none )

                Err _ ->
                    ( model, Cmd.none )

        GotDiscountCsvString (Ok discountCsvString) ->
            ( { model | discountCsvString = Just discountCsvString }
            , Cmd.none
            )

        GotDiscountCsvString (Err _) ->
            ( { model | error = Just "Failed to load discount CSV" }
            , Cmd.none
            )

        GotCarrierContracts (Ok carrierContracts) ->
            let
                updatedModel =
                    { model | carrierContracts = carrierContracts }
            in
            ( updatedModel
            , fetchPlans updatedModel
            )

        GotCarrierContracts (Err _) ->
            ( { model | error = Just "Failed to load organization settings" }
            , Cmd.none
            )

        ToggleDiscount ->
            ( { model | showDiscount = not model.showDiscount }
            , Cmd.none
            )

        ToggleDiscountInfo ->
            ( { model | showDiscountInfo = not model.showDiscountInfo }
            , Cmd.none
            )

        GotPlans result ->
            case result of
                Ok plansRaw ->
                    let
                        plans0 =
                            filterPlansByCarrier plansRaw model.carrierContracts

                        addDiscountDescriptions : Plan -> Plan
                        addDiscountDescriptions plan =
                            case ( model.discountCsvString, naicToCarrier plan.naic ) of
                                ( Just discountCsvString, Just carrier ) ->
                                    { plan
                                        | discountDescription =
                                            discountDescription
                                                discountCsvString
                                                carrier
                                                plan.naic
                                                plan.state
                                                |> Result.toMaybe
                                                |> Maybe.withDefault Nothing
                                    }

                                _ ->
                                    plan

                        plans =
                            { planG =
                                plans0.planG
                                    |> List.map addDiscountDescriptions
                                    |> List.filter (\plan -> not (isPlanExcluded plan))
                            , planN =
                                plans0.planN
                                    |> List.map addDiscountDescriptions
                                    |> List.filter (\plan -> not (isPlanExcluded plan))
                            }

                        hasPlans =
                            not (List.isEmpty plans.planG && List.isEmpty plans.planN)

                        errorMsg =
                            if not hasPlans then
                                Just "No plans available for the selected criteria. Please try different parameters."

                            else
                                Nothing
                    in
                    ( { model
                        | plans = plans
                        , isLoading = False
                        , error = errorMsg
                      }
                    , Cmd.none
                    )

                Err error ->
                    let
                        detailedError =
                            case error of
                                Http.BadStatus 401 ->
                                    "Authentication error: Please check your session and try again."

                                Http.BadStatus 403 ->
                                    "Access forbidden: You don't have permission to access these quotes."

                                Http.BadStatus 500 ->
                                    "Server error: The quote service is experiencing issues. Please try again later."

                                Http.NetworkError ->
                                    "Network error: Please check your internet connection and try again."

                                Http.Timeout ->
                                    "Request timed out: The quote service took too long to respond. Please try again."

                                Http.BadUrl url ->
                                    "Invalid URL: " ++ url

                                Http.BadBody message ->
                                    "Invalid response format: " ++ message

                                _ ->
                                    httpErrorToString error
                    in
                    ( { model
                        | error = Just detailedError
                        , isLoading = False
                      }
                    , Cmd.none
                    )

        TogglePlanType ->
            ( { model
                | selectedPlanType = togglePlanType model.selectedPlanType
                , currentCardIndex = 0
                , selectedPlan = Nothing
              }
            , Cmd.none
            )

        SelectPlan plan ->
            ( { model | showQualificationVideo = True }
            , Cmd.batch
                [ Nav.pushUrl model.key
                    (case model.quoteId of
                        Just id ->
                            let
                                orgIdParam =
                                    case model.orgId of
                                        Just orgId ->
                                            "&orgId=" ++ orgId

                                        Nothing ->
                                            -- Try to extract orgId from the quoteId as a fallback
                                            case String.split "-" id |> List.head of
                                                Just extractedOrgId ->
                                                    "&orgId=" ++ extractedOrgId

                                                Nothing ->
                                                    ""
                            in
                            "/eligibility?id=" ++ id ++ orgIdParam

                        Nothing ->
                            let
                                orgIdParam =
                                    case model.orgId of
                                        Just orgId ->
                                            "?orgId=" ++ orgId

                                        Nothing ->
                                            ""
                            in
                            "/eligibility" ++ orgIdParam
                    )
                , Task.perform (\_ -> NoOp) (Dom.setViewport 0 0)
                ]
            )

        SelectPlanCard plan ->
            ( { model
                | selectedPlan =
                    if Just plan == model.selectedPlan then
                        Nothing
                        -- Deselect if clicking the same plan again

                    else
                        Just plan

                -- Otherwise select the new plan
              }
            , Cmd.none
            )

        ScrollDown viewport ->
            ( model, Cmd.none )

        CloseReviewVideo ->
            ( { model | showReviewVideo = False }
            , Cmd.none
            )

        OpenGvsNVideo ->
            ( { model | showGvsNVideo = True }, Cmd.none )

        CloseGvsNVideo ->
            ( { model | showGvsNVideo = False }, Cmd.none )

        ShowQualificationVideo ->
            ( { model | showQualificationVideo = True }
            , Cmd.none
            )

        CloseQualificationVideo ->
            ( { model | showQualificationVideo = False }
            , Nav.pushUrl model.key
                (let
                    orgIdParam =
                        case model.orgId of
                            Just orgId ->
                                "?orgId=" ++ orgId

                            Nothing ->
                                -- Try to extract orgId from the quoteId as a fallback
                                case model.quoteId of
                                    Just id ->
                                        case String.split "-" id |> List.head of
                                            Just extractedOrgId ->
                                                "?orgId=" ++ extractedOrgId

                                            Nothing ->
                                                ""

                                    Nothing ->
                                        ""
                 in
                 "/eligibility" ++ orgIdParam
                )
            )

        ShowFAQ ->
            ( { model | showFAQ = True }
            , Cmd.none
            )

        CloseFAQ ->
            ( { model | showFAQ = False }
            , Cmd.none
            )

        NextCard ->
            ( { model | currentCardIndex = Basics.min (model.currentCardIndex + 1) (List.length (getSelectedPlans model) - 1) }
            , Cmd.none
            )

        PreviousCard ->
            ( { model | currentCardIndex = Basics.max (model.currentCardIndex - 1) 0 }
            , Cmd.none
            )

        CloseRatesVideo ->
            ( { model | showRatesVideo = False }, Cmd.none )

        NavigateTo path ->
            ( model, Nav.pushUrl model.key path )

        GotCurrentDate date ->
            let
                effectiveDate =
                    date
                        |> Date.add Date.Months 1
                        |> Date.floor Date.Month
            in
            ( { model
                | currentDate = Just date
                , effectiveDate = Just effectiveDate
              }
            , Cmd.none
            )

        GotContactData (Ok response) ->
            let
                -- Update model with contact data
                updatedModel0 =
                    { model
                        | contact = response.contact
                        , agent = Just response.agent
                        , orgSlug = Just response.orgSlug
                        , orgName = Just response.orgName
                        , orgLogo = response.orgLogo
                        , orgPhone = response.orgPhone
                        , useOrg = response.orgSignature
                        , orgSignatureText = response.orgSignatureText
                        , carrierContracts = response.carrierContracts
                        , loadingContact = False
                        , forceOrgSenderDetails = response.forceOrgSenderDetails
                    }

                updatedModel =
                    case response.contact of
                        Just contact ->
                            { updatedModel0
                                | name = Just (contact.firstName ++ " " ++ contact.lastName)
                                , gender = Just contact.gender
                                , tobacco = Just contact.tobacco
                                , state = Just contact.state
                                , zip = Just contact.zipCode
                                , age = Just contact.age
                                , currentCarrier = contact.currentCarrier
                                , planType = contact.planType
                            }

                        Nothing ->
                            updatedModel0

                cmd =
                    case response.contact of
                        Just _ ->
                            fetchPlans updatedModel

                        Nothing ->
                            Nav.pushUrl
                                model.key
                                ("/self-onboarding/"
                                    ++ response.orgSlug
                                    ++ "?quoteId="
                                    ++ Maybe.withDefault "" model.quoteId
                                )
            in
            ( updatedModel
            , cmd
            )

        GotContactData (Err _) ->
            ( { model
                | error = Just "This quote link appears to be invalid or has expired. Please get a new quote to continue."
                , loadingContact = False
                , isLoading = False
              }
            , Nav.pushUrl model.key "/error?message=This%20quote%20link%20appears%20to%20be%20invalid%20or%20has%20expired.%20Please%20get%20a%20new%20quote%20to%20continue."
            )

        ShowLocationModal ->
            ( { model
                | showLocationModal = True
                , editingZipCode = model.zip
                , editingCounty = Nothing
                , availableCounties = []
                , locationUpdateError = Nothing
                , fetchNewPlans = False
              }
            , Cmd.none
            )

        CloseEditModal ->
            ( { model
                | showLocationModal = False
                , editingZipCode = Nothing
                , editingCounty = Nothing
                , availableCounties = []
                , locationUpdateError = Nothing
                , isLoading = False
                , fetchNewPlans = False
              }
            , Cmd.none
            )

        CloseEditModalAndFetchPlans ->
            let
                maybeEffectiveDate =
                    case model.editingEffectiveDate of
                        Just effectiveDateString ->
                            Date.fromIsoString effectiveDateString
                                |> Result.toMaybe

                        Nothing ->
                            model.effectiveDate

                updatedModel =
                    { model
                        | showLocationModal = False
                        , editingZipCode = Nothing
                        , editingCounty = Nothing
                        , availableCounties = []
                        , locationUpdateError = Nothing
                        , fetchNewPlans = False
                        , effectiveDate = maybeEffectiveDate
                    }
            in
            if model.fetchNewPlans then
                ( { updatedModel
                    | fetchNewPlans = False
                    , isLoading = True
                  }
                , fetchPlans updatedModel
                )

            else
                ( updatedModel
                , Cmd.none
                )

        UpdateZipCode newZip ->
            ( { model | editingZipCode = Just newZip }
            , Cmd.none
            )

        UpdateCounty county ->
            ( { model | editingCounty = Just county }
            , Cmd.none
            )

        UpdateEffectiveDate dateString ->
            let
                updatedModel =
                    { model
                        | effectiveDate = Date.fromIsoString dateString |> Result.toMaybe
                        , editingEffectiveDate = Just dateString
                        , fetchNewPlans = True
                    }
            in
            ( updatedModel
            , Cmd.none
            )

        SubmitLocationUpdate ->
            case model.contact of
                Just contact ->
                    case model.orgSlug of
                        Just orgSlug ->
                            ( { model | submittingLocation = True, locationUpdateError = Nothing }
                            , Http.post
                                { url = "/api/self-service/update-location"
                                , body =
                                    Http.jsonBody
                                        (E.object
                                            [ ( "orgSlug", E.string orgSlug )
                                            , ( "contactId", E.string (String.fromInt contact.id) )
                                            , ( "zipCode", E.string (Maybe.withDefault "" model.editingZipCode) )
                                            , ( "county", E.string (Maybe.withDefault "" model.editingCounty) )
                                            ]
                                        )
                                , expect = Http.expectJson GotLocationUpdate locationUpdateResponseDecoder
                                }
                            )

                        Nothing ->
                            ( { model | locationUpdateError = Just "Organization ID not found" }
                            , Cmd.none
                            )

                Nothing ->
                    ( { model | locationUpdateError = Just "Contact information not found" }
                    , Cmd.none
                    )

        GotLocationUpdate result ->
            case result of
                Ok response ->
                    if response.success then
                        case response.counties of
                            [] ->
                                -- No counties returned, show error
                                ( { model
                                    | locationUpdateError = Just "No counties found for this ZIP code"
                                    , submittingLocation = False
                                  }
                                , Cmd.none
                                )

                            [ singleCounty ] ->
                                -- Only one county, use it and close modal
                                let
                                    -- Update contact with new location info
                                    updatedContact =
                                        model.contact
                                            |> Maybe.map
                                                (\contact ->
                                                    { contact
                                                        | zipCode = response.zipCode
                                                        , state = response.state
                                                        , county = Just singleCounty
                                                    }
                                                )

                                    updatedModel =
                                        { model
                                            | zip = Just response.zipCode
                                            , state = Just response.state
                                            , county = Just singleCounty
                                            , contact = updatedContact
                                            , showLocationModal = False
                                            , editingZipCode = Nothing
                                            , editingCounty = Nothing
                                            , availableCounties = []
                                            , locationUpdateError = Nothing
                                            , submittingLocation = False
                                        }
                                in
                                -- Reload the page to refresh everything
                                ( updatedModel
                                , Nav.reload
                                )

                            multipleCounties ->
                                -- Multiple counties, show dropdown
                                ( { model
                                    | availableCounties = multipleCounties
                                    , zip = Just response.zipCode
                                    , state = Just response.state
                                    , editingCounty = Nothing
                                    , submittingLocation = False
                                  }
                                , Cmd.none
                                )

                    else
                        ( { model
                            | locationUpdateError = Just "Failed to update location"
                            , submittingLocation = False
                          }
                        , Cmd.none
                        )

                Err error ->
                    ( { model
                        | locationUpdateError = Just (httpErrorToString error)
                        , submittingLocation = False
                      }
                    , Cmd.none
                    )

        ToggleMobileTooltip plan ->
            ( { model | activeTooltipPlan = plan }
            , Cmd.none
            )

        NoOp ->
            ( model, Cmd.none )



-- HELPERS


togglePlanType : PlanType -> PlanType
togglePlanType planType =
    case planType of
        PlanG ->
            PlanN

        PlanN ->
            PlanG


getSelectedPlans : Model -> List Plan
getSelectedPlans model =
    let
        plans =
            case model.selectedPlan of
                Just plan ->
                    [ plan ]

                Nothing ->
                    case model.selectedPlanType of
                        PlanG ->
                            model.plans.planG

                        PlanN ->
                            model.plans.planN

        carrierNaics =
            model.currentCarrier
                |> Maybe.andThen stringToCarrier
                |> Maybe.map carrierToNaics

        filteredPlans =
            case carrierNaics of
                Just naicList ->
                    List.filter
                        (\plan ->
                            not (List.member plan.naic naicList)
                        )
                        plans

                Nothing ->
                    plans

        sortedAndLimited =
            List.sortBy .price filteredPlans
                |> List.take 3
    in
    sortedAndLimited



-- Get the top N cheapest plans for a specific plan type


getTopPlans : Model -> List Plan -> Int -> List Plan
getTopPlans model plans count =
    let
        carrierNaics =
            model.currentCarrier
                |> Maybe.andThen stringToCarrier
                |> Maybe.map carrierToNaics

        filteredPlans =
            case carrierNaics of
                Just naicList ->
                    List.filter
                        (\plan ->
                            not (List.member plan.naic naicList)
                        )
                        plans

                Nothing ->
                    plans
    in
    List.sortBy
        (\plan ->
            {--
            if model.showDiscount then
                plan.priceDiscount

            else
            --}
            plan.price
        )
        filteredPlans
        |> List.take count


httpErrorToString : Http.Error -> String
httpErrorToString error =
    case error of
        Http.BadUrl url ->
            "Bad URL: " ++ url ++ ". Please check the URL and try again."

        Http.Timeout ->
            "Request timed out. The server took too long to respond. Please try again later or check your internet connection."

        Http.NetworkError ->
            "Network error. Unable to connect to the server. Please check your internet connection and try again."

        Http.BadStatus statusCode ->
            "Bad status: " ++ String.fromInt statusCode ++ ". The server returned an unexpected status code. Please try again later or contact support if the issue persists."

        Http.BadBody message ->
            "Bad body: " ++ message ++ ". The server response was not in the expected format. Please try again or contact support if the issue persists."



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        closeModalOnEscape : String -> Msg
        closeModalOnEscape key =
            if key == "Escape" then
                case model of
                    _ ->
                        if model.showLocationModal then
                            CloseEditModal

                        else if model.showGvsNVideo then
                            CloseGvsNVideo

                        else if model.showQualificationVideo then
                            CloseQualificationVideo

                        else if model.showRatesVideo then
                            CloseRatesVideo

                        else if model.showFAQ then
                            CloseFAQ

                        else
                            NoOp

            else
                NoOp

        shouldListenForEscape =
            model.showLocationModal
                || model.showGvsNVideo
                || model.showQualificationVideo
                || model.showRatesVideo
                || model.showFAQ
    in
    if shouldListenForEscape then
        Browser.Events.onKeyDown
            (D.map closeModalOnEscape (D.field "key" D.string))

    else
        Sub.none



-- VIEW


viewPersonalInfo : Model -> Html Msg
viewPersonalInfo model =
    div [ class "flex flex-col gap-4 sm:gap-10" ]
        [ div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)]" ]
            [ -- Personal Quote Header
              div [ class "border-b border-[#DCE2E5] bg-[#F9F5FF] px-4 sm:px-6 py-4 rounded-t-[10px]" ]
                [ h2 [ class "text-2xl font-extrabold -tracking-[0.04em] text-[#101828] leading-[1.2]" ] [ text "Personal Quote" ]
                ]
            , div
                [ class "p-4 sm:p-6 flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4 sm:gap-6 bg-white rounded-b-[10px]" ]
                [ div [ class "flex flex-col sm:flex-row gap-4 sm:gap-12" ]
                    [ -- Quote For section
                      div [ class "flex flex-col" ]
                        [ div [ class "mb-2" ]
                            [ p [ class "text-sm text-[#667085] mb-1" ] [ text "Quote For" ]
                            , p [ class "text-[16px] font-medium" ] [ text (Maybe.withDefault "Loading..." model.name) ]
                            , p [ class "text-[12px] text-[#667085]" ]
                                [ text
                                    (if String.contains "F" (model.gender |> Maybe.withDefault "" |> String.toUpper) then
                                        "F"

                                     else
                                        "M"
                                    )
                                , span [ class "text-[#475569] mx-2 font-medium" ] [ text "│" ]
                                , text
                                    (if Maybe.withDefault False model.tobacco then
                                        "Tobacco"

                                     else
                                        "Non-Tobacco"
                                    )
                                , span [ class "text-[#475569] mx-2 font-medium" ] [ text "│" ]
                                , text (String.fromInt (Maybe.withDefault 0 model.age))
                                , text " years"
                                , span [ class "text-[#475569] mx-2 font-medium" ] [ text "│" ]
                                , text (Maybe.withDefault "" model.state)
                                , text " "
                                , text (Maybe.withDefault "" model.zip)
                                ]
                            ]
                        , div [ class "flex flex-col gap-2" ]
                            [ div [ class "flex gap-2" ]
                                [ case model.effectiveDate of
                                    Just date ->
                                        p [ class "text-xs text-[#667085]" ]
                                            [ span [ class "font-medium" ] [ text "Effective Date: " ]
                                            , text (date |> Date.toIsoString |> formatEffectiveDate)
                                            ]

                                    Nothing ->
                                        text ""
                                , button [ class "text-xs text-[#2563EB] underline text-left", onClick ShowLocationModal ] [ text "Change" ]
                                ]
                            , div [ class "hidden sm:block" ]
                                [ div [ class "flex flex-col mt-4 gap-1" ]
                                    [ p [ class "text-xs text-[#667085]" ] [ text "Need a Quote for Someone else?" ]
                                    , a [ href ("/self-onboarding/" ++ Maybe.withDefault "" model.orgSlug), class "text-xs text-[#667085] underline" ] [ text "Start Here" ]
                                    ]
                                ]
                            ]
                        ]

                    -- Mobile divider
                    , div [ class "block sm:hidden h-[1px] bg-[#DCE2E5] my-4" ] []

                    -- Desktop divider
                    , div [ class "hidden sm:block w-[1px] bg-[#DCE2E5]" ] []

                    -- Quote From section
                    , div [ class "flex flex-col min-w-[200px]" ]
                        [ p [ class "text-sm text-[#667085] mb-1" ] [ text "Quote From" ]
                        , let
                            -- Determine whether to use org or agent details
                            effectiveUseOrg =
                                if model.forceOrgSenderDetails then
                                    True

                                else
                                    case model.agent of
                                        Just agent ->
                                            agent.useOrgSenderDetails

                                        Nothing ->
                                            model.useOrg

                            -- fallback to old logic
                          in
                          if effectiveUseOrg then
                            -- Organization information
                            div []
                                [ case model.orgSignatureText of
                                    Just signature ->
                                        div [ class "mb-2" ]
                                            [ text signature ]

                                    Nothing ->
                                        p [ class "text-[16px] font-medium mb-2" ]
                                            [ text (Maybe.withDefault "Organization" model.orgName) ]
                                , case model.orgPhone of
                                    Just phone ->
                                        div [ class "flex flex-col gap-3" ]
                                            [ a
                                                [ href ("tel:" ++ String.filter (\c -> c >= '0' && c <= '9') phone)
                                                , class "flex items-center gap-1.5 bg-[#F9F5FF] px-2.5 py-2 rounded hover:bg-[#F4EBFF] transition-colors min-w-[200px] w-fit"
                                                ]
                                                [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 12 12", Svg.Attributes.fill "none" ]
                                                    [ path
                                                        [ Svg.Attributes.fillRule "evenodd"
                                                        , Svg.Attributes.clipRule "evenodd"
                                                        , Svg.Attributes.d "M1.75442 1.13022C2.80442 0.0802194 4.57692 0.160219 5.30817 1.47022L5.7138 2.19709C6.19067 3.05209 5.98755 4.13147 5.2888 4.83897C5.24752 4.90156 5.22497 4.97463 5.2238 5.04959C5.21567 5.20959 5.27255 5.58022 5.84692 6.15397C6.42067 6.72772 6.79067 6.78522 6.9513 6.77709C7.02626 6.77592 7.09934 6.75337 7.16192 6.71209C7.8688 6.01334 8.9488 5.81022 9.8038 6.28709L10.5307 6.69334C11.8407 7.42459 11.9207 9.19584 10.8707 10.2465C10.3088 10.8077 9.56255 11.3071 8.68442 11.3402C7.38442 11.3896 5.22442 11.0533 3.08567 8.91522C0.947548 6.77647 0.611298 4.61709 0.660673 3.31647C0.693798 2.43834 1.19317 1.69147 1.75442 1.13022ZM4.48942 1.92709C4.11442 1.25584 3.10817 1.10209 2.41755 1.79334C1.93317 2.27772 1.61755 2.81209 1.59755 3.35147C1.5563 4.43647 1.82442 6.32772 3.7488 8.25147C5.6738 10.1765 7.56442 10.4446 8.6488 10.4033C9.18817 10.3827 9.7238 10.0677 10.2075 9.58334C10.8988 8.89209 10.745 7.88584 10.0738 7.51147L9.34692 7.10584C8.89505 6.85397 8.25942 6.93959 7.8138 7.38584C7.77005 7.42959 7.4913 7.68959 6.99692 7.71334C6.49067 7.73834 5.87755 7.51084 5.18442 6.81709C4.49005 6.12334 4.26255 5.51022 4.28755 5.00334C4.3113 4.50897 4.57192 4.23022 4.61505 4.18647C5.0613 3.74084 5.14692 3.10584 4.89505 2.65397L4.48942 1.92709Z"
                                                        , Svg.Attributes.fill "#03045E"
                                                        ]
                                                        []
                                                    ]
                                                , span [ class "text-sm text-[#03045E]" ]
                                                    [ text (formatPhoneNumber phone) ]
                                                ]
                                            ]

                                    Nothing ->
                                        text ""
                                ]

                          else
                            -- Agent information
                            div []
                                [ p [ class "text-[16px] font-medium mb-2" ]
                                    [ text
                                        (case model.agent of
                                            Just agent ->
                                                agent.firstName ++ " " ++ agent.lastName

                                            Nothing ->
                                                "Loading..."
                                        )
                                    ]
                                , div [ class "flex flex-col gap-3" ]
                                    [ a
                                        [ href
                                            (case model.agent of
                                                Just agent ->
                                                    "mailto:" ++ agent.email

                                                Nothing ->
                                                    "#"
                                            )
                                        , class "flex items-center gap-1.5 bg-[#F9F5FF] px-2.5 py-2 rounded hover:bg-[#F4EBFF] transition-colors min-w-[200px] w-fit"
                                        ]
                                        [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 12 12", Svg.Attributes.fill "none" ]
                                            [ path [ Svg.Attributes.d "M1 6C1 4.1145 1 3.1715 1.586 2.586C2.1715 2 3.1145 2 5 2H7C8.8855 2 9.8285 2 10.414 2.586C11 3.1715 11 4.1145 11 6C11 7.8855 11 8.8285 10.414 9.414C9.8285 10 8.8855 10 7 10H5C3.1145 10 2.1715 10 1.586 9.414C1 8.8285 1 7.8855 1 6Z", Svg.Attributes.stroke "#03045E" ] []
                                            , path [ Svg.Attributes.d "M3 4L4.0795 4.9C4.998 5.665 5.457 6.0475 6 6.0475C6.543 6.0475 7.0025 5.665 7.9205 4.8995L9 4", Svg.Attributes.stroke "#03045E", Svg.Attributes.strokeLinecap "round", Svg.Attributes.strokeLinejoin "round" ] []
                                            ]
                                        , span [ class "text-sm text-[#03045E]" ]
                                            [ text
                                                (case model.agent of
                                                    Just agent ->
                                                        agent.email

                                                    Nothing ->
                                                        "Loading..."
                                                )
                                            ]
                                        ]
                                    , a
                                        [ href
                                            (case model.agent of
                                                Just agent ->
                                                    "tel:" ++ String.filter (\c -> c >= '0' && c <= '9') agent.phone

                                                Nothing ->
                                                    "#"
                                            )
                                        , class "flex items-center gap-1.5 bg-[#F9F5FF] px-2.5 py-2 rounded hover:bg-[#F4EBFF] transition-colors min-w-[200px] w-fit"
                                        ]
                                        [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 12 12", Svg.Attributes.fill "none" ]
                                            [ path
                                                [ Svg.Attributes.fillRule "evenodd"
                                                , Svg.Attributes.clipRule "evenodd"
                                                , Svg.Attributes.d "M1.75442 1.13022C2.80442 0.0802194 4.57692 0.160219 5.30817 1.47022L5.7138 2.19709C6.19067 3.05209 5.98755 4.13147 5.2888 4.83897C5.24752 4.90156 5.22497 4.97463 5.2238 5.04959C5.21567 5.20959 5.27255 5.58022 5.84692 6.15397C6.42067 6.72772 6.79067 6.78522 6.9513 6.77709C7.02626 6.77592 7.09934 6.75337 7.16192 6.71209C7.8688 6.01334 8.9488 5.81022 9.8038 6.28709L10.5307 6.69334C11.8407 7.42459 11.9207 9.19584 10.8707 10.2465C10.3088 10.8077 9.56255 11.3071 8.68442 11.3402C7.38442 11.3896 5.22442 11.0533 3.08567 8.91522C0.947548 6.77647 0.611298 4.61709 0.660673 3.31647C0.693798 2.43834 1.19317 1.69147 1.75442 1.13022ZM4.48942 1.92709C4.11442 1.25584 3.10817 1.10209 2.41755 1.79334C1.93317 2.27772 1.61755 2.81209 1.59755 3.35147C1.5563 4.43647 1.82442 6.32772 3.7488 8.25147C5.6738 10.1765 7.56442 10.4446 8.6488 10.4033C9.18817 10.3827 9.7238 10.0677 10.2075 9.58334C10.8988 8.89209 10.745 7.88584 10.0738 7.51147L9.34692 7.10584C8.89505 6.85397 8.25942 6.93959 7.8138 7.38584C7.77005 7.42959 7.4913 7.68959 6.99692 7.71334C6.49067 7.73834 5.87755 7.51084 5.18442 6.81709C4.49005 6.12334 4.26255 5.51022 4.28755 5.00334C4.3113 4.50897 4.57192 4.23022 4.61505 4.18647C5.0613 3.74084 5.14692 3.10584 4.89505 2.65397L4.48942 1.92709Z"
                                                , Svg.Attributes.fill "#03045E"
                                                ]
                                                []
                                            ]
                                        , span [ class "text-sm text-[#03045E]" ]
                                            [ text
                                                (case model.agent of
                                                    Just agent ->
                                                        formatPhoneNumber agent.phone

                                                    Nothing ->
                                                        "Loading..."
                                                )
                                            ]
                                        ]
                                    ]
                                ]
                        ]

                    -- Desktop divider before video
                    , div [ class "hidden sm:block w-[1px] bg-[#DCE2E5]" ] []

                    -- Video button section
                    , div [ class "hidden sm:flex flex-col justify-center items-center cursor-pointer gap-2 bg-[#F9F5FF] rounded-[10px] p-4 border border-[#DCE2E5] min-w-[200px] min-h-[160px]", onClick OpenGvsNVideo ]
                        [ p [ class "text-base font-bold text-[#03045E] -tracking-[0.03em] leading-[1.21] text-center" ] [ text "Learn About Plan G vs Plan N" ]
                        , div [ class "w-[33px] h-[33px] rounded-full border border-[#03045E] flex items-center justify-center" ]
                            [ div [ class "w-0 h-0 border-t-[8px] border-t-transparent border-l-[12px] border-l-[#03045E] border-b-[8px] border-b-transparent ml-1" ] []
                            ]
                        , p [ class "text-xs text-[#667085] -tracking-[0.03em] leading-[1.21] text-center" ] [ text "Watch the Video" ]
                        ]
                    ]
                ]
            , div [ class "block sm:hidden mt-2 mb-6 justify-center flex items-center w-full" ]
                [ div [ class "text-sm text-[#667085] text-center flex flex-wrap justify-center items-center gap-1" ]
                    [ text "Need a Quote for Someone else? "
                    , a [ href ("/self-onboarding/" ++ Maybe.withDefault "" model.orgSlug), class " underline" ] [ text "Start Here" ]
                    ]
                ]
            ]
        ]


viewPlanCard : Model -> String -> Plan -> Html Msg
viewPlanCard model planTypeCode plan =
    let
        isSelected =
            model.selectedPlan == Just plan

        displayPlanBadgeText =
            case plan.originalPlanName of
                Just originalName ->
                    formatOriginalPlanName originalName

                Nothing ->
                    "PLAN " ++ planTypeCode

        ( badgeTextColor, badgeBgColor ) =
            if planTypeCode == "G" then
                ( "text-[#363F72]", "bg-[#F8F9FC]" )

            else
                ( "text-[#363F72]", "bg-[#F8F9FC]" )

        borderClass =
            if isSelected then
                "border-2 border-[#2563EB]"

            else
                "border border-[#D4D4D4]"

        isTooltipActive =
            case model.activeTooltipPlan of
                Just activePlan ->
                    activePlan.id == plan.id

                Nothing ->
                    False
    in
    div [ class "flex flex-col" ]
        [ div
            [ class ("relative bg-white rounded-lg " ++ borderClass ++ " overflow-hidden cursor-pointer w-[calc(100vw-72px)] sm:w-[340px]")
            , onClick (SelectPlanCard plan)
            ]
            [ -- Top row with Plan type badge and radio
              div [ class "flex items-center justify-between p-2 sm:p-4" ]
                [ div [ class ("px-2.5 py-0.5 rounded-lg text-xs font-medium leading-5 " ++ badgeTextColor ++ " " ++ badgeBgColor) ]
                    [ text displayPlanBadgeText ]
                , div [ class "flex items-center gap-1.5" ]
                    [ span [ class "text-sm sm:text-sm font-medium text-[#667085]" ] [ text "Select This Plan" ]
                    , if isSelected then
                        svg [ Svg.Attributes.width "18", Svg.Attributes.height "19", Svg.Attributes.viewBox "0 0 14 15", Svg.Attributes.fill "none" ]
                            [ Svg.rect [ Svg.Attributes.x "0.5", Svg.Attributes.y "1", Svg.Attributes.width "13", Svg.Attributes.height "13", Svg.Attributes.rx "6.5", Svg.Attributes.fill "#F9F5FF" ] []
                            , Svg.rect [ Svg.Attributes.x "0.5", Svg.Attributes.y "1", Svg.Attributes.width "13", Svg.Attributes.height "13", Svg.Attributes.rx "6.5", Svg.Attributes.stroke "#7F56D9" ] []
                            , Svg.path [ Svg.Attributes.d "M10.5 5.25L6 9.75L3.5 7.25", Svg.Attributes.stroke "#7F56D9", Svg.Attributes.strokeWidth "1.6666", Svg.Attributes.strokeLinecap "round", Svg.Attributes.strokeLinejoin "round" ] []
                            ]

                      else
                        svg [ Svg.Attributes.width "18", Svg.Attributes.height "19", Svg.Attributes.viewBox "0 0 14 15", Svg.Attributes.fill "none" ]
                            [ Svg.rect [ Svg.Attributes.x "0.5", Svg.Attributes.y "1", Svg.Attributes.width "13", Svg.Attributes.height "13", Svg.Attributes.rx "6.5", Svg.Attributes.fill "white" ] []
                            , Svg.rect [ Svg.Attributes.x "0.5", Svg.Attributes.y "1", Svg.Attributes.width "13", Svg.Attributes.height "13", Svg.Attributes.rx "6.5", Svg.Attributes.stroke "#D4D4D4" ] []
                            ]
                    ]
                ]

            -- Carrier Logo
            , div [ class "px-4 flex justify-center items-center min-h-[120px] py-4" ]
                [ img [ src plan.image, alt (plan.name ++ " logo"), class "h-20 max-w-[240px] object-contain" ] [] ]

            -- Rates
            , div [ class "flex justify-between items-center px-6 py-4 bg-[#F9FAFB]" ]
                [ div [ class "flex items-center" ]
                    [ span [ class "text-sm font-medium text-[#667085]" ] [ text "Standard:" ]
                    , span [ class "text-lg font-bold text-[#667085] ml-1" ] [ text ("$" ++ String.fromInt (floor plan.price)) ]
                    ]
                , div [ class "flex items-center" ]
                    [ div [ class "w-[1px] h-[24px] bg-[#DCE2E5] mx-4" ] [] ]
                , div [ class "flex items-center relative group" ]
                    [ span [ class "text-sm font-medium text-[#667085]" ] [ text "Discount:" ]
                    , span [ class "text-lg font-bold text-[#667085] ml-1" ] [ text ("$" ++ String.fromInt (floor plan.priceDiscount)) ]
                    , case plan.discountDescription of
                        Just description ->
                            div [ class "inline-flex ml-1 relative" ]
                                [ -- Desktop hover tooltip (hidden on mobile)
                                  div [ class "hidden sm:inline-flex text-blue-500 cursor-help" ]
                                    [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 24 24", Svg.Attributes.fill "none" ]
                                        [ Svg.circle [ Svg.Attributes.cx "12", Svg.Attributes.cy "12", Svg.Attributes.r "10", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2" ] []
                                        , Svg.path [ Svg.Attributes.d "M12 8v4", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2", Svg.Attributes.strokeLinecap "round" ] []
                                        , Svg.path [ Svg.Attributes.d "M12 16h.01", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2", Svg.Attributes.strokeLinecap "round" ] []
                                        ]
                                    , div [ class "absolute bottom-full mb-2 right-0 w-48 p-2 bg-gray-800 text-white text-xs rounded shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200" ]
                                        [ text description
                                        , div [ class "absolute right-3 top-full -mt-1 border-4 border-transparent border-t-gray-800" ] []
                                        ]
                                    ]

                                -- Mobile tap tooltip icon (hidden on desktop)
                                , div
                                    [ class "sm:hidden inline-flex text-blue-500 cursor-pointer z-10"
                                    , Html.Events.stopPropagationOn "click"
                                        (D.succeed ( ToggleMobileTooltip (Just plan), True ))
                                    ]
                                    [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 24 24", Svg.Attributes.fill "none" ]
                                        [ Svg.circle [ Svg.Attributes.cx "12", Svg.Attributes.cy "12", Svg.Attributes.r "10", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2" ] []
                                        , Svg.path [ Svg.Attributes.d "M12 8v4", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2", Svg.Attributes.strokeLinecap "round" ] []
                                        , Svg.path [ Svg.Attributes.d "M12 16h.01", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2", Svg.Attributes.strokeLinecap "round" ] []
                                        ]
                                    ]
                                ]

                        Nothing ->
                            text ""
                    ]
                ]
            ]
        , div
            [ class
                ("overflow-hidden transition-all duration-300 ease-in-out "
                    ++ (if isSelected then
                            "max-h-[100px] opacity-100 mt-8 mb-8"

                        else
                            "max-h-0 opacity-0 mt-0 mb-0"
                       )
                )
            ]
            [ div [ class "flex justify-center" ]
                [ button
                    [ class "w-[200px] bg-[#03045E] text-white text-sm font-medium px-4 py-4 rounded-lg hover:bg-[#02034D] transition-colors"
                    , onClick (SelectPlan plan)
                    ]
                    [ text "See if I Qualify" ]
                ]
            ]
        ]


viewPlansSection : Model -> Html Msg
viewPlansSection model =
    let
        hasPlanG =
            not (List.isEmpty model.plans.planG)

        hasPlanN =
            not (List.isEmpty model.plans.planN)

        hasAnyPlans =
            hasPlanG || hasPlanN

        hasOriginalPlanNames =
            List.any (\p -> p.originalPlanName /= Nothing) model.plans.planG
                || List.any (\p -> p.originalPlanName /= Nothing) model.plans.planN

        stateSpecificNotice =
            if hasOriginalPlanNames then
                div [ class "bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4" ]
                    [ div [ class "flex items-start gap-3" ]
                        [ svg [ Svg.Attributes.width "20", Svg.Attributes.height "20", Svg.Attributes.viewBox "0 0 20 20", Svg.Attributes.fill "none", Svg.Attributes.class "flex-shrink-0 mt-0.5" ]
                            [ path
                                [ Svg.Attributes.d "M10 0C4.477 0 0 4.477 0 10s4.477 10 10 10 10-4.477 10-10S15.523 0 10 0zm1 15H9v-2h2v2zm0-4H9V5h2v6z"
                                , Svg.Attributes.fill "#2563EB"
                                ]
                                []
                            ]
                        , div [ class "flex-1 space-y-2" ]
                            [ h4 [ class "text-sm font-semibold text-blue-900 mb-1" ]
                                [ text "State-Specific Plan Names" ]
                            , p [ class "text-sm text-blue-800" ]
                                [ text "Your state uses slightly different variations from standardized Medicare Supplement plans. The plans shown reflect these state-specific names and do include additional optional riders that may be available in your state. Premiums may vary accordingly."
                                ]
                            , p [ class "text-sm text-blue-800" ]
                                [ text "We would be happy to discuss these details further with you to help you find the best plan for your needs."
                                ]
                            ]
                        ]
                    ]

            else
                text ""

        planGHeader =
            case List.head model.plans.planG of
                Just firstPlanG ->
                    firstPlanG.originalPlanName
                        |> Maybe.map formatOriginalPlanName
                        |> Maybe.withDefault "Plan G"
                        |> (\name -> name ++ " Monthly Premiums")

                Nothing ->
                    "Plan G Monthly Premiums"

        planNHeader =
            case List.head model.plans.planN of
                Just firstPlanN ->
                    firstPlanN.originalPlanName
                        |> Maybe.map formatOriginalPlanName
                        |> Maybe.withDefault "Plan N"
                        |> (\name -> name ++ " Monthly Premiums")

                Nothing ->
                    "Plan N Monthly Premiums"
    in
    if not hasAnyPlans then
        -- No plans found, display a message with contact info and button
        div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)] mt-6 p-6 sm:p-8 text-center" ]
            [ div [ class "w-12 h-12 rounded-full bg-[#F9F5FF] flex items-center justify-center mx-auto mb-4" ]
                [ svg [ Svg.Attributes.width "26", Svg.Attributes.height "26", Svg.Attributes.viewBox "0 0 24 24", Svg.Attributes.fill "none" ]
                    [ path
                        [ Svg.Attributes.d "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"
                        , Svg.Attributes.stroke "#7F56D9"
                        , Svg.Attributes.strokeWidth "2"
                        , Svg.Attributes.strokeLinecap "round"
                        , Svg.Attributes.strokeLinejoin "round"
                        ]
                        []
                    , path
                        [ Svg.Attributes.d "M12 8V12"
                        , Svg.Attributes.stroke "#7F56D9"
                        , Svg.Attributes.strokeWidth "2"
                        , Svg.Attributes.strokeLinecap "round"
                        , Svg.Attributes.strokeLinejoin "round"
                        ]
                        []
                    , path
                        [ Svg.Attributes.d "M12 16H12.01"
                        , Svg.Attributes.stroke "#7F56D9"
                        , Svg.Attributes.strokeWidth "2"
                        , Svg.Attributes.strokeLinecap "round"
                        , Svg.Attributes.strokeLinejoin "round"
                        ]
                        []
                    ]
                ]
            , h3 [ class "text-lg sm:text-xl font-bold text-[#101828] -tracking-[0.02em] mb-2" ]
                [ text "We couldn't find plans for your specific criteria." ]
            , p [ class "text-sm sm:text-base text-[#667085] mb-4" ]
                [ text "Please give us a call at ", span [ class "font-semibold" ] [ text (getPhoneNumberForDisplay model |> formatPhoneNumber) ], text ". We're happy to help you find the best plan for your needs." ]
            , a
                [ href (getScheduleLink model)
                , class "whitespace-nowrap bg-[#03045E] text-white px-5 sm:px-4 py-3 sm:py-2 rounded-lg hover:bg-[#02034D] transition-colors text-sm sm:text-base w-full sm:w-auto text-center max-w-xs mx-auto block font-semibold"
                ]
                [ text "Connect With Us" ]
            ]

    else
        div [ class "flex flex-col gap-4 sm:gap-0" ]
            [ -- State-specific notice
              stateSpecificNotice

            -- Plan G Section - Desktop and Mobile
            , if hasPlanG then
                div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)]" ]
                    [ -- Header (desktop only)
                      div [ class "hidden sm:flex px-4 sm:px-6 py-4 flex-row items-center justify-between border-b border-[#DCE2E5] bg-[#F9F5FF] rounded-t-[10px]" ]
                        [ div [ class "flex items-end gap-3" ]
                            [ h2 [ class "text-2xl font-extrabold -tracking-[0.04em] text-[#101828] leading-[1.2]" ] [ text "Recommended Plans for You" ]
                            , p [ class "text-[16px] font-medium text-[#667085] -tracking-[0.04em] leading-[1.2] pb-[2px]" ] [ text "Select one to see if you qualify" ]
                            ]
                        ]

                    -- Mobile header
                    , div [ class "block sm:hidden px-4 py-4 border-b border-[#DCE2E5] bg-[#F9F5FF] rounded-t-[10px]" ]
                        [ h2 [ class "text-2xl font-extrabold -tracking-[0.04em] text-[#101828] leading-[1.2]" ] [ text "Recommended Plans" ]
                        , p [ class "text-[16px] font-medium text-[#667085] -tracking-[0.04em] leading-[1.2]" ] [ text "Select one to continue" ]
                        ]

                    -- Plan G Section
                    , div [ class "px-3 sm:px-4 py-6 bg-white" ]
                        [ h3 [ class "text-xl font-extrabold -tracking-[0.02em] mb-6 text-[#101828]" ] [ text planGHeader ]
                        , div [ class "flex flex-wrap gap-8 justify-center sm:justify-start sm:pl-8" ]
                            (List.map (viewPlanCard model "G") (getTopPlans model model.plans.planG 3))
                        ]
                    ]

              else
                text ""

            -- Mobile video button (standalone between Plan G and Plan N)
            -- Only show if both G and N plans are available
            , if hasPlanG && hasPlanN then
                div [ class "block sm:hidden py-4 px-3" ]
                    [ div [ class "mx-auto max-w-[280px] bg-[#F9F5FF] rounded-[10px] p-4 flex flex-row items-center cursor-pointer gap-4", onClick OpenGvsNVideo ]
                        [ div [ class "w-[33px] h-[33px] rounded-full border border-[#03045E] flex items-center justify-center flex-shrink-0" ]
                            [ div [ class "w-0 h-0 border-t-[8px] border-t-transparent border-l-[12px] border-l-[#03045E] border-b-[8px] border-b-transparent ml-1" ] []
                            ]
                        , div [ class "flex flex-col items-start" ]
                            [ p [ class "text-[16px] font-bold text-[#03045E] -tracking-[0.03em] leading-[1.21] text-left" ] [ text "Learn About Plan G vs N" ]
                            , p [ class "text-[12px] text-[#667085] -tracking-[0.03em] leading-[1.21]" ] [ text "Watch the Video" ]
                            ]
                        ]
                    ]

              else
                text ""

            -- Plan N Section (separate container for mobile)
            , if hasPlanN then
                div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)]" ]
                    [ -- Plan N Section Header (Mobile only)
                      div [ class "block sm:hidden px-4 py-4 border-b border-[#DCE2E5] bg-[#F9F5FF] rounded-t-[10px]" ]
                        [ h2 [ class "text-2xl font-extrabold -tracking-[0.04em] text-[#101828] leading-[1.2]" ] [ text "Plan N Options" ]
                        ]

                    -- Plan N Content
                    , div [ class "px-3 sm:px-4 py-6 bg-white" ]
                        [ h3 [ class "text-xl font-extrabold -tracking-[0.02em] mb-6 text-[#101828]" ] [ text planNHeader ]
                        , div [ class "flex flex-wrap gap-8 justify-center sm:justify-start sm:pl-8" ]
                            (List.map (viewPlanCard model "N") (getTopPlans model model.plans.planN 3))
                        ]
                    ]

              else
                text ""

            -- Medicare Advantage Off Ramp Section
            -- This will also be hidden if no plans were found initially by the top-level `if not hasAnyPlans`
            , viewMedicareAdvantageOffRamp model
            ]



-- Medicare Advantage Off Ramp component


viewMedicareAdvantageOffRamp : Model -> Html Msg
viewMedicareAdvantageOffRamp model =
    div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)] mt-6" ]
        [ div [ class "px-4 sm:px-6 py-4 sm:py-5 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 sm:gap-0" ]
            [ div [ class "flex items-start gap-4" ]
                [ -- Icon for the section
                  div [ class "w-12 h-12 rounded-full bg-[#F9F5FF] flex items-center justify-center flex-shrink-0" ]
                    [ svg [ Svg.Attributes.width "26", Svg.Attributes.height "26", Svg.Attributes.viewBox "0 0 24 24", Svg.Attributes.fill "none" ]
                        [ path
                            [ Svg.Attributes.d "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"
                            , Svg.Attributes.stroke "#7F56D9"
                            , Svg.Attributes.strokeWidth "2"
                            , Svg.Attributes.strokeLinecap "round"
                            , Svg.Attributes.strokeLinejoin "round"
                            ]
                            []
                        , path
                            [ Svg.Attributes.d "M12 8V12"
                            , Svg.Attributes.stroke "#7F56D9"
                            , Svg.Attributes.strokeWidth "2"
                            , Svg.Attributes.strokeLinecap "round"
                            , Svg.Attributes.strokeLinejoin "round"
                            ]
                            []
                        , path
                            [ Svg.Attributes.d "M12 16H12.01"
                            , Svg.Attributes.stroke "#7F56D9"
                            , Svg.Attributes.strokeWidth "2"
                            , Svg.Attributes.strokeLinecap "round"
                            , Svg.Attributes.strokeLinejoin "round"
                            ]
                            []
                        ]
                    ]
                , div [ class "flex flex-col" ]
                    [ h3 [ class "text-lg sm:text-xl font-bold text-[#101828] -tracking-[0.02em]" ]
                        [ text "Looking to dramatically lower your monthly costs?" ]
                    , p [ class "text-sm sm:text-base text-[#667085]" ]
                        [ text "Medicare Advantage plans offer $0 monthly premiums with drug coverage included. These plans have improved a lot over recent years, with more benefits and flexibility than ever. If saving money is your priority, let's find the right plan for you." ]
                    ]
                ]
            , div [ class "sm:ml-4 flex justify-center sm:justify-start" ]
                [ a
                    [ href
                        (case model.quoteId of
                            Just id ->
                                let
                                    orgQ =
                                        String.split "-" id
                                            |> List.head
                                            |> Maybe.map
                                                (\org ->
                                                    "?org=" ++ org ++ "&"
                                                )
                                            |> Maybe.withDefault "?"
                                in
                                "/schedule" ++ orgQ ++ "id=" ++ id ++ "&status=decline"

                            Nothing ->
                                "/contact"
                        )
                    , class "whitespace-nowrap bg-[#03045E] text-white px-5 sm:px-4 py-3 sm:py-2 rounded-lg hover:bg-[#02034D] transition-colors text-sm sm:text-base w-full sm:w-auto text-center"
                    ]
                    [ text "Explore Options" ]
                ]
            ]
        ]


view : Model -> Browser.Document Msg
view model =
    { title = "Quote - Medicare Max"
    , body =
        [ viewHeader model.orgLogo model.orgName
        , div [ class "bg-white min-h-screen pb-12 scroll-smooth" ]
            [ if model.loadingContact || model.isLoading then
                viewLoading

              else
                div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3 space-y-8 sm:space-y-10" ]
                    [ -- Personal Quote Card
                      viewPersonalInfo model

                    -- Plans Section (mobile video button moved inside viewPlansSection)
                    , viewPlansSection model
                    ]
            ]
        , viewGvsNModal model
        , viewQualificationModal model
        , viewRatesModal model
        , viewLocationModal model
        , viewMobileTooltip model
        ]
    }


viewLoading : Html Msg
viewLoading =
    div [ class "fixed inset-0 bg-white flex flex-col items-center justify-center gap-4 text-center" ]
        [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-purple-600 border-t-transparent" ] []
        , p [ class "text-center text-lg font-medium text-gray-600" ]
            [ text "Loading your personalized quote..." ]
        , div
            [ class "sm:hidden opacity-0 transition-opacity duration-500 delay-[10000ms] mt-6 px-4 max-w-xs text-center text-sm text-gray-500"
            , style "animation" "fadeIn 0.5s 5s forwards"
            ]
            [ text "If page fails to load, please try refreshing or opening in your device's default browser." ]
        , Html.node "style"
            []
            [ text """
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
              """
            ]
        ]


viewError : String -> Maybe String -> Html Msg
viewError error orgSlug =
    div [ class "fixed inset-0 bg-white flex flex-col items-center justify-center gap-6 text-center px-4" ]
        [ div [ class "max-w-lg" ]
            [ h1 [ class "text-2xl font-semibold text-[#1A1A1A] mb-4" ]
                [ text "Unable to Load Quote" ]
            , p [ class "text-lg text-gray-600 mb-8" ]
                [ text "This quote link appears to be invalid or has expired. Please get a new quote to continue." ]
            , case orgSlug of
                Just slug ->
                    a
                        [ href ("/self-onboarding/" ++ slug)
                        , class "inline-block bg-[#03045E] text-white text-sm font-medium px-6 py-3 rounded hover:bg-[#02034D] transition-colors"
                        ]
                        [ text "Get a New Quote" ]

                Nothing ->
                    text ""
            ]
        ]


viewGvsNModal : Model -> Html Msg
viewGvsNModal model =
    if model.showGvsNVideo then
        div [ class "fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4 backdrop-blur-sm" ]
            [ div [ class "bg-white rounded-lg p-4 pt-8 sm:p-8 w-[95%] h-auto max-w-5xl mx-auto shadow-lg relative" ]
                [ button
                    [ class "absolute top-4 right-4 text-gray-500 hover:text-gray-700 text-xl p-1"
                    , onClick CloseGvsNVideo
                    ]
                    [ text "×" ]
                , h2 [ class "text-xl sm:text-2xl font-bold mb-1 sm:mb-2 text-center" ] [ text "Plan G vs. Plan N" ]
                , p [ class "mb-2 text-center text-sm sm:text-base" ] [ text "Watch this video to learn about the key differences between plans" ]
                , div [ class "w-full mx-auto my-auto h-[450px] sm:h-[500px] mt-2 sm:mt-4 sm:max-w-[90%]" ]
                    [ div [ class "w-full h-full" ]
                        [ iframe
                            -- [ src "https://player.vimeo.com/video/1075091871?autoplay=0&title=0&byline=0&portrait=0&responsive=1" -- education example
                            [ src "https://player.vimeo.com/video/1089216242?autoplay=0&title=0&byline=0&portrait=0&responsive=1"
                            , class "w-full h-full"
                            , attribute "frameborder" "0"
                            , attribute "allow" "autoplay; fullscreen; picture-in-picture"
                            , attribute "allowfullscreen" ""
                            ]
                            []
                        ]
                    ]
                ]
            ]

    else
        text ""


viewQualificationModal : Model -> Html Msg
viewQualificationModal model =
    if model.showQualificationVideo then
        div [ class "fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4 backdrop-blur-sm" ]
            [ div [ class "bg-white rounded-lg p-4 sm:p-8 w-[95%] max-w-5xl mx-auto shadow-lg" ]
                [ button
                    [ class "absolute top-2 right-2 text-gray-500 hover:text-gray-700 text-xl p-1"
                    , onClick CloseQualificationVideo
                    ]
                    [ text "×" ]
                , h1 [ class "text-xl sm:text-2xl font-bold mb-2 sm:mb-4 text-center" ] [ text "Great Choice!" ]
                , h2 [ class "text-lg sm:text-xl font-bold mb-2 sm:mb-4 text-center" ] [ text "Now let's see if you qualify" ]
                , p [ class "mb-3 sm:mb-4 text-center text-sm sm:text-base" ] [ text "Watch this video to understand the process of qualifying for the plan you selected" ]
                , div [ class "w-full max-w-3xl mx-auto" ]
                    [ div [ class "relative", style "padding-top" "100%" ]
                        [ iframe
                            [ src "https://player.vimeo.com/video/1089216242?autoplay=0&title=0&byline=0&portrait=0&responsive=1"
                            , class "w-full h-full absolute top-0 left-0"
                            , attribute "frameborder" "0"
                            , attribute "allow" "autoplay; fullscreen; picture-in-picture"
                            , attribute "allowfullscreen" ""
                            ]
                            []
                        ]
                    ]
                , button
                    [ class "bg-purple-500 text-white px-4 sm:px-6 py-2 rounded hover:bg-purple-600 mt-4 w-full sm:w-auto"
                    , onClick CloseQualificationVideo
                    ]
                    [ text "Continue" ]
                ]
            ]

    else
        text ""


viewRatesModal : Model -> Html Msg
viewRatesModal model =
    if model.showRatesVideo then
        let
            rateText =
                case List.head (getSelectedPlans model) of
                    Just plan ->
                        "$" ++ String.fromFloat plan.price

                    Nothing ->
                        ""

            countyText =
                Maybe.withDefault "" model.county

            stateText =
                Maybe.withDefault "" model.state

            planTypeText =
                case model.selectedPlanType of
                    PlanG ->
                        "Plan G"

                    PlanN ->
                        "Plan N"
        in
        div [ class "fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4 backdrop-blur-sm" ]
            [ div [ class "bg-white rounded-lg p-4 sm:p-8 w-[95%] max-w-5xl mx-auto shadow-lg" ]
                [ button
                    [ class "absolute top-2 right-2 text-gray-500 hover:text-gray-700 text-xl p-1"
                    , onClick CloseRatesVideo
                    ]
                    [ text "×" ]
                , h1 [ class "text-xl sm:text-2xl font-bold mb-2 sm:mb-4 text-center" ] [ text "Good News!" ]
                , h2 [ class "text-base sm:text-xl font-bold mb-2 sm:mb-4 text-center leading-tight" ]
                    [ text ("We found " ++ planTypeText ++ " options as low as " ++ rateText ++ " in " ++ countyText ++ " County, " ++ stateText) ]
                , p [ class "mb-3 sm:mb-4 text-center text-sm sm:text-base" ] [ text "Watch this quick video for 3 things to consider while reviewing your quotes" ]
                , div [ class "w-full max-w-3xl mx-auto" ]
                    [ div [ class "relative", style "padding-top" "100%" ]
                        [ iframe
                            [ src "https://player.vimeo.com/video/1089216242?autoplay=0&title=0&byline=0&portrait=0&responsive=1"
                            , class "w-full h-full absolute top-0 left-0"
                            , attribute "frameborder" "0"
                            , attribute "allow" "autoplay; fullscreen; picture-in-picture"
                            , attribute "allowfullscreen" ""
                            ]
                            []
                        ]
                    ]
                , button
                    [ class "bg-purple-500 text-white px-4 sm:px-6 py-2 rounded hover:bg-purple-600 mt-4 w-full sm:w-auto"
                    , onClick CloseRatesVideo
                    ]
                    [ text "Continue" ]
                ]
            ]

    else
        text ""


viewLocationModal : Model -> Html Msg
viewLocationModal model =
    if model.showLocationModal then
        div [ class "fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4 backdrop-blur-sm" ]
            [ div [ class "bg-white rounded-lg p-6 w-[95%] max-w-md mx-auto shadow-lg" ]
                [ div [ class "flex justify-between items-center mb-4" ]
                    [ h2 [ class "text-xl font-extrabold -tracking-[0.04em] text-[#101828]" ] [ text "Update" ]
                    , button
                        [ class "text-[#667085] hover:text-[#101828] transition-colors"
                        , onClick CloseEditModal
                        ]
                        [ text "×" ]
                    ]
                , case ( model.effectiveDate, model.currentDate ) of
                    ( Just effectiveDate, Just currentDate ) ->
                        let
                            defaultEffectiveDate =
                                model.editingEffectiveDate
                                    |> Maybe.withDefault (Date.toIsoString effectiveDate)
                        in
                        div [ class "mb-4" ]
                            [ label [ class "block text-sm font-medium text-[#667085] mb-1" ]
                                [ text "Effective Date" ]
                            , select
                                [ class "w-full px-3 py-2 border border-[#DCE2E5] rounded-md focus:outline-none focus:ring-1 focus:ring-[#03045E] focus:border-[#03045E]"
                                , onInput UpdateEffectiveDate
                                , value defaultEffectiveDate
                                ]
                                (List.map
                                    (\date ->
                                        option
                                            [ value date, selected (date == defaultEffectiveDate) ]
                                            [ text (formatEffectiveDate date) ]
                                    )
                                    (getNextEffectiveDates currentDate 4)
                                )
                            ]

                    _ ->
                        text ""
                , if model.locationUpdateError /= Nothing then
                    div [ class "mb-4 text-red-600 text-sm" ]
                        [ text (Maybe.withDefault "" model.locationUpdateError) ]

                  else
                    text ""
                , div [ class "flex justify-center" ]
                    [ button
                        [ class "px-4 py-2 bg-[#03045E] text-white rounded hover:bg-[#02034D] transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center min-w-[80px]"
                        , onClick CloseEditModalAndFetchPlans
                        , disabled
                            (String.length (Maybe.withDefault "" model.editingZipCode)
                                /= 5
                                || (not (List.isEmpty model.availableCounties)
                                        && Maybe.withDefault "" model.editingCounty
                                        == ""
                                   )
                                || model.submittingLocation
                            )
                        ]
                        [ if model.submittingLocation then
                            div [ class "animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent mr-2" ] []

                          else
                            text ""
                        , text
                            (if model.submittingLocation then
                                "Updating..."

                             else
                                "Update"
                            )
                        ]
                    ]
                ]
            ]

    else
        text ""


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    let
        cleanPhone =
            String.filter (\c -> c >= '0' && c <= '9') phone
    in
    String.slice 0 3 cleanPhone ++ "-" ++ String.slice 3 6 cleanPhone ++ "-" ++ String.slice 6 10 cleanPhone


contactResponseDecoder : Decoder ContactResponse
contactResponseDecoder =
    D.succeed ContactResponse
        |> Pipeline.optional "contact" (D.oneOf [ D.map Just contactDecoder, D.succeed Nothing ]) Nothing
        |> Pipeline.required "agent" agentDecoder
        |> Pipeline.required "orgSlug" D.string
        |> Pipeline.required "orgName" D.string
        |> Pipeline.required "orgLogo" (D.nullable D.string)
        |> Pipeline.optional "orgPhone" (D.nullable D.string) Nothing
        |> Pipeline.required "orgSignature" D.bool
        |> Pipeline.optional "orgSignatureText" (D.nullable D.string) Nothing
        |> Pipeline.required "carrierContracts" (D.list carrierDecoder)
        |> Pipeline.required "forceOrgSenderDetails" D.bool


contactDecoder : Decoder Contact
contactDecoder =
    D.succeed Contact
        |> Pipeline.required "id" D.int
        |> Pipeline.required "firstName" D.string
        |> Pipeline.required "lastName" D.string
        |> Pipeline.required "email" D.string
        |> Pipeline.required "phoneNumber" D.string
        |> Pipeline.required "age" D.int
        |> Pipeline.required "gender" D.string
        |> Pipeline.required "tobacco" D.bool
        |> Pipeline.required "state" D.string
        |> Pipeline.required "zipCode" D.string
        |> Pipeline.optional "county" (D.nullable D.string) Nothing
        |> Pipeline.optional "currentCarrier" (D.nullable D.string) Nothing
        |> Pipeline.optional "planType" (D.nullable D.string) Nothing


agentDecoder : Decoder Agent
agentDecoder =
    D.succeed Agent
        |> Pipeline.required "firstName" D.string
        |> Pipeline.required "lastName" D.string
        |> Pipeline.required "email" D.string
        |> Pipeline.required "phone" D.string
        |> Pipeline.optional "signature" D.string ""
        |> Pipeline.optional "useOrgSenderDetails" D.bool True
        |> Pipeline.optional "bookingLink" D.string ""


locationUpdateResponseDecoder : Decoder LocationUpdateResponse
locationUpdateResponseDecoder =
    D.map4 LocationUpdateResponse
        (D.field "success" D.bool)
        (D.field "zipCode" D.string)
        (D.field "state" D.string)
        (D.field "counties" (D.list D.string))



-- Helper function to format the date in a more readable way


formatEffectiveDate : String -> String
formatEffectiveDate isoDate =
    case Date.fromIsoString isoDate of
        Ok date ->
            Date.format "MMMM 1, yyyy" date

        Err _ ->
            isoDate



-- Helper function to get next N months of effective dates


getNextEffectiveDates : Date -> Int -> List String
getNextEffectiveDates currentDate count =
    List.range 0 (count - 1)
        |> List.map
            (\n ->
                currentDate
                    |> Date.add Date.Months n
                    |> Date.add Date.Months 1
                    |> Date.floor Date.Month
                    |> Date.toIsoString
            )



-- Mobile tooltip overlay


viewMobileTooltip : Model -> Html Msg
viewMobileTooltip model =
    case model.activeTooltipPlan of
        Just tooltipPlan ->
            case tooltipPlan.discountDescription of
                Just description ->
                    div
                        [ class "sm:hidden fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4"
                        , onClick (ToggleMobileTooltip Nothing)
                        ]
                        [ div
                            [ class "bg-white rounded-lg p-4 max-w-xs w-full shadow-lg text-sm relative"
                            , Html.Events.stopPropagationOn "click" (D.succeed ( NoOp, True ))
                            ]
                            [ button
                                [ class "absolute top-2 right-2 text-gray-500"
                                , onClick (ToggleMobileTooltip Nothing)
                                ]
                                [ text "×" ]
                            , div [ class "font-bold text-gray-800 text-base pb-2" ] [ text (tooltipPlan.name ++ " Discount") ]

                            --, div [ class "text-sm text-gray-700" ] [ text ("Plan " ++ tooltipPlan.planType ++ " Discount") ]
                            , div [ class "pt-3" ] [ text description ]
                            ]
                        ]

                Nothing ->
                    -- If no description, close the tooltip
                    div [ onClick (ToggleMobileTooltip Nothing) ] []

        Nothing ->
            -- No active tooltip
            text ""



-- Helper function to format state-specific plan names for display


formatOriginalPlanName : String -> String
formatOriginalPlanName originalName =
    case String.toUpper originalName of
        "MN_BASIC" ->
            "Minnesota Basic Plan"

        "MN_EXTB" ->
            "Minnesota Extended Basic Plan"

        "WI_BASE" ->
            "Wisconsin Basic Plan"

        "WI_HDED" ->
            "Wisconsin High Deductible Plan"

        "MA_CORE" ->
            "Massachusetts Core Plan"

        "MA_SUPP1" ->
            "Massachusetts Supplement 1 Plan"

        _ ->
            originalName



-- Helper to determine which phone number to display based on org/agent settings


getPhoneNumberForDisplay : Model -> String
getPhoneNumberForDisplay model =
    let
        effectiveUseOrg =
            if model.forceOrgSenderDetails then
                True

            else
                case model.agent of
                    Just agent ->
                        agent.useOrgSenderDetails

                    Nothing ->
                        model.useOrg
    in
    if effectiveUseOrg then
        Maybe.withDefault "" model.orgPhone

    else
        case model.agent of
            Just agent ->
                agent.phone

            Nothing ->
                ""



-- Helper to get the schedule/contact link


getScheduleLink : Model -> String
getScheduleLink model =
    case model.quoteId of
        Just id ->
            let
                orgQ =
                    String.split "-" id
                        |> List.head
                        |> Maybe.map
                            (\org ->
                                "?org=" ++ org ++ "&"
                            )
                        |> Maybe.withDefault "?"
            in
            "/schedule" ++ orgQ ++ "id=" ++ id ++ "&status=decline"

        -- Using "decline" status as per MA off-ramp button
        Nothing ->
            "/contact"

================
File: frontend/src/Contact.elm
================
module Contact exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Browser.Events
import Browser.Navigation as Nav
import Date exposing (Date)
import Dict exposing (Dict)
import EmailScheduler exposing (EmailSchedule, PlanType(..), ScheduledEmail, getScheduledEmails, init, viewFutureActivity)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onBlur, onClick, onInput, onSubmit)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Process
import Task
import Time exposing (Month(..), Posix, Zone)
import Utils.Formatters exposing (formatPhoneNumber)
import Utils.MyDate exposing (dateFromMonthDayYear)



-- TYPES


type alias Contact =
    { id : Int
    , firstName : Maybe String
    , lastName : Maybe String
    , email : String
    , phoneNumber : Maybe String
    , state : Maybe String
    , contactOwnerId : Maybe Int
    , contactOwner : Maybe User
    , currentCarrier : Maybe String
    , effectiveDate : Maybe String
    , birthDate : Maybe String
    , tobaccoUser : Maybe Bool
    , gender : Maybe String
    , zipCode : Maybe String
    , planType : Maybe String
    , status : String
    , agentId : Maybe Int
    , lastEmailed : Maybe String
    }


type alias User =
    { id : Int
    , email : String
    , firstName : String
    , lastName : String
    , isAdmin : Bool
    , isAgent : Bool
    , organizationId : Int
    , isActive : Bool
    , phone : String
    }


type alias ContactForm =
    { id : Maybe Int
    , firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , state : String
    , contactOwnerId : Maybe Int
    , currentCarrier : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : Bool
    , gender : String
    , zipCode : String
    , planType : String
    }


emptyForm : ContactForm
emptyForm =
    { id = Nothing
    , firstName = ""
    , lastName = ""
    , email = ""
    , phoneNumber = ""
    , state = ""
    , contactOwnerId = Nothing
    , currentCarrier = ""
    , effectiveDate = ""
    , birthDate = ""
    , tobaccoUser = False
    , gender = "M"
    , zipCode = ""
    , planType = ""
    }



-- MODEL


type alias Activity =
    { submissionDate : String
    , status : ActivityStatus
    , carrierSelected : Maybe String
    , planSelected : Maybe String
    , quoteAmount : Maybe Float
    }


type ActivityStatus
    = QuoteCreated
    | EmailOpened
    | EmailSent Int -- Int represents which email number (1, 2, etc.)


type QuestionType
    = MainQuestion
    | FollowUpQuestion Int -- Parent question ID


type alias EligibilityQuestion =
    { id : Int
    , text : String
    , questionType : QuestionType
    , answer : Maybe (Either Bool String)
    , followUpQuestions : List EligibilityFollowUp
    }


type alias EligibilityFollowUp =
    { id : Int
    , text : String
    , answer : Maybe (Either Bool String)
    }


type Either a b
    = Left a
    | Right b


type Modal
    = NoModal
    | EditModal
    | DeleteConfirmModal
    | HealthAssessmentModal


type alias EmailTrackingRecord =
    { emailType : String
    , scheduledDate : String
    , sendStatus : String
    , sendMode : String
    }


type alias Model =
    { key : Nav.Key
    , contact : Maybe Contact
    , showModal : Modal
    , editForm : ContactForm
    , isSubmittingForm : Bool
    , error : Maybe String
    , emailTrackingRecords : List EmailTrackingRecord
    , isCheckingEmail : Bool
    , emailExists : Bool
    , isDeletingContact : Bool
    , emailSchedule : EmailSchedule
    , quoteUrl : Maybe String
    , isGeneratingQuote : Bool
    , healthStatus : Maybe HealthStatus
    , eligibilityQuestions : List EligibilityQuestion
    , followUps : List FollowUpRequest
    , timeZone : Zone
    , showAllFollowUps : Bool
    , orgSettings : Maybe Settings
    , emailSendSuccess : Bool
    , demoMode : Bool
    }


type alias HealthStatus =
    { status : String
    , answers : Maybe String
    }


type alias FollowUpRequest =
    { type_ : String
    , quoteId : String
    , createdAt : Posix
    }


type alias Settings =
    { stateLicenses : List String
    , carrierContracts : List String
    , stateCarrierSettings : List StateCarrierSetting
    , allowAgentSettings : Bool
    , emailSendBirthday : Bool
    , emailSendPolicyAnniversary : Bool
    , emailSendAep : Bool
    , smartSendEnabled : Bool
    }


type alias StateCarrierSetting =
    { state : String
    , carrier : String
    , active : Bool
    , targetGI : Bool
    }



-- DECODERS


contactDecoder : Decoder Contact
contactDecoder =
    Decode.succeed Contact
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "first_name" (Decode.nullable Decode.string)
        |> Pipeline.required "last_name" (Decode.nullable Decode.string)
        |> Pipeline.required "email" Decode.string
        |> Pipeline.optional "phone_number" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "state" (Decode.nullable Decode.string)
        |> Pipeline.optional "contact_owner_id" (Decode.nullable Decode.int) Nothing
        |> Pipeline.optional "contact_owner" (Decode.nullable userDecoder) Nothing
        |> Pipeline.optional "current_carrier" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "effective_date" (Decode.nullable Decode.string)
        |> Pipeline.required "birth_date" (Decode.nullable Decode.string)
        |> Pipeline.required "tobacco_user" (Decode.nullable Decode.bool)
        |> Pipeline.required "gender" (Decode.nullable Decode.string)
        |> Pipeline.required "zip_code" (Decode.nullable Decode.string)
        |> Pipeline.optional "plan_type" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "status" Decode.string "New"
        |> Pipeline.required "agent_id" (Decode.nullable Decode.int)
        |> Pipeline.optional "last_emailed_date" (Decode.nullable Decode.string) Nothing


userDecoder : Decoder User
userDecoder =
    Decode.succeed User
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "first_name" Decode.string
        |> Pipeline.required "last_name" Decode.string
        |> Pipeline.required "is_admin" Decode.bool
        |> Pipeline.required "is_agent" Decode.bool
        |> Pipeline.required "organization_id" Decode.int
        |> Pipeline.required "is_active" Decode.bool
        |> Pipeline.required "phone" Decode.string


healthStatusDecoder : Decoder HealthStatus
healthStatusDecoder =
    Decode.map2 HealthStatus
        (Decode.field "status" Decode.string)
        (Decode.field "answers" (Decode.nullable Decode.string))


settingsDecoder : Decoder Settings
settingsDecoder =
    Decode.field "success" Decode.bool
        |> Decode.andThen
            (\success ->
                if success then
                    Decode.field "orgSettings" settingsObjectDecoder

                else
                    Decode.fail "Settings request was not successful"
            )


settingsObjectDecoder : Decoder Settings
settingsObjectDecoder =
    Decode.map8 Settings
        (Decode.field "stateLicenses" (Decode.list Decode.string))
        (Decode.field "carrierContracts" (Decode.list Decode.string))
        (Decode.field "stateCarrierSettings" (Decode.list stateCarrierSettingDecoder))
        (Decode.field "allowAgentSettings" Decode.bool)
        (Decode.field "emailSendBirthday" Decode.bool)
        (Decode.field "emailSendPolicyAnniversary" Decode.bool)
        (Decode.field "emailSendAep" Decode.bool)
        (Decode.field "smartSendEnabled" Decode.bool)


stateCarrierSettingDecoder : Decoder StateCarrierSetting
stateCarrierSettingDecoder =
    Decode.succeed StateCarrierSetting
        |> Pipeline.optional "state" Decode.string ""
        |> Pipeline.required "carrier" Decode.string
        |> Pipeline.required "active" Decode.bool
        |> Pipeline.required "targetGI" Decode.bool


emailTrackingDecoder : Decoder EmailTrackingRecord
emailTrackingDecoder =
    Decode.succeed EmailTrackingRecord
        |> Pipeline.required "email_type" Decode.string
        |> Pipeline.required "scheduled_date" Decode.string
        |> Pipeline.required "send_status" Decode.string
        |> Pipeline.required "send_mode" Decode.string



-- INIT


type alias ZipInfo =
    { state : String
    , counties : List String
    , cities : List String
    }


init : Nav.Key -> String -> Bool -> ( Model, Cmd Msg )
init key contactId demoMode =
    let
        initialSchedule =
            EmailScheduler.init
                (String.toInt contactId |> Maybe.withDefault 0)
                (Date.fromCalendarDate 2024 Jan 1)
                (Date.fromCalendarDate 2024 Jan 1)
                (Date.fromCalendarDate 2024 Jan 1)
                NoPlan
                ""
                []
                []
    in
    ( { key = key
      , contact = Nothing
      , showModal = NoModal
      , editForm = emptyForm
      , isSubmittingForm = False
      , error = Nothing
      , emailTrackingRecords = []
      , isCheckingEmail = False
      , emailExists = False
      , isDeletingContact = False
      , emailSchedule = initialSchedule
      , quoteUrl = Nothing
      , isGeneratingQuote = False
      , healthStatus = Nothing
      , eligibilityQuestions = []
      , followUps = []
      , timeZone = Time.utc
      , showAllFollowUps = False
      , orgSettings = Nothing
      , emailSendSuccess = False
      , demoMode = demoMode
      }
    , Cmd.batch
        [ Http.get
            { url = "/api/contacts/" ++ contactId
            , expect = Http.expectJson GotContact contactDecoder
            }
        , Http.get
            { url = "/api/contacts/email-tracking/" ++ contactId
            , expect =
                Http.expectJson GotEmailTracking
                    (Decode.map2 (\s r -> { success = s, trackingRecords = r })
                        (Decode.field "success" Decode.bool)
                        (Decode.field "trackingRecords" (Decode.list emailTrackingDecoder))
                    )
            }
        , Http.get
            { url = "/api/contacts/" ++ contactId ++ "/eligibility"
            , expect = Http.expectJson GotHealthStatus healthStatusDecoder
            }
        , Http.get
            { url = "/api/contacts/" ++ contactId ++ "/follow-ups"
            , expect = Http.expectJson GotFollowUps followUpsDecoder
            }
        , Task.perform GotCurrentTime Date.today
        , Task.perform GotTimeZone Time.here
        ]
    )



-- UPDATE


type Msg
    = NoOp
    | GotContact (Result Http.Error Contact)
    | GotCurrentTime Date
    | GotTimeZone Zone
    | ShowEditModal
    | CloseModal
    | BackToContacts
    | UpdateEditForm ContactFormField String
    | SubmitEditForm
    | ContactUpdated (Result Http.Error Contact)
    | CheckEmail String
    | EmailChecked (Result Http.Error { exists : Bool })
    | LookupZipCode String
    | GotZipLookup (Result Http.Error ZipInfo)
    | ShowDeleteConfirmModal
    | DeleteContact
    | ContactDeleted (Result Http.Error DeleteResponse)
    | GenerateQuoteLink
    | GotQuoteLink (Result Http.Error { quoteId : String, redirectUrl : String })
    | GotHealthStatus (Result Http.Error HealthStatus)
    | ShowHealthAssessmentModal
    | GotFollowUps (Result Http.Error (List FollowUpRequest))
    | ToggleFollowUps
    | GotOrgSettings (Result Http.Error Settings)
    | SendQuoteEmail
    | QuoteEmailSent (Result Http.Error { success : Bool, message : String, trackingRecord : Maybe EmailTrackingRecord })
    | GotEmailTracking (Result Http.Error { success : Bool, trackingRecords : List EmailTrackingRecord })
    | ResetEmailSendState


type ContactFormField
    = FirstName
    | LastName
    | Email
    | PhoneNumber
    | State
    | ContactOwnerId
    | CurrentCarrier
    | EffectiveDate
    | BirthDate
    | TobaccoUser
    | Gender
    | ZipCode
    | PlanType


safeStringToDate : String -> Result String Date
safeStringToDate dateString =
    case Date.fromIsoString dateString of
        Ok date ->
            Ok date

        Err error ->
            case dateFromMonthDayYear dateString of
                Ok date ->
                    Ok date

                Err _ ->
                    Err error


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        GotContact (Ok contact) ->
            let
                defaultDate =
                    Date.fromCalendarDate 1970 Jan 1

                effectiveDateResult =
                    case contact.effectiveDate of
                        Just date ->
                            if String.isEmpty date then
                                Ok defaultDate

                            else
                                safeStringToDate date

                        Nothing ->
                            Ok defaultDate

                birthDateResult =
                    case contact.birthDate of
                        Just date ->
                            if String.isEmpty date then
                                Ok defaultDate

                            else
                                safeStringToDate date

                        Nothing ->
                            Ok defaultDate
            in
            case effectiveDateResult of
                Ok effectiveDate ->
                    case birthDateResult of
                        Ok birthDate ->
                            let
                                planType =
                                    case contact.planType of
                                        Just s ->
                                            case String.toLower s of
                                                "plan n" ->
                                                    PlanN

                                                "n" ->
                                                    PlanN

                                                "plan g" ->
                                                    PlanG

                                                "g" ->
                                                    PlanG

                                                _ ->
                                                    NoPlan

                                        Nothing ->
                                            NoPlan

                                ( stateCarrierSettings, stateLicenses ) =
                                    case model.orgSettings of
                                        Just settings ->
                                            ( settings.stateCarrierSettings, settings.stateLicenses )

                                        Nothing ->
                                            ( [], [] )

                                newSchedule =
                                    EmailScheduler.init
                                        contact.id
                                        effectiveDate
                                        birthDate
                                        model.emailSchedule.currentDate
                                        planType
                                        (Maybe.withDefault "" contact.state)
                                        stateCarrierSettings
                                        stateLicenses
                            in
                            ( { model | contact = Just contact, emailSchedule = newSchedule }
                            , Cmd.batch
                                [ Http.get
                                    { url = "/api/quotes/generate/" ++ String.fromInt contact.id
                                    , expect = Http.expectJson GotQuoteLink quoteLinkDecoder
                                    }
                                , Http.get
                                    { url = "/api/settings"
                                    , expect = Http.expectJson GotOrgSettings settingsDecoder
                                    }
                                ]
                            )

                        Err _ ->
                            ( { model | contact = Just contact, error = Just "Invalid birth date format" }
                            , Cmd.none
                            )

                Err _ ->
                    ( { model | contact = Just contact, error = Just "Invalid effective date format" }
                    , Cmd.none
                    )

        GotContact (Err error) ->
            case error of
                Http.BadStatus 404 ->
                    ( { model | error = Just "Contact not found" }
                    , Cmd.none
                    )

                _ ->
                    ( { model | error = Just "Failed to load contact" }
                    , Cmd.none
                    )

        GotCurrentTime today ->
            let
                currentSchedule =
                    model.emailSchedule

                newSchedule =
                    { currentSchedule | currentDate = today }
            in
            ( { model | emailSchedule = newSchedule }
            , Cmd.none
            )

        GotTimeZone zone ->
            ( { model | timeZone = zone }, Cmd.none )

        ShowEditModal ->
            case model.contact of
                Just contact ->
                    ( { model
                        | showModal = EditModal
                        , editForm =
                            { id = Just contact.id
                            , firstName = Maybe.withDefault "" contact.firstName
                            , lastName = Maybe.withDefault "" contact.lastName
                            , email = contact.email
                            , phoneNumber = Maybe.withDefault "" contact.phoneNumber
                            , state = Maybe.withDefault "" contact.state
                            , contactOwnerId = contact.contactOwnerId
                            , currentCarrier = Maybe.withDefault "" contact.currentCarrier
                            , effectiveDate = Maybe.withDefault "" contact.effectiveDate
                            , birthDate = Maybe.withDefault "" contact.birthDate
                            , tobaccoUser = Maybe.withDefault False contact.tobaccoUser
                            , gender = Maybe.withDefault "" contact.gender
                            , zipCode = Maybe.withDefault "" contact.zipCode
                            , planType = contact.planType |> Maybe.withDefault ""
                            }
                      }
                    , Cmd.none
                    )

                Nothing ->
                    ( model, Cmd.none )

        CloseModal ->
            ( { model | showModal = NoModal }
            , case model.contact of
                Just contact ->
                    Nav.pushUrl model.key ("/contact/" ++ String.fromInt contact.id)

                Nothing ->
                    Cmd.none
            )

        BackToContacts ->
            ( model, Nav.pushUrl model.key "/contacts" )

        UpdateEditForm field value ->
            let
                form =
                    model.editForm

                updatedForm =
                    case field of
                        FirstName ->
                            { form | firstName = value }

                        LastName ->
                            { form | lastName = value }

                        Email ->
                            { form | email = value }

                        PhoneNumber ->
                            { form | phoneNumber = String.filter Char.isDigit value |> String.left 10 }

                        State ->
                            { form | state = value }

                        ContactOwnerId ->
                            { form | contactOwnerId = String.toInt value }

                        CurrentCarrier ->
                            { form | currentCarrier = value }

                        EffectiveDate ->
                            { form | effectiveDate = value }

                        BirthDate ->
                            { form | birthDate = value }

                        TobaccoUser ->
                            { form | tobaccoUser = value == "true" }

                        Gender ->
                            { form | gender = value }

                        ZipCode ->
                            { form | zipCode = value }

                        PlanType ->
                            { form | planType = value }

                cmd =
                    if field == ZipCode && String.length value == 5 then
                        LookupZipCode value
                            |> Task.succeed
                            |> Task.perform identity

                    else if field == Email && String.length value > 0 then
                        checkEmail value

                    else
                        Cmd.none
            in
            ( { model
                | editForm = updatedForm
                , isCheckingEmail = field == Email && String.length value > 0
                , emailExists = False
                , error = Nothing
              }
            , cmd
            )

        SubmitEditForm ->
            case model.editForm.id of
                Just id ->
                    ( { model | isSubmittingForm = True }
                    , Http.request
                        { method = "PUT"
                        , headers = []
                        , url = "/api/contacts/" ++ String.fromInt id
                        , body = Http.jsonBody (encodeContactForm model.editForm)
                        , expect = Http.expectJson ContactUpdated contactDecoder
                        , timeout = Nothing
                        , tracker = Nothing
                        }
                    )

                Nothing ->
                    ( model, Cmd.none )

        ContactUpdated (Ok contact) ->
            ( { model
                | contact = Just contact
                , showModal = NoModal
                , isSubmittingForm = False
                , error = Nothing
              }
            , Cmd.none
            )

        ContactUpdated (Err _) ->
            ( { model
                | isSubmittingForm = False
                , error = Just "Failed to update contact"
              }
            , Cmd.none
            )

        CheckEmail email ->
            ( { model | isCheckingEmail = True }
            , checkEmail email
            )

        EmailChecked (Ok response) ->
            ( { model
                | isCheckingEmail = False
                , emailExists = response.exists
                , error =
                    if response.exists then
                        Just "A contact with this email already exists"

                    else
                        Nothing
              }
            , Cmd.none
            )

        EmailChecked (Err _) ->
            ( { model
                | isCheckingEmail = False
                , error = Just "Failed to check email. Please try again."
              }
            , Cmd.none
            )

        LookupZipCode zipCode ->
            ( model
            , Http.get
                { url = "/api/zip-lookup/" ++ zipCode
                , expect = Http.expectJson GotZipLookup zipInfoDecoder
                }
            )

        GotZipLookup (Ok zipInfo) ->
            let
                form =
                    model.editForm

                updatedForm =
                    { form | state = zipInfo.state }
            in
            ( { model | editForm = updatedForm }
            , Cmd.none
            )

        GotZipLookup (Err _) ->
            ( model, Cmd.none )

        ShowDeleteConfirmModal ->
            ( { model | showModal = DeleteConfirmModal }, Cmd.none )

        DeleteContact ->
            case model.contact of
                Just contact ->
                    ( { model | isDeletingContact = True }
                    , deleteContact contact.id
                    )

                Nothing ->
                    ( model, Cmd.none )

        ContactDeleted (Ok response) ->
            if response.success then
                ( model, Nav.pushUrl model.key "/contacts" )

            else
                ( { model | isDeletingContact = False, error = Just "Failed to delete contact" }, Cmd.none )

        ContactDeleted (Err _) ->
            ( { model | isDeletingContact = False, error = Just "Failed to delete contact" }, Cmd.none )

        GenerateQuoteLink ->
            case model.contact of
                Just contact ->
                    ( { model | isGeneratingQuote = True }
                    , Http.get
                        { url = "/api/quotes/generate/" ++ String.fromInt contact.id
                        , expect = Http.expectJson GotQuoteLink quoteLinkDecoder
                        }
                    )

                Nothing ->
                    ( model, Cmd.none )

        GotQuoteLink (Ok response) ->
            ( { model
                | quoteUrl =
                    case model.contact of
                        Just contact ->
                            let
                                orgId : Maybe String
                                orgId =
                                    response.quoteId
                                        |> String.split "-"
                                        |> List.head

                                outStr : String
                                outStr =
                                    "/compare?id=" ++ response.quoteId
                            in
                            Just outStr

                        Nothing ->
                            Just ("/compare?id=" ++ response.quoteId)
                , isGeneratingQuote = False
              }
            , Cmd.none
            )

        GotQuoteLink (Err _) ->
            ( { model
                | error = Just "Failed to generate quote link"
                , isGeneratingQuote = False
              }
            , Cmd.none
            )

        GotHealthStatus (Ok status) ->
            let
                parsedQuestions =
                    case status.answers of
                        Just answersJson ->
                            parseEligibilityAnswers answersJson

                        Nothing ->
                            []
            in
            ( { model
                | healthStatus = Just status
                , eligibilityQuestions = parsedQuestions
              }
            , Cmd.none
            )

        GotHealthStatus (Err _) ->
            ( model, Cmd.none )

        ShowHealthAssessmentModal ->
            ( { model | showModal = HealthAssessmentModal }, Cmd.none )

        GotFollowUps (Ok followUps) ->
            ( { model | followUps = followUps }
            , Cmd.none
            )

        GotFollowUps (Err _) ->
            ( model, Cmd.none )

        ToggleFollowUps ->
            ( { model | showAllFollowUps = not model.showAllFollowUps }, Cmd.none )

        GotOrgSettings (Ok settings) ->
            let
                currentSchedule =
                    model.emailSchedule

                updatedSchedule =
                    { currentSchedule
                        | stateCarrierSettings = settings.stateCarrierSettings
                        , stateLicenses = settings.stateLicenses
                    }
            in
            ( { model | orgSettings = Just settings, emailSchedule = updatedSchedule }
            , Cmd.none
            )

        GotOrgSettings (Err _) ->
            ( { model | error = Just "Failed to load organization settings" }
            , Cmd.none
            )

        SendQuoteEmail ->
            case model.contact of
                Just contact ->
                    let
                        orgId =
                            contact.contactOwner
                                |> Maybe.map (\owner -> owner.organizationId)
                                |> Maybe.withDefault 0

                        encodedBody =
                            Encode.object
                                [ ( "orgId", Encode.int orgId ) ]
                    in
                    ( { model | isGeneratingQuote = True, emailSendSuccess = False }
                    , Http.post
                        { url = "/api/contacts/" ++ String.fromInt contact.id ++ "/send-quote-email"
                        , body = Http.jsonBody encodedBody
                        , expect =
                            Http.expectJson QuoteEmailSent
                                (Decode.succeed (\s m r -> { success = s, message = m, trackingRecord = r })
                                    |> Pipeline.required "success" Decode.bool
                                    |> Pipeline.required "message" Decode.string
                                    |> Pipeline.optional "trackingRecord" (Decode.nullable emailTrackingDecoder) Nothing
                                )
                        }
                    )

                Nothing ->
                    ( model, Cmd.none )

        QuoteEmailSent (Ok response) ->
            let
                updatedRecords =
                    case response.trackingRecord of
                        Just record ->
                            record :: model.emailTrackingRecords

                        Nothing ->
                            model.emailTrackingRecords
            in
            ( { model
                | isGeneratingQuote = False
                , emailSendSuccess = response.success
                , error =
                    if response.success then
                        Nothing

                    else
                        Just response.message
                , emailTrackingRecords = updatedRecords
              }
            , if response.success then
                Process.sleep 5000
                    |> Task.perform (\_ -> ResetEmailSendState)

              else
                Cmd.none
            )

        QuoteEmailSent (Err _) ->
            ( { model
                | isGeneratingQuote = False
                , emailSendSuccess = False
                , error = Just "Failed to send quote email"
              }
            , Cmd.none
            )

        GotEmailTracking (Ok response) ->
            ( { model | emailTrackingRecords = response.trackingRecords }, Cmd.none )

        GotEmailTracking (Err _) ->
            ( model, Cmd.none )

        ResetEmailSendState ->
            ( { model | emailSendSuccess = False }, Cmd.none )



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Contact Details"
    , body =
        [ div [ class "min-h-screen bg-white" ]
            [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
                [ viewBackButton
                , case model.contact of
                    Just contact ->
                        div []
                            [ viewHeader contact model
                            , if model.error /= Nothing then
                                div [ class "mb-8 p-4 bg-red-50 border border-red-200 rounded-lg text-red-700" ]
                                    [ text (Maybe.withDefault "An error occurred" model.error)
                                    , button [ class "ml-2 underline", onClick BackToContacts ] [ text "Back to Contacts" ]
                                    ]

                              else
                                text ""
                            , viewContactSummary contact model.quoteUrl model.isGeneratingQuote model.healthStatus model.eligibilityQuestions model.followUps model.timeZone model.showAllFollowUps
                            , if model.orgSettings /= Nothing && model.error == Nothing then
                                div [ class "bg-white rounded-lg border border-gray-200 p-6 mb-8" ]
                                    [ viewFutureActivity (getScheduledEmails model.emailSchedule) ]

                              else
                                div [ class "bg-white rounded-lg border border-gray-200 p-6 mb-8" ]
                                    [ h2 [ class "text-lg font-medium mb-4" ] [ text "Future Activity" ]
                                    , div [ class "flex justify-center items-center py-8" ]
                                        [ viewSpinner
                                        , span [ class "ml-3 text-gray-500" ] [ text "Loading future activities..." ]
                                        ]
                                    ]
                            , viewActivity model.emailTrackingRecords
                            ]

                    Nothing ->
                        case model.error of
                            Just errorMsg ->
                                div [ class "text-center py-12" ]
                                    [ div [ class "text-red-600 text-lg mb-4" ] [ text errorMsg ]
                                    , button
                                        [ class "px-4 py-2 text-sm font-medium text-blue-600 hover:text-blue-700 bg-blue-50 hover:bg-blue-100 rounded-lg transition-colors duration-200"
                                        , onClick BackToContacts
                                        ]
                                        [ text "Back to Contacts" ]
                                    ]

                            Nothing ->
                                viewLoading
                ]
            ]
        , viewModals model
        ]
    }


viewBackButton : Html Msg
viewBackButton =
    button
        [ class "mb-6 inline-flex items-center text-sm text-gray-600 hover:text-gray-900"
        , onClick BackToContacts
        ]
        [ span [ class "mr-2" ] [ text "←" ]
        , text "Back to Contacts"
        ]


viewHeader : Contact -> Model -> Html Msg
viewHeader contact model =
    div [ class "flex justify-between items-center mb-8" ]
        [ div [ class "flex items-center gap-4" ]
            [ h1 [ class "text-2xl font-semibold" ]
                [ text (Maybe.withDefault "" contact.firstName ++ " " ++ Maybe.withDefault "" contact.lastName) ]
            , viewEmailStatus contact.status
            ]
        , div [ class "flex gap-2" ]
            [ button
                [ class
                    (String.join " "
                        [ "px-4 py-2 text-sm font-medium rounded-lg transition-colors duration-200 flex items-center gap-2"
                        , if model.demoMode then
                            "text-blue-400 bg-blue-50 cursor-not-allowed"

                          else
                            "text-blue-600 hover:text-blue-700 bg-blue-50 hover:bg-blue-100"
                        ]
                    )
                , onClick
                    (if model.isGeneratingQuote || model.emailSendSuccess || model.demoMode then
                        NoOp

                     else
                        SendQuoteEmail
                    )
                , disabled model.demoMode
                ]
                (if model.isGeneratingQuote then
                    [ viewSpinner
                    , text "Sending..."
                    ]

                 else if model.emailSendSuccess then
                    [ span [ class "text-green-600" ] [ text "✓" ]
                    , text "Email Sent"
                    ]

                 else
                    [ text "Send Quote" ]
                )
            , button
                [ class "px-4 py-2 text-sm font-medium text-purple-600 hover:text-purple-700 bg-purple-50 hover:bg-purple-100 rounded-lg transition-colors duration-200 flex items-center gap-2"
                , onClick ShowEditModal
                ]
                [ text "Edit" ]
            , button
                [ class "px-4 py-2 text-sm font-medium text-red-600 hover:text-red-700 bg-red-50 hover:bg-red-100 rounded-lg transition-colors duration-200 flex items-center gap-2"
                , onClick ShowDeleteConfirmModal
                ]
                [ text "Delete" ]
            ]
        ]


viewContactSummary : Contact -> Maybe String -> Bool -> Maybe HealthStatus -> List EligibilityQuestion -> List FollowUpRequest -> Zone -> Bool -> Html Msg
viewContactSummary contact quoteUrl isGeneratingQuote healthStatus eligibilityQuestions followUps zone showAllFollowUps =
    let
        followUpsSection =
            if not (List.isEmpty followUps) then
                div [ class "bg-white rounded-lg border border-gray-200 p-6 mb-8" ]
                    [ div [ class "flex justify-between items-center mb-6" ]
                        [ h2 [ class "text-lg font-medium" ] [ text "Follow-up Requests" ] ]
                    , div [ class "space-y-4" ]
                        (List.take
                            (if showAllFollowUps then
                                List.length followUps

                             else
                                2
                            )
                            followUps
                            |> List.map (viewFollowUpRequest zone)
                        )
                    , if not showAllFollowUps && List.length followUps > 2 then
                        div [ class "mt-4 text-center" ]
                            [ button
                                [ class "text-sm text-purple-600 hover:text-purple-800"
                                , onClick ToggleFollowUps
                                ]
                                [ text ("Show " ++ String.fromInt (List.length followUps - 2) ++ " More") ]
                            ]

                      else if showAllFollowUps then
                        div [ class "mt-4 text-center" ]
                            [ button
                                [ class "text-sm text-purple-600 hover:text-purple-800"
                                , onClick ToggleFollowUps
                                ]
                                [ text "Show Less" ]
                            ]

                      else
                        text ""
                    ]

            else
                text ""
    in
    div []
        [ div [ class "bg-white rounded-lg border border-gray-200 p-6 mb-8" ]
            [ h2 [ class "text-lg font-medium mb-6" ] [ text "Contact Summary" ]
            , div [ class "grid grid-cols-2 gap-x-8 gap-y-6" ]
                [ viewField "Date of Birth" (Maybe.withDefault "" contact.birthDate)
                , viewField "Contact Owner" (Maybe.map .firstName contact.contactOwner |> Maybe.withDefault "Default")
                , viewField "Phone Number" (formatPhoneNumber (Maybe.withDefault "" contact.phoneNumber))
                , viewField "Email" contact.email
                , viewField "Current Carrier" (Maybe.withDefault "" contact.currentCarrier)
                , viewField "Gender" (Maybe.withDefault "" contact.gender)
                , viewField "Tobacco Use"
                    (if Maybe.withDefault False contact.tobaccoUser then
                        "Yes"

                     else
                        "No"
                    )
                , viewField "State" (Maybe.withDefault "" contact.state)
                , viewField "Zip Code" (Maybe.withDefault "" contact.zipCode)
                , viewField "Effective Date" (Maybe.withDefault "" contact.effectiveDate)
                , viewField "Plan Type" (Maybe.withDefault "" contact.planType)
                , viewQuoteField quoteUrl isGeneratingQuote
                , viewHealthStatusField healthStatus eligibilityQuestions
                ]
            ]
        , followUpsSection
        ]


viewQuoteField : Maybe String -> Bool -> Html Msg
viewQuoteField quoteUrl isGeneratingQuote =
    div []
        [ div [ class "text-sm font-medium text-gray-500" ] [ text "Quote Link" ]
        , div [ class "mt-1" ]
            [ case quoteUrl of
                Just url ->
                    a
                        [ href url
                        , class "text-sm text-blue-600 hover:text-blue-800 underline"
                        , target "_blank"
                        ]
                        [ text "View Quote" ]

                Nothing ->
                    if isGeneratingQuote then
                        viewSpinner

                    else
                        text "-"
            ]
        ]


viewHealthStatusField : Maybe HealthStatus -> List EligibilityQuestion -> Html Msg
viewHealthStatusField maybeStatus questions =
    div []
        [ div [ class "text-sm font-medium text-gray-500" ] [ text "Health Status" ]
        , div [ class "mt-1" ]
            [ case maybeStatus of
                Just status ->
                    let
                        hasYesAnswers =
                            List.any
                                (\q ->
                                    case q.answer of
                                        Just (Left True) ->
                                            q.questionType == MainQuestion

                                        _ ->
                                            False
                                )
                                questions
                    in
                    div [ class "flex items-center" ]
                        [ if List.isEmpty questions then
                            -- No eligibility questions means not completed
                            div [ class "flex items-center text-gray-500 text-sm" ]
                                [ span [ class "mr-1" ] [ text "•" ]
                                , text "Not Completed"
                                ]

                          else if hasYesAnswers then
                            div [ class "flex items-center text-red-600 text-sm" ]
                                [ span [ class "mr-1" ] [ text "✕" ]
                                , text "Issue Flagged"
                                ]

                          else
                            div [ class "flex items-center text-green-600 text-sm" ]
                                [ span [ class "mr-1" ] [ text "✓" ]
                                , text "Pass"
                                ]
                        , button
                            [ class "ml-3 text-blue-600 text-sm hover:text-blue-800 underline"
                            , onClick ShowHealthAssessmentModal
                            ]
                            [ text "View Details" ]
                        ]

                Nothing ->
                    div [ class "text-gray-600 text-sm" ]
                        [ text "Loading..." ]
            ]
        ]


viewField : String -> String -> Html Msg
viewField label value =
    div []
        [ div [ class "text-sm font-medium text-gray-500" ] [ text label ]
        , div [ class "mt-1 text-sm text-gray-900" ] [ text value ]
        ]


viewActivity : List EmailTrackingRecord -> Html Msg
viewActivity records =
    div [ class "bg-white rounded-lg border border-gray-200 p-6" ]
        [ h2 [ class "text-lg font-medium mb-6" ] [ text "Email Activity" ]
        , table [ class "min-w-full" ]
            [ thead [ class "bg-gray-50" ]
                [ tr []
                    [ th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase" ] [ text "Date" ]
                    , th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase" ] [ text "Email Type" ]
                    , th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase" ] [ text "Status" ]
                    , th [ class "px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase" ] [ text "Mode" ]
                    ]
                ]
            , tbody [ class "divide-y divide-gray-200" ]
                (List.map viewEmailTrackingRow records)
            ]
        ]


viewEmailTrackingRow : EmailTrackingRecord -> Html Msg
viewEmailTrackingRow record =
    tr [ class "hover:bg-gray-50" ]
        [ td [ class "px-3 py-2 text-sm text-gray-900" ] [ text record.scheduledDate ]
        , td [ class "px-3 py-2 text-sm text-gray-900" ] [ text (formatEmailType record.emailType) ]
        , td [ class "px-3 py-2 text-sm" ] [ viewEmailStatus record.sendStatus ]
        , td [ class "px-3 py-2 text-sm text-gray-900" ] [ text (formatSendMode record.sendMode) ]
        ]


formatEmailType : String -> String
formatEmailType emailType =
    case emailType of
        "quote_email" ->
            "Quote Email"

        "follow_up_1" ->
            "Follow-up #1"

        "follow_up_2" ->
            "Follow-up #2"

        "follow_up_3" ->
            "Follow-up #3"

        "birthday" ->
            "Birthday Email"

        "anniversary" ->
            "Anniversary Email"

        _ ->
            emailType


formatSendMode : String -> String
formatSendMode mode =
    case mode of
        "production" ->
            "Production"

        "test" ->
            "Test"

        _ ->
            mode


viewEmailStatus : String -> Html Msg
viewEmailStatus status =
    let
        ( bgColor, textColor, statusText ) =
            case status of
                "sent" ->
                    ( "bg-green-50", "text-green-700", "Sent" )

                "scheduled" ->
                    ( "bg-blue-50", "text-blue-700", "Scheduled" )

                "failed" ->
                    ( "bg-red-50", "text-red-700", "Failed" )

                "opened" ->
                    ( "bg-purple-50", "text-purple-700", "Opened" )

                _ ->
                    ( "bg-gray-50", "text-gray-700", status )
    in
    div [ class ("inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium " ++ bgColor ++ " " ++ textColor) ]
        [ text statusText ]


viewModals : Model -> Html Msg
viewModals model =
    case model.showModal of
        NoModal ->
            text ""

        EditModal ->
            viewEditModal model

        DeleteConfirmModal ->
            viewDeleteConfirmModal model

        HealthAssessmentModal ->
            viewHealthAssessmentModal model


viewEditModal : Model -> Html Msg
viewEditModal model =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-5xl w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ text "×" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Edit Contact" ]
            , viewContactForm model.editForm model.isSubmittingForm model
            ]
        ]


viewContactForm : ContactForm -> Bool -> Model -> Html Msg
viewContactForm form isSubmitting model =
    let
        carrierOptions =
            ( "", "Select a carrier" ) :: List.map (\c -> ( c, c )) (model.orgSettings |> Maybe.map .carrierContracts |> Maybe.withDefault []) ++ [ ( "Other", "Other" ) ]

        planTypeOptions =
            [ ( "", "Select a plan type" ), ( "Plan N", "Plan N" ), ( "Plan G", "Plan G" ), ( "Other", "Other" ) ]

        agentOptions =
            case model.orgSettings of
                Just settings ->
                    case settings.allowAgentSettings of
                        True ->
                            -- If agent settings are allowed, show all agents (if available)
                            []

                        -- TODO: Populate with agents if available in model
                        False ->
                            []

                Nothing ->
                    []

        selectedCarrier =
            form.currentCarrier

        selectedPlanType =
            form.planType

        selectedAgentId =
            form.contactOwnerId |> Maybe.map String.fromInt |> Maybe.withDefault ""
    in
    Html.form [ onSubmit SubmitEditForm ]
        [ div [ class "grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-3" ]
            [ viewFormInput "First Name" "text" form.firstName FirstName model True
            , viewFormInput "Last Name" "text" form.lastName LastName model True
            , viewFormInput "Email" "email" form.email Email model True
            , viewFormInput "Phone Number" "text" form.phoneNumber PhoneNumber model False
            , viewFormSelect "Current Carrier" selectedCarrier CurrentCarrier model carrierOptions
            , viewFormSelect "Plan Type" selectedPlanType PlanType model planTypeOptions
            , viewFormInput "Effective Date" "date" form.effectiveDate EffectiveDate model False
            , viewFormInput "Birth Date" "date" form.birthDate BirthDate model False
            , viewFormRadioGroup "Tobacco User"
                (if form.tobaccoUser then
                    "true"

                 else
                    "false"
                )
                TobaccoUser
                model
                [ ( "true", "Yes" ), ( "false", "No" ) ]
            , viewFormRadioGroup "Gender" form.gender Gender model [ ( "M", "Male" ), ( "F", "Female" ) ]
            , div [ class "col-span-1 sm:col-span-2 grid grid-cols-1 sm:grid-cols-2 gap-x-4" ]
                [ viewZipCodeField model form
                , viewStateField form
                ]
            ]
        , if model.error /= Nothing && not model.emailExists then
            div [ class "mt-2 text-red-600 text-xs" ] [ text (Maybe.withDefault "" model.error) ]

          else
            text ""
        , div [ class "mt-4 flex justify-end space-x-2" ]
            [ button
                [ type_ "button"
                , onClick CloseModal
                , class "px-3 py-1.5 bg-white text-gray-700 text-sm font-medium rounded-md border border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200 focus:ring-1 focus:ring-purple-100"
                ]
                [ text "Cancel" ]
            , if isSubmitting then
                div [ class "px-3 py-1.5 flex items-center" ] [ viewSpinner ]

              else
                let
                    isValid =
                        String.length form.firstName > 0 && String.length form.lastName > 0 && String.length form.email > 0 && not model.emailExists && not model.isCheckingEmail
                in
                button
                    [ type_ "submit"
                    , class
                        ("px-3 py-1.5 text-white text-sm font-medium rounded-md transition-colors duration-200 focus:ring-1 focus:ring-purple-200 "
                            ++ (if isValid then
                                    "bg-purple-500 hover:bg-purple-600"

                                else
                                    "bg-gray-300 cursor-not-allowed"
                               )
                        )
                    , Html.Attributes.disabled (not isValid)
                    ]
                    [ text "Save Changes" ]
            ]
        ]


viewFormInput : String -> String -> String -> ContactFormField -> Model -> Bool -> Html Msg
viewFormInput labelText inputType inputValue field model isRequired =
    let
        displayValue =
            if field == PhoneNumber then
                Utils.Formatters.formatPhoneNumber inputValue

            else
                inputValue

        inputHandler =
            if field == PhoneNumber then
                \val -> UpdateEditForm field (String.filter Char.isDigit val |> String.left 10)

            else
                UpdateEditForm field

        placeholderText =
            if field == PhoneNumber then
                "(555) 555-5555"

            else
                ""
    in
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ] [ text labelText ]
        , Html.input
            [ type_ inputType
            , class "w-full px-2 py-1.5 bg-white border-[1.5px] border-purple-300 rounded-md text-sm text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-1 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , Html.Attributes.value displayValue
            , onInput inputHandler
            , required isRequired
            , placeholder placeholderText
            ]
            []
        ]


viewFormSelect : String -> String -> ContactFormField -> Model -> List ( String, String ) -> Html Msg
viewFormSelect labelText selectedValue field model options =
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ] [ text labelText ]
        , Html.select
            [ class "w-full px-2 py-1.5 bg-white border-[1.5px] border-purple-300 rounded-md text-sm text-gray-700 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-1 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , Html.Attributes.value selectedValue
            , onInput (UpdateEditForm field)
            ]
            (List.map (\( val, label ) -> Html.option [ value val, selected (val == selectedValue) ] [ text label ]) options)
        ]


viewFormRadioGroup : String -> String -> ContactFormField -> Model -> List ( String, String ) -> Html Msg
viewFormRadioGroup labelText selectedValue field model options =
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ] [ text labelText ]
        , div [ class "flex gap-2" ]
            (List.map
                (\( val, txt ) ->
                    label
                        [ class
                            ("flex items-center px-2 py-1 rounded-md border text-sm cursor-pointer transition-all duration-200 "
                                ++ (if selectedValue == val then
                                        "border-purple-500 bg-purple-50 text-purple-700"

                                    else
                                        "border-gray-200 hover:border-purple-200"
                                   )
                            )
                        ]
                        [ input
                            [ type_ "radio"
                            , value val
                            , checked (selectedValue == val)
                            , onInput (\_ -> UpdateEditForm field val)
                            , class "sr-only"
                            ]
                            []
                        , text txt
                        ]
                )
                options
            )
        ]


viewZipCodeField : Model -> ContactForm -> Html Msg
viewZipCodeField model form =
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ] [ text "ZIP Code" ]
        , Html.input
            [ type_ "text"
            , class "w-full px-2 py-1.5 bg-white border-[1.5px] border-purple-300 rounded-md text-sm text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-1 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , Html.Attributes.value form.zipCode
            , onInput (UpdateEditForm ZipCode)
            ]
            []
        ]


viewStateField : ContactForm -> Html Msg
viewStateField form =
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ] [ text "State" ]
        , Html.input
            [ type_ "text"
            , class "w-full px-2 py-1.5 bg-white border-[1.5px] border-gray-200 rounded-md text-sm text-gray-700 placeholder-gray-400 shadow-sm focus:ring-1 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , Html.Attributes.value form.state
            , Html.Attributes.disabled True
            ]
            []
        ]


viewLoading : Html Msg
viewLoading =
    div [ class "flex justify-center items-center h-64" ]
        [ div [ class "animate-spin rounded-full h-8 w-8 border-2 border-purple-500 border-t-transparent" ] [] ]


viewSpinner : Html msg
viewSpinner =
    div [ class "animate-spin rounded-full h-5 w-5 border-2 border-purple-500 border-t-transparent" ] []



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    if model.showModal /= NoModal then
        Browser.Events.onKeyDown
            (Decode.map
                (\key ->
                    if key == "Escape" then
                        CloseModal

                    else
                        NoOp
                )
                (Decode.field "key" Decode.string)
            )

    else
        Sub.none


checkEmail : String -> Cmd Msg
checkEmail email =
    Http.get
        { url = "/api/contacts/check-email/" ++ email
        , expect = Http.expectJson EmailChecked (Decode.map (\exists -> { exists = exists }) (Decode.field "exists" Decode.bool))
        }


lookupZipCode : String -> Cmd Msg
lookupZipCode zipCode =
    Http.get
        { url = "/api/zip-lookup/" ++ zipCode
        , expect = Http.expectJson GotZipLookup zipInfoDecoder
        }


zipInfoDecoder : Decode.Decoder ZipInfo
zipInfoDecoder =
    Decode.succeed ZipInfo
        |> Pipeline.required "state" Decode.string
        |> Pipeline.required "counties" (Decode.list Decode.string)
        |> Pipeline.required "cities" (Decode.list Decode.string)


deleteContact : Int -> Cmd Msg
deleteContact contactId =
    Http.request
        { method = "DELETE"
        , headers = []
        , url = "/api/contacts"
        , body = Http.jsonBody (Encode.list Encode.int [ contactId ])
        , expect = Http.expectJson ContactDeleted deleteResponseDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


type alias DeleteResponse =
    { success : Bool
    , deletedIds : List Int
    , message : String
    }


deleteResponseDecoder : Decode.Decoder DeleteResponse
deleteResponseDecoder =
    Decode.map3 DeleteResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "deleted_ids" (Decode.list Decode.int))
        (Decode.field "message" Decode.string)


viewDeleteConfirmModal : Model -> Html Msg
viewDeleteConfirmModal model =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ text "×" ]
            , h2 [ class "text-xl font-semibold text-gray-900 mb-4" ]
                [ text "Delete Contact" ]
            , p [ class "text-sm text-gray-600 mb-6" ]
                [ text "Are you sure you want to delete this contact? This action cannot be undone." ]
            , div [ class "flex justify-end space-x-4" ]
                [ button
                    [ class "px-4 py-2 text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200"
                    , onClick CloseModal
                    ]
                    [ text "Cancel" ]
                , if model.isDeletingContact then
                    div [ class "px-4 py-2 flex items-center" ]
                        [ viewSpinner ]

                  else
                    button
                        [ class "px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors duration-200"
                        , onClick DeleteContact
                        ]
                        [ text "Delete" ]
                ]
            ]
        ]


quoteLinkDecoder : Decode.Decoder { quoteId : String, redirectUrl : String }
quoteLinkDecoder =
    Decode.map2 (\id url -> { quoteId = id, redirectUrl = url })
        (Decode.field "quoteId" Decode.string)
        (Decode.field "redirectUrl" Decode.string)


followUpsDecoder : Decoder (List FollowUpRequest)
followUpsDecoder =
    Decode.list
        (Decode.map3 FollowUpRequest
            (Decode.field "type" Decode.string)
            (Decode.field "quoteId" Decode.string)
            (Decode.field "createdAt" posixDecoder)
        )


posixDecoder : Decoder Posix
posixDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                let
                    parts =
                        String.split " " str

                    datePart =
                        List.head parts |> Maybe.withDefault ""

                    timePart =
                        List.drop 1 parts |> List.head |> Maybe.withDefault ""

                    dateParts =
                        String.split "-" datePart

                    year =
                        List.head dateParts |> Maybe.andThen String.toInt |> Maybe.withDefault 1970

                    month =
                        List.drop 1 dateParts |> List.head |> Maybe.andThen String.toInt |> Maybe.withDefault 1

                    day =
                        List.drop 2 dateParts |> List.head |> Maybe.andThen String.toInt |> Maybe.withDefault 1

                    timeComponents =
                        String.split ":" timePart

                    hour =
                        List.head timeComponents |> Maybe.andThen String.toInt |> Maybe.withDefault 0

                    minute =
                        List.drop 1 timeComponents |> List.head |> Maybe.andThen String.toInt |> Maybe.withDefault 0

                    second =
                        List.drop 2 timeComponents |> List.head |> Maybe.andThen (String.split "." >> List.head) |> Maybe.andThen String.toInt |> Maybe.withDefault 0

                    -- Calculate milliseconds since epoch
                    msPerDay =
                        86400000

                    msPerHour =
                        3600000

                    msPerMinute =
                        60000

                    msPerSecond =
                        1000

                    -- Start with Unix epoch (1970-01-01) and add days
                    daysFromEpoch =
                        (year - 1970)
                            * 365
                            + ((year - 1969) // 4)
                            + (case month of
                                1 ->
                                    0

                                2 ->
                                    31

                                3 ->
                                    59

                                4 ->
                                    90

                                5 ->
                                    120

                                6 ->
                                    151

                                7 ->
                                    181

                                8 ->
                                    212

                                9 ->
                                    243

                                10 ->
                                    273

                                11 ->
                                    304

                                12 ->
                                    334

                                _ ->
                                    0
                              )
                            + day
                            - 1

                    timestamp =
                        daysFromEpoch
                            * msPerDay
                            + hour
                            * msPerHour
                            + minute
                            * msPerMinute
                            + second
                            * msPerSecond
                in
                Decode.succeed (Time.millisToPosix timestamp)
            )


viewFollowUpRequest : Zone -> FollowUpRequest -> Html Msg
viewFollowUpRequest zone followUp =
    div [ class "flex items-center justify-between py-3 border-b border-gray-100 last:border-0" ]
        [ div [ class "flex items-center space-x-4" ]
            [ div [ class "text-sm text-gray-600" ]
                [ text (formatDate zone followUp.createdAt) ]
            , div [ class "text-sm font-medium" ]
                [ text
                    (case followUp.type_ of
                        "accept" ->
                            "Accepted - Ready to Switch"

                        "decline" ->
                            "Declined - Looking for Alternatives"

                        _ ->
                            "General Follow-up Request"
                    )
                ]
            ]
        ]


formatDate : Zone -> Posix -> String
formatDate zone time =
    let
        year =
            String.fromInt (Time.toYear zone time)

        month =
            case Time.toMonth zone time of
                Jan ->
                    "01"

                Feb ->
                    "02"

                Mar ->
                    "03"

                Apr ->
                    "04"

                May ->
                    "05"

                Jun ->
                    "06"

                Jul ->
                    "07"

                Aug ->
                    "08"

                Sep ->
                    "09"

                Oct ->
                    "10"

                Nov ->
                    "11"

                Dec ->
                    "12"

        day =
            String.padLeft 2 '0' (String.fromInt (Time.toDay zone time))

        hour =
            Time.toHour zone time

        ( displayHour, amPm ) =
            if hour == 0 then
                ( "12", "AM" )

            else if hour < 12 then
                ( String.fromInt hour, "AM" )

            else if hour == 12 then
                ( "12", "PM" )

            else
                ( String.fromInt (hour - 12), "PM" )

        minute =
            String.padLeft 2 '0' (String.fromInt (Time.toMinute zone time))
    in
    year ++ "-" ++ month ++ "-" ++ day ++ " at " ++ displayHour ++ ":" ++ minute ++ " " ++ amPm



-- HELPERS


isStateActive : EmailSchedule -> Bool
isStateActive schedule =
    List.member schedule.state schedule.stateLicenses



-- Helper function to parse eligibility answers from JSON string


parseEligibilityAnswers : String -> List EligibilityQuestion
parseEligibilityAnswers jsonStr =
    let
        jsonResult =
            Decode.decodeString (Decode.dict eligibilityQuestionDecoder) jsonStr
    in
    case jsonResult of
        Ok dict ->
            Dict.toList dict
                |> List.map
                    (\( idStr, question ) ->
                        let
                            id =
                                String.toInt idStr |> Maybe.withDefault 0
                        in
                        { question | id = id }
                    )
                |> List.sortBy .id

        Err _ ->
            []


eligibilityQuestionDecoder : Decode.Decoder EligibilityQuestion
eligibilityQuestionDecoder =
    Decode.map5 EligibilityQuestion
        (Decode.succeed 0)
        -- Temporary ID that will be replaced
        (Decode.field "question_text" Decode.string)
        (Decode.field "question_type" questionTypeDecoder)
        (Decode.field "answer" answerDecoder)
        (Decode.oneOf
            [ Decode.field "follow_up_questions" (Decode.list followUpQuestionDecoder)
            , Decode.succeed [] -- Default to empty list if missing
            ]
        )


followUpQuestionDecoder : Decode.Decoder EligibilityFollowUp
followUpQuestionDecoder =
    Decode.map3 EligibilityFollowUp
        (Decode.field "id" Decode.int)
        (Decode.field "question_text" Decode.string)
        (Decode.field "answer" answerDecoder)


questionTypeDecoder : Decode.Decoder QuestionType
questionTypeDecoder =
    Decode.string
        |> Decode.andThen
            (\typeStr ->
                if typeStr == "main" then
                    Decode.succeed MainQuestion

                else if String.startsWith "followup_" typeStr then
                    let
                        parentIdStr =
                            String.dropLeft 9 typeStr

                        parentId =
                            String.toInt parentIdStr |> Maybe.withDefault 0
                    in
                    Decode.succeed (FollowUpQuestion parentId)

                else
                    -- Treat other question types as main questions instead of failing
                    Decode.succeed MainQuestion
            )


answerDecoder : Decode.Decoder (Maybe (Either Bool String))
answerDecoder =
    Decode.oneOf
        [ Decode.bool |> Decode.map (\b -> Just (Left b))
        , Decode.string |> Decode.map (\s -> Just (Right s))
        , Decode.null Nothing
        ]


viewHealthAssessmentModal : Model -> Html Msg
viewHealthAssessmentModal model =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-4 sm:p-8 z-50 overflow-auto" ]
        [ div [ class "bg-white rounded-xl shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col" ]
            [ div [ class "px-6 py-4 border-b border-gray-200 flex justify-between items-center" ]
                [ h2 [ class "text-xl font-semibold text-gray-900" ]
                    [ text "Health Assessment Results" ]
                , button
                    [ class "text-gray-400 hover:text-gray-600 focus:outline-none"
                    , onClick CloseModal
                    ]
                    [ text "×" ]
                ]
            , div [ class "p-6 overflow-auto flex-grow" ]
                [ viewHealthAssessmentContent model.eligibilityQuestions ]
            , div [ class "px-6 py-4 border-t border-gray-200 flex justify-end" ]
                [ button
                    [ class "px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 font-medium"
                    , onClick CloseModal
                    ]
                    [ text "Close" ]
                ]
            ]
        ]


viewHealthAssessmentContent : List EligibilityQuestion -> Html Msg
viewHealthAssessmentContent questions =
    if List.isEmpty questions then
        div [ class "text-center p-8" ]
            [ div [ class "inline-flex items-center justify-center w-12 h-12 rounded-full bg-gray-100 text-gray-500 mb-4" ]
                [ text "!" ]
            , h3 [ class "text-lg font-medium text-gray-700 mb-2" ]
                [ text "Health Assessment Not Completed" ]
            , p [ class "text-gray-600" ]
                [ text "This contact has not yet completed their health assessment questionnaire." ]
            ]

    else
        let
            mainQuestions =
                List.filter (\q -> q.questionType == MainQuestion) questions
                    |> List.sortBy .id

            hasAnyYes =
                List.any
                    (\q ->
                        case q.answer of
                            Just (Left True) ->
                                q.questionType == MainQuestion

                            _ ->
                                False
                    )
                    questions

            statusBorderClass =
                if hasAnyYes then
                    "border-red-200 bg-red-50"

                else
                    "border-green-200 bg-green-50"

            statusIconClass =
                if hasAnyYes then
                    "bg-red-100 text-red-600"

                else
                    "bg-green-100 text-green-600"

            statusTitleClass =
                if hasAnyYes then
                    "text-red-800"

                else
                    "text-green-800"

            statusTextClass =
                if hasAnyYes then
                    "text-red-700"

                else
                    "text-green-700"
        in
        div []
            [ div [ class ("mb-6 p-4 rounded-lg border " ++ statusBorderClass) ]
                [ div [ class "flex items-center" ]
                    [ span [ class ("inline-flex items-center justify-center w-8 h-8 rounded-full " ++ statusIconClass) ]
                        [ if hasAnyYes then
                            text "!"

                          else
                            text "✓"
                        ]
                    , div [ class "ml-3" ]
                        [ h3 [ class ("font-medium " ++ statusTitleClass) ]
                            [ if hasAnyYes then
                                text "Health Issues Identified"

                              else
                                text "All Health Checks Passed"
                            ]
                        , p [ class ("text-sm " ++ statusTextClass) ]
                            [ if hasAnyYes then
                                text "This contact has flagged health conditions that may affect their eligibility."

                              else
                                text "This contact has no health conditions that would affect their eligibility."
                            ]
                        ]
                    ]
                ]
            , div [ class "space-y-6" ]
                (List.map (viewMainQuestionWithFollowups questions) mainQuestions)
            ]


viewMainQuestionWithFollowups : List EligibilityQuestion -> EligibilityQuestion -> Html Msg
viewMainQuestionWithFollowups allQuestions mainQuestion =
    let
        isYes =
            case mainQuestion.answer of
                Just (Left True) ->
                    True

                _ ->
                    False

        borderClass =
            if isYes then
                "border-red-300"

            else
                "border-gray-200"
    in
    div [ class ("rounded-lg border " ++ borderClass ++ " overflow-hidden") ]
        [ div
            [ class
                ("p-4 "
                    ++ (if isYes then
                            "bg-red-50"

                        else
                            "bg-gray-50"
                       )
                )
            ]
            [ div [ class "flex items-start" ]
                [ div [ class "flex-grow" ]
                    [ div [ class "font-medium mb-1" ]
                        [ text mainQuestion.text ]
                    , div
                        [ class
                            ("text-sm font-medium "
                                ++ (if isYes then
                                        "text-red-700"

                                    else
                                        "text-green-700"
                                   )
                            )
                        ]
                        [ text
                            (if isYes then
                                "Yes"

                             else
                                "No"
                            )
                        ]
                    ]
                ]
            ]
        , if isYes && not (List.isEmpty mainQuestion.followUpQuestions) then
            div [ class "divide-y divide-gray-100" ]
                (List.map viewFollowUpQuestionAnswer mainQuestion.followUpQuestions)

          else
            text ""
        ]


viewFollowUpQuestionAnswer : EligibilityFollowUp -> Html Msg
viewFollowUpQuestionAnswer followUp =
    div [ class "p-4 bg-white" ]
        [ div [ class "font-medium text-sm text-gray-700 mb-1" ]
            [ text followUp.text ]
        , div [ class "text-sm" ]
            [ case followUp.answer of
                Just (Left isYes) ->
                    div
                        [ class
                            (if isYes then
                                "text-red-600 font-medium"

                             else
                                "text-green-600 font-medium"
                            )
                        ]
                        [ text
                            (if isYes then
                                "Yes"

                             else
                                "No"
                            )
                        ]

                Just (Right textAnswer) ->
                    if String.isEmpty textAnswer then
                        div [ class "text-gray-500 italic" ]
                            [ text "No answer provided" ]

                    else
                        div [ class "text-gray-900 bg-gray-50 p-2 rounded border border-gray-200" ]
                            [ text textAnswer ]

                Nothing ->
                    div [ class "text-gray-500 italic" ]
                        [ text "No answer" ]
            ]
        ]


encodeContactForm : ContactForm -> Encode.Value
encodeContactForm form =
    Encode.object
        [ ( "first_name", Encode.string form.firstName )
        , ( "last_name", Encode.string form.lastName )
        , ( "email", Encode.string form.email )
        , ( "phone_number", Encode.string (String.filter Char.isDigit form.phoneNumber |> String.left 10) )
        , ( "state", Encode.string form.state )
        , ( "contact_owner_id", Maybe.map Encode.int form.contactOwnerId |> Maybe.withDefault Encode.null )
        , ( "current_carrier", Encode.string form.currentCarrier )
        , ( "effective_date", Encode.string form.effectiveDate )
        , ( "birth_date", Encode.string form.birthDate )
        , ( "tobacco_user", Encode.bool form.tobaccoUser )
        , ( "gender", Encode.string form.gender )
        , ( "zip_code", Encode.string form.zipCode )
        , ( "plan_type", Encode.string form.planType )
        ]

================
File: frontend/src/Contacts.elm
================
module Contacts exposing
    ( Model
    , Msg(..)
    , init
    , subscriptions
    , update
    , view
    )

-- Proper imports for CSV parsing

import Browser
import Browser.Events
import Browser.Navigation as Nav
import Csv.Decode as CsvDecode
import Csv.Parser as CsvParser
import CsvProcessor exposing (CarrierMapping, ColumnMapping, extractHeaders, extractUniqueValues, processCsvToContacts, suggestCarrierMappings, suggestColumnMappings)
import Dict exposing (Dict)
import File exposing (File)
import File.Download
import File.Select as Select
import Html exposing (Html, button, col, colgroup, details, div, h1, h2, h3, input, label, nav, option, p, select, span, summary, table, tbody, td, text, th, thead, tr)
import Html.Attributes exposing (attribute, checked, class, disabled, placeholder, required, selected, title, type_, value)
import Html.Events exposing (on, onClick, onInput, onSubmit, preventDefaultOn, stopPropagationOn)
import Http
import Json.Decode as Decode exposing (Decoder, bool, int, nullable, string)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import List.Extra
import Process
import Svg exposing (path, svg)
import Svg.Attributes exposing (d, fill, stroke, viewBox)
import Task
import Time
import Url exposing (Url)
import Url.Builder as Url
import Utils.Formatters exposing (formatPhoneNumber)



-- MAIN


main : Program () Model Msg
main =
    Browser.application
        { init = \flags url key -> init key Nothing
        , view = \model -> { title = "Dashboard", body = [ view model ] }
        , update = update
        , subscriptions = subscriptions
        , onUrlChange = \_ -> NoOp
        , onUrlRequest = \_ -> NoOp
        }



-- MODEL


type alias Contact =
    { id : Int
    , firstName : Maybe String
    , lastName : Maybe String
    , email : String
    , phoneNumber : Maybe String
    , state : Maybe String
    , contactOwnerId : Maybe Int
    , contactOwner : Maybe User
    , currentCarrier : Maybe String
    , effectiveDate : Maybe String
    , birthDate : Maybe String
    , tobaccoUser : Maybe Bool
    , gender : Maybe String
    , zipCode : Maybe String
    , planType : Maybe String
    , status : String
    , agentId : Maybe Int
    , lastEmailed : Maybe String
    }


type Modal
    = NoModal
    | ContactChoiceModal
    | AddModal
    | EditModal Contact
    | CsvUploadModal UploadState
    | DeleteConfirmModal
    | ReassignAgentModal


type alias Model =
    { contacts : List Contact
    , selectedContacts : List Int
    , showModal : Modal
    , searchQuery : String
    , addForm : ContactForm
    , editForm : ContactForm
    , sortColumn : Maybe SortColumn
    , sortDirection : SortDirection
    , activeFilters : Filters
    , openFilter : Maybe FilterType
    , currentTime : Time.Posix
    , isLoadingContacts : Bool
    , isUploadingCsv : Bool
    , isDeletingContacts : Bool
    , isSubmittingForm : Bool
    , isCheckingEmail : Bool
    , emailExists : Bool
    , currentUser : Maybe User
    , showProfileMenu : Bool
    , error : Maybe String
    , saveOnUpdate : Bool
    , expandedContactId : Maybe Int
    , availableFilters : AvailableFilters
    , carriers : List String
    , agents : List User
    , defaultAgentId : Maybe Int -- Added field for default agent ID
    , key : Nav.Key
    , pagination : PaginationState
    , quotesSent : Int
    , manualQuotesSent : Int
    , quotesViewed : Int
    , healthQuestionsCompleted : Int
    , isLoadingDashboardStats : Bool
    , dashboardStatsError : Maybe String
    }


type alias ContactForm =
    { id : Maybe Int
    , firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , state : String
    , contactOwnerId : Maybe Int
    , currentCarrier : Maybe String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : Bool
    , gender : String
    , zipCode : String
    , planType : Maybe String
    }


type SortColumn
    = NameCol
    | StatusCol
    | EmailCol
    | PhoneNumberCol
    | StateCol
    | ContactOwnerCol
    | CurrentCarrierCol
    | EffectiveDateCol


type SortDirection
    = Ascending
    | Descending


type alias Filters =
    { carriers : List String
    , states : List String
    , ageRange : Maybe ( Int, Int )
    , agents : List Int
    }


type alias ZipInfo =
    { state : String
    , counties : List String
    , cities : List String
    }


type alias UploadState =
    { dragOver : Bool
    , file : Maybe File
    , error : Maybe String
    , errorCsv : Maybe String
    , converted_carriers_csv : Maybe String
    , stats : Maybe UploadStats
    , overwriteDuplicates : Bool
    , selectedAgentId : Maybe Int
    , columnMapping : Maybe ColumnMapping
    , carrierMapping : Maybe CarrierMapping
    , detectedCarriers : List String
    , csvHeaders : List String
    , processingHeaders : Bool
    , extractingCarriers : Bool
    , invalidEmails : List { email : String, reason : String }
    }


type alias UploadStats =
    { totalRows : Int
    , errorRows : Int
    , validRows : Int
    , converted_carrier_rows : Int
    , supported_carriers : List { name : String, aliases : List String }
    }


type alias DeleteResponse =
    { success : Bool
    , deletedIds : List Int
    , message : String
    }


type alias ReassignResponse =
    { success : Bool
    , updatedIds : List Int
    , message : String
    }


type alias User =
    { id : Int
    , email : String
    , firstName : String
    , lastName : String
    , isAdmin : Bool
    , isAgent : Bool
    , isDefault : Bool
    , organizationId : Int
    , isActive : Bool
    , phone : String
    , carriers : List String
    , stateLicenses : List String
    }


type alias AvailableFilters =
    { carriers : List String
    , states : List String
    }


type alias ContactsResponse =
    { contacts : List Contact
    , filterOptions : AvailableFilters
    , total : Int
    , page : Int
    , limit : Int
    }


type alias PaginationState =
    { currentPage : Int
    , totalPages : Int
    , totalItems : Int
    , itemsPerPage : Int
    }


type alias ColumnMapping =
    { firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , currentCarrier : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : String
    , gender : String
    , zipCode : String
    , planType : String
    }


type alias CarrierMapping =
    { detectedCarriers : List String
    , mappings : Dict String String -- Original carrier name -> Standardized carrier name
    }


type alias SuggestedMappings =
    { columnMappings : ColumnMapping
    , carrierMappings : Dict String String
    }


emptyAvailableFilters : AvailableFilters
emptyAvailableFilters =
    { carriers = []
    , states = []
    }


init : Nav.Key -> Maybe User -> ( Model, Cmd Msg )
init key maybeUser =
    let
        model =
            { contacts = []
            , selectedContacts = []
            , showModal = NoModal
            , searchQuery = ""
            , addForm = emptyForm
            , editForm = emptyForm
            , sortColumn = Nothing
            , sortDirection = Ascending
            , activeFilters = emptyFilters
            , openFilter = Nothing
            , currentTime = Time.millisToPosix 0
            , isLoadingContacts = True
            , isUploadingCsv = False
            , isDeletingContacts = False
            , isSubmittingForm = False
            , isCheckingEmail = False
            , emailExists = False
            , currentUser = maybeUser
            , showProfileMenu = False
            , error = Nothing
            , saveOnUpdate = False
            , expandedContactId = Nothing
            , availableFilters = emptyAvailableFilters
            , carriers = []
            , agents = []
            , defaultAgentId = Nothing -- Initialize defaultAgentId
            , key = key
            , pagination = { currentPage = 1, totalPages = 1, totalItems = 0, itemsPerPage = 100 }
            , quotesSent = 0
            , manualQuotesSent = 0
            , quotesViewed = 0
            , healthQuestionsCompleted = 0
            , isLoadingDashboardStats = True
            , dashboardStatsError = Nothing
            }
    in
    ( model
    , Cmd.batch
        [ fetchContacts model
        , fetchDashboardStats
        , fetchAgents
        , fetchCarriers
        ]
    )


emptyForm : ContactForm
emptyForm =
    { id = Nothing
    , firstName = ""
    , lastName = ""
    , email = ""
    , phoneNumber = ""
    , state = ""
    , contactOwnerId = Nothing
    , currentCarrier = Nothing
    , effectiveDate = ""
    , birthDate = ""
    , tobaccoUser = False
    , gender = ""
    , zipCode = ""
    , planType = Nothing
    }


emptyFilters : Filters
emptyFilters =
    { carriers = []
    , states = []
    , ageRange = Nothing
    , agents = []
    }


emptyUploadState : Model -> UploadState
emptyUploadState model =
    let
        selectedAgentId =
            case model.currentUser of
                Just user ->
                    if user.isAgent then
                        Just user.id

                    else
                        Nothing

                Nothing ->
                    Nothing

        overwriteOption =
            case model.currentUser of
                Just user ->
                    not (user.isAgent && not user.isAdmin)

                Nothing ->
                    True
    in
    { dragOver = False
    , file = Nothing
    , error = Nothing
    , errorCsv = Nothing
    , converted_carriers_csv = Nothing
    , stats = Nothing
    , overwriteDuplicates = overwriteOption
    , selectedAgentId = selectedAgentId
    , columnMapping = Nothing
    , carrierMapping = Nothing
    , detectedCarriers = []
    , csvHeaders = []
    , processingHeaders = False
    , extractingCarriers = False
    , invalidEmails = []
    }



-- UPDATE


type Msg
    = NoOp
    | ShowContactChoiceModal
    | ChooseSingleContact
    | ChooseMultipleContacts
    | ShowAddModal
    | ShowEditModal Contact
    | CloseModal
    | UpdateSearchQuery String
    | UpdateAddForm ContactFormField String
    | UpdateEditForm ContactFormField String
    | EmailBlur String -- New message for email blur events
    | SubmitAddForm
    | SubmitEditForm
    | CheckEmail String
    | EmailChecked (Result Http.Error { exists : Bool })
    | EmailCheckTimeout
    | GotContacts (Result Http.Error ContactsResponse)
    | ContactAdded (Result Http.Error Contact)
    | ContactUpdated (Result Http.Error Contact)
    | HandleKeyDown String
    | SetSort SortColumn
    | ToggleFilter FilterType String
    | SetAgeFilter Int Int
    | ClearFilters
    | LookupZipCode String
    | GotZipLookup (Result Http.Error ZipInfo)
    | Batch (List Msg)
    | ToggleFilterDropdown FilterType
    | SelectAllFilter FilterType Bool
    | CloseFilterDropdown
    | GotCurrentTime Time.Posix
    | ToggleSelectContact Int
    | SelectAllContacts
    | DeselectAllContacts
    | EmailSelectedCarriers
    | EmailSelectedContacts
    | ShowCsvUploadModal
    | DragEnter
    | DragLeave
    | FileDrop File
    | FileSelected File
    | ClickedSelectFile
    | UploadCsv
    | CsvUploaded (Result Http.Error UploadResponse)
    | DownloadErrorCsv String
    | DownloadCarrierConversionsCsv String
    | ShowDeleteConfirmModal
    | DeleteSelectedContacts
    | ContactsDeleted (Result Http.Error DeleteResponse)
    | ToggleOverwriteDuplicates Bool
    | GotCurrentUser (Result Http.Error User)
    | NavigateToContact Int
    | GotCarriers (Result Http.Error (List String))
    | GotAgents (Result Http.Error AgentsResponseWithDefault)
    | SelectUploadAgent Int
    | ShowReassignAgentModal
    | SelectReassignAgent Int
    | ReassignSelectedContacts
    | ContactsReassigned (Result Http.Error ReassignResponse)
    | ChangePage Int
    | ChangeItemsPerPage Int
    | UpdateColumnMapping String String
    | ExtractCsvHeaders File
    | CsvHeadersExtracted (Result String (List String))
    | SuggestedMappingsReceived (Result Http.Error SuggestedMappings)
    | ExtractCarrierValues
    | CarrierValuesExtracted (List String)
    | UpdateCarrierMapping String String
    | GotCarriersForMapping (List String) (Result Http.Error (List { name : String, aliases : List String }))
    | EmailValidationCompleted (List { email : String, reason : String })
      -- Dashboard stats messages
    | FetchDashboardStats
    | GotDashboardStats (Result Http.Error { success : Bool, stats : { quotesSent : Int, manualQuotesSent : Int, quotesViewed : Int, followUpsRequested : Int, healthQuestionsCompleted : Int } })


type ContactFormField
    = FirstName
    | LastName
    | Email
    | PhoneNumber
    | State
    | ContactOwnerId
    | CurrentCarrier
    | EffectiveDate
    | BirthDate
    | TobaccoUser
    | Gender
    | ZipCode
    | PlanType


type FilterType
    = CarrierFilter
    | StateFilter
    | AgeFilter
    | AgentFilter


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        ShowContactChoiceModal ->
            ( { model | showModal = ContactChoiceModal }, Cmd.none )

        ChooseSingleContact ->
            ( { model | showModal = AddModal }, Cmd.none )

        ChooseMultipleContacts ->
            ( { model | showModal = CsvUploadModal (emptyUploadState model) }
            , Cmd.batch [ fetchAgents, fetchCarriers ]
            )

        ShowAddModal ->
            ( { model | showModal = AddModal }, Cmd.none )

        ShowEditModal contact ->
            ( { model
                | showModal = EditModal contact
                , editForm =
                    { id = Just contact.id
                    , firstName = Maybe.withDefault "" contact.firstName
                    , lastName = Maybe.withDefault "" contact.lastName
                    , email = contact.email
                    , phoneNumber = Maybe.withDefault "" contact.phoneNumber
                    , state = Maybe.withDefault "" contact.state
                    , contactOwnerId = contact.contactOwnerId
                    , currentCarrier = contact.currentCarrier
                    , effectiveDate = Maybe.withDefault "" contact.effectiveDate
                    , birthDate = Maybe.withDefault "" contact.birthDate
                    , tobaccoUser = Maybe.withDefault False contact.tobaccoUser
                    , gender = Maybe.withDefault "" contact.gender
                    , zipCode = Maybe.withDefault "" contact.zipCode
                    , planType = contact.planType
                    }
              }
            , Cmd.none
            )

        CloseModal ->
            ( { model
                | showModal = NoModal
                , addForm = emptyForm
                , editForm = emptyForm
                , isCheckingEmail = False
                , emailExists = False
                , error = Nothing
                , isSubmittingForm = False
              }
            , Cmd.none
            )

        UpdateSearchQuery query ->
            let
                updatedModel =
                    { model | searchQuery = query, isLoadingContacts = True }
            in
            ( updatedModel, fetchContacts updatedModel )

        UpdateAddForm field value ->
            let
                form =
                    model.addForm

                updatedForm =
                    case field of
                        FirstName ->
                            { form | firstName = value }

                        LastName ->
                            { form | lastName = value }

                        Email ->
                            { form | email = value }

                        PhoneNumber ->
                            { form | phoneNumber = String.filter Char.isDigit value |> String.left 10 }

                        State ->
                            { form | state = value }

                        ContactOwnerId ->
                            { form | contactOwnerId = String.toInt value }

                        CurrentCarrier ->
                            { form | currentCarrier = Just value }

                        EffectiveDate ->
                            { form | effectiveDate = value }

                        BirthDate ->
                            { form | birthDate = value }

                        TobaccoUser ->
                            { form | tobaccoUser = value == "true" }

                        Gender ->
                            { form | gender = value }

                        ZipCode ->
                            { form | zipCode = value }

                        PlanType ->
                            { form | planType = Just value }

                -- Update the command logic to check emails properly
                cmd =
                    if field == ZipCode && String.length value == 5 then
                        submitEditFormWithFlag updatedForm True

                    else
                        Cmd.none
            in
            case model.showModal of
                ContactChoiceModal ->
                    ( model, Cmd.none )

                AddModal ->
                    ( { model
                        | addForm = updatedForm
                        , isCheckingEmail = field == Email && String.contains "@" value && String.length value > 5
                        , emailExists = False
                        , error = Nothing
                      }
                    , cmd
                    )

                EditModal _ ->
                    ( { model | editForm = updatedForm }, cmd )

                NoModal ->
                    ( model, Cmd.none )

                CsvUploadModal _ ->
                    ( model, Cmd.none )

                DeleteConfirmModal ->
                    ( model, Cmd.none )

                ReassignAgentModal ->
                    ( model, Cmd.none )

        UpdateEditForm field value ->
            let
                form =
                    model.editForm

                updatedForm =
                    case field of
                        FirstName ->
                            { form | firstName = value }

                        LastName ->
                            { form | lastName = value }

                        Email ->
                            { form | email = value }

                        PhoneNumber ->
                            { form | phoneNumber = String.filter Char.isDigit value |> String.left 10 }

                        State ->
                            { form | state = value }

                        ContactOwnerId ->
                            { form | contactOwnerId = String.toInt value }

                        CurrentCarrier ->
                            { form | currentCarrier = Just value }

                        EffectiveDate ->
                            { form | effectiveDate = value }

                        BirthDate ->
                            { form | birthDate = value }

                        TobaccoUser ->
                            { form | tobaccoUser = value == "true" }

                        Gender ->
                            { form | gender = value }

                        ZipCode ->
                            { form | zipCode = value }

                        PlanType ->
                            { form | planType = Just value }

                -- Update the command logic
                cmd =
                    if field == ZipCode && String.length value == 5 then
                        LookupZipCode value
                            |> Task.succeed
                            |> Task.perform identity

                    else
                        Cmd.none
            in
            case model.showModal of
                ContactChoiceModal ->
                    ( model, Cmd.none )

                AddModal ->
                    ( { model
                        | addForm = updatedForm
                        , isCheckingEmail = field == Email && String.contains "@" value && String.length value > 5
                        , emailExists = False
                        , error = Nothing
                      }
                    , cmd
                    )

                EditModal _ ->
                    ( { model
                        | editForm = updatedForm
                        , isCheckingEmail = field == Email && String.contains "@" value && String.length value > 5
                        , emailExists = False
                        , error = Nothing
                      }
                    , cmd
                    )

                NoModal ->
                    ( model, Cmd.none )

                CsvUploadModal _ ->
                    ( model, Cmd.none )

                DeleteConfirmModal ->
                    ( model, Cmd.none )

                ReassignAgentModal ->
                    ( model, Cmd.none )

        EmailBlur email ->
            if isValidEmail email then
                ( { model | isCheckingEmail = True }
                , checkEmail email
                )

            else
                ( model, Cmd.none )

        SubmitAddForm ->
            ( { model | isSubmittingForm = True }
            , submitAddForm model.addForm
            )

        SubmitEditForm ->
            ( { model
                | isSubmittingForm = True
                , saveOnUpdate = True
              }
            , submitEditFormWithFlag model.editForm False
            )

        CheckEmail email ->
            ( { model | isCheckingEmail = True }
            , checkEmail email
            )

        EmailChecked (Ok response) ->
            ( { model
                | isCheckingEmail = False
                , emailExists = response.exists
                , error =
                    if response.exists then
                        Just "A contact with this email already exists"

                    else
                        Nothing
              }
            , Cmd.none
            )

        EmailChecked (Err error) ->
            let
                errorMsg =
                    case error of
                        Http.BadUrl _ ->
                            "Invalid URL for email check"

                        Http.Timeout ->
                            "Email check timed out"

                        Http.NetworkError ->
                            "Network error during email check"

                        Http.BadStatus code ->
                            "Server error: " ++ String.fromInt code

                        Http.BadBody errBody ->
                            "Invalid response: " ++ errBody
            in
            ( { model
                | isCheckingEmail = False
                , error = Just ("Failed to check email: " ++ errorMsg)
              }
            , Cmd.none
            )

        EmailCheckTimeout ->
            ( { model
                | isCheckingEmail = False
                , error = Just "Email check timed out. Please continue."
              }
            , Cmd.none
            )

        GotContacts (Ok response) ->
            ( { model
                | contacts = response.contacts
                , isLoadingContacts = False
                , availableFilters = response.filterOptions
                , pagination =
                    { currentPage = response.page
                    , totalItems = response.total
                    , itemsPerPage = response.limit
                    , totalPages = ceiling (toFloat response.total / toFloat response.limit)
                    }
              }
            , Cmd.none
            )

        GotContacts (Err error) ->
            ( { model | error = Just "Failed to load contacts" }, Cmd.none )

        ContactAdded (Ok contact) ->
            ( { model
                | contacts = contact :: model.contacts
                , showModal = NoModal
                , addForm = emptyForm
                , isSubmittingForm = False
              }
            , Cmd.none
            )

        ContactAdded (Err _) ->
            ( { model | isSubmittingForm = False }
            , Cmd.none
            )

        ContactUpdated (Ok contact) ->
            let
                updatedContacts =
                    updateContact contact model.contacts

                updatedModel =
                    if model.saveOnUpdate then
                        -- Close the modal for a final save
                        { model
                            | contacts = updatedContacts
                            , showModal = NoModal
                            , editForm = emptyForm
                            , isSubmittingForm = False
                            , error = Nothing
                            , saveOnUpdate = False
                        }

                    else
                        -- Just update the state field in the form
                        { model
                            | contacts = updatedContacts
                            , editForm =
                                model.editForm
                                    |> (\form -> { form | state = Maybe.withDefault "" contact.state })
                            , isSubmittingForm = False
                            , error = Nothing
                        }
            in
            ( updatedModel, Cmd.none )

        ContactUpdated (Err error) ->
            ( { model
                | isSubmittingForm = False
                , error = Just "Failed to update contact. Please check the ZIP code is valid."
              }
            , Cmd.none
            )

        HandleKeyDown key ->
            if key == "Escape" then
                ( { model | showModal = NoModal }, Cmd.none )

            else
                ( model, Cmd.none )

        SetSort column ->
            let
                ( newColumn, newDirection ) =
                    case ( model.sortColumn, model.sortDirection ) of
                        ( Just currentColumn, direction ) ->
                            if currentColumn == column then
                                -- Toggle direction if same column
                                ( Just column
                                , if direction == Ascending then
                                    Descending

                                  else
                                    Ascending
                                )

                            else
                                -- New column, start with ascending
                                ( Just column, Ascending )

                        ( Nothing, _ ) ->
                            -- First time sorting, start with ascending
                            ( Just column, Ascending )
            in
            ( { model
                | sortColumn = newColumn
                , sortDirection = newDirection
              }
            , Cmd.none
            )

        ToggleFilter filterType value ->
            let
                updatedModel =
                    { model
                        | activeFilters = toggleFilter model.activeFilters filterType value
                        , isLoadingContacts = True
                    }
            in
            ( updatedModel, fetchContacts updatedModel )

        SetAgeFilter min max ->
            ( { model | activeFilters = setAgeFilter min max model.activeFilters }, Cmd.none )

        ClearFilters ->
            ( { model | activeFilters = emptyFilters }, Cmd.none )

        LookupZipCode zipCode ->
            ( model
            , Http.get
                { url = "/api/zip-lookup/" ++ zipCode
                , expect = Http.expectJson GotZipLookup zipInfoDecoder
                }
            )

        GotZipLookup (Ok zipInfo) ->
            let
                updateForm form =
                    { form | state = zipInfo.state }
            in
            case model.showModal of
                ContactChoiceModal ->
                    ( model, Cmd.none )

                AddModal ->
                    ( { model | addForm = updateForm model.addForm }, Cmd.none )

                EditModal _ ->
                    ( { model | editForm = updateForm model.editForm }, Cmd.none )

                NoModal ->
                    ( model, Cmd.none )

                CsvUploadModal _ ->
                    ( model, Cmd.none )

                DeleteConfirmModal ->
                    ( model, Cmd.none )

                ReassignAgentModal ->
                    ( model, Cmd.none )

        GotZipLookup (Err _) ->
            ( model, Cmd.none )

        Batch messages ->
            List.foldl
                (\msg_ ( model_, cmds ) ->
                    let
                        ( newModel, newCmd ) =
                            update msg_ model_
                    in
                    ( newModel, newCmd :: cmds )
                )
                ( model, [] )
                messages
                |> (\( m, cs ) -> ( m, Cmd.batch cs ))

        ToggleFilterDropdown filterType ->
            ( { model
                | openFilter =
                    if model.openFilter == Just filterType then
                        Nothing

                    else
                        Just filterType
              }
            , Cmd.none
            )

        SelectAllFilter filterType select ->
            let
                options =
                    case filterType of
                        CarrierFilter ->
                            model.availableFilters.carriers

                        StateFilter ->
                            model.availableFilters.states

                        AgentFilter ->
                            model.agents
                                |> List.filter (\agent -> agent.isAgent)
                                |> List.map (\agent -> agent.firstName ++ " " ++ agent.lastName)

                        _ ->
                            []

                updatedFilters =
                    case filterType of
                        CarrierFilter ->
                            { carriers =
                                if select then
                                    options

                                else
                                    []
                            , states = model.activeFilters.states
                            , ageRange = model.activeFilters.ageRange
                            , agents = model.activeFilters.agents
                            }

                        StateFilter ->
                            { carriers = model.activeFilters.carriers
                            , states =
                                if select then
                                    options

                                else
                                    []
                            , ageRange = model.activeFilters.ageRange
                            , agents = model.activeFilters.agents
                            }

                        AgentFilter ->
                            { carriers = model.activeFilters.carriers
                            , states = model.activeFilters.states
                            , ageRange = model.activeFilters.ageRange
                            , agents =
                                if select then
                                    model.agents
                                        |> List.filter (\agent -> agent.isAgent)
                                        |> List.map (\agent -> agent.id)

                                else
                                    []
                            }

                        _ ->
                            model.activeFilters

                updatedModel =
                    { model | activeFilters = updatedFilters }
            in
            ( updatedModel, fetchContacts updatedModel )

        CloseFilterDropdown ->
            -- Only close the dropdown, don't prevent further events
            ( { model | openFilter = Nothing }, Cmd.none )

        GotCurrentTime time ->
            ( { model | currentTime = time }, Cmd.none )

        ToggleSelectContact id ->
            ( { model
                | selectedContacts =
                    if List.member id model.selectedContacts then
                        List.filter (\x -> x /= id) model.selectedContacts

                    else
                        id :: model.selectedContacts
              }
            , Cmd.none
            )

        SelectAllContacts ->
            let
                visibleContacts =
                    model.contacts
                        |> filterContacts model.activeFilters model.searchQuery model.currentTime
                        |> List.map .id
            in
            ( { model | selectedContacts = visibleContacts }
            , Cmd.none
            )

        DeselectAllContacts ->
            ( { model | selectedContacts = [] }
            , Cmd.none
            )

        EmailSelectedCarriers ->
            -- For now, just a placeholder that does nothing
            ( model, Cmd.none )

        EmailSelectedContacts ->
            -- For now, just a placeholder that does nothing
            ( model, Cmd.none )

        ShowCsvUploadModal ->
            ( { model | showModal = CsvUploadModal (emptyUploadState model) }
            , Cmd.batch [ fetchAgents, fetchCarriers ]
            )

        DragEnter ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | dragOver = True } }, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        DragLeave ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | dragOver = False } }, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        FileDrop file ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | file = Just file, dragOver = False, processingHeaders = True } }
                    , extractCsvHeaders file
                    )

                _ ->
                    ( model, Cmd.none )

        FileSelected file ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | file = Just file, processingHeaders = True } }
                    , extractCsvHeaders file
                    )

                _ ->
                    ( model, Cmd.none )

        ClickedSelectFile ->
            ( model
            , Select.file [ "text/csv" ] FileSelected
            )

        UploadCsv ->
            case model.showModal of
                CsvUploadModal state ->
                    case state.file of
                        Just file ->
                            ( { model
                                | showModal = CsvUploadModal { state | error = Nothing, errorCsv = Nothing, stats = Nothing }
                                , isUploadingCsv = True
                              }
                            , uploadCsv file state.overwriteDuplicates state.selectedAgentId model
                            )

                        Nothing ->
                            ( model, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        CsvUploaded (Ok response) ->
            let
                currentModal =
                    case model.showModal of
                        CsvUploadModal state ->
                            if response.success then
                                NoModal

                            else
                                CsvUploadModal
                                    { state
                                        | error = Just response.message
                                    }

                        _ ->
                            model.showModal

                updatedModel =
                    { model
                        | showModal = currentModal
                        , isUploadingCsv = False
                    }
            in
            ( updatedModel
            , if response.success then
                fetchContacts updatedModel

              else
                Cmd.none
            )

        CsvUploaded (Err httpError) ->
            let
                errorMessage =
                    case httpError of
                        Http.BadUrl url ->
                            "Invalid URL: " ++ url

                        Http.BadStatus statusCode ->
                            if statusCode == 400 then
                                "The CSV format is invalid. Please check that all required columns are present and data is in the correct format."

                            else if statusCode == 413 then
                                "The file is too large. Please try a smaller file or split your data into multiple uploads."

                            else if statusCode == 403 then
                                "You don't have permission to upload contacts. Please contact your administrator."

                            else
                                "Server error (status " ++ String.fromInt statusCode ++ "). Please try again later."

                        Http.BadBody responseBody ->
                            "The server response was not in the expected format: " ++ responseBody

                        Http.NetworkError ->
                            "Network error. Please check your connection and try again."

                        Http.Timeout ->
                            "The upload timed out. Please try again."
            in
            case model.showModal of
                CsvUploadModal state ->
                    ( { model
                        | showModal = CsvUploadModal { state | error = Just errorMessage }
                        , isUploadingCsv = False
                      }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        DownloadErrorCsv csvContent ->
            ( model
            , File.Download.string "upload_errors.csv" "text/csv" csvContent
            )

        DownloadCarrierConversionsCsv csvContent ->
            ( model
            , File.Download.string "carrier_conversions.csv" "text/csv" csvContent
            )

        ShowDeleteConfirmModal ->
            ( { model | showModal = DeleteConfirmModal }, Cmd.none )

        DeleteSelectedContacts ->
            ( { model | isDeletingContacts = True, showModal = NoModal }
            , if List.isEmpty model.selectedContacts then
                Cmd.none

              else
                deleteContacts model.selectedContacts
            )

        ContactsDeleted (Ok response) ->
            if response.success then
                let
                    updatedModel =
                        { model
                            | contacts = List.filter (\c -> not (List.member c.id response.deletedIds)) model.contacts
                            , selectedContacts = []
                            , isDeletingContacts = False
                        }
                in
                ( updatedModel
                , fetchContacts updatedModel
                )

            else
                ( { model | isDeletingContacts = False }, Cmd.none )

        ContactsDeleted (Err _) ->
            ( model, Cmd.none )

        ToggleOverwriteDuplicates value ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | overwriteDuplicates = value } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        GotCurrentUser (Ok user) ->
            ( { model | currentUser = Just user }, Cmd.none )

        GotCurrentUser (Err _) ->
            ( model, Cmd.none )

        NavigateToContact id ->
            ( model, Nav.pushUrl model.key ("/contact/" ++ String.fromInt id) )

        GotCarriers (Ok carriers) ->
            ( { model | carriers = carriers }
            , Cmd.none
            )

        GotCarriers (Err _) ->
            ( model, Cmd.none )

        GotAgents (Ok response) ->
            let
                parser : String -> String
                parser =
                    Url.percentDecode >> Maybe.withDefault ""

                parseAgent : User -> User
                parseAgent agent =
                    { agent | firstName = parser agent.firstName, lastName = parser agent.lastName, email = parser agent.email }
            in
            ( { model
                | agents = response.agents |> List.map parseAgent
                , defaultAgentId = response.defaultAgentId |> Maybe.andThen String.toInt
              }
            , Cmd.none
            )

        GotAgents (Err error) ->
            ( model, Cmd.none )

        SelectUploadAgent agentId ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | selectedAgentId = Just agentId } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        ShowReassignAgentModal ->
            let
                -- Get the first agent ID as the default selected agent
                defaultAgentId =
                    model.agents
                        |> List.head
                        |> Maybe.map .id

                -- Update the edit form with the selected agent
                updatedForm =
                    model.editForm

                updatedFormWithAgent =
                    { updatedForm | contactOwnerId = defaultAgentId }
            in
            ( { model | showModal = ReassignAgentModal, editForm = updatedFormWithAgent }, Cmd.none )

        SelectReassignAgent agentId ->
            let
                updatedForm =
                    model.editForm

                updatedFormWithAgent =
                    { updatedForm | contactOwnerId = Just agentId }
            in
            ( { model | editForm = updatedFormWithAgent }
            , Cmd.none
            )

        ReassignSelectedContacts ->
            if List.isEmpty model.selectedContacts then
                ( model, Cmd.none )

            else
                case model.editForm.contactOwnerId of
                    Just agentId ->
                        if agentId == 0 then
                            -- If "Default" (0) is selected, pass null for agent_id
                            ( { model | showModal = NoModal }
                            , reassignContacts model.selectedContacts 0
                            )

                        else
                            -- Normal agent reassignment
                            ( { model | showModal = NoModal }
                            , reassignContacts model.selectedContacts agentId
                            )

                    Nothing ->
                        ( { model | error = Just "Please select an agent to reassign contacts to" }
                        , Cmd.none
                        )

        ContactsReassigned (Ok response) ->
            let
                updatedModel =
                    { model | showModal = NoModal, selectedContacts = [], editForm = emptyForm }
            in
            ( updatedModel, fetchContacts updatedModel )

        ContactsReassigned (Err _) ->
            ( { model | error = Just "Failed to reassign contacts", showModal = NoModal }, Cmd.none )

        ChangePage page ->
            let
                updatedModel =
                    { model
                        | pagination =
                            model.pagination
                                |> (\p -> { p | currentPage = page })
                        , isLoadingContacts = True
                    }
            in
            ( updatedModel
            , fetchContacts updatedModel
            )

        ChangeItemsPerPage limit ->
            let
                updatedModel =
                    { model
                        | pagination =
                            model.pagination
                                |> (\p -> { p | itemsPerPage = limit, currentPage = 1 })
                        , isLoadingContacts = True
                    }
            in
            ( updatedModel
            , fetchContacts updatedModel
            )

        UpdateColumnMapping field value ->
            case model.showModal of
                CsvUploadModal state ->
                    let
                        updatedMapping =
                            case state.columnMapping of
                                Just mapping ->
                                    Just
                                        (case field of
                                            "firstName" ->
                                                { mapping | firstName = value }

                                            "lastName" ->
                                                { mapping | lastName = value }

                                            "email" ->
                                                { mapping | email = value }

                                            "phoneNumber" ->
                                                { mapping | phoneNumber = value }

                                            "currentCarrier" ->
                                                { mapping | currentCarrier = value }

                                            "effectiveDate" ->
                                                { mapping | effectiveDate = value }

                                            "birthDate" ->
                                                { mapping | birthDate = value }

                                            "tobaccoUser" ->
                                                { mapping | tobaccoUser = value }

                                            "gender" ->
                                                { mapping | gender = value }

                                            "zipCode" ->
                                                { mapping | zipCode = value }

                                            "planType" ->
                                                { mapping | planType = value }

                                            _ ->
                                                mapping
                                        )

                                Nothing ->
                                    Just
                                        { firstName =
                                            if field == "firstName" then
                                                value

                                            else
                                                ""
                                        , lastName =
                                            if field == "lastName" then
                                                value

                                            else
                                                ""
                                        , email =
                                            if field == "email" then
                                                value

                                            else
                                                ""
                                        , phoneNumber =
                                            if field == "phoneNumber" then
                                                value

                                            else
                                                ""
                                        , currentCarrier =
                                            if field == "currentCarrier" then
                                                value

                                            else
                                                ""
                                        , effectiveDate =
                                            if field == "effectiveDate" then
                                                value

                                            else
                                                ""
                                        , birthDate =
                                            if field == "birthDate" then
                                                value

                                            else
                                                ""
                                        , tobaccoUser =
                                            if field == "tobaccoUser" then
                                                value

                                            else
                                                ""
                                        , gender =
                                            if field == "gender" then
                                                value

                                            else
                                                ""
                                        , zipCode =
                                            if field == "zipCode" then
                                                value

                                            else
                                                ""
                                        , planType =
                                            if field == "planType" then
                                                value

                                            else
                                                ""
                                        }
                    in
                    ( { model | showModal = CsvUploadModal { state | columnMapping = updatedMapping } }
                    , case ( field, state.file, updatedMapping ) of
                        ( "currentCarrier", Just file, Just mapping ) ->
                            if mapping.currentCarrier == "" then
                                Cmd.none

                            else
                                Task.perform
                                    (\content -> CarrierValuesExtracted (extractUniqueCarriers content mapping.currentCarrier))
                                    (File.toString file)

                        _ ->
                            Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        ExtractCsvHeaders file ->
            ( model
            , Task.perform
                (\content -> CsvHeadersExtracted (extractHeadersFromCsv content))
                (File.toString file)
            )

        CsvHeadersExtracted result ->
            case model.showModal of
                CsvUploadModal state ->
                    case result of
                        Ok headers ->
                            ( { model | showModal = CsvUploadModal { state | csvHeaders = headers, processingHeaders = False } }
                            , suggestMappings headers
                            )

                        Err error ->
                            ( { model | showModal = CsvUploadModal { state | error = Just ("Failed to parse CSV headers: " ++ error), processingHeaders = False } }
                            , Cmd.none
                            )

                _ ->
                    ( model, Cmd.none )

        SuggestedMappingsReceived result ->
            case model.showModal of
                CsvUploadModal state ->
                    case result of
                        Ok suggestions ->
                            let
                                hasCarrierColumn =
                                    case suggestions.columnMappings.currentCarrier of
                                        "" ->
                                            False

                                        _ ->
                                            True

                                updatedState =
                                    { state
                                        | columnMapping = Just suggestions.columnMappings
                                        , carrierMapping = Just { detectedCarriers = state.detectedCarriers, mappings = suggestions.carrierMappings }
                                        , extractingCarriers = hasCarrierColumn
                                    }

                                -- Create commands to run
                                commands =
                                    []

                                -- Add carrier extraction command if needed
                                commands1 =
                                    case ( hasCarrierColumn, state.file ) of
                                        ( True, Just file ) ->
                                            Task.perform
                                                (\content -> CarrierValuesExtracted (extractUniqueCarriers content suggestions.columnMappings.currentCarrier))
                                                (File.toString file)
                                                :: commands

                                        _ ->
                                            commands

                                -- Add email validation command
                                commands2 =
                                    case state.file of
                                        Just file ->
                                            if not (String.isEmpty suggestions.columnMappings.email) then
                                                let
                                                    dummyCarrierMapping =
                                                        { detectedCarriers = []
                                                        , mappings = Dict.empty
                                                        }
                                                in
                                                Task.perform
                                                    (\content ->
                                                        case CsvProcessor.processCsvToContacts content suggestions.columnMappings dummyCarrierMapping of
                                                            Ok result1 ->
                                                                EmailValidationCompleted (List.map (\contact -> { email = contact.email, reason = contact.reason }) result1.invalid)

                                                            Err _ ->
                                                                EmailValidationCompleted []
                                                    )
                                                    (File.toString file)
                                                    :: commands1

                                            else
                                                commands1

                                        Nothing ->
                                            commands1
                            in
                            ( { model | showModal = CsvUploadModal updatedState }
                            , Cmd.batch commands2
                            )

                        Err _ ->
                            ( { model | showModal = CsvUploadModal { state | error = Just "Failed to get column suggestions" } }
                            , Cmd.none
                            )

                _ ->
                    ( model, Cmd.none )

        ExtractCarrierValues ->
            case model.showModal of
                CsvUploadModal state ->
                    case state.file of
                        Just file ->
                            -- Get carrier column from the column mapping
                            let
                                carrierColumn =
                                    case state.columnMapping of
                                        Just mapping ->
                                            if String.isEmpty mapping.currentCarrier then
                                                Nothing

                                            else
                                                Just mapping.currentCarrier

                                        Nothing ->
                                            Nothing
                            in
                            case carrierColumn of
                                Just column ->
                                    ( { model | showModal = CsvUploadModal { state | extractingCarriers = True } }
                                    , Task.perform
                                        (\content -> CarrierValuesExtracted (extractUniqueCarriers content column))
                                        (File.toString file)
                                    )

                                Nothing ->
                                    ( model, Cmd.none )

                        Nothing ->
                            ( model, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        CarrierValuesExtracted carrierValues ->
            case model.showModal of
                CsvUploadModal state ->
                    -- Instead of making a new API call, create a structure from the model's carriers list
                    let
                        -- Create a map of common carrier aliases for better matching
                        carrierAliases =
                            Dict.fromList
                                [ ( "Aetna", [ "aetna medicare", "aetna advantage", "aetna health", "aetna cvs" ] )
                                , ( "United Healthcare", [ "uhc", "united health", "united", "aarp", "aarp / uhc", "aarp/uhc" ] )
                                , ( "Humana", [ "humana gold", "humana gold plus", "humana choice", "humana value", "humana preferred" ] )
                                , ( "Cigna", [ "cigna healthspring", "cigna-healthspring", "cigna health", "connecticut general" ] )
                                , ( "Blue Cross Blue Shield", [ "bcbs", "blue cross", "blue shield", "anthem", "anthem bcbs" ] )
                                , ( "Wellcare", [ "wellcare by allwell", "allwell", "wellcare value", "wellcare essentials" ] )
                                , ( "Kaiser Permanente", [ "kaiser", "kp", "kaiser senior advantage" ] )
                                , ( "Anthem", [ "anthem blue", "anthem medicare", "anthem medigap" ] )
                                , ( "Molina", [ "molina healthcare", "molina advantage", "molina health" ] )
                                , ( "Ace Chubb", [ "ace / chubb", "ace/chubb", "ace chubb", "chubb" ] )
                                ]

                        -- Convert the simple carriers string list to the format expected by CsvProcessor
                        -- and enhance with known aliases
                        standardCarriers =
                            List.map
                                (\name ->
                                    { name = name
                                    , aliases = Dict.get name carrierAliases |> Maybe.withDefault []
                                    }
                                )
                                model.carriers

                        -- Use CsvProcessor to suggest carrier mappings
                        carrierMapping =
                            CsvProcessor.suggestCarrierMappings carrierValues standardCarriers

                        -- Add validation command if we have all necessary components
                        validateEmails =
                            case ( state.file, state.columnMapping ) of
                                ( Just file, Just colMapping ) ->
                                    if String.isEmpty colMapping.email then
                                        Cmd.none

                                    else
                                        Task.perform
                                            (\content ->
                                                case CsvProcessor.processCsvToContacts content colMapping carrierMapping of
                                                    Ok result ->
                                                        EmailValidationCompleted (List.map (\contact -> { email = contact.email, reason = contact.reason }) result.invalid)

                                                    Err _ ->
                                                        EmailValidationCompleted []
                                            )
                                            (File.toString file)

                                _ ->
                                    Cmd.none
                    in
                    ( { model
                        | showModal =
                            CsvUploadModal
                                { state
                                    | detectedCarriers = carrierValues
                                    , carrierMapping = Just carrierMapping
                                    , extractingCarriers = False
                                }
                      }
                    , validateEmails
                    )

                _ ->
                    ( model, Cmd.none )

        UpdateCarrierMapping original mapped ->
            case model.showModal of
                CsvUploadModal state ->
                    case state.carrierMapping of
                        Just mapping ->
                            let
                                updatedMappings =
                                    Dict.insert original mapped mapping.mappings

                                updatedMapping =
                                    { mapping | mappings = updatedMappings }
                            in
                            ( { model | showModal = CsvUploadModal { state | carrierMapping = Just updatedMapping } }
                            , case ( original, state.file ) of
                                ( "currentCarrier", Just file ) ->
                                    Task.perform
                                        (\content -> CarrierValuesExtracted (extractUniqueCarriers content mapped))
                                        (File.toString file)

                                _ ->
                                    Cmd.none
                            )

                        Nothing ->
                            ( model, Cmd.none )

                _ ->
                    ( model, Cmd.none )

        GotCarriersForMapping detectedCarriers (Ok carriers) ->
            let
                -- Use CsvProcessor to suggest carrier mappings with fuzzy matching
                carrierMapping =
                    CsvProcessor.suggestCarrierMappings detectedCarriers carriers
            in
            case model.showModal of
                CsvUploadModal state ->
                    ( { model
                        | showModal =
                            CsvUploadModal
                                { state
                                    | carrierMapping = Just carrierMapping
                                    , extractingCarriers = False
                                }
                      }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        GotCarriersForMapping _ (Err error) ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model
                        | showModal =
                            CsvUploadModal
                                { state
                                    | extractingCarriers = False
                                    , error = Just "Failed to fetch carrier data for matching"
                                }
                      }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        EmailValidationCompleted invalidEmails ->
            case model.showModal of
                CsvUploadModal state ->
                    ( { model | showModal = CsvUploadModal { state | invalidEmails = invalidEmails } }
                    , Cmd.none
                    )

                _ ->
                    ( model, Cmd.none )

        FetchDashboardStats ->
            ( { model | isLoadingDashboardStats = True, dashboardStatsError = Nothing }
            , fetchDashboardStats
            )

        GotDashboardStats result ->
            case result of
                Ok response ->
                    if response.success then
                        let
                            totalQuotesSent =
                                response.stats.quotesSent + response.stats.manualQuotesSent
                        in
                        ( { model
                            | isLoadingDashboardStats = False
                            , quotesSent = totalQuotesSent
                            , manualQuotesSent = response.stats.manualQuotesSent
                            , quotesViewed = response.stats.quotesViewed
                            , healthQuestionsCompleted = response.stats.healthQuestionsCompleted
                            , dashboardStatsError = Nothing
                          }
                        , Cmd.none
                        )

                    else
                        ( { model | isLoadingDashboardStats = False, dashboardStatsError = Just "Failed to load dashboard data." }
                        , Cmd.none
                        )

                Err httpError ->
                    ( { model | isLoadingDashboardStats = False, dashboardStatsError = Just "Error loading dashboard stats." }
                    , Cmd.none
                    )



-- TODO: Handle error
-- Add other update cases here...
-- VIEW


view : Model -> Html Msg
view model =
    div [ class "min-h-screen bg-white" ]
        [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
            [ -- Stats Section - Make more compact with reduced margins
              div [ class "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 mb-6" ]
                [ if model.isLoadingContacts then
                    statsCardWithSpinner "Total Contacts"

                  else
                    statsCard "Total Contacts" (String.fromInt model.pagination.totalItems)
                , if model.isLoadingDashboardStats then
                    statsCardWithSpinner "Quotes Sent"

                  else if model.dashboardStatsError /= Nothing then
                    statsCard "Quotes Sent" "0"

                  else
                    statsCard "Quotes Sent" (String.fromInt model.quotesSent)
                , if model.isLoadingDashboardStats then
                    statsCardWithSpinner "Quotes Viewed"

                  else if model.dashboardStatsError /= Nothing then
                    statsCard "Quotes Viewed" "0"

                  else
                    statsCard "Quotes Viewed" (String.fromInt model.quotesViewed)
                , if model.isLoadingDashboardStats then
                    statsCardWithSpinner "Health Questions"

                  else if model.dashboardStatsError /= Nothing then
                    statsCard "Health Questions" "0"

                  else
                    statsCard "Health Questions" (String.fromInt model.healthQuestionsCompleted)
                ]
            , -- Table Container with overflow handling - reduced vertical spacing
              div [ class "overflow-x-auto max-w-7xl mx-auto" ]
                [ -- Add a container around both the header and the table to ensure they have the same width
                  div [ class "w-full" ]
                    [ -- Contacts header and filters - reduced margin bottom
                      div [ class "flex justify-between items-center mb-3 w-full" ]
                        [ div [ class "flex items-center gap-2" ]
                            [ h1 [ class "text-base font-semibold" ] [ text "Contacts " ]
                            , span [ class "text-sm text-gray-500" ]
                                [ text ("(" ++ String.fromInt model.pagination.totalItems ++ ")") ]
                            ]
                        , div [ class "flex items-center gap-2" ]
                            [ -- Only show Agent filter for admins
                              if isAdminOrAdminAgent model.currentUser then
                                div [ class "relative" ]
                                    [ button
                                        [ class "inline-flex items-center gap-1 px-2 py-1 border rounded-md text-sm text-gray-700 hover:bg-gray-50"
                                        , onClick (ToggleFilterDropdown AgentFilter)
                                        ]
                                        [ text "Agent"
                                        , viewIcon "M19 9l-7 7-7-7"
                                        ]
                                    , if model.openFilter == Just AgentFilter then
                                        viewFilterDropdown model AgentFilter

                                      else
                                        text ""
                                    ]

                              else
                                text ""
                            , div [ class "relative" ]
                                [ button
                                    [ class "inline-flex items-center gap-1 px-2 py-1 border rounded-md text-sm text-gray-700 hover:bg-gray-50"
                                    , onClick (ToggleFilterDropdown CarrierFilter)
                                    ]
                                    [ text "Carrier"
                                    , viewIcon "M19 9l-7 7-7-7"
                                    ]
                                , if model.openFilter == Just CarrierFilter then
                                    viewFilterDropdown model CarrierFilter

                                  else
                                    text ""
                                ]
                            , div [ class "relative" ]
                                [ button
                                    [ class "inline-flex items-center gap-1 px-2 py-1 border rounded-md text-sm text-gray-700 hover:bg-gray-50"
                                    , onClick (ToggleFilterDropdown StateFilter)
                                    ]
                                    [ text "State"
                                    , viewIcon "M19 9l-7 7-7-7"
                                    ]
                                , if model.openFilter == Just StateFilter then
                                    viewFilterDropdown model StateFilter

                                  else
                                    text ""
                                ]
                            , div [ class "relative" ]
                                [ input
                                    [ class "w-48 px-2 py-1 border rounded-md text-sm placeholder-gray-500 focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
                                    , placeholder "Search contacts..."
                                    , value model.searchQuery
                                    , onInput UpdateSearchQuery
                                    ]
                                    []
                                ]
                            , -- Add the add contact button with a different style
                              button
                                [ class "px-2 py-1 bg-black text-white rounded-md text-sm hover:bg-gray-800 transition-colors"
                                , onClick ShowContactChoiceModal
                                ]
                                [ text "+ Add Contact" ]
                            ]
                        ]
                    , table [ class "w-full" ]
                        [ colgroup []
                            [ col [ class "w-12" ] [] -- Checkbox
                            , col [ class "w-48" ] [] -- Name
                            , col [ class "w-16" ] [] -- Contact Status (reduced from w-20)
                            , col [ class "w-48" ] [] -- Email
                            , col [ class "w-28" ] [] -- Phone Number
                            , col [ class "w-16" ] [] -- State
                            , col [ class "w-36" ] [] -- Assigned Agent (increased from w-32)
                            , col [ class "w-20" ] [] -- Current Carrier (reduced from w-24)
                            , col [ class "w-32" ] [] -- Effective Date (increased from w-28)
                            , col [ class "w-16" ] [] -- Actions (reduced from w-20)
                            ]
                        , thead [ class "bg-gray-50" ]
                            [ tr []
                                [ th [ class "sticky top-0 px-2 py-1 border-b border-gray-200 bg-gray-50" ]
                                    [ input
                                        [ type_ "checkbox"
                                        , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                        , checked (not (List.isEmpty model.contacts) && List.length model.selectedContacts == List.length model.contacts)
                                        , onClick
                                            (if not (List.isEmpty model.contacts) && List.length model.selectedContacts == List.length model.contacts then
                                                DeselectAllContacts

                                             else
                                                SelectAllContacts
                                            )
                                        ]
                                        []
                                    ]
                                , tableHeader "Name"
                                , tableHeader "Email"
                                , tableHeader "Phone"
                                , tableHeader "State"
                                , tableHeader "Agent"
                                , tableHeader "Carrier"
                                , tableHeader "Eff. Date"
                                , tableHeader "Edit"
                                ]
                            ]
                        , tbody [ class "bg-white" ]
                            (if model.isLoadingContacts then
                                [ tr []
                                    [ td
                                        [ class "px-3 py-8 text-sm text-gray-500 text-center border-t border-gray-200"
                                        , attribute "colspan" "10"
                                        ]
                                        [ div [ class "flex items-center justify-center gap-3" ]
                                            [ viewSpinner
                                            , text "Loading contacts..."
                                            ]
                                        ]
                                    ]
                                ]

                             else if List.isEmpty model.contacts then
                                [ tr []
                                    [ td
                                        [ class "px-3 py-2 text-sm text-gray-500 text-center border-t border-gray-200"
                                        , attribute "colspan" "10"
                                        ]
                                        [ text "No contacts found" ]
                                    ]
                                ]

                             else
                                List.concatMap (viewTableRow model) model.contacts
                            )
                        ]
                    ]
                ]
            ]
        , viewModals model
        , if not (List.isEmpty model.selectedContacts) then
            viewBulkActionBar model

          else
            text ""
        , viewPaginationControls model -- Add pagination controls
        ]


viewBulkActionBar : Model -> Html Msg
viewBulkActionBar model =
    let
        isAdmin =
            isAdminOrAdminAgent model.currentUser
    in
    div
        [ class "fixed bottom-0 inset-x-0 bg-white border-t border-gray-200 shadow-lg transform transition-all duration-200 z-50" ]
        [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4" ]
            [ div [ class "flex justify-between items-center" ]
                [ div [ class "flex items-center gap-4" ]
                    [ span [ class "text-sm text-gray-600" ]
                        [ text (String.fromInt (List.length model.selectedContacts) ++ " contacts selected") ]
                    ]
                , div [ class "flex items-center gap-3" ]
                    [ button
                        [ class "px-4 py-2 text-sm font-medium text-gray-700 hover:text-gray-900"
                        , onClick DeselectAllContacts
                        ]
                        [ text "Cancel" ]
                    , if isAdmin then
                        -- Reassign button (only for admins)
                        button
                            [ class "px-4 py-2 bg-purple-600 text-white text-sm font-medium rounded-lg hover:bg-purple-700 transition-colors duration-200 mr-2"
                            , onClick ShowReassignAgentModal
                            ]
                            [ text "Reassign Agent" ]

                      else
                        text ""
                    , button
                        [ class "px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors duration-200"
                        , onClick ShowDeleteConfirmModal
                        ]
                        [ if model.isDeletingContacts then
                            viewSpinner

                          else
                            text "Delete Selected"
                        ]
                    ]
                ]
            ]
        ]


statsCard : String -> String -> Html Msg
statsCard title value =
    div [ class "bg-white rounded-lg shadow-xl p-4 sm:p-6" ]
        [ div [ class "text-gray-600 text-xs sm:text-sm" ] [ text title ]
        , div [ class "text-2xl sm:text-4xl font-bold mt-1 sm:mt-2 text-[#03045E]" ] [ text value ]
        ]


statsCardWithSpinner : String -> Html Msg
statsCardWithSpinner title =
    div [ class "bg-white rounded-lg shadow-xl p-4 sm:p-6" ]
        [ div [ class "text-gray-600 text-xs sm:text-sm" ] [ text title ]
        , div [ class "text-2xl sm:text-4xl font-bold mt-1 sm:mt-2 text-[#03045E] flex items-center justify-center" ]
            [ div [ class "animate-spin rounded-full h-8 w-8 border-t-2 border-l-2 border-purple-500" ] [] ]
        ]


tableHeader : String -> Html Msg
tableHeader headerText =
    th [ class "px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200 bg-gray-50" ]
        [ text headerText ]


viewTableRow : Model -> Contact -> List (Html Msg)
viewTableRow model contact =
    let
        cellClass =
            "px-2 py-1 text-sm border-t border-gray-200"

        phoneCellClass =
            cellClass ++ " text-xs"

        compactCellClass =
            "px-1 py-1 text-sm border-t border-gray-200"

        -- Reduced padding for compact cells
        -- Added smaller text for phone numbers
        initials =
            String.left 1 (Maybe.withDefault "" contact.firstName) ++ String.left 1 (Maybe.withDefault "" contact.lastName)

        agentName =
            case contact.contactOwner of
                Just owner ->
                    owner.firstName ++ " " ++ owner.lastName

                Nothing ->
                    -- No contactOwner directly on the contact
                    case contact.agentId of
                        Just agentIdFromContact ->
                            -- Try to find the agent by ID from the contact
                            model.agents
                                |> List.filter (\agent -> agent.id == agentIdFromContact)
                                |> List.head
                                |> Maybe.map (\agent -> agent.firstName ++ " " ++ agent.lastName)
                                |> Maybe.withDefault ""

                        -- Fallback if agent ID on contact doesn't match any known agent
                        Nothing ->
                            -- No agentId on the contact, try to use the defaultAgentId from the model
                            case model.defaultAgentId of
                                Just defAgentId ->
                                    model.agents
                                        |> List.filter (\agent -> agent.id == defAgentId)
                                        |> List.head
                                        |> Maybe.map (\agent -> agent.firstName ++ " " ++ agent.lastName)
                                        |> Maybe.withDefault "Default"

                                -- Fallback if defaultAgentId doesn't match
                                Nothing ->
                                    -- No defaultAgentId in model, fall back to single agent logic or "Default"
                                    if List.length model.agents == 1 then
                                        case List.head model.agents of
                                            Just singleAgent ->
                                                singleAgent.firstName ++ " " ++ singleAgent.lastName

                                            Nothing ->
                                                "Default"

                                    else
                                        "Default"

        currentCarrier =
            Maybe.withDefault "" contact.currentCarrier
    in
    [ tr [ class "hover:bg-gray-50 transition-colors duration-200" ]
        [ td
            [ class (cellClass ++ " text-center")
            ]
            [ input
                [ type_ "checkbox"
                , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                , checked (List.member contact.id model.selectedContacts)
                , onClick (ToggleSelectContact contact.id)
                ]
                []
            ]
        , td [ class cellClass ]
            [ div [ class "flex items-center" ]
                [ div [ class "h-8 w-8 rounded-full bg-purple-100 flex items-center justify-center text-sm text-purple-700 font-medium uppercase" ]
                    [ text initials ]
                , div [ class "ml-3 text-sm text-gray-900" ]
                    [ button
                        [ class "text-left text-gray-900 hover:text-purple-600 transition-colors duration-200"
                        , onClick (NavigateToContact contact.id)
                        ]
                        [ text (Maybe.withDefault "" contact.firstName ++ " " ++ Maybe.withDefault "" contact.lastName) ]
                    ]
                ]
            ]
        , td [ class cellClass, Html.Attributes.title contact.email ]
            [ text (truncateEmail contact.email) ]
        , td [ class phoneCellClass ]
            [ text (formatPhoneNumber (Maybe.withDefault "" contact.phoneNumber)) ]
        , td [ class cellClass ]
            [ text (Maybe.withDefault "" contact.state) ]
        , td [ class cellClass ]
            [ text agentName ]
        , td [ class compactCellClass ]
            [ text currentCarrier ]
        , td [ class cellClass ]
            [ text (Maybe.withDefault "" contact.effectiveDate) ]
        , td [ class cellClass ]
            [ button
                [ class "text-purple-600 hover:text-purple-800 transition-colors duration-200"
                , onClick (NavigateToContact contact.id)
                ]
                [ viewIcon "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" ]
            ]
        ]
    ]


viewStatus : String -> Html Msg
viewStatus status =
    let
        ( bgColor, textColor, statusText ) =
            case status of
                "Quote Created" ->
                    ( "bg-green-50", "text-green-700", "Quote Created" )

                "Opened Email" ->
                    ( "bg-red-50", "text-red-700", "Opened Email" )

                "Email #2 Sent" ->
                    ( "bg-blue-50", "text-blue-700", "Email #2 Sent" )

                "Email #1 Sent" ->
                    ( "bg-blue-50", "text-blue-700", "Email #1 Sent" )

                "In Queue" ->
                    ( "bg-orange-50", "text-orange-700", "In Queue" )

                _ ->
                    ( "bg-gray-50", "text-gray-700", status )
    in
    div [ class ("inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium " ++ bgColor ++ " " ++ textColor) ]
        [ text statusText ]



-- HELPERS


truncateEmail : String -> String
truncateEmail email =
    if String.length email > 30 then
        String.left 30 email ++ "..."

    else
        email


updateContact : Contact -> List Contact -> List Contact
updateContact updated contacts =
    List.map
        (\contact ->
            if contact.id == updated.id then
                updated

            else
                contact
        )
        contacts



-- HTTP


submitAddForm : ContactForm -> Cmd Msg
submitAddForm form =
    Http.request
        { method = "POST"
        , headers = []
        , url = "/api/contacts/create"
        , body = Http.jsonBody (encodeContactForm form)
        , expect = Http.expectJson ContactAdded contactDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


encodeContactFormTemp : ContactForm -> Encode.Value
encodeContactFormTemp form =
    Encode.object
        [ ( "first_name", Encode.string form.firstName )
        , ( "last_name", Encode.string form.lastName )
        , ( "email", Encode.string form.email )
        , ( "phone_number", Encode.string (String.filter Char.isDigit form.phoneNumber |> String.left 10) )
        , ( "state", Encode.string form.state )
        , ( "effective_date", Encode.string form.effectiveDate )
        , ( "birth_date", Encode.string form.birthDate )
        , ( "tobacco_user", Encode.bool form.tobaccoUser )
        , ( "gender", Encode.string form.gender )
        , ( "zip_code", Encode.string form.zipCode )
        , ( "contact_owner_id", Encode.null )
        ]


fetchDashboardStats : Cmd Msg
fetchDashboardStats =
    Http.get
        { url = "/api/dashboard/stats"
        , expect = Http.expectJson GotDashboardStats dashboardStatsResponseDecoder
        }


dashboardStatsResponseDecoder : Decode.Decoder { success : Bool, stats : { quotesSent : Int, manualQuotesSent : Int, quotesViewed : Int, followUpsRequested : Int, healthQuestionsCompleted : Int } }
dashboardStatsResponseDecoder =
    Decode.map2
        (\success stats ->
            { success = success
            , stats = stats
            }
        )
        (Decode.field "success" Decode.bool)
        (Decode.field "stats" dashboardStatsDecoder)


dashboardStatsDecoder : Decode.Decoder { quotesSent : Int, manualQuotesSent : Int, quotesViewed : Int, followUpsRequested : Int, healthQuestionsCompleted : Int }
dashboardStatsDecoder =
    Decode.map5
        (\quotesSent manualQuotesSent quotesViewed followUpsRequested healthQuestionsCompleted ->
            { quotesSent = quotesSent
            , manualQuotesSent = manualQuotesSent
            , quotesViewed = quotesViewed
            , followUpsRequested = followUpsRequested
            , healthQuestionsCompleted = healthQuestionsCompleted
            }
        )
        (Decode.field "quotesSent" Decode.int)
        (Decode.field "manualQuotesSent" Decode.int)
        (Decode.field "quotesViewed" Decode.int)
        (Decode.field "followUpsRequested" Decode.int)
        (Decode.field "healthQuestionsCompleted" Decode.int)


submitEditFormWithFlag : ContactForm -> Bool -> Cmd Msg
submitEditFormWithFlag form isZipUpdate =
    case form.id of
        Just id ->
            let
                url =
                    if isZipUpdate then
                        "/api/contacts/" ++ String.fromInt id ++ "?zip_update=true"

                    else
                        "/api/contacts/" ++ String.fromInt id
            in
            Http.request
                { method = "PUT"
                , headers = []
                , url = url
                , body = Http.jsonBody (encodeContactForm form)
                , expect = Http.expectJson ContactUpdated contactDecoder
                , timeout = Nothing
                , tracker = Nothing
                }

        Nothing ->
            Cmd.none



-- JSON


contactDecoder : Decode.Decoder Contact
contactDecoder =
    Decode.succeed Contact
        |> Pipeline.required "id" Decode.int
        |> Pipeline.optional "first_name" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "last_name" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "email" Decode.string
        |> Pipeline.optional "phone_number"
            (Decode.string
                |> Decode.andThen
                    (\val -> Decode.succeed val)
                |> Decode.nullable
            )
            Nothing
        |> Pipeline.optional "state" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "contact_owner_id" (Decode.nullable Decode.int) Nothing
        |> Pipeline.optional "contact_owner" (Decode.nullable userDecoder) Nothing
        |> Pipeline.optional "current_carrier" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "effective_date" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "birth_date" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "tobacco_user" (Decode.nullable Decode.bool) Nothing
        |> Pipeline.optional "gender" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "zip_code" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "plan_type" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "status" Decode.string "New"
        |> Pipeline.required "agent_id" (Decode.nullable Decode.int)
        |> Pipeline.required "last_emailed" (Decode.nullable Decode.string)


contactsDecoder : Decode.Decoder ContactsResponse
contactsDecoder =
    Decode.succeed ContactsResponse
        |> Pipeline.required "contacts" (Decode.list contactDecoder)
        |> Pipeline.required "filterOptions" filterOptionsDecoder
        |> Pipeline.required "total" Decode.int
        |> Pipeline.required "page" Decode.int
        |> Pipeline.required "limit" Decode.int


filterOptionsDecoder : Decode.Decoder AvailableFilters
filterOptionsDecoder =
    Decode.succeed AvailableFilters
        |> Pipeline.required "carriers" (Decode.list Decode.string)
        |> Pipeline.required "states" (Decode.list Decode.string)


encodeContactForm : ContactForm -> Encode.Value
encodeContactForm form =
    let
        planType =
            case form.planType of
                Just value ->
                    [ ( "plan_type", Encode.string value ) ]

                Nothing ->
                    []

        currentCarrier =
            case form.currentCarrier of
                Just value ->
                    [ ( "current_carrier", Encode.string value ) ]

                Nothing ->
                    []

        contactOwnerId =
            case form.contactOwnerId of
                Just value ->
                    [ ( "contact_owner_id", Encode.int value ) ]

                Nothing ->
                    []
    in
    Encode.object
        ([ ( "first_name", Encode.string form.firstName )
         , ( "last_name", Encode.string form.lastName )
         , ( "email", Encode.string form.email )
         , ( "phone_number", Encode.string (String.filter Char.isDigit form.phoneNumber |> String.left 10) )
         , ( "state", Encode.string form.state )
         , ( "effective_date", Encode.string form.effectiveDate )
         , ( "birth_date", Encode.string form.birthDate )
         , ( "tobacco_user", Encode.bool form.tobaccoUser )
         , ( "gender", Encode.string form.gender )
         , ( "zip_code", Encode.string form.zipCode )
         ]
            ++ planType
            ++ currentCarrier
            ++ contactOwnerId
        )


viewModals : Model -> Html Msg
viewModals model =
    case model.showModal of
        NoModal ->
            text ""

        ContactChoiceModal ->
            viewContactChoiceModal

        AddModal ->
            viewAddModal model model.isSubmittingForm

        EditModal contact ->
            viewEditModal model model.isSubmittingForm

        CsvUploadModal state ->
            viewCsvUploadModal state model.isUploadingCsv model

        DeleteConfirmModal ->
            viewDeleteConfirmModal model

        ReassignAgentModal ->
            viewReassignAgentModal model


viewContactChoiceModal : Html Msg
viewContactChoiceModal =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-4" ]
        [ div [ class "bg-white rounded-md p-5 max-w-lg w-full mx-2 shadow-lg relative" ]
            [ button
                [ class "absolute top-2 right-2 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-xl font-semibold text-gray-900 mb-2" ]
                [ text "Add Contacts" ]
            , div [ class "text-xs text-gray-600 mb-4" ]
                [ text "Select how you want to add your new contacts." ]
            , div [ class "grid grid-cols-2 gap-3" ]
                [ div
                    [ class "p-3 border border-gray-200 rounded-md hover:border-[#03045E] hover:bg-[#03045E]/5 cursor-pointer transition-colors"
                    , onClick ChooseSingleContact
                    ]
                    [ div [ class "flex items-center mb-2" ]
                        [ div [ class "h-6 w-6 rounded-full bg-purple-100 flex items-center justify-center text-xs text-purple-700 font-medium" ]
                            [ viewIcon "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" ]
                        ]
                    , h3 [ class "text-base font-medium text-gray-900 mb-1" ]
                        [ text "Single Contact" ]
                    , p [ class "text-xs text-gray-600" ]
                        [ text "Individual Form" ]
                    ]
                , div
                    [ class "p-3 border border-gray-200 rounded-md hover:border-[#03045E] hover:bg-[#03045E]/5 cursor-pointer transition-colors"
                    , onClick ChooseMultipleContacts
                    ]
                    [ div [ class "flex items-center mb-2" ]
                        [ div [ class "h-6 w-6 rounded-full bg-purple-100 flex items-center justify-center text-xs text-purple-700 font-medium" ]
                            [ viewIcon "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" ]
                        ]
                    , h3 [ class "text-base font-medium text-gray-900 mb-1" ]
                        [ text "Multiple Contacts" ]
                    , p [ class "text-xs text-gray-600" ]
                        [ text "CSV Upload" ]
                    ]
                ]
            ]
        ]


viewAddModal : Model -> Bool -> Html Msg
viewAddModal model isSubmitting =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-4" ]
        [ div [ class "bg-white rounded-md p-5 max-w-lg w-full mx-2 shadow-lg relative max-h-[90vh] flex flex-col" ]
            [ button
                [ class "absolute top-2 right-2 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-xl font-semibold text-gray-900 mb-4" ]
                [ text "Add New Client" ]
            , div [ class "overflow-y-auto pr-1 flex-grow" ]
                [ viewContactForm model model.addForm UpdateAddForm SubmitAddForm "Add Client" isSubmitting ]
            ]
        ]


viewEditModal : Model -> Bool -> Html Msg
viewEditModal model isSubmitting =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-4" ]
        [ div [ class "bg-white rounded-md p-5 max-w-lg w-full mx-2 shadow-lg relative max-h-[90vh] flex flex-col" ]
            [ button
                [ class "absolute top-2 right-2 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-xl font-semibold text-gray-900 mb-4" ]
                [ text "Edit Client" ]
            , div [ class "overflow-y-auto pr-1 flex-grow" ]
                [ viewContactForm model model.editForm UpdateEditForm SubmitEditForm "Save Changes" isSubmitting ]
            ]
        ]


viewCsvUploadModal : UploadState -> Bool -> Model -> Html Msg
viewCsvUploadModal state isUploading model =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-10 max-w-2xl w-full mx-4 shadow-xl relative max-h-[90vh] overflow-y-auto" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Upload CSV" ]
            , div [ class "mb-6 text-sm text-gray-600" ]
                [ text "Need help formatting your CSV? "
                , Html.a
                    [ class "text-purple-600 hover:text-purple-800 hover:underline"
                    , Html.Attributes.href "/example.csv"
                    , Html.Attributes.download "example.csv"
                    ]
                    [ text "Download example CSV file" ]
                ]

            -- Error display
            , if state.error /= Nothing then
                div [ class "mb-6" ]
                    [ if state.stats /= Nothing then
                        let
                            stats =
                                Maybe.withDefault
                                    { totalRows = 0
                                    , errorRows = 0
                                    , validRows = 0
                                    , converted_carrier_rows = 0
                                    , supported_carriers = []
                                    }
                                    state.stats
                        in
                        div []
                            [ if stats.errorRows > 0 then
                                div [ class "p-4 mb-4 bg-red-50 border border-red-200 rounded-lg" ]
                                    [ div [ class "flex items-start" ]
                                        [ div [ class "flex-shrink-0" ]
                                            [ viewIcon "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" ]
                                        , div [ class "ml-3" ]
                                            [ h3 [ class "text-sm font-medium text-red-800" ]
                                                [ text "Upload Errors" ]
                                            , div [ class "mt-2 text-sm text-red-700" ]
                                                [ text ("Found " ++ String.fromInt stats.errorRows ++ " rows with errors. Successfully imported " ++ String.fromInt stats.validRows ++ " rows.")
                                                , case state.errorCsv of
                                                    Just csvContent ->
                                                        div [ class "mt-2 font-medium" ]
                                                            [ button
                                                                [ class "text-purple-600 hover:text-purple-800 hover:underline"
                                                                , onClick (DownloadErrorCsv csvContent)
                                                                ]
                                                                [ text "Download and Fix Error Rows" ]
                                                            ]

                                                    Nothing ->
                                                        text ""
                                                ]
                                            ]
                                        ]
                                    ]

                              else
                                text ""
                            , if stats.converted_carrier_rows > 0 then
                                div [ class "p-4 bg-yellow-50 border border-yellow-200 rounded-lg" ]
                                    [ div [ class "flex items-start" ]
                                        [ div [ class "flex-shrink-0" ]
                                            [ viewIcon "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" ]
                                        , div [ class "ml-3" ]
                                            [ h3 [ class "text-sm font-medium text-yellow-800 mb-3" ]
                                                [ text "Carrier Conversions" ]
                                            , div [ class "space-y-4 text-sm text-yellow-700" ]
                                                [ p []
                                                    [ text (String.fromInt stats.converted_carrier_rows ++ " rows had carriers we do not currently recognize or provide quotes for. This is normal and expected -- we will still email these contacts with quotes from supported Carriers.") ]
                                                , p []
                                                    [ text "However, this can also happen if there is a misspelling of a supported carrier. Please review to ensure the data is correct." ]
                                                , case state.converted_carriers_csv of
                                                    Just csvContent ->
                                                        div [ class "pt-1" ]
                                                            [ button
                                                                [ class "text-purple-600 hover:text-purple-800 hover:underline font-medium"
                                                                , onClick (DownloadCarrierConversionsCsv csvContent)
                                                                ]
                                                                [ text "Download Unrecognized Carrier Rows" ]
                                                            ]

                                                    Nothing ->
                                                        text ""
                                                , div [ class "pt-2 border-t border-yellow-200" ]
                                                    [ details [ class "text-sm" ]
                                                        [ summary [ class "cursor-pointer text-purple-600 hover:text-purple-800 font-medium" ]
                                                            [ text "Click to see supported carriers" ]
                                                        , div [ class "mt-3 pl-4 space-y-2" ]
                                                            (List.map
                                                                (\carrier ->
                                                                    div [ class "flex items-baseline" ]
                                                                        [ span [ class "font-medium" ] [ text carrier.name ]
                                                                        , if not (List.isEmpty carrier.aliases) then
                                                                            span [ class "ml-4 text-yellow-800" ]
                                                                                [ text ("Also accepts: " ++ String.join ", " carrier.aliases) ]

                                                                          else
                                                                            text ""
                                                                        ]
                                                                )
                                                                stats.supported_carriers
                                                            )
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]

                              else
                                text ""
                            ]

                      else
                        div [ class "p-4 bg-red-50 border border-red-200 rounded-lg" ]
                            [ div [ class "flex items-start" ]
                                [ div [ class "flex-shrink-0" ]
                                    [ viewIcon "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" ]
                                , div [ class "ml-3" ]
                                    [ h3 [ class "text-sm font-medium text-red-800" ]
                                        [ text "Error uploading CSV" ]
                                    , div [ class "mt-2 text-sm text-red-700" ]
                                        [ text (Maybe.withDefault "" state.error) ]
                                    ]
                                ]
                            ]
                    ]

              else
                text ""

            -- Display invalid emails section (if any)
            , if not (List.isEmpty state.invalidEmails) then
                div [ class "mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg" ]
                    [ div [ class "flex items-start" ]
                        [ div [ class "flex-shrink-0" ]
                            [ viewIcon "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" ]
                        , div [ class "ml-3 w-full" ]
                            [ h3 [ class "text-sm font-medium text-yellow-800 mb-2" ]
                                [ text ("Invalid Emails (" ++ String.fromInt (List.length state.invalidEmails) ++ ")") ]
                            , p [ class "text-sm text-yellow-700 mb-3" ]
                                [ text "The following records have invalid email addresses and will be skipped during import:" ]
                            , div [ class "max-h-80 overflow-y-auto bg-white border border-yellow-200 rounded p-2" ]
                                [ Html.ul [ class "text-xs text-yellow-800 space-y-1" ]
                                    (List.indexedMap
                                        (\index inv ->
                                            Html.li [ class "flex" ]
                                                [ span [ class "text-gray-500 w-16 flex-shrink-0" ] [ text ("Row " ++ String.fromInt (index + 1) ++ ":") ]
                                                , span [ class "flex-grow" ]
                                                    [ if String.isEmpty inv.email then
                                                        text "(empty string)"

                                                      else
                                                        text inv.email
                                                    ]
                                                ]
                                        )
                                        state.invalidEmails
                                    )
                                ]
                            ]
                        ]
                    ]

              else
                text ""

            -- Form fields (agent selection, etc.)
            , div [ class "mb-4 space-y-4" ]
                [ case model.currentUser of
                    Just user ->
                        if user.isAdmin then
                            div [ class "flex items-center space-x-2" ]
                                [ input
                                    [ type_ "checkbox"
                                    , checked state.overwriteDuplicates
                                    , onInput (\val -> ToggleOverwriteDuplicates (val == "true"))
                                    , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                    ]
                                    []
                                , label [ class "text-sm text-gray-600" ]
                                    [ text "Overwrite existing contacts (matched on email address)" ]
                                ]

                        else
                            text ""

                    Nothing ->
                        text ""
                , div [ class "form-group" ]
                    [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
                        [ text "Assign to Agent" ]
                    , div [ class "relative" ]
                        [ if List.isEmpty model.agents then
                            div [ class "p-2 text-gray-500 border rounded" ]
                                [ text "Loading agents..." ]

                          else
                            case model.currentUser of
                                Just user ->
                                    if user.isAgent && not user.isAdmin then
                                        -- For non-admin agents, show their name as fixed value
                                        let
                                            agentName =
                                                model.agents
                                                    |> List.filter (\agent -> agent.id == user.id)
                                                    |> List.head
                                                    |> Maybe.map (\agent -> agent.firstName ++ " " ++ agent.lastName)
                                                    |> Maybe.withDefault (user.firstName ++ " " ++ user.lastName)
                                        in
                                        div [ class "w-full px-4 py-3 bg-gray-100 border-[2.5px] border-gray-300 rounded-lg text-gray-700" ]
                                            [ text agentName ]

                                    else
                                        -- For admins, show dropdown with all agents
                                        let
                                            agentOptions =
                                                List.map
                                                    (\agent ->
                                                        ( String.fromInt agent.id
                                                        , agent.firstName ++ " " ++ agent.lastName
                                                        )
                                                    )
                                                    model.agents

                                            -- Get default agent ID - either from state.selectedAgentId if valid, or from current user
                                            defaultAgentId =
                                                user.id
                                        in
                                        Html.select
                                            [ class "w-full px-4 py-3 bg-white border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200 appearance-none"
                                            , value (String.fromInt defaultAgentId)
                                            , onInput (\val -> SelectUploadAgent (String.toInt val |> Maybe.withDefault 0))
                                            ]
                                            (List.map
                                                (\( val, label ) ->
                                                    option [ value val ] [ text label ]
                                                )
                                                agentOptions
                                            )

                                Nothing ->
                                    text ""
                        ]
                    ]
                ]

            -- File upload area
            , if state.processingHeaders then
                -- Show loading indicator while processing CSV headers
                div [ class "w-full h-64 border-2 border-gray-200 rounded-lg flex flex-col items-center justify-center p-8" ]
                    [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent mb-4" ] []
                    , div [ class "text-gray-600 text-center" ]
                        [ span [ class "block font-medium mb-1" ]
                            [ text "Processing your CSV file" ]
                        , span [ class "text-sm" ]
                            [ text "We're analyzing your file to map the columns automatically..." ]
                        ]
                    ]

              else
                div
                    [ class
                        ("w-full h-64 border-2 border-dashed rounded-lg flex flex-col items-center justify-center p-8 transition-colors "
                            ++ (if state.dragOver then
                                    "border-purple-500 bg-purple-50"

                                else
                                    "border-gray-300 hover:border-purple-400"
                               )
                        )
                    , preventDefaultOn "dragenter" (Decode.succeed ( DragEnter, True ))
                    , preventDefaultOn "dragover" (Decode.succeed ( NoOp, True ))
                    , preventDefaultOn "dragleave" (Decode.succeed ( DragLeave, True ))
                    , preventDefaultOn "drop" (dropDecoder FileDrop)
                    ]
                    [ div [ class "text-gray-500 text-center" ]
                        [ span [ class "block text-lg font-medium mb-2" ]
                            [ text "Drag and drop your CSV file here, or " ]
                        , button
                            [ class "text-purple-600 font-semibold hover:text-purple-700 focus:outline-none focus:underline"
                            , onClick ClickedSelectFile
                            ]
                            [ text "browse" ]
                        , if state.file /= Nothing then
                            div [ class "mt-4 text-sm bg-green-50 text-green-800 px-3 py-2 rounded-lg" ]
                                [ text ("File selected: " ++ (Maybe.map File.name state.file |> Maybe.withDefault "")) ]

                          else
                            text ""
                        ]
                    ]

            -- Column mapping section
            , if state.file /= Nothing && not state.processingHeaders && not (List.isEmpty state.csvHeaders) then
                div [ class "mt-8 space-y-6" ]
                    [ viewColumnMapping state
                    , viewCarrierMapping state model.carriers
                    , div [ class "mt-4" ]
                        [ h3 [ class "text-sm font-medium text-gray-700 mb-2" ]
                            [ text "Available CSV Columns" ]
                        , div [ class "bg-gray-50 p-3 rounded-md text-sm" ]
                            [ span [ class "text-gray-400 mr-2" ]
                                [ text "Headers:" ]
                            , span [ class "text-gray-600" ]
                                [ text (String.join ", " state.csvHeaders) ]
                            ]
                        ]
                    ]

              else
                text ""

            -- Buttons
            , div [ class "mt-8 flex justify-end space-x-4" ]
                [ button
                    [ class "px-6 py-3 bg-gray-100 text-gray-600 text-sm font-medium rounded-lg hover:bg-gray-200 transition-colors duration-200 focus:ring-4 focus:ring-gray-200"
                    , onClick CloseModal
                    ]
                    [ text "Cancel" ]
                , if isUploading then
                    div [ class "px-6 py-3 flex items-center space-x-2" ]
                        [ viewSpinner ]

                  else
                    let
                        isDisabled =
                            state.file
                                == Nothing
                                || state.processingHeaders
                                || state.extractingCarriers
                                || not (hasCarrierMappings state)
                                || List.isEmpty state.detectedCarriers
                    in
                    button
                        [ type_ "submit"
                        , class
                            (if isDisabled then
                                "px-6 py-3 bg-purple-400 text-white text-sm font-medium rounded-lg transition-colors duration-200 focus:ring-4 focus:ring-purple-200 cursor-not-allowed"

                             else
                                "px-6 py-3 bg-purple-500 text-white text-sm font-medium rounded-lg hover:bg-purple-600 transition-colors duration-200 focus:ring-4 focus:ring-purple-200"
                            )
                        , onClick UploadCsv
                        , Html.Attributes.disabled isDisabled
                        ]
                        [ text "Upload" ]
                ]
            ]
        ]


viewColumnMapping : UploadState -> Html Msg
viewColumnMapping state =
    div [ class "space-y-4" ]
        [ h3 [ class "text-sm font-medium text-gray-700 flex justify-between" ]
            [ text "Column Mapping"
            , span [ class "text-xs text-purple-600" ]
                [ text ("Detected " ++ String.fromInt (List.length state.csvHeaders) ++ " columns in your CSV") ]
            ]
        , p [ class "text-xs text-gray-500" ]
            [ text "Map your CSV columns to our required fields." ]
        , div [ class "grid grid-cols-2 gap-3" ]
            [ viewColumnMapField "First Name" "firstName" state
            , viewColumnMapField "Last Name" "lastName" state
            , viewColumnMapField "Email" "email" state
            , viewColumnMapField "Phone Number" "phoneNumber" state
            , viewColumnMapField "Current Carrier" "currentCarrier" state
            , viewColumnMapField "Effective Date" "effectiveDate" state
            , viewColumnMapField "Birth Date" "birthDate" state
            , viewColumnMapField "Tobacco User" "tobaccoUser" state
            , viewColumnMapField "Gender" "gender" state
            , viewColumnMapField "ZIP Code" "zipCode" state
            , viewColumnMapField "Plan Type" "planType" state
            ]
        ]


viewCarrierMapping : UploadState -> List String -> Html Msg
viewCarrierMapping state supportedCarriers =
    let
        carrierColumnName =
            case state.columnMapping of
                Just mapping ->
                    mapping.currentCarrier

                Nothing ->
                    ""

        hasCarrierColumn =
            not (String.isEmpty carrierColumnName)

        hasExtractedCarriers =
            not (List.isEmpty state.detectedCarriers)
    in
    div [ class "mt-6 space-y-4 border-t pt-6" ]
        [ h3 [ class "text-sm font-medium text-gray-700" ]
            [ text "Carrier Mapping" ]
        , p [ class "text-xs text-gray-500" ]
            [ text "Map carrier names in your CSV to standard carrier names in our system." ]

        -- Show which column is used for carrier data
        , div [ class "mb-4" ]
            [ if hasCarrierColumn then
                div [ class "flex space-x-2" ]
                    [ div [ class "text-xs font-medium text-gray-600 py-1" ]
                        [ text ("Using column \"" ++ carrierColumnName ++ "\" for carrier data") ]

                    {--
                    , button
                        [ class "px-3 py-1 bg-purple-500 text-white text-xs font-medium rounded hover:bg-purple-600 transition-colors"
                        , onClick ExtractCarrierValues
                        , disabled state.extractingCarriers
                        ]
                        [ if state.extractingCarriers then
                            div [ class "flex items-center" ]
                                [ viewSpinner
                                , span [ class "ml-2" ] [ text "Extracting..." ]
                                ]

                          else
                            text "Extract Carriers"
                        ]
                    --}
                    ]

              else
                div [ class "text-xs text-gray-500 italic" ]
                    [ text "Select a column for \"Current Carrier\" in the mapping above to continue." ]
            ]

        -- Show carrier mappings once extracted
        , if hasExtractedCarriers then
            div [ class "border rounded-md p-4 bg-gray-50" ]
                [ p [ class "text-xs text-gray-600 mb-3" ]
                    [ text ("Found " ++ String.fromInt (List.length state.detectedCarriers) ++ " unique carrier names in your CSV.") ]
                , if List.isEmpty state.detectedCarriers then
                    div [ class "text-sm text-gray-500 italic" ]
                        [ text "No carrier names found in the selected column." ]

                  else
                    div [ class "space-y-2 max-h-64 overflow-y-auto pr-2" ]
                        (List.map
                            (\carrier -> viewCarrierMappingRow carrier state supportedCarriers)
                            state.detectedCarriers
                        )
                ]

          else if hasCarrierColumn then
            div [ class "text-sm text-gray-500 italic" ]
                [ text "Click 'Extract Carriers' to analyze carrier names in your CSV." ]

          else
            div [ class "text-sm text-gray-500 italic" ]
                [ text "Select the \"Current Carrier\" column in the mapping above to begin." ]
        ]


viewCarrierMappingRow : String -> UploadState -> List String -> Html Msg
viewCarrierMappingRow carrier state supportedCarriers =
    let
        currentMapping =
            case state.carrierMapping of
                Just mapping ->
                    Dict.get carrier mapping.mappings
                        |> Maybe.withDefault "Other"

                Nothing ->
                    "Other"
    in
    div [ class "flex justify-between items-center py-1 border-b border-gray-200" ]
        [ div [ class "text-sm text-gray-700" ]
            [ text carrier ]
        , div [ class "w-1/2" ]
            [ select
                [ class "w-full px-2 py-1 text-sm border rounded"
                , value currentMapping
                , onInput (UpdateCarrierMapping carrier)
                ]
                (option [ value "Other" ] [ text "Other/Unsupported" ]
                    :: List.map
                        (\c ->
                            option
                                [ value c
                                , selected (currentMapping == c)
                                ]
                                [ text c ]
                        )
                        supportedCarriers
                )
            ]
        ]


viewColumnMapField : String -> String -> UploadState -> Html Msg
viewColumnMapField labelText field state =
    div [ class "flex flex-col gap-1" ]
        [ label [ class "text-xs font-medium text-gray-600" ]
            [ text labelText ]
        , select
            [ class "w-full px-2 py-1 text-sm border rounded"
            , value (getColumnMapping field state)
            , onInput (UpdateColumnMapping field)
            ]
            (option [ value "" ] [ text "Select a column" ]
                :: List.map
                    (\header ->
                        option
                            [ value header
                            , selected (getColumnMapping field state == header)
                            ]
                            [ text header ]
                    )
                    state.csvHeaders
            )
        ]


getColumnMapping : String -> UploadState -> String
getColumnMapping field state =
    case state.columnMapping of
        Just mapping ->
            case field of
                "firstName" ->
                    mapping.firstName

                "lastName" ->
                    mapping.lastName

                "email" ->
                    mapping.email

                "phoneNumber" ->
                    mapping.phoneNumber

                "currentCarrier" ->
                    mapping.currentCarrier

                "effectiveDate" ->
                    mapping.effectiveDate

                "birthDate" ->
                    mapping.birthDate

                "tobaccoUser" ->
                    mapping.tobaccoUser

                "gender" ->
                    mapping.gender

                "zipCode" ->
                    mapping.zipCode

                "planType" ->
                    mapping.planType

                _ ->
                    ""

        Nothing ->
            ""


dropDecoder : (File -> msg) -> Decoder ( msg, Bool )
dropDecoder toMsg =
    Decode.at [ "dataTransfer", "files" ] (Decode.index 0 File.decoder)
        |> Decode.map (\file -> ( toMsg file, True ))


uploadCsv : File -> Bool -> Maybe Int -> Model -> Cmd Msg
uploadCsv file overwriteDuplicates maybeAgentId model =
    let
        actualOverwriteValue =
            case model.currentUser of
                Just user ->
                    if user.isAgent && not user.isAdmin then
                        False

                    else
                        overwriteDuplicates

                Nothing ->
                    overwriteDuplicates
    in
    File.toString file
        |> Task.andThen
            (\csvContent ->
                case model.showModal of
                    CsvUploadModal state ->
                        case ( state.columnMapping, state.carrierMapping ) of
                            ( Just colMapping, Just carrierMapping ) ->
                                case CsvProcessor.processCsvToContacts csvContent colMapping carrierMapping of
                                    Ok { valid, invalid } ->
                                        if List.isEmpty valid then
                                            -- If there are no valid contacts, return an error
                                            Task.succeed
                                                (Err
                                                    (Http.BadBody
                                                        "No valid contacts found in CSV. Please check email formats."
                                                    )
                                                )

                                        else
                                            Http.task
                                                { method = "POST"
                                                , headers = []
                                                , url = "/api/contacts/bulk-import"
                                                , body =
                                                    Http.jsonBody
                                                        (Encode.object
                                                            [ ( "contacts", Encode.list encodeProcessedContact valid )
                                                            , ( "overwriteExisting", Encode.bool actualOverwriteValue )
                                                            , ( "agentId"
                                                              , case maybeAgentId of
                                                                    Just id ->
                                                                        Encode.int id

                                                                    Nothing ->
                                                                        Encode.null
                                                              )
                                                            ]
                                                        )
                                                , resolver =
                                                    Http.stringResolver <|
                                                        \response ->
                                                            case response of
                                                                Http.GoodStatus_ _ body ->
                                                                    case Decode.decodeString uploadResponseDecoder body of
                                                                        Ok value ->
                                                                            Ok value

                                                                        Err err ->
                                                                            Err (Http.BadBody (Decode.errorToString err))

                                                                Http.BadUrl_ url ->
                                                                    Err (Http.BadUrl url)

                                                                Http.Timeout_ ->
                                                                    Err Http.Timeout

                                                                Http.NetworkError_ ->
                                                                    Err Http.NetworkError

                                                                Http.BadStatus_ metadata _ ->
                                                                    Err (Http.BadStatus metadata.statusCode)
                                                , timeout = Nothing
                                                }
                                                |> Task.map Ok
                                                |> Task.onError (\err -> Task.succeed (Err err))

                                    Err err ->
                                        Task.succeed
                                            (Err
                                                (Http.BadBody
                                                    (case err of
                                                        CsvProcessor.ParseError msg ->
                                                            "Failed to parse CSV: " ++ msg

                                                        CsvProcessor.EmptyFile ->
                                                            "CSV file is empty"

                                                        CsvProcessor.NoHeaders ->
                                                            "CSV file has no headers"
                                                    )
                                                )
                                            )

                            _ ->
                                Task.succeed
                                    (Err
                                        (Http.BadBody "Column mapping or carrier mapping not configured")
                                    )

                    _ ->
                        Task.succeed
                            (Err
                                (Http.BadBody "Invalid modal state")
                            )
            )
        |> Task.perform CsvUploaded



-- Add encoder for processed contacts


encodeProcessedContact : CsvProcessor.ProcessedContact -> Encode.Value
encodeProcessedContact contact =
    Encode.object
        [ ( "first_name", Encode.string contact.firstName )
        , ( "last_name", Encode.string contact.lastName )
        , ( "email", Encode.string contact.email )
        , ( "phone_number", Encode.string contact.phoneNumber )
        , ( "current_carrier", Encode.string contact.currentCarrier )
        , ( "effective_date", Encode.string contact.effectiveDate )
        , ( "birth_date", Encode.string contact.birthDate )
        , ( "tobacco_user", Encode.bool contact.tobaccoUser )
        , ( "gender", Encode.string contact.gender )
        , ( "zip_code", Encode.string contact.zipCode )
        , ( "plan_type", Encode.string contact.planType )
        ]



-- Helper function to encode column mapping to JSON


encodeColumnMapping : ColumnMapping -> String
encodeColumnMapping mapping =
    Encode.encode 0
        (Encode.object
            [ ( "firstName", Encode.string mapping.firstName )
            , ( "lastName", Encode.string mapping.lastName )
            , ( "email", Encode.string mapping.email )
            , ( "phoneNumber", Encode.string mapping.phoneNumber )
            , ( "currentCarrier", Encode.string mapping.currentCarrier )
            , ( "effectiveDate", Encode.string mapping.effectiveDate )
            , ( "birthDate", Encode.string mapping.birthDate )
            , ( "tobaccoUser", Encode.string mapping.tobaccoUser )
            , ( "gender", Encode.string mapping.gender )
            , ( "zipCode", Encode.string mapping.zipCode )
            , ( "planType", Encode.string mapping.planType )
            ]
        )



-- Helper function to encode carrier mapping to JSON


encodeCarrierMapping : CarrierMapping -> String
encodeCarrierMapping mapping =
    Encode.encode 0
        (Encode.object
            [ ( "detectedCarriers", Encode.list Encode.string mapping.detectedCarriers )
            , ( "mappings", Encode.dict identity Encode.string mapping.mappings )
            ]
        )


uploadResponseDecoder : Decode.Decoder UploadResponse
uploadResponseDecoder =
    Decode.succeed UploadResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "message" Decode.string
        |> Pipeline.required "totalRows" Decode.int


type alias UploadResponse =
    { success : Bool
    , message : String
    , totalRows : Int
    }


formatUploadError : String -> String
formatUploadError message =
    if String.startsWith "Missing required columns:" message then
        let
            missingColumns =
                String.dropLeft (String.length "Missing required columns:") message
                    |> String.trim
                    |> String.split ","
                    |> List.map String.trim
                    |> String.join ", "
        in
        "Your CSV is missing the following required columns: " ++ missingColumns ++ ". Please add these columns and try again."

    else
        message



-- Add this new subscription function


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch
        [ case model.showModal of
            NoModal ->
                Sub.none

            ContactChoiceModal ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))

            AddModal ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))

            EditModal _ ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))

            CsvUploadModal _ ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))

            DeleteConfirmModal ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))

            ReassignAgentModal ->
                Browser.Events.onKeyDown (Decode.map HandleKeyDown (Decode.field "key" Decode.string))
        , if model.openFilter /= Nothing then
            -- Only listen for clicks outside when a dropdown is open
            Browser.Events.onMouseDown (Decode.succeed CloseFilterDropdown)

          else
            Sub.none
        ]


sortContacts : Maybe SortColumn -> SortDirection -> List Contact -> List Contact
sortContacts maybeColumn direction contacts =
    case maybeColumn of
        Nothing ->
            contacts

        Just column ->
            let
                comparator =
                    case column of
                        NameCol ->
                            \a b ->
                                compare
                                    (Maybe.withDefault "" a.firstName ++ " " ++ Maybe.withDefault "" a.lastName)
                                    (Maybe.withDefault "" b.firstName ++ " " ++ Maybe.withDefault "" b.lastName)

                        StatusCol ->
                            \a b -> compare a.status b.status

                        EmailCol ->
                            \a b -> compare a.email b.email

                        PhoneNumberCol ->
                            \a b -> compare (Maybe.withDefault "" a.phoneNumber) (Maybe.withDefault "" b.phoneNumber)

                        StateCol ->
                            \a b -> compare (Maybe.withDefault "" a.state) (Maybe.withDefault "" b.state)

                        ContactOwnerCol ->
                            \a b ->
                                let
                                    aName =
                                        getUserName a.contactOwner

                                    bName =
                                        getUserName b.contactOwner
                                in
                                compare aName bName

                        CurrentCarrierCol ->
                            \a b -> compare (Maybe.withDefault "" a.currentCarrier) (Maybe.withDefault "" b.currentCarrier)

                        EffectiveDateCol ->
                            \a b -> compare (Maybe.withDefault "" a.effectiveDate) (Maybe.withDefault "" b.effectiveDate)
            in
            List.sortWith
                (if direction == Ascending then
                    comparator

                 else
                    \a b -> comparator b a
                )
                contacts


filterContacts : Filters -> String -> Time.Posix -> List Contact -> List Contact
filterContacts filters searchQuery currentTime contacts =
    contacts
        |> filterBySearch searchQuery
        |> filterByCarriers filters.carriers
        |> filterByList (\c -> Maybe.withDefault "" c.state) filters.states
        |> filterByAge filters.ageRange
        |> filterByAgents filters.agents


filterByCarriers : List String -> List Contact -> List Contact
filterByCarriers carriers contacts =
    if List.isEmpty carriers then
        contacts

    else
        List.filter
            (\contact ->
                case contact.currentCarrier of
                    Just carrier ->
                        List.member carrier carriers

                    Nothing ->
                        False
            )
            contacts


filterBySearch : String -> List Contact -> List Contact
filterBySearch query contacts =
    if String.isEmpty query then
        contacts

    else
        let
            loweredQuery =
                String.toLower query
        in
        List.filter
            (\contact ->
                String.contains loweredQuery (String.toLower (Maybe.withDefault "" contact.firstName))
                    || String.contains loweredQuery (String.toLower (Maybe.withDefault "" contact.lastName))
                    || (case contact.currentCarrier of
                            Just carrier ->
                                String.contains loweredQuery (String.toLower carrier)

                            Nothing ->
                                False
                       )
            )
            contacts


filterByAge : Maybe ( Int, Int ) -> List Contact -> List Contact
filterByAge range contacts =
    case range of
        Nothing ->
            contacts

        Just ( min, max ) ->
            List.filter
                (\contact ->
                    let
                        age =
                            calculateAge (Maybe.withDefault "" contact.birthDate)
                    in
                    age >= min && age <= max
                )
                contacts


calculateAge : String -> Int
calculateAge birthDate =
    -- This is a simplified version. You might want to use a proper date library
    2024 - (String.left 4 birthDate |> String.toInt |> Maybe.withDefault 0)


toggleFilter : Filters -> FilterType -> String -> Filters
toggleFilter filters filterType value =
    case filterType of
        CarrierFilter ->
            { filters | carriers = toggleList filters.carriers value }

        StateFilter ->
            { filters | states = toggleList filters.states value }

        AgeFilter ->
            { filters | ageRange = toggleAgeRange filters.ageRange value }

        AgentFilter ->
            { filters | agents = toggleAgentList filters.agents (String.toInt value |> Maybe.withDefault 0) }


toggleList : List String -> String -> List String
toggleList list value =
    if List.member value list then
        List.filter (\v -> v /= value) list

    else
        value :: list


toggleAgeRange : Maybe ( Int, Int ) -> String -> Maybe ( Int, Int )
toggleAgeRange maybeRange value =
    case maybeRange of
        Nothing ->
            Just ( String.toInt value |> Maybe.withDefault 0, String.toInt value |> Maybe.withDefault 0 )

        Just ( min, max ) ->
            if min == (String.toInt value |> Maybe.withDefault 0) then
                Just ( String.toInt value |> Maybe.withDefault 0, max )

            else if max == (String.toInt value |> Maybe.withDefault 0) then
                Just ( min, String.toInt value |> Maybe.withDefault 0 )

            else
                Just ( min, max )


setAgeFilter : Int -> Int -> Filters -> Filters
setAgeFilter min max filters =
    if max < 1 then
        { filters | ageRange = Nothing }
        -- Don't apply filter if max is 0 or negative

    else
        { filters | ageRange = Just ( min, max ) }



-- Helper function to get unique values from contacts


getUniqueValues : (Contact -> String) -> List Contact -> List String
getUniqueValues getter contacts =
    contacts
        |> List.map getter
        |> List.sort
        |> List.Extra.unique


zipInfoDecoder : Decode.Decoder ZipInfo
zipInfoDecoder =
    Decode.succeed ZipInfo
        |> Pipeline.required "state" Decode.string
        |> Pipeline.required "counties" (Decode.list Decode.string)
        |> Pipeline.required "cities" (Decode.list Decode.string)


filterByList : (Contact -> String) -> List String -> List Contact -> List Contact
filterByList getter selectedValues contacts =
    if List.isEmpty selectedValues then
        contacts

    else
        List.filter
            (\contact ->
                List.member (getter contact) selectedValues
            )
            contacts


viewContactForm : Model -> ContactForm -> (ContactFormField -> String -> Msg) -> Msg -> String -> Bool -> Html Msg
viewContactForm model form updateMsg submitMsg buttonText isSubmitting =
    let
        carrierOptions =
            ( "", "Select a carrier" ) :: List.map (\c -> ( c, c )) model.carriers ++ [ ( "Other", "Other" ) ]

        planTypeOptions =
            [ ( "", "Select a plan type" ), ( "Plan N", "Plan N" ), ( "Plan G", "Plan G" ), ( "Other", "Other" ) ]

        -- Simple agent dropdown options - show all available agents
        agentOptions =
            if List.isEmpty model.agents then
                -- If no agents loaded, use current user as fallback if they're an agent
                case model.currentUser of
                    Just user ->
                        [ ( String.fromInt user.id, user.firstName ++ " " ++ user.lastName ) ]

                    Nothing ->
                        []

            else
                -- Just show all available agents
                List.map
                    (\agent ->
                        ( String.fromInt agent.id, agent.firstName ++ " " ++ agent.lastName )
                    )
                    model.agents

        -- Get the selected agent ID or default to first agent
        defaultAgentId =
            case List.head model.agents of
                Just agent ->
                    String.fromInt agent.id

                Nothing ->
                    -- Try current user as fallback
                    case model.currentUser of
                        Just user ->
                            String.fromInt user.id

                        Nothing ->
                            ""

        selectedAgentId =
            case form.contactOwnerId of
                Just id ->
                    String.fromInt id

                Nothing ->
                    defaultAgentId

        selectedCarrier =
            Maybe.withDefault "" form.currentCarrier

        emailField =
            div [ class "form-group mb-3 relative" ]
                [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ]
                    [ text "Email" ]
                , div [ class "relative" ]
                    [ Html.input
                        [ type_ "email"
                        , class
                            ("w-full px-2 py-1.5 bg-white border-[1.5px] rounded-md text-sm text-gray-700 placeholder-gray-400 shadow-sm transition-all duration-200 "
                                ++ (if model.emailExists then
                                        "border-red-300 hover:border-red-400 focus:border-red-500 focus:ring-1 focus:ring-red-200"

                                    else
                                        "border-purple-300 hover:border-purple-400 focus:border-purple-500 focus:ring-1 focus:ring-purple-200"
                                   )
                            )
                        , value form.email
                        , onInput (updateMsg Email)
                        , on "blur" (Decode.succeed (EmailBlur form.email)) -- Add onBlur handler
                        , required True
                        ]
                        []
                    , if model.isCheckingEmail then
                        div [ class "absolute right-2 top-1.5" ]
                            [ viewSpinner ]

                      else if model.emailExists then
                        div
                            [ class "absolute right-2 top-1.5 text-red-500" ]
                            [ viewIcon "M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" ]

                      else if String.length form.email > 0 then
                        div
                            [ class "absolute right-2 top-1.5 text-green-500" ]
                            [ viewIcon "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" ]

                      else
                        text ""
                    ]
                , if model.emailExists then
                    div [ class "mt-1 text-xs text-red-600" ]
                        [ text "A contact with this email already exists" ]

                  else
                    text ""
                ]
    in
    Html.form [ onSubmit submitMsg ]
        [ div [ class "grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-3" ]
            [ viewFormInput "First Name" "text" form.firstName FirstName updateMsg True
            , viewFormInput "Last Name" "text" form.lastName LastName updateMsg True
            , emailField
            , viewFormInput "Phone Number" "text" form.phoneNumber PhoneNumber updateMsg False
            , viewFormSelect "Current Carrier" selectedCarrier CurrentCarrier updateMsg carrierOptions
            , viewFormSelect "Plan Type" (Maybe.withDefault "" form.planType) PlanType updateMsg planTypeOptions
            , viewFormSelectWithValue "Assigned Agent" selectedAgentId ContactOwnerId updateMsg agentOptions
            , viewFormInput "Effective Date" "date" form.effectiveDate EffectiveDate updateMsg False
            , viewFormInput "Birth Date" "date" form.birthDate BirthDate updateMsg False
            , viewFormRadioGroup "Tobacco User"
                (if form.tobaccoUser then
                    "true"

                 else
                    "false"
                )
                TobaccoUser
                updateMsg
                [ ( "true", "Yes" ), ( "false", "No" ) ]
            , viewFormRadioGroup "Gender" form.gender Gender updateMsg [ ( "M", "Male" ), ( "F", "Female" ) ]
            , div [ class "col-span-1 sm:col-span-2 grid grid-cols-1 sm:grid-cols-2 gap-x-4" ]
                [ viewZipCodeField model form
                , viewStateField form
                ]
            ]
        , if model.error /= Nothing && not model.emailExists then
            div [ class "mt-2 text-red-600 text-xs" ] [ text (Maybe.withDefault "" model.error) ]

          else
            text ""
        , div [ class "mt-4 flex justify-end space-x-2" ]
            [ button
                [ type_ "button"
                , onClick CloseModal
                , class "px-3 py-1.5 bg-white text-gray-700 text-sm font-medium rounded-md border border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200 focus:ring-1 focus:ring-purple-100"
                ]
                [ text "Cancel" ]
            , if isSubmitting then
                div [ class "px-3 py-1.5 flex items-center" ] [ viewSpinner ]

              else
                let
                    isValid =
                        isContactFormValid form && not model.emailExists && not model.isCheckingEmail
                in
                button
                    [ type_ "submit"
                    , class
                        ("px-3 py-1.5 text-white text-sm font-medium rounded-md transition-colors duration-200 focus:ring-1 focus:ring-purple-200 "
                            ++ (if isValid then
                                    "bg-purple-500 hover:bg-purple-600"

                                else
                                    "bg-gray-300 cursor-not-allowed"
                               )
                        )
                    , Html.Attributes.disabled (not isValid)
                    ]
                    [ text buttonText ]
            ]
        ]


viewFormInput : String -> String -> String -> ContactFormField -> (ContactFormField -> String -> Msg) -> Bool -> Html Msg
viewFormInput labelText inputType inputValue field updateMsg isRequired =
    let
        displayValue =
            if field == PhoneNumber then
                formatPhoneNumber inputValue

            else
                inputValue

        inputHandler =
            if field == PhoneNumber then
                \val ->
                    let
                        digits =
                            String.filter Char.isDigit val |> String.left 10
                    in
                    updateMsg field digits

            else
                updateMsg field

        placeholderText =
            if field == PhoneNumber then
                "(555) 555-5555"

            else
                ""
    in
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ]
            [ text labelText ]
        , Html.input
            [ type_ inputType
            , class "w-full px-2 py-1.5 bg-white border-[1.5px] border-purple-300 rounded-md text-sm text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-1 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , value displayValue
            , onInput inputHandler
            , required isRequired
            , placeholder placeholderText
            ]
            []
        ]


viewFormSelect : String -> String -> ContactFormField -> (ContactFormField -> String -> Msg) -> List ( String, String ) -> Html Msg
viewFormSelect labelText selectedValue field updateMsg options =
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ]
            [ text labelText ]
        , Html.select
            [ class "w-full px-2 py-1.5 bg-white border-[1.5px] border-purple-300 rounded-md text-sm text-gray-700 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-1 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , value selectedValue
            , onInput (updateMsg field)
            , required False
            ]
            (List.map
                (\( val, label ) ->
                    Html.option
                        [ value val, selected (val == selectedValue) ]
                        [ text label ]
                )
                options
            )
        ]


viewFormRadioGroup : String -> String -> ContactFormField -> (ContactFormField -> String -> Msg) -> List ( String, String ) -> Html Msg
viewFormRadioGroup labelText selectedValue field updateMsg options =
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ]
            [ text labelText ]
        , div [ class "flex gap-2" ]
            (List.map
                (\( val, txt ) ->
                    label
                        [ class
                            ("flex items-center px-2 py-1 rounded-md border text-sm cursor-pointer transition-all duration-200 "
                                ++ (if selectedValue == val then
                                        "border-purple-500 bg-purple-50 text-purple-700"

                                    else
                                        "border-gray-200 hover:border-purple-200"
                                   )
                            )
                        ]
                        [ input
                            [ type_ "radio"
                            , value val
                            , checked (selectedValue == val)
                            , onInput (\_ -> updateMsg field val)
                            , class "sr-only" -- Hide the actual radio button
                            ]
                            []
                        , text txt
                        ]
                )
                options
            )
        ]


viewZipCodeField : Model -> ContactForm -> Html Msg
viewZipCodeField model form =
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ]
            [ text "ZIP Code" ]
        , Html.input
            [ type_ "text"
            , class "w-full px-2 py-1.5 bg-white border-[1.5px] border-purple-300 rounded-md text-sm text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-1 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , value form.zipCode
            , onInput
                (\zip ->
                    Batch
                        [ case model.showModal of
                            AddModal ->
                                UpdateAddForm ZipCode zip

                            EditModal _ ->
                                UpdateEditForm ZipCode zip

                            _ ->
                                NoOp
                        , if String.length zip == 5 then
                            LookupZipCode zip

                          else
                            NoOp
                        ]
                )
            ]
            []
        ]


viewStateField : ContactForm -> Html Msg
viewStateField form =
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ]
            [ text "State" ]
        , Html.input
            [ type_ "text"
            , class "w-full px-2 py-1.5 bg-white border-[1.5px] border-gray-200 rounded-md text-sm text-gray-700 placeholder-gray-400 shadow-sm focus:ring-1 focus:ring-purple-200 focus:bg-white transition-all duration-200"
            , value form.state
            , Html.Attributes.disabled True
            ]
            []
        ]


viewSpinner : Html msg
viewSpinner =
    div [ class "animate-spin rounded-full h-5 w-5 border-2 border-purple-500 border-t-transparent" ] []


onClickOutside : msg -> Html.Attribute msg
onClickOutside msg =
    on "click" (Decode.succeed msg)


userDecoder : Decode.Decoder User
userDecoder =
    Decode.succeed User
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "first_name" Decode.string
        |> Pipeline.required "last_name" Decode.string
        |> Pipeline.required "is_admin" Decode.bool
        |> Pipeline.required "is_agent" Decode.bool
        |> Pipeline.required "is_default" Decode.bool
        |> Pipeline.required "organization_id" Decode.int
        |> Pipeline.required "is_active" Decode.bool
        |> Pipeline.required "phone" Decode.string
        |> Pipeline.optional "carriers" (Decode.list Decode.string) []
        |> Pipeline.optional "stateLicenses" (Decode.list Decode.string) []


deleteContacts : List Int -> Cmd Msg
deleteContacts contactIds =
    Http.request
        { method = "DELETE"
        , headers = []
        , url = "/api/contacts"
        , body = Http.jsonBody (encodeContactIds contactIds)
        , expect = Http.expectJson ContactsDeleted deleteResponseDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


encodeContactIds : List Int -> Encode.Value
encodeContactIds ids =
    Encode.list Encode.int ids


deleteResponseDecoder : Decode.Decoder DeleteResponse
deleteResponseDecoder =
    Decode.map3 DeleteResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "deleted_ids" (Decode.list Decode.int))
        (Decode.field "message" Decode.string)



-- HELPER FUNCTIONS


isAdminOrAdminAgent : Maybe User -> Bool
isAdminOrAdminAgent maybeUser =
    case maybeUser of
        Just user ->
            let
                isAdmin =
                    user.isAdmin
            in
            isAdmin

        Nothing ->
            False


viewExpandedContent : Contact -> Html Msg
viewExpandedContent contact =
    div
        [ class "grid grid-cols-5 gap-4 py-2 px-4 transition-all duration-200 ease-in-out" ]
        [ viewExpandedField "Birth Date" (Maybe.withDefault "" contact.birthDate)
        , viewExpandedField "Tobacco User"
            (case contact.tobaccoUser of
                Just True ->
                    "Yes"

                Just False ->
                    "No"

                Nothing ->
                    ""
            )
        , viewExpandedField "Gender" (Maybe.withDefault "" contact.gender)
        , viewExpandedField "ZIP Code" (Maybe.withDefault "" contact.zipCode)
        , viewExpandedField "Plan Type" (Maybe.withDefault "" contact.planType)
        ]


viewExpandedField : String -> String -> Html Msg
viewExpandedField label value =
    div [ class "text-sm" ]
        [ span [ class "font-medium text-gray-500" ] [ text label ]
        , div [ class "mt-1 text-gray-900" ] [ text value ]
        ]


viewIcon : String -> Html Msg
viewIcon path =
    svg
        [ Svg.Attributes.class "w-4 h-4"
        , Svg.Attributes.fill "none"
        , Svg.Attributes.stroke "currentColor"
        , Svg.Attributes.viewBox "0 0 24 24"
        ]
        [ Svg.path [ Svg.Attributes.d path ] [] ]



-- HTTP FUNCTIONS


fetchContacts : Model -> Cmd Msg
fetchContacts model =
    let
        queryParams =
            [ ( "search", model.searchQuery )
            , ( "states", String.join "," model.activeFilters.states )
            , ( "carriers", String.join "," model.activeFilters.carriers )
            , ( "agents"
              , model.activeFilters.agents
                    |> List.map String.fromInt
                    |> String.join ","
              )
            , ( "page", String.fromInt model.pagination.currentPage )
            , ( "limit", String.fromInt model.pagination.itemsPerPage )
            ]
                |> List.filter (\( _, value ) -> not (String.isEmpty value))
                |> List.map (\( key, value ) -> Url.string key value)
    in
    Http.get
        { url = Url.absolute [ "api", "contacts" ] queryParams
        , expect = Http.expectJson GotContacts contactsDecoder
        }


fetchCurrentUser : Cmd Msg
fetchCurrentUser =
    Http.get
        { url = "/api/me"
        , expect = Http.expectJson GotCurrentUser userDecoder
        }


viewFilterDropdown : Model -> FilterType -> Html Msg
viewFilterDropdown model filterType =
    let
        options =
            case filterType of
                CarrierFilter ->
                    model.availableFilters.carriers

                StateFilter ->
                    model.availableFilters.states

                AgentFilter ->
                    -- Add "Default" option for unassigned contacts
                    "Default"
                        :: (model.agents
                                |> List.filter (\agent -> agent.isAgent)
                                |> List.map
                                    (\agent ->
                                        agent.firstName ++ " " ++ agent.lastName
                                    )
                           )

                _ ->
                    []

        activeFilters =
            case filterType of
                CarrierFilter ->
                    model.activeFilters.carriers

                StateFilter ->
                    model.activeFilters.states

                AgentFilter ->
                    model.activeFilters.agents
                        |> List.map String.fromInt

                _ ->
                    []

        hasActiveFilters =
            not (List.isEmpty activeFilters)
    in
    div
        [ class "absolute left-0 mt-2 w-60 sm:w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 z-10"

        -- IMPORTANT: This mousedown handler prevents the dropdown from closing when clicking inside it
        , Html.Events.stopPropagationOn "mousedown" (Decode.succeed ( NoOp, True ))
        ]
        [ div [ class "py-1" ]
            [ div [ class "p-2 border-b border-gray-200" ]
                [ button
                    [ class
                        ("w-full text-left text-sm font-medium "
                            ++ (if hasActiveFilters then
                                    "text-purple-600 hover:text-purple-800 cursor-pointer"

                                else
                                    "text-gray-400 cursor-not-allowed"
                               )
                        )
                    , onClick (SelectAllFilter filterType False)
                    , Html.Attributes.disabled (not hasActiveFilters)
                    ]
                    [ text "Clear Filters" ]
                ]
            , div [ class "max-h-56 sm:max-h-48 overflow-y-auto p-2" ]
                (case filterType of
                    AgentFilter ->
                        -- Special handling for agent filter since it's using IDs
                        -- First add the Default option (agentId = 0 means unassigned/default)
                        label
                            [ class "flex items-center space-x-2 py-1" ]
                            [ input
                                [ type_ "checkbox"
                                , checked (List.member 0 model.activeFilters.agents)
                                , onClick (ToggleFilter filterType (String.fromInt 0))
                                , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                ]
                                []
                            , span [ class "text-sm text-gray-600" ]
                                [ text "Default" ]
                            ]
                            :: (model.agents
                                    |> List.filter (\agent -> agent.isAgent)
                                    |> List.map
                                        (\agent ->
                                            label
                                                [ class "flex items-center space-x-2 py-1" ]
                                                [ input
                                                    [ type_ "checkbox"
                                                    , checked (List.member agent.id model.activeFilters.agents)
                                                    , onClick (ToggleFilter filterType (String.fromInt agent.id))
                                                    , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                                    ]
                                                    []
                                                , span [ class "text-sm text-gray-600" ]
                                                    [ text (agent.firstName ++ " " ++ agent.lastName) ]
                                                ]
                                        )
                               )

                    _ ->
                        -- Original handling for other filters
                        List.map
                            (\option ->
                                label
                                    [ class "flex items-center space-x-2 py-1" ]
                                    [ input
                                        [ type_ "checkbox"
                                        , checked (List.member option activeFilters)
                                        , onClick (ToggleFilter filterType option)
                                        , class "rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                        ]
                                        []
                                    , span [ class "text-sm text-gray-600" ]
                                        [ text option ]
                                    ]
                            )
                            options
                )
            ]
        ]


isContactFormValid : ContactForm -> Bool
isContactFormValid form =
    String.length form.firstName
        > 0
        && String.length form.lastName
        > 0
        && String.length form.email
        > 0


isJust : Maybe a -> Bool
isJust maybeValue =
    case maybeValue of
        Just _ ->
            True

        Nothing ->
            False



-- Add the isValidEmail function here


isValidEmail : String -> Bool
isValidEmail email =
    String.contains "@" email
        && String.contains "." email
        && String.length email
        > 5


fetchCarriers : Cmd Msg
fetchCarriers =
    Http.get
        { url = "/api/settings/carriers"
        , expect = Http.expectJson GotCarriers (Decode.list (Decode.field "name" Decode.string))
        }


fetchAgents : Cmd Msg
fetchAgents =
    Http.get
        { url = "/api/agents"
        , expect = Http.expectJson GotAgents agentsResponseDecoder
        }



-- Add a decoder for the new response format


type alias AgentsResponseWithDefault =
    { agents : List User
    , defaultAgentId : Maybe String
    }


agentsResponseDecoder : Decoder AgentsResponseWithDefault
agentsResponseDecoder =
    Decode.succeed AgentsResponseWithDefault
        |> Pipeline.required "agents" (Decode.list agentDecoder)
        |> Pipeline.optional "defaultAgentId" (Decode.nullable Decode.string) Nothing


checkEmail : String -> Cmd Msg
checkEmail email =
    Http.request
        { method = "GET"
        , headers = []
        , url = "/api/contacts/check-email/" ++ email
        , body = Http.emptyBody
        , expect = Http.expectJson EmailChecked emailCheckDecoder
        , timeout = Just 5000 -- 5 second timeout
        , tracker = Nothing
        }


emailCheckDecoder : Decode.Decoder { exists : Bool }
emailCheckDecoder =
    Decode.oneOf
        [ -- Try to decode the standard response
          Decode.map (\exists -> { exists = exists })
            (Decode.field "exists" Decode.bool)
        , -- Try to decode success response wrapper with exists field
          Decode.field "success" Decode.bool
            |> Decode.andThen
                (\_ ->
                    Decode.map (\exists -> { exists = exists })
                        (Decode.field "exists" Decode.bool)
                )
        , -- Fallback for any other structure
          Decode.succeed { exists = False }
        ]


carrierDecoder : Decode.Decoder { name : String, aliases : List String }
carrierDecoder =
    Decode.succeed (\name aliases -> { name = name, aliases = aliases })
        |> Pipeline.required "name" Decode.string
        |> Pipeline.required "aliases" (Decode.list Decode.string)


viewDeleteConfirmModal : Model -> Html Msg
viewDeleteConfirmModal model =
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-8" ]
        [ div [ class "bg-white rounded-xl p-8 max-w-md w-full mx-4 shadow-xl relative" ]
            [ button
                [ class "absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ text "×" ]
            , h2 [ class "text-xl font-semibold text-gray-900 mb-4" ]
                [ text "Delete Contacts" ]
            , p [ class "text-sm text-gray-600 mb-6" ]
                [ text ("Are you sure you want to delete " ++ String.fromInt (List.length model.selectedContacts) ++ " contacts? This action cannot be undone.") ]
            , div [ class "flex justify-end space-x-4" ]
                [ button
                    [ class "px-4 py-2 text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200"
                    , onClick CloseModal
                    ]
                    [ text "Cancel" ]
                , if model.isDeletingContacts then
                    div [ class "px-4 py-2 flex items-center" ]
                        [ viewSpinner ]

                  else
                    button
                        [ class "px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors duration-200"
                        , onClick DeleteSelectedContacts
                        ]
                        [ text "Delete" ]
                ]
            ]
        ]



-- Add a new function to allow setting a custom selected value


viewFormSelectWithValue : String -> String -> ContactFormField -> (ContactFormField -> String -> Msg) -> List ( String, String ) -> Html Msg
viewFormSelectWithValue labelText selectedValue field updateMsg options =
    div [ class "form-group mb-3" ]
        [ Html.label [ class "block text-xs font-medium text-gray-700 mb-1" ]
            [ text labelText ]
        , div [ class "relative" ]
            [ Html.select
                [ class "w-full px-2 py-1.5 bg-white border-[1.5px] border-purple-300 rounded-md text-sm text-gray-700 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-1 focus:ring-purple-200 focus:bg-white transition-all duration-200 appearance-none"
                , value selectedValue
                , onInput (updateMsg field)
                , required False
                ]
                (option [ value "", disabled True, selected (selectedValue == "") ] [ text "Select an Agent" ]
                    :: List.map (\( val, txt ) -> option [ value val, selected (val == selectedValue) ] [ text txt ]) options
                )
            , div [ class "absolute inset-y-0 right-0 flex items-center px-1 pointer-events-none text-gray-500" ]
                [ viewIcon "M19 9l-7 7-7-7" ]
            ]
        ]


agentDecoder : Decode.Decoder User
agentDecoder =
    Decode.succeed User
        |> Pipeline.required "id"
            (Decode.oneOf
                [ -- Try to decode as an integer directly
                  Decode.int
                , -- If that fails, try to decode as a string and convert to int
                  Decode.string
                    |> Decode.andThen
                        (\str ->
                            case String.toInt str of
                                Just intVal ->
                                    Decode.succeed intVal

                                Nothing ->
                                    Decode.fail ("Could not convert agent ID string to integer: " ++ str)
                        )
                ]
            )
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "firstName" Decode.string
        |> Pipeline.required "lastName" Decode.string
        |> Pipeline.required "isAdmin" Decode.bool
        |> Pipeline.required "isAgent" Decode.bool
        |> Pipeline.required "isDefault" Decode.bool
        |> Pipeline.optional "organizationId" Decode.int 0
        -- Add default value for isActive since it's not in the API response
        |> Pipeline.hardcoded True
        -- Assume agents are active
        |> Pipeline.optional "phone" Decode.string ""
        |> Pipeline.optional "carriers" (Decode.list Decode.string) []
        |> Pipeline.optional "stateLicenses" (Decode.list Decode.string) []


viewReassignAgentModal : Model -> Html Msg
viewReassignAgentModal model =
    let
        -- Use all users in the agents list
        agentList =
            model.agents

        -- Create list of agent options
        agentOptions =
            List.map
                (\agent ->
                    ( agent.id
                    , agent.firstName ++ " " ++ agent.lastName
                    )
                )
                agentList

        -- Get the first agent ID as the default value if no agent is currently selected
        defaultAgentId =
            case List.head agentList of
                Just agent ->
                    String.fromInt agent.id

                Nothing ->
                    "0"
    in
    div [ class "fixed inset-0 bg-gray-500/75 flex items-center justify-center p-4 sm:p-8" ]
        [ div [ class "bg-white rounded-xl p-5 sm:p-8 md:p-10 max-w-2xl w-full mx-4 shadow-xl relative overflow-y-auto max-h-[90vh]" ]
            [ button
                [ class "absolute top-2 sm:top-4 right-2 sm:right-4 text-gray-400 hover:text-gray-600 transition-colors duration-200"
                , onClick CloseModal
                ]
                [ viewIcon "M6 18L18 6M6 6l12 12" ]
            , h2 [ class "text-2xl font-semibold text-gray-900 mb-8" ]
                [ text "Reassign Contacts" ]
            , div [ class "mb-6 text-sm text-gray-600" ]
                [ text "Select an agent to reassign the selected contacts to." ]
            , div [ class "form-group" ]
                [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
                    [ text "Select Agent" ]
                , div [ class "relative" ]
                    [ if List.isEmpty model.agents then
                        div [ class "p-2 text-gray-500 border rounded" ]
                            [ text "Loading agents..." ]

                      else
                        Html.select
                            [ class "w-full px-3 py-2 sm:px-4 sm:py-3 bg-white border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200 appearance-none"
                            , value defaultAgentId
                            , onInput (\val -> SelectReassignAgent (String.toInt val |> Maybe.withDefault 0))
                            ]
                            (List.map
                                (\( val, label ) ->
                                    option [ value (String.fromInt val) ] [ text label ]
                                )
                                agentOptions
                            )
                    , div [ class "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none" ]
                        [ viewIcon "M19 9l-7 7-7-7" ]
                    ]
                ]
            , div [ class "mt-8 flex justify-end space-x-4" ]
                [ button
                    [ class "px-4 py-2 sm:px-6 sm:py-3 bg-white text-gray-700 text-sm font-medium rounded-lg border-2 border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors duration-200 focus:ring-4 focus:ring-purple-100"
                    , onClick CloseModal
                    ]
                    [ text "Cancel" ]
                , button
                    [ class "px-4 py-2 sm:px-6 sm:py-3 bg-purple-500 text-white text-sm font-medium rounded-lg hover:bg-purple-600 transition-colors duration-200 focus:ring-4 focus:ring-purple-200"
                    , onClick ReassignSelectedContacts
                    ]
                    [ text "Reassign" ]
                ]
            ]
        ]


reassignContacts : List Int -> Int -> Cmd Msg
reassignContacts contactIds agentId =
    Http.request
        { method = "PUT"
        , headers = []
        , url = "/api/contacts/reassign"
        , body =
            Http.jsonBody
                (Encode.object
                    [ ( "contact_ids", Encode.list Encode.int contactIds )
                    , ( "agent_id"
                      , if agentId == 0 then
                            -- Send null for Default option
                            Encode.null

                        else
                            Encode.int agentId
                      )
                    ]
                )
        , expect = Http.expectJson ContactsReassigned reassignResponseDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


reassignResponseDecoder : Decode.Decoder ReassignResponse
reassignResponseDecoder =
    Decode.succeed ReassignResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "updated_ids" (Decode.list Decode.int)
        |> Pipeline.required "message" Decode.string


toggleAgentList : List Int -> Int -> List Int
toggleAgentList list value =
    if List.member value list then
        List.filter (\v -> v /= value) list

    else
        value :: list



-- Add the filterByAgents function


filterByAgents : List Int -> List Contact -> List Contact
filterByAgents agentIds contacts =
    if List.isEmpty agentIds then
        contacts

    else
        List.filter
            (\contact ->
                case contact.agentId of
                    Just agentId ->
                        List.member agentId agentIds

                    Nothing ->
                        False
            )
            contacts



-- Replace the old contact limit banner functions with this more streamlined one


viewPaginationControls : Model -> Html Msg
viewPaginationControls model =
    let
        totalPages =
            model.pagination.totalPages

        currentPage =
            model.pagination.currentPage

        itemsPerPage =
            model.pagination.itemsPerPage

        totalItems =
            model.pagination.totalItems

        -- Calculate range of items being displayed
        startItem =
            (currentPage - 1) * itemsPerPage + 1

        endItem =
            min (currentPage * itemsPerPage) totalItems

        -- Create a list of page numbers to show
        pageNumbers =
            if totalPages <= 7 then
                List.range 1 totalPages

            else if currentPage <= 4 then
                List.range 1 5 ++ [ -1, totalPages ]

            else if currentPage >= totalPages - 3 then
                1 :: -1 :: List.range (totalPages - 4) totalPages

            else
                1 :: -1 :: List.range (currentPage - 1) (currentPage + 1) ++ [ -1, totalPages ]

        -- Helper function to render a page button
        pageButton page =
            if page == -1 then
                -- Render ellipsis for skipped pages
                span [ class "px-3 py-2 text-gray-400" ] [ text "..." ]

            else
                button
                    [ class
                        ("px-3 py-2 text-sm font-medium rounded-md transition-colors "
                            ++ (if page == currentPage then
                                    "bg-purple-50 text-purple-600 border-purple-500"

                                else
                                    "text-gray-500 hover:bg-gray-50 hover:text-gray-700"
                               )
                        )
                    , onClick (ChangePage page)
                    ]
                    [ text (String.fromInt page) ]
    in
    div [ class "max-w-7xl mx-auto pb-24" ]
        -- Added padding at bottom to prevent overlap with bulk action bar
        [ div [ class "mt-4 flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6" ]
            [ div [ class "flex flex-1 justify-between sm:hidden" ]
                [ button
                    [ class "relative inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
                    , onClick (ChangePage (currentPage - 1))
                    , Html.Attributes.disabled (currentPage == 1)
                    ]
                    [ text "Previous" ]
                , button
                    [ class "relative ml-3 inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
                    , onClick (ChangePage (currentPage + 1))
                    , Html.Attributes.disabled (currentPage == totalPages)
                    ]
                    [ text "Next" ]
                ]
            , div [ class "hidden sm:flex sm:flex-1 sm:items-center sm:justify-between" ]
                [ div [ class "text-sm text-gray-700" ]
                    [ span [] [ text "Showing " ]
                    , span [ class "font-medium" ] [ text (String.fromInt startItem) ]
                    , span [] [ text " to " ]
                    , span [ class "font-medium" ] [ text (String.fromInt endItem) ]
                    , span [] [ text " of " ]
                    , span [ class "font-medium" ] [ text (String.fromInt totalItems) ]
                    , span [] [ text " results" ]
                    ]
                , div [ class "flex items-center space-x-4" ]
                    [ div [ class "relative" ]
                        [ select
                            [ class "block w-full rounded-md border-gray-300 py-1.5 pl-3 pr-10 text-base focus:border-purple-500 focus:outline-none focus:ring-purple-500 sm:text-sm"
                            , onInput (\val -> ChangeItemsPerPage (Maybe.withDefault 100 (String.toInt val)))
                            , value (String.fromInt itemsPerPage)
                            ]
                            [ option [ value "50" ] [ text "50 per page" ]
                            , option [ value "100" ] [ text "100 per page" ]
                            , option [ value "250" ] [ text "250 per page" ]
                            ]
                        ]
                    , nav
                        [ class "isolate inline-flex -space-x-px rounded-md shadow-sm"
                        , Html.Attributes.attribute "aria-label" "Pagination"
                        ]
                        (List.map pageButton pageNumbers)
                    ]
                ]
            ]
        ]


extractCsvHeaders : File -> Cmd Msg
extractCsvHeaders file =
    Task.perform
        (\content -> CsvHeadersExtracted (extractHeadersFromCsv content))
        (File.toString file)


extractHeadersFromCsv : String -> Result String (List String)
extractHeadersFromCsv csvContent =
    case CsvProcessor.extractHeaders csvContent of
        Ok headers ->
            Ok headers

        Err CsvProcessor.EmptyFile ->
            Err "CSV file appears to be empty"

        Err CsvProcessor.NoHeaders ->
            Err "CSV file has no headers"

        Err (CsvProcessor.ParseError msg) ->
            Err ("Failed to parse CSV file: " ++ msg)


suggestMappings : List String -> Cmd Msg
suggestMappings headers =
    let
        -- Use the CsvProcessor to find best matches for column mappings locally
        columnMappings =
            CsvProcessor.suggestColumnMappings headers

        -- Create an empty carrier mapping for now (will be populated later)
        carrierMappings =
            Dict.empty
    in
    -- Return the suggested mappings directly instead of making an HTTP request
    Task.perform
        (\_ ->
            SuggestedMappingsReceived
                (Ok
                    { columnMappings = columnMappings
                    , carrierMappings = carrierMappings
                    }
                )
        )
        (Task.succeed ())


extractUniqueCarriers : String -> String -> List String
extractUniqueCarriers csvContent carrierColumn =
    case CsvProcessor.extractUniqueValues csvContent carrierColumn of
        Ok values ->
            values

        Err _ ->
            []



-- Helper function to get an element at a specific index


getAt : Int -> List a -> Maybe a
getAt index list =
    if index < 0 then
        Nothing

    else
        List.head (List.drop index list)



-- Add a function to fetch carriers and create CsvProcessor.CarrierMapping compatible format


fetchAndProcessCarriers : List String -> Cmd Msg
fetchAndProcessCarriers detectedCarriers =
    -- Use a model function instead of an API call
    -- We'll use this from the GotCarriers handler
    Cmd.none



-- Add this helper function near other helper functions


hasCarrierMappings : UploadState -> Bool
hasCarrierMappings state =
    case state.carrierMapping of
        Just mapping ->
            not (List.isEmpty mapping.detectedCarriers)

        Nothing ->
            False


getUserName : Maybe User -> String
getUserName maybeUser =
    case maybeUser of
        Just user ->
            user.firstName ++ " " ++ user.lastName

        Nothing ->
            "Default"

================
File: frontend/src/ContactUs.elm
================
module ContactUs exposing (Model, Msg(..), init, update, view)

import Browser exposing (Document)
import Html exposing (Html, a, button, div, form, h1, h2, h3, input, label, p, section, span, text, textarea)
import Html.Attributes exposing (class, for, href, id, name, placeholder, rows, type_, value)
import Html.Events exposing (onClick, onInput, onSubmit)
import Http
import Json.Encode as E
import MyIcon



-- MODEL


type alias Model =
    { name : String
    , email : String
    , phone : String
    , message : String
    , loading : Bool
    , submitStatus : SubmitStatus
    }


type SubmitStatus
    = NotSubmitted
    | Submitting
    | Success
    | Error String


init : () -> ( Model, Cmd Msg )
init _ =
    ( { name = ""
      , email = ""
      , phone = ""
      , message = ""
      , loading = False
      , submitStatus = NotSubmitted
      }
    , Cmd.none
    )



-- UPDATE


type Msg
    = UpdateName String
    | UpdateEmail String
    | UpdatePhone String
    | UpdateMessage String
    | SubmitForm
    | FormSubmitted (Result Http.Error ())


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateName name ->
            ( { model | name = name }, Cmd.none )

        UpdateEmail email ->
            ( { model | email = email }, Cmd.none )

        UpdatePhone phone ->
            ( { model | phone = phone }, Cmd.none )

        UpdateMessage message ->
            ( { model | message = message }, Cmd.none )

        SubmitForm ->
            if String.isEmpty model.name || String.isEmpty model.email || String.isEmpty model.message then
                ( { model | submitStatus = Error "Please fill in all required fields" }, Cmd.none )

            else
                ( { model | submitStatus = Submitting }
                , submitContactForm model
                )

        FormSubmitted result ->
            case result of
                Ok _ ->
                    ( { model
                        | submitStatus = Success
                        , name = ""
                        , email = ""
                        , phone = ""
                        , message = ""
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model | submitStatus = Error "Failed to submit form. Please try again." }
                    , Cmd.none
                    )


submitContactForm : Model -> Cmd Msg
submitContactForm model =
    Http.post
        { url = "/api/contact-us"
        , body =
            Http.jsonBody
                (E.object
                    [ ( "name", E.string model.name )
                    , ( "email", E.string model.email )
                    , ( "phone", E.string model.phone )
                    , ( "message", E.string model.message )
                    ]
                )
        , expect = Http.expectWhatever FormSubmitted
        }



-- VIEW


view : Model -> Document Msg
view model =
    { title = "Contact Us - Medicare Max"
    , body = [ viewContent model ]
    }


viewContent : Model -> Html Msg
viewContent model =
    div [ class "min-h-screen bg-white" ]
        [ div [ class "max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:px-8" ]
            [ div [ class "text-center mb-12" ]
                [ h1 [ class "text-4xl font-bold text-gray-900 mb-4" ]
                    [ text "Contact Us" ]
                , p [ class "text-lg text-gray-600" ]
                    [ text "We're here to help with all your Medicare needs" ]
                ]
            , div [ class "grid grid-cols-1 lg:grid-cols-2 gap-12" ]
                [ viewContactInfo
                , viewContactForm model
                ]
            ]
        ]


viewContactInfo : Html Msg
viewContactInfo =
    div [ class "space-y-8" ]
        [ div [ class "bg-white rounded-lg shadow-md p-8" ]
            [ h2 [ class "text-2xl font-semibold text-gray-900 mb-6" ]
                [ text "Get in Touch" ]
            , div [ class "space-y-6" ]
                [ viewContactItem (MyIcon.phone 20 "#6B7280") "Phone" "816-799-6644"
                , viewContactItem (MyIcon.mail 20 "#6B7280") "Email" "information@medicaremax.ai"
                ]
            ]
        , div [ class "bg-blue-50 rounded-lg p-6" ]
            [ h3 [ class "text-lg font-semibold text-blue-900 mb-3" ]
                [ text "Quick Help" ]
            , div [ class "space-y-2" ]
                [ a
                    [ href "/schedule-main"
                    , class "block text-blue-600 hover:text-blue-800 underline"
                    ]
                    [ text "Schedule a Demo" ]
                , a
                    [ href "/pricing"
                    , class "block text-blue-600 hover:text-blue-800 underline"
                    ]
                    [ text "View Pricing" ]
                , a
                    [ href "/dashboard?payment_success=true"
                    , class "block text-blue-600 hover:text-blue-800 underline"
                    ]
                    [ text "Watch Platform Walkthrough" ]
                ]
            ]
        ]


viewContactItem : Html msg -> String -> String -> Html msg
viewContactItem icon title content =
    div [ class "flex items-start space-x-3" ]
        [ div [ class "flex-shrink-0 mt-1" ]
            [ icon
            ]
        , div []
            [ p [ class "font-medium text-gray-900" ]
                [ text title ]
            , p [ class "text-gray-600 whitespace-pre-line" ]
                [ text content ]
            ]
        ]


viewContactForm : Model -> Html Msg
viewContactForm model =
    div [ class "bg-white rounded-lg shadow-md p-8" ]
        [ h2 [ class "text-2xl font-semibold text-gray-900 mb-6" ]
            [ text "Send us a Message" ]
        , case model.submitStatus of
            Success ->
                div [ class "bg-green-50 border border-green-200 rounded-md p-4 mb-6" ]
                    [ p [ class "text-green-800" ]
                        [ text "Thank you for contacting us! We'll get back to you soon." ]
                    ]

            Error errorMsg ->
                div [ class "bg-red-50 border border-red-200 rounded-md p-4 mb-6" ]
                    [ p [ class "text-red-800" ]
                        [ text errorMsg ]
                    ]

            _ ->
                text ""
        , form [ onSubmit SubmitForm ]
            [ div [ class "space-y-6" ]
                [ div []
                    [ label
                        [ for "name"
                        , class "block text-sm font-medium text-gray-700 mb-1"
                        ]
                        [ text "Name *" ]
                    , input
                        [ type_ "text"
                        , id "name"
                        , name "name"
                        , value model.name
                        , onInput UpdateName
                        , placeholder "Your name"
                        , class "w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        ]
                        []
                    ]
                , div []
                    [ label
                        [ for "email"
                        , class "block text-sm font-medium text-gray-700 mb-1"
                        ]
                        [ text "Email *" ]
                    , input
                        [ type_ "email"
                        , id "email"
                        , name "email"
                        , value model.email
                        , onInput UpdateEmail
                        , placeholder "your@email.com"
                        , class "w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        ]
                        []
                    ]
                , div []
                    [ label
                        [ for "phone"
                        , class "block text-sm font-medium text-gray-700 mb-1"
                        ]
                        [ text "Phone (optional)" ]
                    , input
                        [ type_ "tel"
                        , id "phone"
                        , name "phone"
                        , value model.phone
                        , onInput UpdatePhone
                        , placeholder "(123) 456-7890"
                        , class "w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        ]
                        []
                    ]
                , div []
                    [ label
                        [ for "message"
                        , class "block text-sm font-medium text-gray-700 mb-1"
                        ]
                        [ text "Message *" ]
                    , textarea
                        [ id "message"
                        , name "message"
                        , rows 5
                        , value model.message
                        , onInput UpdateMessage
                        , placeholder "How can we help you?"
                        , class "w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        ]
                        []
                    ]
                , button
                    [ type_ "submit"
                    , class "w-full bg-blue-600 text-white py-3 px-6 rounded-md font-medium hover:bg-blue-700 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                    , Html.Attributes.disabled (model.submitStatus == Submitting)
                    ]
                    [ text
                        (if model.submitStatus == Submitting then
                            "Sending..."

                         else
                            "Send Message"
                        )
                    ]
                ]
            ]
        ]

================
File: frontend/src/CsvProcessor.elm
================
module CsvProcessor exposing
    ( CarrierMapping
    , ColumnMapping
    , Error(..)
    , ProcessedContact
    , extractHeaders
    , extractUniqueValues
    , findBestMatch
    , processCsvToContacts
    , suggestCarrierMappings
    , suggestColumnMappings
    , transformCsvData
    )

import Csv.Parser
import Dict exposing (Dict)
import Fuzzy
import List.Extra
import Set



-- TYPES


type Error
    = ParseError String
    | EmptyFile
    | NoHeaders


type alias ColumnMapping =
    { firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , currentCarrier : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : String
    , gender : String
    , zipCode : String
    , planType : String
    }


type alias CarrierMapping =
    { detectedCarriers : List String
    , mappings : Dict String String -- Original carrier name -> Standardized carrier name
    }


type alias FieldVariations =
    Dict String (List String)


emptyColumnMapping : ColumnMapping
emptyColumnMapping =
    { firstName = ""
    , lastName = ""
    , email = ""
    , phoneNumber = ""
    , currentCarrier = ""
    , effectiveDate = ""
    , birthDate = ""
    , tobaccoUser = ""
    , gender = ""
    , zipCode = ""
    , planType = ""
    }


emptyCarrierMapping : CarrierMapping
emptyCarrierMapping =
    { detectedCarriers = []
    , mappings = Dict.empty
    }



-- Add new type for processed contact data


type alias ProcessedContact =
    { firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , currentCarrier : String
    , effectiveDate : String
    , birthDate : String
    , tobaccoUser : Bool
    , gender : String
    , zipCode : String
    , planType : String
    }



-- EXTRACT CSV DATA


extractHeaders : String -> Result Error (List String)
extractHeaders csvContent =
    if String.isEmpty (String.trim csvContent) then
        Err EmptyFile

    else
        case Csv.Parser.parse { fieldSeparator = ',' } csvContent of
            Ok rows ->
                case List.head rows of
                    Just headerRow ->
                        Ok headerRow

                    Nothing ->
                        Err NoHeaders

            Err _ ->
                Err (ParseError "Failed to parse CSV file")


extractUniqueValues : String -> String -> Result Error (List String)
extractUniqueValues csvContent columnName =
    if String.isEmpty (String.trim csvContent) then
        Err EmptyFile

    else
        case Csv.Parser.parse { fieldSeparator = ',' } csvContent of
            Ok rows ->
                case List.head rows of
                    Just headerRow ->
                        -- Find the index of the column
                        let
                            columnIndex =
                                List.indexedMap (\i h -> ( i, h )) headerRow
                                    |> List.filter (\( _, h ) -> h == columnName)
                                    |> List.head
                                    |> Maybe.map Tuple.first
                        in
                        case columnIndex of
                            Just index ->
                                -- Get values from that column (skip header)
                                let
                                    values =
                                        List.drop 1 rows
                                            |> List.filterMap
                                                (\row ->
                                                    if index < List.length row then
                                                        Just (getAt index row |> Maybe.withDefault "")

                                                    else
                                                        Nothing
                                                )
                                            |> List.filter (not << String.isEmpty)
                                            |> List.map String.trim
                                            |> uniqueValues
                                in
                                Ok values

                            Nothing ->
                                Err (ParseError ("Column not found: " ++ columnName))

                    Nothing ->
                        Err NoHeaders

            Err _ ->
                Err (ParseError "Failed to parse CSV file")



-- FUZZY MATCHING AND SUGGESTIONS


suggestColumnMappings : List String -> ColumnMapping
suggestColumnMappings headers =
    let
        -- Field name variations
        fieldVariations =
            createFieldVariations

        -- For each field, find the best matching header
        findBestHeader : String -> List String -> List String -> String
        findBestHeader field variations allHeaders =
            let
                -- Try exact matches first
                exactMatches =
                    List.filter
                        (\h ->
                            List.member (String.toLower h) (List.map String.toLower (field :: variations))
                        )
                        allHeaders
            in
            case List.head exactMatches of
                Just match ->
                    match

                Nothing ->
                    -- Try fuzzy matching if no exact matches
                    findBestMatch field variations allHeaders
    in
    { firstName = findBestHeader "firstName" (Maybe.withDefault [] (Dict.get "firstName" fieldVariations)) headers
    , lastName = findBestHeader "lastName" (Maybe.withDefault [] (Dict.get "lastName" fieldVariations)) headers
    , email = findBestHeader "email" (Maybe.withDefault [] (Dict.get "email" fieldVariations)) headers
    , phoneNumber = findBestHeader "phoneNumber" (Maybe.withDefault [] (Dict.get "phoneNumber" fieldVariations)) headers
    , currentCarrier = findBestHeader "currentCarrier" (Maybe.withDefault [] (Dict.get "currentCarrier" fieldVariations)) headers
    , effectiveDate = findBestHeader "effectiveDate" (Maybe.withDefault [] (Dict.get "effectiveDate" fieldVariations)) headers
    , birthDate = findBestHeader "birthDate" (Maybe.withDefault [] (Dict.get "birthDate" fieldVariations)) headers
    , tobaccoUser = findBestHeader "tobaccoUser" (Maybe.withDefault [] (Dict.get "tobaccoUser" fieldVariations)) headers
    , gender = findBestHeader "gender" (Maybe.withDefault [] (Dict.get "gender" fieldVariations)) headers
    , zipCode = findBestHeader "zipCode" (Maybe.withDefault [] (Dict.get "zipCode" fieldVariations)) headers
    , planType = findBestHeader "planType" (Maybe.withDefault [] (Dict.get "planType" fieldVariations)) headers
    }


suggestCarrierMappings : List String -> List { name : String, aliases : List String } -> CarrierMapping
suggestCarrierMappings detectedCarriers standardCarriers =
    let
        mappings =
            List.foldl
                (\carrier dict ->
                    let
                        matchedCarrier =
                            findBestCarrierMatch carrier standardCarriers
                    in
                    Dict.insert carrier matchedCarrier dict
                )
                Dict.empty
                detectedCarriers
    in
    { detectedCarriers = detectedCarriers
    , mappings = mappings
    }


findBestCarrierMatch : String -> List { name : String, aliases : List String } -> String
findBestCarrierMatch carrierName standardCarriers =
    let
        normalizedCarrierName =
            String.toLower (String.trim carrierName)

        -- Add special case handling for common patterns
        specialCaseMatch =
            case normalizedCarrierName of
                "aarp" ->
                    Just "United Healthcare"

                "aarp / uhc" ->
                    Just "United Healthcare"

                "aarp/uhc" ->
                    Just "United Healthcare"

                "aarp / uhica" ->
                    Just "United Healthcare"

                "aarp/uhica" ->
                    Just "United Healthcare"

                "uhc" ->
                    Just "United Healthcare"

                "uhica" ->
                    Just "United Healthcare"

                "united healthcare" ->
                    Just "United Healthcare"

                "unitedhealthcare" ->
                    Just "United Healthcare"

                "ace / chubb" ->
                    Just "Ace Chubb"

                "ace/chubb" ->
                    Just "Ace Chubb"

                "ace chubb" ->
                    Just "Ace Chubb"

                "cigna healthspring" ->
                    Just "Cigna"

                "cigna-healthspring" ->
                    Just "Cigna"

                "bcbs" ->
                    Just "Blue Cross Blue Shield"

                "blue cross" ->
                    Just "Blue Cross Blue Shield"

                "blue shield" ->
                    Just "Blue Cross Blue Shield"

                "humana" ->
                    Just "Humana"

                "humana gold" ->
                    Just "Humana"

                "humana gold plus" ->
                    Just "Humana"

                "wellcare by allwell" ->
                    Just "Wellcare"

                "allwell" ->
                    Just "Wellcare"

                _ ->
                    Nothing

        -- First check for special case matches
        -- Then check for exact matches
        -- Then try fuzzy matching
        exactMatches =
            List.filter
                (\carrier ->
                    String.toLower carrier.name
                        == normalizedCarrierName
                        || List.member normalizedCarrierName (List.map String.toLower carrier.aliases)
                )
                standardCarriers

        -- Try fuzzy matching if no exact match
        fuzzyMatches =
            if List.isEmpty exactMatches then
                List.map
                    (\carrier ->
                        let
                            -- Match against carrier name
                            nameScore =
                                Fuzzy.match [] [] normalizedCarrierName (String.toLower carrier.name)

                            -- Match against aliases and take best score
                            aliasScores =
                                List.map
                                    (\alias -> Fuzzy.match [] [] normalizedCarrierName (String.toLower alias))
                                    carrier.aliases

                            bestAliasScore =
                                List.sortBy .score aliasScores
                                    |> List.head
                                    |> Maybe.withDefault { score = 100000, matches = [] }

                            -- Take the better of the name or alias match
                            bestScore =
                                if nameScore.score <= bestAliasScore.score then
                                    nameScore.score

                                else
                                    bestAliasScore.score
                        in
                        ( carrier.name, bestScore )
                    )
                    standardCarriers
                    |> List.sortBy Tuple.second
                    |> List.head

            else
                Nothing
    in
    case specialCaseMatch of
        Just name ->
            name

        Nothing ->
            case exactMatches of
                carrier :: _ ->
                    carrier.name

                [] ->
                    case fuzzyMatches of
                        Just ( name, score ) ->
                            -- Only use fuzzy match if the score is good enough
                            if score < 10 then
                                name

                            else
                                "Other"

                        Nothing ->
                            "Other"



-- Default to "Other" if no good match found


findBestMatch : String -> List String -> List String -> String
findBestMatch field variations candidates =
    let
        -- Normalize everything for comparison
        normalize s =
            String.toLower (String.trim s)

        normalizedField =
            normalize field

        normalizedVariations =
            List.map normalize variations

        normalizedCandidates =
            List.map normalize candidates

        -- Get the candidate with the best fuzzy match score
        allQueries =
            normalizedField :: normalizedVariations

        scoredCandidates =
            List.map2
                (\normalizedCandidate originalCandidate ->
                    let
                        scores =
                            List.map
                                (\query ->
                                    Fuzzy.match [] [] query normalizedCandidate
                                )
                                allQueries

                        bestScore =
                            List.sortBy .score scores
                                |> List.head
                                |> Maybe.withDefault { score = 100000, matches = [] }
                    in
                    ( originalCandidate, bestScore.score )
                )
                normalizedCandidates
                candidates

        bestMatch =
            List.sortBy Tuple.second scoredCandidates
                |> List.head
                |> Maybe.map Tuple.first
                |> Maybe.withDefault ""
    in
    bestMatch



-- HELPERS


getAt : Int -> List a -> Maybe a
getAt index list =
    if index < 0 then
        Nothing

    else
        List.head (List.drop index list)


uniqueValues : List String -> List String
uniqueValues list =
    list
        |> Set.fromList
        |> Set.toList


createFieldVariations : FieldVariations
createFieldVariations =
    Dict.fromList
        [ ( "firstName", [ "first_name", "firstname", "first name", "fname", "first", "given name", "givenname" ] )
        , ( "lastName", [ "last_name", "lastname", "last name", "lname", "last", "surname", "family name", "familyname" ] )
        , ( "email", [ "email_address", "emailaddress", "email address", "e_mail", "e-mail" ] )
        , ( "phoneNumber", [ "phone_number", "phonenumber", "phone", "cell", "mobile", "telephone", "contact_number", "contact number", "phone number", "cell number", "mobile number" ] )
        , ( "currentCarrier", [ "current_carrier", "current carrier", "carrier", "insurance_provider", "insurance provider", "provider", "current_provider", "current provider", "insurance", "insurance carrier", "insurance_carrier", "insurancecarrier" ] )
        , ( "effectiveDate", [ "effective_date", "effectivedate", "effective date", "start_date", "startdate", "start date", "date_effective", "date effective", "coverage date", "plan start date" ] )
        , ( "birthDate", [ "birth_date", "birthdate", "birth date", "dob", "date_of_birth", "date of birth", "born", "birthday" ] )
        , ( "tobaccoUser", [ "tobacco_user", "tobaccouser", "tobacco user", "tobacco", "smoker", "tobacco_status", "tobacco status", "smokes", "is smoker", "smoking" ] )
        , ( "gender", [ "sex", "m/f", "male/female" ] )
        , ( "zipCode", [ "zip_code", "zipcode", "zip", "postal_code", "postalcode", "postal code", "postal", "zip code" ] )
        , ( "planType", [ "plan_type", "plantype", "plan type", "plan", "insurance_type", "insurancetype", "insurance type", "coverage type", "coverage" ] )
        ]



-- CSV TRANSFORMATION


transformCsvData : String -> ColumnMapping -> Result Error String
transformCsvData csvContent columnMapping =
    case Csv.Parser.parse { fieldSeparator = ',' } csvContent of
        Ok rows ->
            case List.head rows of
                Just headers ->
                    let
                        -- Create new standardized headers
                        standardHeaders =
                            [ "first_name"
                            , "last_name"
                            , "email"
                            , "phone_number"
                            , "current_carrier"
                            , "effective_date"
                            , "birth_date"
                            , "tobacco_user"
                            , "gender"
                            , "zip_code"
                            , "plan_type"
                            ]

                        -- Create mapping from old to new headers
                        headerMapping =
                            [ ( columnMapping.firstName, "first_name" )
                            , ( columnMapping.lastName, "last_name" )
                            , ( columnMapping.email, "email" )
                            , ( columnMapping.phoneNumber, "phone_number" )
                            , ( columnMapping.currentCarrier, "current_carrier" )
                            , ( columnMapping.effectiveDate, "effective_date" )
                            , ( columnMapping.birthDate, "birth_date" )
                            , ( columnMapping.tobaccoUser, "tobacco_user" )
                            , ( columnMapping.gender, "gender" )
                            , ( columnMapping.zipCode, "zip_code" )
                            , ( columnMapping.planType, "plan_type" )
                            ]
                                |> Dict.fromList

                        -- Get indices of columns we want to keep
                        columnIndices =
                            headers
                                |> List.indexedMap Tuple.pair
                                |> List.filter
                                    (\( _, h ) ->
                                        List.member h
                                            [ columnMapping.firstName
                                            , columnMapping.lastName
                                            , columnMapping.email
                                            , columnMapping.phoneNumber
                                            , columnMapping.currentCarrier
                                            , columnMapping.effectiveDate
                                            , columnMapping.birthDate
                                            , columnMapping.tobaccoUser
                                            , columnMapping.gender
                                            , columnMapping.zipCode
                                            , columnMapping.planType
                                            ]
                                    )
                                |> List.map Tuple.first

                        -- Transform each row
                        transformedRows =
                            List.map
                                (\row ->
                                    List.filterMap (\i -> getAt i row) columnIndices
                                )
                                (List.drop 1 rows)

                        -- Convert back to CSV string
                        toCsvRow : List String -> String
                        toCsvRow row =
                            row
                                |> List.map
                                    (\cell ->
                                        if String.contains "," cell then
                                            "\"" ++ cell ++ "\""

                                        else
                                            cell
                                    )
                                |> String.join ","
                    in
                    Ok (String.join "\n" (toCsvRow standardHeaders :: List.map toCsvRow transformedRows))

                Nothing ->
                    Err NoHeaders

        Err _ ->
            Err (ParseError "Failed to parse CSV file")



-- Add function to validate an email address


isValidEmail : String -> Bool
isValidEmail email =
    not (String.isEmpty (String.trim email))
        && String.contains "@" email
        && String.contains "." email
        && String.length email
        > 5



-- Add a type for invalid contacts with reason


type alias InvalidContact =
    { rowData : List String
    , email : String
    , reason : String
    , rowNumber : Int
    }



-- Update the return type to include both valid and invalid contacts


processCsvToContacts : String -> ColumnMapping -> CarrierMapping -> Result Error { valid : List ProcessedContact, invalid : List InvalidContact }
processCsvToContacts csvContent columnMapping carrierMapping =
    case Csv.Parser.parse { fieldSeparator = ',' } csvContent of
        Ok rows ->
            case List.head rows of
                Just headers ->
                    let
                        -- Get indices for each field
                        getColumnIndex : String -> Maybe Int
                        getColumnIndex columnName =
                            List.indexedMap Tuple.pair headers
                                |> List.filter (\( _, h ) -> h == columnName)
                                |> List.head
                                |> Maybe.map Tuple.first

                        -- Get indices for all required fields
                        indices =
                            { firstName = getColumnIndex columnMapping.firstName
                            , lastName = getColumnIndex columnMapping.lastName
                            , email = getColumnIndex columnMapping.email
                            , phoneNumber = getColumnIndex columnMapping.phoneNumber
                            , currentCarrier = getColumnIndex columnMapping.currentCarrier
                            , effectiveDate = getColumnIndex columnMapping.effectiveDate
                            , birthDate = getColumnIndex columnMapping.birthDate
                            , tobaccoUser = getColumnIndex columnMapping.tobaccoUser
                            , gender = getColumnIndex columnMapping.gender
                            , zipCode = getColumnIndex columnMapping.zipCode
                            , planType = getColumnIndex columnMapping.planType
                            }

                        -- Process each row, categorizing as valid or invalid
                        processRow : List String -> ( Maybe ProcessedContact, Maybe InvalidContact )
                        processRow row =
                            let
                                getValue : Maybe Int -> String
                                getValue maybeIndex =
                                    case maybeIndex of
                                        Just i ->
                                            if i < List.length row then
                                                row |> getAt i |> Maybe.withDefault ""

                                            else
                                                ""

                                        Nothing ->
                                            ""

                                -- Get carrier value and map it to standardized name
                                rawCarrier =
                                    getValue indices.currentCarrier

                                mappedCarrier =
                                    Dict.get rawCarrier carrierMapping.mappings
                                        |> Maybe.withDefault rawCarrier

                                -- Parse tobacco user value
                                parseTobaccoUser : String -> Bool
                                parseTobaccoUser val =
                                    let
                                        lower =
                                            String.toLower (String.trim val)
                                    in
                                    lower == "yes" || lower == "true" || lower == "1" || lower == "y"

                                -- Get email value
                                email =
                                    getValue indices.email

                                -- Check if email is valid
                                emailValid =
                                    isValidEmail email
                            in
                            if not emailValid then
                                ( Nothing
                                , Just
                                    { rowData = row
                                    , email = email
                                    , reason = "Invalid email format"
                                    , rowNumber = 0
                                    }
                                )

                            else
                                ( Just
                                    { firstName = getValue indices.firstName
                                    , lastName = getValue indices.lastName
                                    , email = email
                                    , phoneNumber = getValue indices.phoneNumber |> String.filter Char.isDigit
                                    , currentCarrier = mappedCarrier
                                    , effectiveDate = getValue indices.effectiveDate
                                    , birthDate = getValue indices.birthDate
                                    , tobaccoUser = getValue indices.tobaccoUser |> parseTobaccoUser
                                    , gender = getValue indices.gender
                                    , zipCode = getValue indices.zipCode
                                    , planType = getValue indices.planType
                                    }
                                , Nothing
                                )

                        -- Process all rows except header
                        processed =
                            rows
                                |> List.drop 1
                                |> List.indexedMap
                                    (\index row ->
                                        let
                                            ( maybeContact, maybeInvalidContact ) =
                                                processRow row

                                            updatedInvalidContact =
                                                maybeInvalidContact
                                                    |> Maybe.map (\contact -> { contact | rowNumber = index + 1 })
                                        in
                                        ( maybeContact, updatedInvalidContact )
                                    )

                        -- Separate valid and invalid contacts
                        validContacts =
                            processed
                                |> List.filterMap Tuple.first

                        invalidContacts =
                            processed
                                |> List.filterMap Tuple.second
                    in
                    Ok { valid = validContacts, invalid = invalidContacts }

                Nothing ->
                    Err NoHeaders

        Err _ ->
            Err (ParseError "Failed to parse CSV file")

================
File: frontend/src/Dashboard.elm
================
module Dashboard exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser exposing (Document)
import Browser.Navigation as Nav
import Components.LimitBanner as LimitBanner exposing (LimitWarning(..))
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import String
import Time



-- MODEL


type alias Model =
    { limitBanner : LimitBanner.Model
    , showTutorialModal : Bool
    , key : Nav.Key

    -- walkthroughModal : Walkthrough.Model -- Removed
    -- , showWalkthroughModal : Bool -- Removed
    -- Stats (consolidated from both Performance and Activity)
    , quotesSent : Int
    , manualQuotesSent : Int
    , quotesViewed : Int
    , followUpsRequested : Int
    , healthQuestionsCompleted : Int
    , statsLoading : Bool
    , statsError : Maybe String
    , chartData : List ChartDataFromAPI

    -- Send Ranking
    , sendRankingData : List SendRankingItem
    , sendRankingSortBy : RankingSortOption
    , sendRankingLoading : Bool

    -- Upcoming Emails
    , upcomingRenewals : List Renewal
    , upcomingEmailsTotal : Int
    , upcomingEmailsPage : List UpcomingEmail
    , upcomingEmailsPageNum : Int
    , upcomingEmailsPageSize : Int

    -- Common
    , selectedTimeFilter : TimeFilter
    , customStartDateInput : String
    , customEndDateInput : String
    , showCustomDateInputs : Bool -- New field to control date input visibility
    , selectedChartView : ChartView
    }



-- New types for Send Ranking


type alias SendRankingItem =
    { rank : Int
    , sendDate : String
    , quotesSent : Int
    , quotesViewed : Int
    , healthCompleted : Int
    }


type RankingSortOption
    = SortByQuotesSent
    | SortByQuotesViewed
    | SortByChronological


type alias SendRankingResponse =
    { success : Bool
    , data : List SendRankingItem
    }



-- This is the data structure from the API for Performance Metrics


type alias ChartDataFromAPI =
    { x : Float -- timestamp or month index
    , sends : Float
    , views : Float
    , followUps : Float
    , healthCompleted : Float -- New field
    }



-- This is the data structure for Chartist.js


type alias ChartistJsData =
    { labels : List String
    , series : List (List Float)
    }


type TimeFilter
    = Last7Days
    | Last30Days
    | Last90Days
    | YearToDate
    | Today
    | Yesterday
    | CustomRange


type ChartView
    = FunnelView



-- | TrendView  -- Commented out - may add back later


type alias Renewal =
    { id : String
    , name : String
    , email : String
    , phone : String
    , date : String
    , policyType : String
    }



-- MESSAGES


type Msg
    = NoOp
    | LimitBannerMsg LimitBanner.Msg
    | CloseTutorialModal
    | OpenTutorialModal
      -- | WalkthroughMsg Walkthrough.Msg -- Removed
    | UserDataReceived Bool -- hasCompletedWalkthrough flag
    | GotDashboardStats (Result Http.Error DashboardStatsResponse)
    | SelectTimeFilter TimeFilter
    | UpdateCustomStartDate String
    | UpdateCustomEndDate String
    | SelectChartView ChartView
    | FetchRenewals
    | GotRenewals (Result Http.Error RenewalResponse)
    | SendReminderToContact String
    | CallContact String
    | RefreshData
    | ChangeSendRankingSort RankingSortOption -- New message
    | GotSendRankingData (Result Http.Error SendRankingResponse) -- New message


type alias Flags =
    { isPostPayment : Maybe Bool
    }


type alias DashboardStats =
    { quotesSent : Int
    , manualQuotesSent : Int
    , quotesViewed : Int
    , followUpsRequested : Int
    , healthQuestionsCompleted : Int
    , chartData : List ChartDataFromAPI
    , upcomingEmailsTotal : Int
    , upcomingEmailsPage : List UpcomingEmail
    }


type alias DashboardStatsResponse =
    { success : Bool
    , stats : DashboardStats
    }


type alias RenewalResponse =
    { success : Bool
    , renewals : List Renewal
    }


type alias UpcomingEmail =
    { id : Int
    , contactId : Int
    , emailType : String
    , scheduledSendDate : String
    , status : String
    , firstName : String
    , lastName : String
    }


dashboardStatsDecoder : Decoder DashboardStats
dashboardStatsDecoder =
    Decode.succeed DashboardStats
        |> Pipeline.required "quotesSent" Decode.int
        |> Pipeline.required "manualQuotesSent" Decode.int
        |> Pipeline.required "quotesViewed" Decode.int
        |> Pipeline.required "followUpsRequested" Decode.int
        |> Pipeline.required "healthQuestionsCompleted" Decode.int
        |> Pipeline.required "chartData" (Decode.list chartDataFromAPIDecoder)
        |> Pipeline.required "upcomingEmailsTotal" Decode.int
        |> Pipeline.required "upcomingEmailsPage" (Decode.list upcomingEmailDecoder)


chartDataFromAPIDecoder : Decoder ChartDataFromAPI
chartDataFromAPIDecoder =
    Decode.succeed ChartDataFromAPI
        |> Pipeline.required "x" Decode.float
        |> Pipeline.required "sends" Decode.float
        |> Pipeline.required "views" Decode.float
        |> Pipeline.required "followUps" Decode.float
        |> Pipeline.optional "healthCompleted" Decode.float 0.0



-- Default to 0 if not present


dashboardStatsResponseDecoder : Decoder DashboardStatsResponse
dashboardStatsResponseDecoder =
    Decode.succeed DashboardStatsResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "stats" dashboardStatsDecoder


renewalDecoder : Decoder Renewal
renewalDecoder =
    Decode.succeed Renewal
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "name" Decode.string
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "phone" Decode.string
        |> Pipeline.required "date" Decode.string
        |> Pipeline.required "policyType" Decode.string


renewalResponseDecoder : Decoder RenewalResponse
renewalResponseDecoder =
    Decode.succeed RenewalResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "renewals" (Decode.list renewalDecoder)


sendRankingItemDecoder : Decoder SendRankingItem
sendRankingItemDecoder =
    Decode.succeed SendRankingItem
        |> Pipeline.required "rank" Decode.int
        |> Pipeline.required "sendDate" Decode.string
        |> Pipeline.required "quotesSent" Decode.int
        |> Pipeline.required "quotesViewed" Decode.int
        |> Pipeline.required "healthCompleted" Decode.int


sendRankingResponseDecoder : Decoder SendRankingResponse
sendRankingResponseDecoder =
    Decode.succeed SendRankingResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "data" (Decode.list sendRankingItemDecoder)



-- HELPERS
-- Function to encode ChartistJsData to JSON


encodeChartistJsData : ChartistJsData -> Encode.Value
encodeChartistJsData data =
    Encode.object
        [ ( "labels", Encode.list Encode.string data.labels )
        , ( "series", Encode.list (Encode.list Encode.float) data.series )
        ]



-- Helper to format month float to short string (e.g., 0.0 -> "Jan")


formatMonthLabel : Float -> String
formatMonthLabel x =
    let
        monthIndex =
            round x
    in
    case monthIndex of
        0 ->
            "Jan"

        1 ->
            "Feb"

        2 ->
            "Mar"

        3 ->
            "Apr"

        4 ->
            "May"

        5 ->
            "Jun"

        6 ->
            "Jul"

        7 ->
            "Aug"

        8 ->
            "Sep"

        9 ->
            "Oct"

        10 ->
            "Nov"

        11 ->
            "Dec"

        _ ->
            ""



-- Calculate percentages and rates


calculateViewRate : Model -> Float
calculateViewRate model =
    if model.quotesSent == 0 then
        0

    else
        toFloat model.quotesViewed / toFloat model.quotesSent * 100


calculateFollowUpRate : Model -> Float
calculateFollowUpRate model =
    if model.quotesViewed == 0 then
        0

    else
        toFloat model.followUpsRequested / toFloat model.quotesViewed * 100


calculateCompletionRate : Model -> Float
calculateCompletionRate model =
    if model.quotesSent == 0 then
        0

    else
        toFloat model.healthQuestionsCompleted / toFloat model.quotesSent * 100



-- Helper to get API endpoint based on time filter


timeFilterToApiParam : TimeFilter -> String
timeFilterToApiParam filter =
    case filter of
        Last7Days ->
            "7days"

        Last30Days ->
            "30days"

        Last90Days ->
            "90days"

        YearToDate ->
            "ytd"

        Today ->
            "today"

        Yesterday ->
            "yesterday"

        CustomRange ->
            "custom"



-- Would need to append date parameters
-- INIT


init : Nav.Key -> Flags -> ( Model, Cmd Msg )
init key flags =
    let
        ( limitBannerModel, limitBannerCmd ) =
            LimitBanner.init

        -- ( walkthroughModel, walkthroughCmd ) = -- Removed
        -- Walkthrough.init False -- Removed
    in
    ( { limitBanner = limitBannerModel
      , showTutorialModal = Maybe.withDefault False flags.isPostPayment
      , key = key

      -- , walkthroughModal = walkthroughModel -- Removed
      -- , showWalkthroughModal = False -- Removed
      , quotesSent = 0
      , manualQuotesSent = 0
      , quotesViewed = 0
      , followUpsRequested = 0
      , healthQuestionsCompleted = 0
      , statsLoading = True
      , statsError = Nothing
      , chartData = []
      , sendRankingData = []
      , sendRankingSortBy = SortByChronological
      , sendRankingLoading = True
      , upcomingRenewals = []
      , upcomingEmailsTotal = 0
      , upcomingEmailsPage = []
      , upcomingEmailsPageNum = 1
      , upcomingEmailsPageSize = 20
      , selectedTimeFilter = Last30Days
      , customStartDateInput = ""
      , customEndDateInput = ""
      , showCustomDateInputs = False
      , selectedChartView = FunnelView
      }
    , Cmd.batch
        [ Cmd.map LimitBannerMsg limitBannerCmd
        , fetchDashboardStats Last30Days "" ""
        , fetchSendRankingData Last30Days "" ""
        ]
    )



-- HTTP


fetchDashboardStats : TimeFilter -> String -> String -> Cmd Msg
fetchDashboardStats timeFilter startDate endDate =
    let
        timeParam =
            timeFilterToApiParam timeFilter

        baseUrl =
            "/api/dashboard/stats?period=" ++ timeParam

        url =
            if timeFilter == CustomRange && not (String.isEmpty startDate) && not (String.isEmpty endDate) then
                baseUrl ++ "&startDate=" ++ startDate ++ "&endDate=" ++ endDate

            else
                baseUrl
    in
    Http.get
        { url = url
        , expect = Http.expectJson GotDashboardStats dashboardStatsResponseDecoder
        }


fetchRenewals : Cmd Msg
fetchRenewals =
    Http.get
        { url = "/api/dashboard/renewals"
        , expect = Http.expectJson GotRenewals renewalResponseDecoder
        }


fetchSendRankingData : TimeFilter -> String -> String -> Cmd Msg
fetchSendRankingData timeFilter startDate endDate =
    let
        timeParam =
            timeFilterToApiParam timeFilter

        baseUrl =
            "/api/dashboard/send-ranking?period=" ++ timeParam

        url =
            if timeFilter == CustomRange && not (String.isEmpty startDate) && not (String.isEmpty endDate) then
                baseUrl ++ "&startDate=" ++ startDate ++ "&endDate=" ++ endDate

            else
                baseUrl
    in
    Http.get
        { url = url
        , expect = Http.expectJson GotSendRankingData sendRankingResponseDecoder
        }


httpErrorToString : Http.Error -> String
httpErrorToString error =
    case error of
        Http.BadUrl url ->
            "Bad URL: " ++ url

        Http.Timeout ->
            "Request timed out"

        Http.NetworkError ->
            "Network error"

        Http.BadStatus code ->
            "Bad status: " ++ String.fromInt code

        Http.BadBody message ->
            "Bad body: " ++ message



-- UPDATE


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        LimitBannerMsg limitBannerMsg ->
            let
                ( limitBanner, cmd ) =
                    LimitBanner.update limitBannerMsg model.limitBanner
            in
            ( { model | limitBanner = limitBanner }
            , Cmd.map LimitBannerMsg cmd
            )

        CloseTutorialModal ->
            ( { model | showTutorialModal = False }
            , Nav.pushUrl model.key "/dashboard"
            )

        OpenTutorialModal ->
            ( { model | showTutorialModal = True }
            , Cmd.none
            )

        UserDataReceived hasCompletedWalkthrough ->
            -- if not hasCompletedWalkthrough then -- Removed walkthrough triggering logic
            --     let
            --         ( walkthroughModel, _ ) =
            --             Walkthrough.init True
            --     in
            --     ( { model | showWalkthroughModal = True, walkthroughModal = walkthroughModel }
            --     , Cmd.none
            --     )
            -- else
            --     ( model, Cmd.none )
            ( model, Cmd.none )

        GotDashboardStats result ->
            case result of
                Ok response ->
                    if response.success then
                        let
                            totalQuotesSent =
                                response.stats.quotesSent + response.stats.manualQuotesSent
                        in
                        ( { model
                            | statsLoading = False
                            , quotesSent = totalQuotesSent
                            , manualQuotesSent = response.stats.manualQuotesSent
                            , quotesViewed = response.stats.quotesViewed
                            , followUpsRequested = response.stats.followUpsRequested
                            , healthQuestionsCompleted = response.stats.healthQuestionsCompleted
                            , chartData = response.stats.chartData
                            , upcomingEmailsTotal = response.stats.upcomingEmailsTotal
                            , upcomingEmailsPage = response.stats.upcomingEmailsPage
                          }
                        , Cmd.none
                        )

                    else
                        ( { model | statsLoading = False, statsError = Just "Failed to load dashboard data (API error)." }, Cmd.none )

                Err httpError ->
                    ( { model | statsLoading = False, statsError = Just (httpErrorToString httpError) }, Cmd.none )

        SelectTimeFilter timeFilter ->
            if timeFilter == CustomRange then
                -- Just update the filter and show inputs, don't fetch
                ( { model
                    | selectedTimeFilter = timeFilter
                    , showCustomDateInputs = True
                    , statsLoading = False
                  }
                , Cmd.none
                )

            else
                -- For non-custom filters, hide inputs and fetch data
                ( { model
                    | selectedTimeFilter = timeFilter
                    , customStartDateInput = ""
                    , customEndDateInput = ""
                    , showCustomDateInputs = False
                    , statsLoading = True
                    , sendRankingLoading = True
                    , statsError = Nothing
                  }
                , Cmd.batch
                    [ fetchDashboardStats timeFilter "" ""
                    , fetchSendRankingData timeFilter "" ""
                    ]
                )

        UpdateCustomStartDate dateStr ->
            ( { model | customStartDateInput = dateStr, selectedTimeFilter = CustomRange }, Cmd.none )

        UpdateCustomEndDate dateStr ->
            ( { model | customEndDateInput = dateStr, selectedTimeFilter = CustomRange }, Cmd.none )

        SelectChartView chartView ->
            ( { model | selectedChartView = chartView }
            , Cmd.none
            )

        FetchRenewals ->
            ( model, fetchRenewals )

        GotRenewals result ->
            case result of
                Ok response ->
                    if response.success then
                        ( { model | upcomingRenewals = response.renewals }, Cmd.none )

                    else
                        ( model, Cmd.none )

                Err _ ->
                    ( model, Cmd.none )

        SendReminderToContact contactId ->
            ( model, Cmd.none )

        CallContact contactId ->
            ( model, Cmd.none )

        ChangeSendRankingSort sortOption ->
            let
                sortedData =
                    case sortOption of
                        SortByQuotesSent ->
                            List.sortBy (negate << .quotesSent) model.sendRankingData

                        SortByQuotesViewed ->
                            List.sortBy (negate << .quotesViewed) model.sendRankingData

                        SortByChronological ->
                            List.sortWith (\a b -> compare b.sendDate a.sendDate) model.sendRankingData

                -- Re-rank after sorting
                rerankedData =
                    List.indexedMap (\idx item -> { item | rank = idx + 1 }) sortedData
            in
            ( { model
                | sendRankingSortBy = sortOption
                , sendRankingData = rerankedData
              }
            , Cmd.none
            )

        GotSendRankingData result ->
            case result of
                Ok response ->
                    if response.success then
                        let
                            -- Apply current sort
                            sortedData =
                                case model.sendRankingSortBy of
                                    SortByQuotesSent ->
                                        List.sortBy (negate << .quotesSent) response.data

                                    SortByQuotesViewed ->
                                        List.sortBy (negate << .quotesViewed) response.data

                                    SortByChronological ->
                                        List.sortWith (\a b -> compare b.sendDate a.sendDate) response.data

                            rankedData =
                                List.indexedMap (\idx item -> { item | rank = idx + 1 }) sortedData
                        in
                        ( { model
                            | sendRankingLoading = False
                            , sendRankingData = rankedData
                          }
                        , Cmd.none
                        )

                    else
                        ( { model | sendRankingLoading = False }
                        , Cmd.none
                        )

                Err _ ->
                    ( { model | sendRankingLoading = False }
                    , Cmd.none
                    )

        RefreshData ->
            let
                ( startDate, endDate ) =
                    if model.selectedTimeFilter == CustomRange then
                        ( model.customStartDateInput, model.customEndDateInput )

                    else
                        ( "", "" )

                shouldFetch =
                    if model.selectedTimeFilter == CustomRange then
                        not (String.isEmpty startDate) && not (String.isEmpty endDate)

                    else
                        True

                fetchCmd =
                    if shouldFetch then
                        Cmd.batch
                            [ fetchDashboardStats model.selectedTimeFilter startDate endDate
                            , fetchSendRankingData model.selectedTimeFilter startDate endDate
                            ]

                    else
                        Cmd.none
            in
            ( { model
                | statsLoading = shouldFetch
                , sendRankingLoading = shouldFetch
                , statsError =
                    if shouldFetch then
                        Nothing

                    else
                        model.statsError
              }
            , fetchCmd
            )

        NoOp ->
            ( model, Cmd.none )


viewChartist : String -> ChartView -> Html msg
viewChartist chartistDataJson chartView =
    let
        chartType =
            case chartView of
                FunnelView ->
                    "chartist-funnel"

        -- TrendView ->  -- Commented out - may add back later
        --     "chartist-line"
    in
    node chartType
        [ attribute "data" chartistDataJson
        , attribute "style" "height: 100%; width: 100%; display: block;"
        ]
        []



-- VIEW


view : Model -> Document Msg
view model =
    { title = "Dashboard"
    , body =
        [ div [ class "p-4 sm:p-6 max-w-7xl mx-auto" ]
            [ LimitBanner.view model.limitBanner
                |> Html.map LimitBannerMsg
            , if model.showTutorialModal then
                viewTutorialModal

              else
                text ""
            , viewDashboardHeader model
            , viewStatsCards model
            , div [ class "grid grid-cols-1 lg:grid-cols-3 gap-6 mt-6" ]
                [ -- Chart and Send Ranking section (spans 2 columns)
                  div [ class "lg:col-span-2 flex flex-col" ]
                    [ viewPerformanceChart model
                    , div [ class "flex-1" ] [ viewSendRanking model ]
                    ]
                , -- Upcoming Emails section (1 column) - height matches the left column exactly
                  div [ class "lg:col-span-1 flex" ]
                    [ viewUpcomingEmails model ]
                ]
            ]
        ]
    }


viewDashboardHeader : Model -> Html Msg
viewDashboardHeader model =
    div [ class "flex flex-col sm:flex-row justify-between items-center mb-6" ]
        [ h1 [ class "text-2xl font-bold text-gray-800 mb-4 sm:mb-0" ]
            [ text "Dashboard" ]
        , div [ class "flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2 items-center" ]
            [ select
                [ class "bg-white border border-gray-300 rounded-md px-3 py-2 text-sm"
                , onInput
                    (\val ->
                        case val of
                            "today" ->
                                SelectTimeFilter Today

                            "yesterday" ->
                                SelectTimeFilter Yesterday

                            "7days" ->
                                SelectTimeFilter Last7Days

                            "30days" ->
                                SelectTimeFilter Last30Days

                            "90days" ->
                                SelectTimeFilter Last90Days

                            "ytd" ->
                                SelectTimeFilter YearToDate

                            "custom" ->
                                SelectTimeFilter CustomRange

                            _ ->
                                NoOp
                    )
                , value (timeFilterToHtmlValue model.selectedTimeFilter)
                ]
                [ option [ value "today" ] [ text "Today" ]
                , option [ value "yesterday" ] [ text "Yesterday" ]
                , option [ value "7days" ] [ text "Last 7 Days" ]
                , option [ value "30days" ] [ text "Last 30 Days" ]
                , option [ value "90days" ] [ text "Last 90 Days" ]
                , option [ value "ytd" ] [ text "Year to Date" ]
                , option [ value "custom" ] [ text "Custom Dates" ]
                ]

            -- Only show date inputs when Custom Dates is selected
            , if model.showCustomDateInputs then
                div [ class "flex space-x-2 items-center" ]
                    [ label [ class "text-sm" ] [ text "From:" ]
                    , input
                        [ type_ "date"
                        , class "bg-white border border-gray-300 rounded-md px-2 py-1.5 text-sm"
                        , value model.customStartDateInput
                        , onInput UpdateCustomStartDate
                        ]
                        []
                    , label [ class "text-sm" ] [ text "To:" ]
                    , input
                        [ type_ "date"
                        , class "bg-white border border-gray-300 rounded-md px-2 py-1.5 text-sm"
                        , value model.customEndDateInput
                        , onInput UpdateCustomEndDate
                        ]
                        []
                    ]

              else
                text ""
            , button
                [ class "bg-[#03045e] text-white px-4 py-2 rounded-md text-sm hover:bg-opacity-90"
                , onClick RefreshData
                ]
                [ text "Refresh" ]
            ]
        ]


viewStatsCards : Model -> Html Msg
viewStatsCards model =
    let
        viewRate =
            calculateViewRate model |> round

        followUpRate =
            calculateFollowUpRate model |> round

        completionRate =
            calculateCompletionRate model |> round
    in
    div [ class "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 mb-6" ]
        [ -- Quotes Sent card
          if model.statsLoading then
            viewStatsCardWithSpinner "Quotes Sent" "text-[#03045e]"

          else if model.statsError /= Nothing then
            viewStatsCard "Quotes Sent" "0" "text-red-600" "Failed to load data"

          else
            viewStatsCard "Quotes Sent" (String.fromInt model.quotesSent) "text-[#03045e]" "Total emails sent with quotes"

        -- View Rate card
        , if model.statsLoading then
            viewStatsCardWithSpinner "View Rate" "text-[#0077b6]"

          else if model.statsError /= Nothing then
            viewStatsCard "View Rate" "0" "text-red-600" "Failed to load data"

          else
            viewStatsCard "View Rate" (String.fromInt viewRate ++ "%") "text-[#0077b6]" (String.fromInt model.quotesViewed ++ " quotes viewed")

        -- Upcoming Emails card
        , if model.statsLoading then
            viewStatsCardWithSpinner "Upcoming Emails" "text-[#00b4d8]"

          else if model.statsError /= Nothing then
            viewStatsCard "Upcoming Emails" "0" "text-red-600" "Failed to load data"

          else
            viewStatsCard "Upcoming Emails" (String.fromInt model.upcomingEmailsTotal) "text-[#00b4d8]" "Scheduled emails in next 30 days"

        -- Completion Rate card
        , if model.statsLoading then
            viewStatsCardWithSpinner "Completion Rate" "text-[#48cae4]"

          else if model.statsError /= Nothing then
            viewStatsCard "Completion Rate" "0" "text-red-600" "Failed to load data"

          else
            viewStatsCard "Completion Rate" (String.fromInt completionRate ++ "%") "text-[#48cae4]" (String.fromInt model.healthQuestionsCompleted ++ " health questions completed")
        ]


viewSendRanking : Model -> Html Msg
viewSendRanking model =
    div [ class "bg-white rounded-lg shadow-xl p-4 mt-6" ]
        [ div [ class "flex justify-between items-center mb-4" ]
            [ h2 [ class "text-lg font-semibold text-gray-800" ] [ text "Send Ranking" ]
            , div [ class "flex items-center space-x-2" ]
                [ span [ class "text-sm text-gray-500" ] [ text "Rank By" ]
                , select
                    [ class "bg-white border border-gray-300 rounded-md px-3 py-1 text-sm"
                    , value (sortOptionToString model.sendRankingSortBy)
                    , onInput
                        (\val ->
                            case val of
                                "quotes_viewed" ->
                                    ChangeSendRankingSort SortByQuotesViewed

                                "quotes_sent" ->
                                    ChangeSendRankingSort SortByQuotesSent

                                "chronological" ->
                                    ChangeSendRankingSort SortByChronological

                                _ ->
                                    NoOp
                        )
                    ]
                    [ option [ value "chronological" ] [ text "Chronological" ]
                    , option [ value "quotes_viewed" ] [ text "Quotes Viewed" ]
                    , option [ value "quotes_sent" ] [ text "Quotes Sent" ]
                    ]
                ]
            ]
        , if model.sendRankingLoading then
            div [ class "flex items-center justify-center py-8" ]
                [ div [ class "animate-spin rounded-full h-8 w-8 border-t-2 border-l-2 border-[#03045e]" ] [] ]

          else if List.isEmpty model.sendRankingData then
            div [ class "text-center py-8 text-gray-400" ]
                [ text "No send data available for the selected period." ]

          else
            div [ class "space-y-3" ]
                (List.map viewSendRankingItem model.sendRankingData)
        ]


viewSendRankingItem : SendRankingItem -> Html Msg
viewSendRankingItem item =
    div [ class "flex items-center space-x-4 p-3 rounded-lg bg-purple-50 border border-purple-100" ]
        [ div [ class "flex-shrink-0 w-12 h-12 flex items-center justify-center rounded-full bg-purple-100 text-purple-700 font-semibold" ]
            [ text ("#" ++ String.fromInt item.rank) ]
        , div [ class "flex-1 grid grid-cols-4 gap-4 text-sm" ]
            [ div []
                [ div [ class "font-medium text-gray-900" ] [ text item.sendDate ]
                , div [ class "text-xs text-gray-500" ] [ text "Send Date" ]
                ]
            , div [ class "text-center" ]
                [ div [ class "font-bold text-2xl text-[#03045e] mb-1" ] [ text (String.fromInt item.quotesSent) ]
                , div [ class "text-xs text-gray-500" ] [ text "Quotes Sent" ]
                ]
            , div [ class "text-center" ]
                [ div [ class "flex items-center justify-center mb-1" ]
                    [ div [ class "font-bold text-2xl text-[#03045e] w-10 text-right" ] [ text (String.fromInt item.quotesViewed) ]
                    , div [ class "inline-block bg-[#6366f1] text-white text-[10px] px-2 py-0.5 rounded ml-2 w-10 text-center" ]
                        [ text
                            (if item.quotesSent > 0 then
                                String.fromInt (round ((toFloat item.quotesViewed / toFloat item.quotesSent) * 100)) ++ "%"

                             else
                                "0%"
                            )
                        ]
                    ]
                , div [ class "text-xs text-gray-500" ] [ text "Quotes Viewed" ]
                ]
            , div [ class "text-center" ]
                [ div [ class "flex items-center justify-center mb-1" ]
                    [ div [ class "font-bold text-2xl text-[#48cae4] w-10 text-right" ] [ text (String.fromInt item.healthCompleted) ]
                    , div [ class "inline-block bg-[#06b6d4] text-white text-[10px] px-2 py-0.5 rounded ml-2 w-10 text-center" ]
                        [ text
                            (if item.quotesSent > 0 then
                                String.fromInt (round ((toFloat item.healthCompleted / toFloat item.quotesSent) * 100)) ++ "%"

                             else
                                "0%"
                            )
                        ]
                    ]
                , div [ class "text-xs text-gray-500" ] [ text "Health Completed" ]
                ]
            ]
        ]


viewPerformanceChart : Model -> Html Msg
viewPerformanceChart model =
    div [ class "bg-white rounded-lg shadow-xl p-4" ]
        [ div [ class "flex justify-between items-center mb-4" ]
            [ h2 [ class "text-lg font-semibold text-gray-800" ] [ text "Performance Metrics" ]

            -- Commented out - may add back later
            {- , div [ class "flex space-x-2" ]
               [ button
                   [ class
                       ("px-3 py-1 text-sm rounded-md "
                           ++ (if model.selectedChartView == FunnelView then
                                   "bg-[#03045e] text-white"

                               else
                                   "bg-gray-100"
                              )
                       )
                   , onClick (SelectChartView FunnelView)
                   ]
                   [ text "Funnel" ]
               , button
                   [ class
                       ("px-3 py-1 text-sm rounded-md "
                           ++ (if model.selectedChartView == TrendView then
                                   "bg-[#03045e] text-white"

                               else
                                   "bg-gray-100"
                              )
                       )
                   , onClick (SelectChartView TrendView)
                   ]
                   [ text "Trend" ]
               ]
            -}
            ]
        , div [ class "h-64" ]
            [ if model.statsLoading then
                -- Chart spinner
                div [ class "h-full w-full flex items-center justify-center" ]
                    [ div [ class "animate-spin rounded-full h-12 w-12 border-t-2 border-l-2 border-[#03045e]" ] []
                    , div [ class "ml-3 text-gray-500" ] [ text "Loading chart data..." ]
                    ]

              else if model.statsError /= Nothing then
                -- Error message
                div [ class "h-full w-full flex items-center justify-center" ]
                    [ div [ class "text-red-500" ] [ text "Error loading chart data. Please try again." ] ]

              else if List.isEmpty model.chartData then
                -- No data message
                div [ class "h-full w-full flex items-center justify-center" ]
                    [ div [ class "text-gray-500" ] [ text "No data available to display." ] ]

              else
                let
                    -- For funnel view only (TrendView commented out)
                    chartistData =
                        -- For funnel view, we need a simpler data structure
                        -- We'll use the most recent data points
                        let
                            latestData =
                                List.reverse model.chartData |> List.head
                        in
                        case latestData of
                            Just latest ->
                                -- Pass the actual values from the model here, not from chartData
                                { labels = [ "Quotes Sent", "Quotes Viewed", "Upcoming Emails", "Health Completed" ]
                                , series = [ [ toFloat model.quotesSent, toFloat model.quotesViewed, toFloat model.followUpsRequested, toFloat model.healthQuestionsCompleted ] ]
                                }

                            Nothing ->
                                -- Even if there's no chart data, we can still use the model values
                                { labels = [ "Quotes Sent", "Quotes Viewed", "Upcoming Emails", "Health Completed" ]
                                , series = [ [ toFloat model.quotesSent, toFloat model.quotesViewed, toFloat model.followUpsRequested, toFloat model.healthQuestionsCompleted ] ]
                                }

                    {- TrendView logic commented out - may add back later
                       case model.selectedChartView of
                           FunnelView ->
                               -- For funnel view, we need a simpler data structure
                               -- We'll use the most recent data points
                               let
                                   latestData =
                                       List.reverse model.chartData |> List.head
                               in
                               case latestData of
                                   Just latest ->
                                       -- Pass the actual values from the model here, not from chartData
                                       { labels = [ "Quotes Sent", "Quotes Viewed", "Upcoming Emails", "Health Completed" ]
                                       , series = [ [ toFloat model.quotesSent, toFloat model.quotesViewed, toFloat model.followUpsRequested, toFloat model.healthQuestionsCompleted ] ]
                                       }

                                   Nothing ->
                                       -- Even if there's no chart data, we can still use the model values
                                       { labels = [ "Quotes Sent", "Quotes Viewed", "Upcoming Emails", "Health Completed" ]
                                       , series = [ [ toFloat model.quotesSent, toFloat model.quotesViewed, toFloat model.followUpsRequested, toFloat model.healthQuestionsCompleted ] ]
                                       }

                           TrendView ->
                               -- For trend view
                               let
                                   labels =
                                       List.map (.x >> formatMonthLabel) model.chartData

                                   seriesSents =
                                       List.map .sends model.chartData

                                   seriesViews =
                                       List.map .views model.chartData

                                   seriesFollowUps =
                                       List.map .followUps model.chartData

                                   seriesHealthCompleted =
                                       List.map .healthCompleted model.chartData
                               in
                               { labels = labels
                               , series = [ seriesSents, seriesViews, seriesFollowUps, seriesHealthCompleted ]
                               }
                    -}
                    chartistJson =
                        Encode.encode 0 (encodeChartistJsData chartistData)
                in
                viewChartist chartistJson model.selectedChartView
            ]
        , div [ class "flex flex-col sm:flex-row justify-center mt-4 space-y-2 sm:space-y-0 sm:space-x-8 text-sm text-gray-600 border-t border-gray-200 pt-4" ]
            [ div [ class "flex items-center" ]
                [ div [ class "w-3 h-3 rounded-full bg-[#03045e] mr-1.5 sm:mr-2" ] []
                , text "Quotes Sent"
                ]
            , div [ class "flex items-center" ]
                [ div [ class "w-3 h-3 rounded-full bg-[#0077b6] mr-1.5 sm:mr-2" ] []
                , text "Quotes Viewed"
                ]
            , div [ class "flex items-center" ]
                [ div [ class "w-3 h-3 rounded-full bg-[#48cae4] mr-1.5 sm:mr-2" ] []
                , text "Health Completed"
                ]
            ]
        ]


viewUpcomingEmails : Model -> Html Msg
viewUpcomingEmails model =
    div [ class "bg-white rounded-lg shadow-sm border border-gray-100 p-4 flex flex-col w-full self-stretch" ]
        [ div [ class "flex justify-between items-center mb-4 flex-shrink-0" ]
            [ h2 [ class "text-lg font-semibold text-gray-800" ] [ text "Upcoming Emails" ]
            , span [ class "bg-gray-100 text-gray-700 text-xs px-2 py-1 rounded-full font-medium" ]
                [ text (String.fromInt model.upcomingEmailsTotal ++ " total") ]
            ]
        , if model.statsLoading then
            div [ class "flex-1 flex items-center justify-center" ]
                [ div [ class "animate-spin rounded-full h-8 w-8 border-t-2 border-l-2 border-gray-400" ] [] ]

          else if model.statsError /= Nothing then
            div [ class "flex-1 flex items-center justify-center text-red-500" ]
                [ text "Error loading upcoming emails." ]

          else if List.isEmpty model.upcomingEmailsPage then
            div [ class "flex-1 flex items-center justify-center text-gray-400" ]
                [ text "No upcoming emails scheduled in the next 30 days." ]

          else
            div [ class "flex-1 overflow-y-auto min-h-0" ]
                (List.map viewUpcomingEmailItem model.upcomingEmailsPage)
        ]


viewUpcomingEmailItem : UpcomingEmail -> Html Msg
viewUpcomingEmailItem email =
    div [ class "flex justify-between items-start py-2.5 border-b border-gray-100 last:border-0" ]
        [ div [ class "flex-1 pr-3" ]
            [ div [ class "font-medium text-gray-900 text-sm mb-1" ] [ text (email.firstName ++ " " ++ email.lastName) ]
            , div [ class "flex items-center" ]
                [ span [ class "text-[10px] text-gray-500 mr-1.5" ] [ text "Email Type:" ]
                , span [ class "inline-block bg-blue-100 text-blue-800 text-[10px] px-1.5 py-0.5 rounded font-medium" ]
                    [ text (formatEmailType email.emailType) ]
                ]
            ]
        , div [ class "text-right flex-shrink-0" ]
            [ div [ class "text-sm font-medium text-gray-900" ] [ text (formatDate email.scheduledSendDate) ]
            , div [ class "text-[10px] text-gray-500" ] [ text "Schedule Date" ]
            ]
        ]


viewRenewalItem : Renewal -> Html Msg
viewRenewalItem renewal =
    div [ class "border-b pb-3" ]
        [ div [ class "flex justify-between items-start" ]
            [ div []
                [ div [ class "font-medium" ] [ text renewal.name ]
                , div [ class "text-sm text-gray-500" ] [ text renewal.policyType ]
                ]
            , div [ class "text-sm font-medium text-[#03045e]" ] [ text renewal.date ]
            ]
        , div [ class "mt-2 flex items-center text-xs text-gray-500" ]
            [ -- Email icon
              span [ class "mr-1" ] [ text "📧" ]
            , text renewal.email
            ]
        , div [ class "mt-1 flex items-center text-xs text-gray-500" ]
            [ -- Phone icon
              span [ class "mr-1" ] [ text "📞" ]
            , text renewal.phone
            ]
        , div [ class "mt-2 flex space-x-2" ]
            [ button
                [ class "bg-[#0077b6] text-white text-xs px-3 py-1 rounded"
                , onClick (SendReminderToContact renewal.id)
                ]
                [ text "Send Reminder" ]
            , button
                [ class "bg-gray-100 text-gray-800 text-xs px-3 py-1 rounded"
                , onClick (CallContact renewal.id)
                ]
                [ text "Call" ]
            ]
        ]


viewTutorialModal : Html Msg
viewTutorialModal =
    div [ class "fixed inset-0 z-50 bg-slate-100 bg-opacity-20 backdrop-blur-sm flex items-center justify-center p-4" ]
        [ div [ class "bg-white p-4 sm:p-6 rounded-lg shadow-lg max-w-2xl w-full" ]
            [ div [ class "flex justify-between items-center mb-4" ]
                [ h2 [ class "text-lg sm:text-xl font-semibold text-[#03045E]" ] [ text "Welcome to MedicareMax!" ]
                , button
                    [ class "text-gray-400 hover:text-gray-600 text-xl p-1", onClick CloseTutorialModal ]
                    [ text "×" ]
                ]
            , div [ class "mb-4 sm:mb-6" ]
                [ iframe
                    [ src "https://www.youtube.com/embed/dQw4w9WgXcQ" -- Replace with actual tutorial video
                    , class "w-full aspect-video max-h-[50vh] sm:h-96"
                    , attribute "allowfullscreen" ""
                    , attribute "frameborder" "0"
                    ]
                    []
                ]
            , p [ class "mb-4 text-gray-600 text-sm sm:text-base" ]
                [ text "This quick setup tutorial will help you get started with MedicareMax and show you how to make the most of its features." ]
            , div [ class "flex justify-end" ]
                [ button
                    [ class "px-4 py-2 bg-[#03045E] text-white rounded-md hover:bg-opacity-90 w-full sm:w-auto"
                    , onClick CloseTutorialModal
                    ]
                    [ text "Close" ]
                ]
            ]
        ]


viewStatsCard : String -> String -> String -> String -> Html Msg
viewStatsCard title value colorClass subtitle =
    div [ class "bg-white rounded-lg shadow-xl p-4 sm:p-6" ]
        [ div [ class "text-gray-600 text-xs sm:text-sm" ] [ text title ]
        , div [ class ("text-2xl sm:text-4xl font-bold mt-1 sm:mt-2 " ++ colorClass) ] [ text value ]
        , div [ class "text-gray-500 text-xs mt-1" ] [ text subtitle ]
        ]


viewStatsCardWithSpinner : String -> String -> Html Msg
viewStatsCardWithSpinner title colorClass =
    div [ class "bg-white rounded-lg shadow-xl p-4 sm:p-6" ]
        [ div [ class "text-gray-600 text-xs sm:text-sm" ] [ text title ]
        , div [ class ("text-2xl sm:text-4xl font-bold mt-1 sm:mt-2 flex items-center justify-center " ++ colorClass) ]
            [ div [ class "animate-spin rounded-full h-8 w-8 border-t-2 border-l-2 border-[#03045e]" ] [] ]
        , div [ class "text-gray-500 text-xs mt-1" ] [ text "Loading..." ]
        ]


formatEmailType : String -> String
formatEmailType emailType =
    case emailType of
        "quote_email" ->
            "Quote Email"

        "QUOTE_EMAIL" ->
            "Quote Email"

        "follow_up_1" ->
            "Follow-up #1"

        "FOLLOW_UP_1" ->
            "Follow-up #1"

        "follow_up_2" ->
            "Follow-up #2"

        "FOLLOW_UP_2" ->
            "Follow-up #2"

        "follow_up_3" ->
            "Follow-up #3"

        "FOLLOW_UP_3" ->
            "Follow-up #3"

        "birthday" ->
            "Birthday"

        "BIRTHDAY" ->
            "Birthday"

        "anniversary" ->
            "Anniversary"

        "ANNIVERSARY" ->
            "Anniversary"

        "effective_date" ->
            "Effective Date"

        "EFFECTIVE_DATE" ->
            "Effective Date"

        _ ->
            emailType


formatDate : String -> String
formatDate dateStr =
    -- Simple formatting, could use a date library for better formatting
    String.left 10 dateStr


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none


upcomingEmailDecoder : Decode.Decoder UpcomingEmail
upcomingEmailDecoder =
    Decode.map7 UpcomingEmail
        (Decode.field "id" Decode.int)
        (Decode.field "contact_id" Decode.int)
        (Decode.field "email_type" Decode.string)
        (Decode.field "scheduled_send_date" Decode.string)
        (Decode.field "status" Decode.string)
        (Decode.field "first_name" Decode.string)
        (Decode.field "last_name" Decode.string)


timeFilterToHtmlValue : TimeFilter -> String
timeFilterToHtmlValue filter =
    case filter of
        Today ->
            "today"

        Yesterday ->
            "yesterday"

        Last7Days ->
            "7days"

        Last30Days ->
            "30days"

        Last90Days ->
            "90days"

        YearToDate ->
            "ytd"

        CustomRange ->
            "custom"


sortOptionToString : RankingSortOption -> String
sortOptionToString sortOption =
    case sortOption of
        SortByQuotesSent ->
            "quotes_sent"

        SortByQuotesViewed ->
            "quotes_viewed"

        SortByChronological ->
            "chronological"

================
File: frontend/src/Decline.elm
================
module Decline exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onInput, onSubmit)
import Http
import Json.Decode as D
import Json.Encode as E
import Url.Parser.Query as Query


type alias Model =
    { name : String
    , email : String
    , isSubmitting : Bool
    , error : Maybe String
    , success : Bool
    , quoteId : Maybe String
    , key : Nav.Key
    }


type Msg
    = UpdateName String
    | UpdateEmail String
    | SubmitForm
    | GotSubmitResponse (Result Http.Error ())
    | GotContactInfo (Result Http.Error ContactInfo)


type alias ContactInfo =
    { email : String
    , firstName : String
    , lastName : String
    }


init : Nav.Key -> Maybe String -> ( Model, Cmd Msg )
init key maybeQuoteId =
    ( { name = ""
      , email = ""
      , isSubmitting = False
      , error = Nothing
      , success = False
      , quoteId = maybeQuoteId
      , key = key
      }
    , case maybeQuoteId of
        Just quoteId ->
            Http.get
                { url = "/api/quotes/decode/" ++ quoteId
                , expect = Http.expectJson GotContactInfo contactInfoDecoder
                }

        Nothing ->
            Cmd.none
    )


contactInfoDecoder : D.Decoder ContactInfo
contactInfoDecoder =
    D.field "contact"
        (D.map3 ContactInfo
            (D.field "email" D.string)
            (D.field "firstName" D.string)
            (D.field "lastName" D.string)
        )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateName name ->
            ( { model | name = name }, Cmd.none )

        UpdateEmail email ->
            ( { model | email = email }, Cmd.none )

        SubmitForm ->
            ( { model | isSubmitting = True }
            , Http.post
                { url = "/api/contact-request"
                , body = Http.jsonBody (encodeForm model)
                , expect = Http.expectWhatever GotSubmitResponse
                }
            )

        GotSubmitResponse result ->
            case result of
                Ok _ ->
                    ( { model | isSubmitting = False, success = True }, Cmd.none )

                Err _ ->
                    ( { model | isSubmitting = False, error = Just "Failed to submit form. Please try again." }, Cmd.none )

        GotContactInfo result ->
            case result of
                Ok info ->
                    ( { model
                        | email = info.email
                        , name = info.firstName ++ " " ++ info.lastName
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( model, Cmd.none )


encodeForm : Model -> E.Value
encodeForm model =
    E.object
        [ ( "name", E.string model.name )
        , ( "email", E.string model.email )
        , ( "type", E.string "decline" )
        , ( "quoteId", Maybe.map E.string model.quoteId |> Maybe.withDefault E.null )
        ]


view : Model -> Browser.Document Msg
view model =
    { title = "Not Eligible - Medicare Max"
    , body =
        [ div [ class "min-h-screen bg-white" ]
            [ nav [ class "bg-white border-b border-gray-200" ]
                [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
                    [ div [ class "flex justify-between h-16 items-center" ]
                        [ div [ class "flex-shrink-0" ]
                            [ img [ src "/images/medicare-max-logo.png", class "h-8 w-auto", alt "Medicare Max" ] [] ]
                        ]
                    ]
                ]
            , div [ class "max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-12" ]
                [ if model.success then
                    div [ class "text-center" ]
                        [ h1 [ class "text-3xl font-bold text-gray-900 mb-4" ]
                            [ text "Thank You" ]
                        , p [ class "text-gray-600" ]
                            [ text "We'll be in touch soon to discuss your options." ]
                        ]

                  else
                    div []
                        [ h1 [ class "text-3xl font-bold text-center text-gray-900 mb-4" ]
                            [ text "We Need to Talk" ]
                        , p [ class "text-gray-600 text-center mb-8" ]
                            [ text "Based on your answers, you may not qualify for this plan. However, we'd love to help you find a different plan that's a perfect fit for your needs." ]
                        , case model.error of
                            Just error ->
                                div [ class "bg-red-50 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" ]
                                    [ text error ]

                            Nothing ->
                                text ""
                        , Html.form [ onSubmit SubmitForm, class "space-y-6 max-w-lg mx-auto" ]
                            [ div []
                                [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
                                    [ text "Name" ]
                                , input
                                    [ type_ "text"
                                    , class "w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-purple-500 focus:border-purple-500"
                                    , value model.name
                                    , onInput UpdateName
                                    , required True
                                    ]
                                    []
                                ]
                            , div []
                                [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
                                    [ text "Email" ]
                                , input
                                    [ type_ "email"
                                    , class "w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-purple-500 focus:border-purple-500"
                                    , value model.email
                                    , onInput UpdateEmail
                                    , required True
                                    ]
                                    []
                                ]
                            , button
                                [ class "w-full bg-purple-600 text-white py-3 px-4 rounded-lg hover:bg-purple-700 transition-colors duration-200 disabled:opacity-50"
                                , type_ "submit"
                                , disabled model.isSubmitting
                                ]
                                [ if model.isSubmitting then
                                    text "Submitting..."

                                  else
                                    text "Request Follow-up"
                                ]
                            ]
                        ]
                ]
            ]
        ]
    }


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/Earnings.elm
================
module Earnings exposing
    ( EarningsInputs
    , EarningsModel
    , baseCase
    , flatCase
    , rolloverCase
    )

import PriceModel


type alias EarningsInputs =
    { calculationInputs : PriceModel.CalculationInputs
    , overheadCost : Float -- Annual fixed overhead cost
    , customerAcquisitionCost : Float -- Cost per new customer
    , earningsMultiple : Float -- Multiple for enterprise value calculation
    }


type alias EarningsModel =
    List
        { year : Int
        , revenue : Float
        , costs : Float
        , earnings : Float
        , enterpriseValue : Float
        }



-- Helper to calculate enterprise value based on earnings and multiple


calculateEnterpriseValue : Float -> Float -> Float
calculateEnterpriseValue earnings multiple =
    earnings * multiple


baseCase : EarningsInputs -> EarningsModel
baseCase inputs =
    List.range 0 6
        |> List.map
            (\year ->
                let
                    -- Base revenue stays constant (existing book)
                    revenue =
                        toFloat inputs.calculationInputs.contacts
                            * inputs.calculationInputs.commissionRate

                    -- Only fixed costs in base case
                    costs =
                        inputs.overheadCost

                    -- Calculate earnings
                    earnings =
                        revenue - costs

                    -- Calculate enterprise value as simple multiple of earnings
                    enterpriseValue =
                        calculateEnterpriseValue earnings inputs.earningsMultiple
                in
                { year = year
                , revenue = revenue
                , costs = costs
                , earnings = earnings
                , enterpriseValue = enterpriseValue
                }
            )


flatCase : EarningsInputs -> EarningsModel
flatCase inputs =
    List.range 0 6
        |> List.map
            (\year ->
                let
                    -- Total contacts stays constant - these are existing policies
                    totalContacts =
                        toFloat inputs.calculationInputs.contacts

                    -- Revenue from existing book - already paying commissions
                    revenue =
                        totalContacts * inputs.calculationInputs.commissionRate

                    -- Need to replace 1/6 of book every year to maintain size
                    replacementCustomers =
                        totalContacts / 6

                    -- Constant replacement rate
                    -- Costs: fixed overhead + CAC for replacements
                    costs =
                        inputs.overheadCost
                            + (replacementCustomers * inputs.customerAcquisitionCost)

                    -- Calculate earnings
                    earnings =
                        revenue - costs

                    -- Calculate enterprise value as simple multiple of earnings
                    enterpriseValue =
                        calculateEnterpriseValue earnings inputs.earningsMultiple
                in
                { year = year
                , revenue = revenue
                , costs = costs
                , earnings = earnings
                , enterpriseValue = enterpriseValue
                }
            )


rolloverCase : EarningsInputs -> EarningsModel
rolloverCase inputs =
    List.range 0 6
        |> List.map
            (\year ->
                let
                    -- Base revenue from existing book
                    baseRevenue =
                        toFloat inputs.calculationInputs.contacts
                            * inputs.calculationInputs.commissionRate

                    -- Calculate retained customers (starting year 1)
                    -- These are customers we would have lost (1/6 of book) but kept (at rollover rate)
                    retainedCustomers =
                        if year == 0 then
                            0

                        else
                            -- 1/6 of book * rollover rate for each year
                            (toFloat inputs.calculationInputs.contacts / 6)
                                * (inputs.calculationInputs.rolloverPercent / 100)
                                * toFloat year

                    -- Additional revenue from retained customers
                    retainedRevenue =
                        retainedCustomers * inputs.calculationInputs.commissionRate

                    revenue =
                        baseRevenue + retainedRevenue

                    -- Need to replace 1/6 of original book minus those we retain
                    baseReplacements =
                        if year == 0 then
                            toFloat inputs.calculationInputs.contacts / 6

                        else
                            -- Only replace those we didn't retain
                            (toFloat inputs.calculationInputs.contacts / 6)
                                * (1 - inputs.calculationInputs.rolloverPercent / 100)

                    -- Costs include fixed overhead plus CAC for replacements
                    costs =
                        inputs.overheadCost
                            + (baseReplacements * inputs.customerAcquisitionCost)

                    -- Calculate earnings
                    earnings =
                        revenue - costs

                    -- Calculate enterprise value as simple multiple of earnings
                    enterpriseValue =
                        calculateEnterpriseValue earnings inputs.earningsMultiple
                in
                { year = year
                , revenue = revenue
                , costs = costs
                , earnings = earnings
                , enterpriseValue = enterpriseValue
                }
            )

================
File: frontend/src/Eligibility.elm
================
module Eligibility exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Dict exposing (Dict)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput, onSubmit)
import Http
import Json.Decode as D
import Json.Decode.Pipeline as P
import Json.Encode as E
import MyIcon
import Svg exposing (path, svg)
import Svg.Attributes exposing (d, fill, fillRule, height, stroke, strokeLinecap, strokeLinejoin, strokeWidth, viewBox, width)
import Url.Builder as Builder
import Utils.QuoteHeader exposing (viewHeader)



-- TYPES


type Color
    = DangerColor
    | BlueColor
    | AmberColor
    | SuccessColor
    | PurpleColor
    | BrandColor


type AnswerType
    = BooleanAnswer (Maybe Bool)
    | TextAnswer String


type alias FollowUpQuestion =
    { id : Int
    , text : String
    , answerType : AnswerType
    }


type alias Question =
    { id : Int
    , icon : Icon
    , title : String
    , text : String
    , color : Color
    , answer : Maybe Bool
    , followUpQuestions : List FollowUpQuestion
    , isExpanded : Bool
    }


type alias Model =
    { key : Nav.Key
    , questions : List Question
    , quoteId : Maybe String
    , orgId : String
    , orgName : Maybe String
    , orgLogo : Maybe String
    , isSubmitting : Bool
    , submissionError : Maybe String
    , isLoading : Bool
    }


type Msg
    = AnswerQuestion Int Bool
    | ToggleExpand Int
    | UpdateFollowUpText Int Int String
    | AnswerFollowUpQuestion Int Int Bool
    | SubmitAnswers
    | SkipQuestions
    | GotSubmitResponse (Result Http.Error ContactResponse)
    | GotTempContactResponse (Result Http.Error String)
    | GotOrgDetails (Result Http.Error OrgDetailsResponse)
    | GotExistingAnswers (Result Http.Error ExistingAnswersResponse)


type alias ContactResponse =
    { contactId : String
    , orgName : String
    , orgLogo : Maybe String
    }


type alias OrgDetailsResponse =
    { orgName : String
    , orgLogo : Maybe String
    }


type Icon
    = HeartIcon
    | LungsIcon
    | AlertCircleIcon
    | DropletsIcon
    | BrainIcon
    | Building2Icon
    | StethoscopeIcon


type alias ExistingAnswersResponse =
    { answers : List ExistingAnswer
    , orgName : String
    , orgLogo : Maybe String
    }


type alias ExistingAnswer =
    { questionId : Int
    , questionText : String
    , questionType : String
    , answer : Bool
    , followUpAnswers : List FollowUpAnswer
    }


type alias FollowUpAnswer =
    { questionId : Int
    , questionText : String
    , answer : AnswerType
    }



-- INIT


defaultQuestions : List Question
defaultQuestions =
    [ { id = 1
      , icon = HeartIcon
      , title = "Heart Health"
      , text = "Have you ever been diagnosed with or treated for any heart condition, including but not limited to heart failure, coronary artery disease, angina, atrial fibrillation, or heart valve problems?"
      , color = DangerColor
      , answer = Nothing
      , isExpanded = False
      , followUpQuestions =
            [ { id = 101
              , text = "What specific heart condition(s) have you been diagnosed with?"
              , answerType = TextAnswer ""
              }
            , { id = 102
              , text = "In the past 2 years, have you been hospitalized, had surgery, or any cardiac procedures (like angioplasty or stenting) for this condition?"
              , answerType = BooleanAnswer Nothing
              }
            , { id = 103
              , text = "Are you currently taking 3 or more medications for this heart condition, or using oxygen or nitroglycerin?"
              , answerType = BooleanAnswer Nothing
              }
            ]
      }
    , { id = 2
      , icon = LungsIcon
      , title = "Lung Health"
      , text = "Have you ever been diagnosed with or treated for a chronic lung condition such as COPD, emphysema, chronic bronchitis, or cystic fibrosis?"
      , color = BlueColor
      , answer = Nothing
      , isExpanded = False
      , followUpQuestions =
            [ { id = 201
              , text = "What specific lung condition(s) have you been diagnosed with?"
              , answerType = TextAnswer ""
              }
            , { id = 202
              , text = "Does this condition require you to use oxygen at home or a nebulizer?"
              , answerType = BooleanAnswer Nothing
              }
            , { id = 203
              , text = "In the past year, have you been hospitalized due to lung problems or had frequent (3 or more) respiratory infections requiring antibiotics or steroids?"
              , answerType = BooleanAnswer Nothing
              }
            ]
      }
    , { id = 3
      , icon = AlertCircleIcon
      , title = "Cancer History"
      , text = "Have you ever been diagnosed with or treated for cancer, leukemia, or lymphoma (excluding basal cell skin cancer)?"
      , color = AmberColor
      , answer = Nothing
      , isExpanded = False
      , followUpQuestions =
            [ { id = 301
              , text = "What type of cancer were you diagnosed with?"
              , answerType = TextAnswer ""
              }
            , { id = 302
              , text = "When were you initially diagnosed?"
              , answerType = TextAnswer ""
              }
            , { id = 303
              , text = "Are you currently undergoing active cancer treatment (chemotherapy, radiation, immunotherapy, targeted therapy, or hormone therapy)?"
              , answerType = BooleanAnswer Nothing
              }
            ]
      }
    , { id = 4
      , icon = DropletsIcon
      , title = "Diabetes with Complications"
      , text = "Have you ever been diagnosed with diabetes that has resulted in any complications affecting your eyes (retinopathy), nerves (neuropathy), kidneys (nephropathy), circulation (vascular disease), or heart?"
      , color = SuccessColor
      , answer = Nothing
      , isExpanded = False
      , followUpQuestions =
            [ { id = 401
              , text = "Which complications of diabetes have you experienced? (e.g., Neuropathy, Retinopathy, Kidney Problems, Vascular Disease, Heart Problems)"
              , answerType = TextAnswer ""
              }
            , { id = 402
              , text = "Do you require insulin to manage your diabetes, and if so, what is your typical daily insulin dosage?"
              , answerType = TextAnswer ""
              }
            ]
      }
    , { id = 5
      , icon = BrainIcon
      , title = "Memory or Cognitive Health"
      , text = "Do you have any concerns about your memory, thinking, or cognitive function, OR have you ever been diagnosed with dementia, Alzheimer's disease, or any other cognitive impairment?"
      , color = PurpleColor
      , answer = Nothing
      , isExpanded = False
      , followUpQuestions =
            [ { id = 501
              , text = "Have you been formally diagnosed with any cognitive impairment? If yes, what diagnosis?"
              , answerType = TextAnswer ""
              }
            , { id = 502
              , text = "Do you require assistance with activities of daily living such as remembering medications, managing finances, or personal care due to cognitive impairment?"
              , answerType = BooleanAnswer Nothing
              }
            ]
      }
    , { id = 6
      , icon = Building2Icon
      , title = "Recent and Current Hospitalizations"
      , text = "In the past 2 years, have you been hospitalized overnight in a hospital more than two times for any medical condition (excluding planned surgeries)?"
      , color = BrandColor
      , answer = Nothing
      , isExpanded = False
      , followUpQuestions = []
      }
    , { id = 7
      , icon = StethoscopeIcon
      , title = "Current Hospitalization or Medical Test"
      , text = "Are you currently hospitalized or waiting on results from a medical test, or been recommended by a doctor to have a medical test performed?"
      , color = BlueColor
      , answer = Nothing
      , isExpanded = False
      , followUpQuestions = []
      }
    ]


init : Nav.Key -> { quoteId : Maybe String, orgId : Maybe String } -> ( Model, Cmd Msg )
init key { quoteId, orgId } =
    let
        extractedOrgId =
            case ( orgId, quoteId ) of
                ( Nothing, Just id ) ->
                    id
                        |> String.split "-"
                        |> List.head
                        |> Maybe.withDefault ""

                ( Just orgIdValue, _ ) ->
                    orgIdValue

                ( Nothing, Nothing ) ->
                    ""

        initialModel =
            { key = key
            , questions = defaultQuestions
            , quoteId = quoteId
            , orgId = extractedOrgId
            , orgName = Nothing
            , orgLogo = Nothing
            , isSubmitting = False
            , submissionError = Nothing
            , isLoading = True
            }

        loadOrgDetails =
            if String.isEmpty extractedOrgId then
                Cmd.none

            else
                Http.get
                    { url = "/api/org/" ++ extractedOrgId ++ "/details"
                    , expect = Http.expectJson GotOrgDetails orgDetailsResponseDecoder
                    }

        loadExistingAnswers =
            case quoteId of
                Just id ->
                    let
                        contactId =
                            String.split "-" id
                                |> List.drop 1
                                |> List.head
                                |> Maybe.withDefault ""
                    in
                    if not (String.isEmpty contactId) then
                        Http.get
                            { url = "/api/org/" ++ extractedOrgId ++ "/eligibility-answers/" ++ contactId
                            , expect = Http.expectJson GotExistingAnswers existingAnswersResponseDecoder
                            }

                    else
                        Cmd.none

                Nothing ->
                    Cmd.none
    in
    ( initialModel
    , Cmd.batch [ loadOrgDetails, loadExistingAnswers ]
    )



-- UPDATE


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SkipQuestions ->
            ( model
            , Nav.pushUrl model.key
                (Builder.absolute [ "schedule" ]
                    ([ Builder.string "orgId" model.orgId ]
                        ++ (case model.quoteId of
                                Just id ->
                                    [ Builder.string "id" id ]

                                Nothing ->
                                    []
                           )
                        ++ [ Builder.string "status" "decline" ]
                    )
                )
            )

        AnswerQuestion id answer ->
            ( { model
                | questions =
                    List.map
                        (\q ->
                            if q.id == id then
                                { q
                                    | answer = Just answer
                                    , isExpanded = answer && not (List.isEmpty q.followUpQuestions) -- Only expand if there are followup questions
                                }

                            else
                                q
                        )
                        model.questions
              }
            , Cmd.none
            )

        ToggleExpand id ->
            ( { model
                | questions =
                    List.map
                        (\q ->
                            if q.id == id then
                                { q | isExpanded = not q.isExpanded }

                            else
                                q
                        )
                        model.questions
              }
            , Cmd.none
            )

        UpdateFollowUpText questionId answerId text ->
            ( { model
                | questions =
                    List.map
                        (\q ->
                            if q.id == questionId then
                                { q
                                    | followUpQuestions =
                                        List.map
                                            (\f ->
                                                if f.id == answerId then
                                                    { f | answerType = TextAnswer text }

                                                else
                                                    f
                                            )
                                            q.followUpQuestions
                                }

                            else
                                q
                        )
                        model.questions
              }
            , Cmd.none
            )

        AnswerFollowUpQuestion questionId answerId answer ->
            ( { model
                | questions =
                    List.map
                        (\q ->
                            if q.id == questionId then
                                { q
                                    | followUpQuestions =
                                        List.map
                                            (\f ->
                                                if f.id == answerId then
                                                    { f | answerType = BooleanAnswer (Just answer) }

                                                else
                                                    f
                                            )
                                            q.followUpQuestions
                                }

                            else
                                q
                        )
                        model.questions
              }
            , Cmd.none
            )

        GotSubmitResponse result ->
            case result of
                Ok response ->
                    let
                        anyYes =
                            List.any (\q -> q.answer == Just True) model.questions

                        nextUrl =
                            Builder.absolute [ "schedule" ]
                                ([ Builder.string "orgId" model.orgId
                                 , Builder.string "status"
                                    (if anyYes then
                                        "decline"

                                     else
                                        "accept"
                                    )
                                 ]
                                    ++ (case model.quoteId of
                                            Just id ->
                                                [ Builder.string "id" id ]

                                            Nothing ->
                                                [ Builder.string "contactId" response.contactId ]
                                       )
                                )
                    in
                    ( { model
                        | isSubmitting = False
                        , orgName = Just response.orgName
                        , orgLogo = response.orgLogo
                      }
                    , Nav.pushUrl model.key nextUrl
                    )

                Err error ->
                    ( { model
                        | isSubmitting = False
                        , submissionError = Just "Failed to save your answers. Please try again."
                      }
                    , Cmd.none
                    )

        GotTempContactResponse result ->
            case result of
                Ok contactId ->
                    -- Now that we have a temporary contact, submit the answers
                    let
                        relevantQuestions =
                            getRelevantQuestions model

                        encodedAnswers =
                            encodeAnswers relevantQuestions
                    in
                    ( model
                    , Http.post
                        { url = "/api/org/" ++ model.orgId ++ "/eligibility-answers"
                        , body =
                            Http.jsonBody <|
                                E.object
                                    [ ( "contact_id", E.string contactId )
                                    , ( "answers", encodedAnswers )
                                    ]
                        , expect = Http.expectJson GotSubmitResponse contactResponseDecoder
                        }
                    )

                Err error ->
                    ( { model
                        | isSubmitting = False
                        , submissionError = Just "Failed to create temporary contact. Please try again."
                      }
                    , Cmd.none
                    )

        GotOrgDetails result ->
            case result of
                Ok response ->
                    ( { model
                        | orgName = Just response.orgName
                        , orgLogo = response.orgLogo
                        , isLoading = False
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model | isLoading = False }
                    , Cmd.none
                    )

        GotExistingAnswers result ->
            case result of
                Ok response ->
                    let
                        updatedQuestions =
                            List.map
                                (\q ->
                                    case List.filter (\a -> a.questionId == q.id) response.answers of
                                        existingAnswer :: _ ->
                                            { q
                                                | answer = Just existingAnswer.answer
                                                , isExpanded = existingAnswer.answer -- Auto-expand if answered Yes
                                                , followUpQuestions =
                                                    List.map
                                                        (\fq ->
                                                            case List.filter (\fa -> fa.questionId == fq.id && fa.questionText == fq.text) existingAnswer.followUpAnswers of
                                                                followUpAnswer :: _ ->
                                                                    { fq | answerType = followUpAnswer.answer }

                                                                [] ->
                                                                    fq
                                                        )
                                                        q.followUpQuestions
                                            }

                                        [] ->
                                            q
                                )
                                model.questions
                    in
                    ( { model
                        | questions = updatedQuestions
                        , orgName = Just response.orgName
                        , orgLogo = response.orgLogo
                        , isLoading = False
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model | isLoading = False }
                    , Cmd.none
                    )

        SubmitAnswers ->
            let
                relevantQuestions =
                    getRelevantQuestions model

                allRelevantQuestionsAnswered =
                    List.all
                        (\q ->
                            case q.followUpQuestions of
                                [] ->
                                    q.answer /= Nothing

                                followUps ->
                                    List.all
                                        (\fq ->
                                            case fq.answerType of
                                                TextAnswer _ ->
                                                    True

                                                BooleanAnswer _ ->
                                                    q.answer /= Nothing
                                        )
                                        followUps
                        )
                        relevantQuestions
            in
            if allRelevantQuestionsAnswered then
                case model.quoteId of
                    Just quoteId ->
                        -- If we have a quote ID, submit answers directly
                        ( { model | isSubmitting = True, submissionError = Nothing }
                        , submitAnswers model
                        )

                    Nothing ->
                        -- If no quote ID, first create a temporary contact
                        ( { model | isSubmitting = True, submissionError = Nothing }
                        , Http.post
                            { url = "/api/org/" ++ model.orgId ++ "/temp-contact"
                            , body = Http.jsonBody <| E.object [] -- Minimal data for temp contact
                            , expect = Http.expectString GotTempContactResponse
                            }
                        )

            else
                ( model
                , Cmd.none
                )



-- Helper functions


getRelevantQuestions : Model -> List Question
getRelevantQuestions model =
    let
        answeredQuestions =
            List.filter (\q -> q.answer /= Nothing) model.questions
    in
    answeredQuestions


encodeAnswers : List Question -> E.Value
encodeAnswers questions =
    E.object
        (List.filterMap
            (\q ->
                if q.answer == Nothing then
                    Nothing

                else
                    let
                        questionType =
                            case q.color of
                                DangerColor ->
                                    "main"

                                BlueColor ->
                                    "lung_health"

                                AmberColor ->
                                    "cancer_history"

                                SuccessColor ->
                                    "diabetes_with_complications"

                                PurpleColor ->
                                    "memory_or_cognitive_health"

                                BrandColor ->
                                    "recent_and_current_hospitalizations"

                        answerValue =
                            case q.answer of
                                Just ans ->
                                    E.bool ans

                                Nothing ->
                                    E.null
                    in
                    Just
                        ( String.fromInt q.id
                        , E.object
                            [ ( "id", E.int q.id )
                            , ( "question_text", E.string q.text )
                            , ( "question_type", E.string questionType )
                            , ( "answer", answerValue )
                            , ( "follow_up_questions", encodeFollowUpQuestions q.followUpQuestions )
                            ]
                        )
            )
            questions
        )


encodeAwnser : AnswerType -> Maybe E.Value
encodeAwnser answerType =
    case answerType of
        BooleanAnswer maybeAnswer ->
            case maybeAnswer of
                Just answer ->
                    Just (E.bool answer)

                Nothing ->
                    Nothing

        TextAnswer text ->
            Just (E.string text)


encodeFollowUpQuestions : List FollowUpQuestion -> E.Value
encodeFollowUpQuestions questions =
    questions
        |> List.filter
            (\q ->
                case q.answerType of
                    TextAnswer "" ->
                        False

                    BooleanAnswer Nothing ->
                        False

                    _ ->
                        True
            )
        |> List.map
            (\q ->
                E.object
                    ([ ( "id", Just (E.int q.id) )
                     , ( "question_text", Just (E.string q.text) )
                     , ( "answer", encodeAwnser q.answerType )
                     ]
                        |> List.filterMap
                            (\( key, value ) ->
                                case value of
                                    Just v ->
                                        Just ( key, v )

                                    Nothing ->
                                        Nothing
                            )
                    )
            )
        |> E.list identity


iconToSvg : Icon -> Color -> Html msg
iconToSvg icon color =
    let
        iconColor =
            case color of
                DangerColor ->
                    "text-[#DC2626]"

                BlueColor ->
                    "text-[#0075F2]"

                AmberColor ->
                    "text-amber-500"

                SuccessColor ->
                    "text-medicare-success"

                PurpleColor ->
                    "text-[#7F56D9]"

                BrandColor ->
                    "text-[#03045E]"
    in
    case icon of
        HeartIcon ->
            div [ class iconColor ] [ MyIcon.heartPulse 24 "currentColor" ]

        LungsIcon ->
            div [ class iconColor ] [ MyIcon.lungs 24 "currentColor" ]

        AlertCircleIcon ->
            div [ class iconColor ] [ MyIcon.activity 24 "currentColor" ]

        DropletsIcon ->
            div [ class iconColor ] [ MyIcon.droplets 24 "currentColor" ]

        BrainIcon ->
            div [ class iconColor ] [ MyIcon.brain 24 "currentColor" ]

        Building2Icon ->
            div [ class iconColor ] [ MyIcon.building2 24 "currentColor" ]

        StethoscopeIcon ->
            div [ class iconColor ] [ MyIcon.stethoscope 24 "currentColor" ]


colorToClasses : Color -> Bool -> { card : String, title : String, indicator : String }
colorToClasses color isActive =
    case color of
        DangerColor ->
            { card =
                if isActive then
                    "bg-[#DC2626]/10"

                else
                    "bg-white"
            , title = "text-[#DC2626]"
            , indicator = "bg-[#DC2626]/10"
            }

        BlueColor ->
            { card =
                if isActive then
                    "bg-[#0075F2]/20"

                else
                    "bg-white"
            , title = "text-[#0075F2]"
            , indicator = "bg-[#0075F2]/10"
            }

        AmberColor ->
            { card =
                if isActive then
                    "bg-amber-50"

                else
                    "bg-white"
            , title = "text-amber-500"
            , indicator = "bg-amber-50"
            }

        SuccessColor ->
            { card =
                if isActive then
                    "bg-medicare-success-light"

                else
                    "bg-white"
            , title = "text-medicare-success"
            , indicator = "bg-medicare-success-light"
            }

        PurpleColor ->
            { card =
                if isActive then
                    "bg-[#7F56D9]/20"

                else
                    "bg-white"
            , title = "text-[#7F56D9]"
            , indicator = "bg-[#7F56D9]/10"
            }

        BrandColor ->
            { card =
                if isActive then
                    "bg-[#03045E]/20"

                else
                    "bg-white"
            , title = "text-[#03045E]"
            , indicator = "bg-[#03045E]/10"
            }



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Underwriting Assessment"
    , body =
        [ div [ class "min-h-screen bg-white" ]
            [ if model.isLoading then
                div [ class "fixed inset-0 bg-white flex flex-col items-center justify-center gap-4 text-center" ]
                    [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-[#03045E] border-t-transparent" ] []
                    , p [ class "text-center text-lg font-medium text-gray-600" ]
                        [ text "Loading assessment..." ]
                    ]

              else
                div [ class "max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-8" ]
                    [ -- Organization Logo/Name
                      viewHeader model.orgLogo model.orgName
                    , h1 [ class "text-2xl sm:text-3xl font-bold text-center text-gray-900 mb-2 sm:mb-3" ]
                        [ text "Underwriting Assessment" ]
                    , p [ class "text-gray-600 px-5 md:px-0 text-center mb-6 sm:mb-8 text-sm sm:text-base max-w-xl mx-auto" ]
                        [ text "In order to qualify for a new Supplemental plan you must pass medical underwriting. Please answer all questions to the best of your knowledge." ]
                    , if model.submissionError /= Nothing then
                        div [ class "mb-4 p-3 bg-red-100 text-red-700 rounded-lg text-sm" ]
                            [ text (Maybe.withDefault "" model.submissionError) ]

                      else
                        text ""
                    , Html.form [ onSubmit SubmitAnswers, class "space-y-4 sm:space-y-6" ]
                        (viewQuestionsWithFollowUps model
                            ++ [ viewSubmitButton model ]
                        )
                    , viewMedicareAdvantageOffRamp model
                    ]
            ]
        ]
    }


viewQuestionsWithFollowUps : Model -> List (Html Msg)
viewQuestionsWithFollowUps model =
    List.map
        (\q ->
            div [ class "mb-6 transition-all duration-200" ]
                [ viewQuestion q ]
        )
        model.questions


viewQuestion : Question -> Html Msg
viewQuestion question =
    let
        colorClasses =
            colorToClasses question.color (question.answer == Just True)

        shouldShowFollowUps =
            question.answer == Just True && question.isExpanded && not (List.isEmpty question.followUpQuestions)

        hasFollowUps =
            not (List.isEmpty question.followUpQuestions)

        bgColorClass =
            if question.answer == Just True then
                case question.color of
                    DangerColor ->
                        "bg-[#DC2626]/10"

                    BlueColor ->
                        "bg-[#0075F2]/10"

                    AmberColor ->
                        "bg-amber-50"

                    SuccessColor ->
                        "bg-medicare-success-light"

                    PurpleColor ->
                        "bg-[#7F56D9]/10"

                    BrandColor ->
                        "bg-[#03045E]/10"

            else
                "bg-white"
    in
    div
        [ class <|
            "rounded-lg shadow-card overflow-hidden transition-all duration-300 border border-[#DCE2E5] "
                ++ bgColorClass
        ]
        [ div [ class "p-3 sm:p-5" ]
            [ div [ class "flex items-start gap-2 sm:gap-4" ]
                [ div [ class "flex-shrink-0 mt-0.5 sm:mt-1" ]
                    [ iconToSvg question.icon question.color ]
                , div [ class "flex-1 min-w-0" ]
                    [ div [ class "flex justify-between items-start" ]
                        [ h3 [ class <| "font-semibold text-base sm:text-lg mb-1.5 sm:mb-2 " ++ colorClasses.title ]
                            [ text question.title ]
                        ]
                    , p [ class "text-gray-700 text-sm sm:text-base mb-3 sm:mb-4" ]
                        [ text question.text ]
                    , div [ class "flex gap-2 sm:gap-3" ]
                        [ viewAnswerButton question True
                        , viewAnswerButton question False
                        ]
                    ]
                ]
            ]
        , if shouldShowFollowUps then
            div [ class "mt-4 space-y-4 border-t border-[#DCE2E5] pt-4 pb-4 sm:pb-5" ]
                (List.map (\f -> viewFollowUpQuestion f question.id) question.followUpQuestions)

          else
            text ""
        ]


viewFollowUpQuestion : FollowUpQuestion -> Int -> Html Msg
viewFollowUpQuestion followUp parentId =
    div [ class "px-3 sm:px-5" ]
        [ p [ class "text-gray-700 text-sm sm:text-base mb-2" ]
            [ text followUp.text ]
        , case followUp.answerType of
            TextAnswer textValue ->
                div [ class "mt-2" ]
                    [ textarea
                        [ class "w-full p-2.5 sm:p-3 text-sm sm:text-base bg-white border border-[#DCE2E5] rounded-lg focus:ring-2 focus:ring-[#03045E] focus:border-[#03045E]"
                        , rows 2
                        , placeholder "Please provide details..."
                        , value textValue
                        , onInput (\text -> UpdateFollowUpText parentId followUp.id text)
                        ]
                        []
                    ]

            BooleanAnswer answer ->
                div [ class "flex gap-2 sm:gap-3" ]
                    [ button
                        [ type_ "button"
                        , onClick (AnswerFollowUpQuestion parentId followUp.id True)
                        , class <|
                            "flex-1 py-2 sm:py-2.5 px-3 sm:px-4 text-sm sm:text-base rounded-lg font-medium transition-colors border "
                                ++ (if answer == Just True then
                                        "bg-[#03045E] text-white border-[#03045E]"

                                    else
                                        "bg-white text-gray-700 border-[#DCE2E5] hover:bg-gray-50"
                                   )
                        ]
                        [ text "Yes" ]
                    , button
                        [ type_ "button"
                        , onClick (AnswerFollowUpQuestion parentId followUp.id False)
                        , class <|
                            "flex-1 py-2 sm:py-2.5 px-3 sm:px-4 text-sm sm:text-base rounded-lg font-medium transition-colors border "
                                ++ (if answer == Just False then
                                        "bg-gray-900 text-white border-gray-900"

                                    else
                                        "bg-white text-gray-700 border-[#DCE2E5] hover:bg-gray-50"
                                   )
                        ]
                        [ text "No" ]
                    ]
        ]


viewRadioButton : Question -> String -> Bool -> Html Msg
viewRadioButton question labelText value =
    label
        [ class
            ("flex items-center justify-center px-3 sm:px-4 py-2 sm:py-2.5 rounded-md border text-sm sm:text-base cursor-pointer transition-all duration-200 w-full "
                ++ (if question.answer == Just value then
                        if value then
                            "border-blue-500 bg-blue-50 text-blue-700 font-medium shadow-sm"

                        else
                            "border-gray-500 bg-gray-50 text-gray-700 font-medium shadow-sm"

                    else
                        "border-gray-200 hover:border-blue-200 hover:bg-gray-50 text-gray-700"
                   )
            )
        , onClick (AnswerQuestion question.id value)
        ]
        [ input
            [ type_ "radio"
            , name ("question-" ++ String.fromInt question.id)
            , checked (question.answer == Just value)
            , class "sr-only"
            ]
            []
        , span [ class "font-medium" ] [ text labelText ]
        ]


viewAnswerButton : Question -> Bool -> Html Msg
viewAnswerButton question isYes =
    button
        [ type_ "button"
        , onClick (AnswerQuestion question.id isYes)
        , class <|
            "flex-1 py-2 sm:py-2.5 px-3 sm:px-4 text-sm sm:text-base rounded-lg font-medium transition-colors border "
                ++ (if question.answer == Just isYes then
                        if isYes then
                            "bg-[#03045E] text-white border-[#03045E]"

                        else
                            "bg-gray-900 text-white border-gray-900"

                    else
                        "bg-white text-gray-700 border-gray-300 hover:bg-gray-50"
                   )
        ]
        [ text
            (if isYes then
                "Yes"

             else
                "No"
            )
        ]


viewSubmitButton : Model -> Html Msg
viewSubmitButton model =
    let
        -- Check if all main questions are answered
        allMainQuestionsAnswered =
            List.all (\q -> q.answer /= Nothing) model.questions

        -- For any "Yes" answers with follow-up questions, check if all boolean follow-ups are answered
        allRequiredFollowUpsAnswered =
            List.all
                (\q ->
                    case q.answer of
                        Just True ->
                            -- If answered Yes, check follow-up questions
                            List.all
                                (\fq ->
                                    case fq.answerType of
                                        TextAnswer _ ->
                                            -- Text answers are optional
                                            True

                                        BooleanAnswer answer ->
                                            -- Boolean answers must be answered
                                            answer /= Nothing
                                )
                                q.followUpQuestions

                        _ ->
                            -- If not answered Yes, follow-ups don't matter
                            True
                )
                model.questions

        canSubmit =
            allMainQuestionsAnswered && allRequiredFollowUpsAnswered && not model.isSubmitting

        buttonClass =
            "w-full py-2.5 sm:py-3 rounded-lg text-white font-medium transition-colors duration-200 mt-4 sm:mt-6 text-sm sm:text-base shadow-sm "
                ++ (if canSubmit then
                        "bg-[#03045E] hover:bg-[#03045E]/90"

                    else
                        "bg-[#03045E]/70 cursor-not-allowed"
                   )
    in
    button
        [ class buttonClass
        , type_ "submit"
        , disabled (not canSubmit)
        ]
        [ if model.isSubmitting then
            text "Submitting..."

          else
            text "Next"
        ]


viewMedicareAdvantageOffRamp : Model -> Html Msg
viewMedicareAdvantageOffRamp model =
    div [ class "mt-12" ]
        [ div [ class "w-full h-px bg-[#DCE2E5] mb-8" ] [] -- Gray divider
        , div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)]" ]
            [ div [ class "px-4 sm:px-6 py-4 sm:py-5 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 sm:gap-0" ]
                [ div [ class "flex items-start gap-4" ]
                    [ -- Icon for the section
                      div [ class "w-12 h-12 rounded-full bg-[#F9F5FF] flex items-center justify-center flex-shrink-0" ]
                        [ svg [ Svg.Attributes.width "26", Svg.Attributes.height "26", Svg.Attributes.viewBox "0 0 24 24", Svg.Attributes.fill "none" ]
                            [ path
                                [ Svg.Attributes.d "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"
                                , Svg.Attributes.stroke "#7F56D9"
                                , Svg.Attributes.strokeWidth "2"
                                , Svg.Attributes.strokeLinecap "round"
                                , Svg.Attributes.strokeLinejoin "round"
                                ]
                                []
                            , path
                                [ Svg.Attributes.d "M12 8V12"
                                , Svg.Attributes.stroke "#7F56D9"
                                , Svg.Attributes.strokeWidth "2"
                                , Svg.Attributes.strokeLinecap "round"
                                , Svg.Attributes.strokeLinejoin "round"
                                ]
                                []
                            , path
                                [ Svg.Attributes.d "M12 16H12.01"
                                , Svg.Attributes.stroke "#7F56D9"
                                , Svg.Attributes.strokeWidth "2"
                                , Svg.Attributes.strokeLinecap "round"
                                , Svg.Attributes.strokeLinejoin "round"
                                ]
                                []
                            ]
                        ]
                    , div [ class "flex flex-col" ]
                        [ h3 [ class "text-lg sm:text-xl font-bold text-[#101828] -tracking-[0.02em]" ]
                            [ text "Looking to dramatically lower your monthly costs?" ]
                        , p [ class "text-sm sm:text-base text-[#667085]" ]
                            [ text "Medicare Advantage plans offer $0 monthly premiums with drug coverage included. These plans have improved a lot over recent years, with more benefits and flexibility than ever. If saving money is your priority, let's find the right plan for you." ]
                        ]
                    ]
                , div [ class "sm:ml-4 flex justify-center sm:justify-start" ]
                    [ button
                        [ onClick SkipQuestions
                        , class "whitespace-nowrap bg-[#03045E] text-white px-5 sm:px-4 py-3 sm:py-2 rounded-lg hover:bg-[#02034D] transition-colors text-sm sm:text-base w-full sm:w-auto text-center"
                        , type_ "button"
                        , disabled model.isSubmitting
                        ]
                        [ text "Explore Options" ]
                    ]
                ]
            ]
        ]



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none



-- Add this near other decoders


contactResponseDecoder : D.Decoder ContactResponse
contactResponseDecoder =
    D.map3 ContactResponse
        (D.field "contactId" D.string)
        (D.field "orgName" D.string)
        (D.field "orgLogo" (D.nullable D.string))


orgDetailsResponseDecoder : D.Decoder OrgDetailsResponse
orgDetailsResponseDecoder =
    D.map2 OrgDetailsResponse
        (D.field "name" D.string)
        (D.field "logo_data" (D.nullable D.string))


submitAnswers : Model -> Cmd Msg
submitAnswers model =
    Http.post
        { url = "/api/org/" ++ model.orgId ++ "/eligibility-answers"
        , body =
            Http.jsonBody <|
                E.object
                    [ ( "quote_id", E.string (Maybe.withDefault "" model.quoteId) )
                    , ( "answers", encodeAnswers (getRelevantQuestions model) )
                    ]
        , expect = Http.expectJson GotSubmitResponse contactResponseDecoder
        }


existingAnswersResponseDecoder : D.Decoder ExistingAnswersResponse
existingAnswersResponseDecoder =
    D.map3 ExistingAnswersResponse
        (D.field "answers" (D.dict existingAnswerDecoder |> D.map dictToAnswerList))
        (D.field "orgName" D.string)
        (D.field "orgLogo" (D.nullable D.string))


existingAnswerDecoder : D.Decoder ExistingAnswer
existingAnswerDecoder =
    D.succeed ExistingAnswer
        |> P.required "id" D.int
        |> P.required "question_text" D.string
        |> P.required "question_type" D.string
        |> P.required "answer" D.bool
        |> P.required "follow_up_questions" (D.list followUpAnswerDecoder)


followUpAnswerDecoder : D.Decoder FollowUpAnswer
followUpAnswerDecoder =
    D.succeed FollowUpAnswer
        |> P.required "id" D.int
        |> P.required "question_text" D.string
        |> P.required "answer" answerTypeDecoder


answerTypeDecoder : D.Decoder AnswerType
answerTypeDecoder =
    D.oneOf
        [ D.map (\b -> BooleanAnswer (Just b)) D.bool
        , D.map TextAnswer D.string
        ]


dictToAnswerList : Dict String ExistingAnswer -> List ExistingAnswer
dictToAnswerList dict =
    Dict.toList dict
        |> List.map
            (\( key, answer ) ->
                { answer | questionId = String.toInt key |> Maybe.withDefault 0 }
            )

================
File: frontend/src/EmailScheduler.elm
================
module EmailScheduler exposing
    ( EmailSchedule
    , PlanType(..)
    , ScheduledEmail
    , ScheduledEmailStatus(..)
    , ScheduledEmailType(..)
    , getScheduledEmails
    , init
    , scheduledEmailTypeToString
    , viewFutureActivity
    , viewScheduledEmail
    )

{-| This module manages email scheduling for various events such as birthdays,
anniversaries, New Year greetings, and October blasts. It supports different plan
types and provides functionality to schedule emails, check their status, and display upcoming activities.

The module includes:

  - Type definitions for email schedules and statuses.
  - Initialization of email schedules.
  - Logic to calculate scheduled emails with status checks.
  - Views to display future scheduled emails in a user-friendly table format.

Dependencies:

  - `Date` for handling dates.
  - `Html` for rendering views.

-}

import BirthdayRules exposing (canPresentDifferentPlanOnly, getDelayedEmailDate, getStateRule, isInBirthdayRuleWindow, isInContinuousOpenEnrollment)
import Date exposing (Date)
import Html exposing (Html, div, h2, span, table, tbody, td, text, th, thead, tr)
import Html.Attributes exposing (class)
import Time exposing (Month(..))



-- TYPES


{-| Represents an email schedule for a contact, including key dates and plan information.

  - `contactId`: Unique identifier for the contact.
  - `effectiveDate`: The date when the plan became effective.
  - `birthDate`: The contact's birth date.
  - `currentDate`: The current date for reference.
  - `planType`: The type of plan (PlanN, PlanG, or NoPlan).
  - `state`: The state of the contact.
  - `stateCarrierSettings`: List of state carrier settings.
  - `stateLicenses`: List of state licenses.

-}
type alias EmailSchedule =
    { contactId : Int
    , effectiveDate : Date
    , birthDate : Date
    , currentDate : Date
    , planType : PlanType
    , state : String
    , stateCarrierSettings : List StateCarrierSetting
    , stateLicenses : List String
    }


{-| Represents a scheduled email with its type, scheduled time, and status.

  - `emailType`: The type of email (e.g., Birthday, Anniversary).
  - `scheduledTime`: The date when the email is scheduled to be sent.
  - `status`: The status of the email (Scheduled or Skipped with a reason).

-}
type alias ScheduledEmail =
    { emailType : ScheduledEmailType
    , scheduledTime : Date
    , status : ScheduledEmailStatus
    }


{-| Represents the status of a scheduled email.

  - `Scheduled`: The email is scheduled to be sent.
  - `Skipped reason`: The email was skipped, with a reason provided.
  - `Delayed reason`: The email was delayed due to birthday rules, with a reason provided.

-}
type ScheduledEmailStatus
    = Scheduled
    | Skipped String
    | Delayed String


{-| Represents the type of scheduled email, associated with a plan type.

  - `Birthday`: Email for the contact's birthday.
  - `Anniversary`: Email for the plan's anniversary.
  - `NewYear`: Email for New Year greetings.
  - `OctoberBlast`: Email for an October promotional blast.
  - `NoEmails`: No scheduled emails.

-}
type ScheduledEmailType
    = Birthday
    | Anniversary
    | NewYear
    | OctoberBlast
    | NoEmails


{-| Represents the plan type for a contact.

  - `PlanN`: Plan N (specific benefits).
  - `PlanG`: Plan G (specific benefits).
  - `NoPlan`: No plan assigned.

-}
type PlanType
    = PlanN
    | PlanG
    | NoPlan


{-| Represents a state carrier setting.

  - `state`: The state.
  - `carrier`: The carrier.
  - `active`: Whether the setting is active.
  - `targetGI`: Whether the setting targets GI.

-}
type alias StateCarrierSetting =
    { state : String
    , carrier : String
    , active : Bool
    , targetGI : Bool
    }



-- INITIALIZATION


{-| Initializes an email schedule for a contact.

  - `contactId`: Unique identifier for the contact.
  - `effective`: The effective date of the plan.
  - `birth`: The contact's birth date.
  - `current`: The current date for scheduling reference.
  - `plan`: The plan type.
  - `state`: The state of the contact.
  - `settings`: List of state carrier settings.
  - `licenses`: List of state licenses.
    Returns an `EmailSchedule` record with the provided values.

-}
init : Int -> Date -> Date -> Date -> PlanType -> String -> List StateCarrierSetting -> List String -> EmailSchedule
init contactId effective birth current plan state settings licenses =
    { contactId = contactId
    , effectiveDate = effective
    , birthDate = birth
    , currentDate = current
    , planType = plan
    , state = state
    , stateCarrierSettings = settings
    , stateLicenses = licenses
    }



-- CALCULATIONS


{-| Checks if a contact's state is active.

  - `schedule`: The email schedule to check.
    Returns `True` if the contact's state is active, otherwise `False`.

-}
isStateActive : EmailSchedule -> Bool
isStateActive schedule =
    List.member schedule.state schedule.stateLicenses


{-| Calculates the list of scheduled emails for a given email schedule.

  - `schedule`: The email schedule to process.
    Returns a list of `ScheduledEmail` records, each with a type, scheduled time, and status.
    Emails are scheduled for:
  - The contact's next birthday.
  - The plan's next anniversary.
  - The next New Year (January 1st).
  - The next October blast (October 1st).
    Emails within the first year of the effective date are skipped.
    Emails for contacts in states with continuous open enrollment are skipped.
    Emails for contacts in their birthday rule window are delayed.

-}
getScheduledEmails : EmailSchedule -> List ScheduledEmail
getScheduledEmails schedule =
    if isInContinuousOpenEnrollment schedule.state then
        [ { emailType = NoEmails
          , scheduledTime = schedule.currentDate
          , status = Skipped "Contact's state has continuous open enrollment"
          }
        ]

    else
        let
            -- Calculate the date one year after the effective date for status checks.
            oneYearAfterEffective : Date
            oneYearAfterEffective =
                Date.add Date.Years 1 schedule.effectiveDate

            -- Check if we're within the first year
            isWithinFirstYear : Bool
            isWithinFirstYear =
                Date.compare schedule.currentDate oneYearAfterEffective == LT

            -- Calculate the next occurrence of an event based on the email type and base date.
            nextOccurrence : ScheduledEmailType -> Date -> Date
            nextOccurrence emailType baseDate =
                let
                    currentYear : Int
                    currentYear =
                        Date.year schedule.currentDate

                    -- Calculate next year's date for birthday and anniversary
                    nextBirthdayOrAnniversaryYear : Date -> Int
                    nextBirthdayOrAnniversaryYear date =
                        let
                            thisYearDate =
                                Date.fromCalendarDate currentYear (Date.month date) (Date.day date)
                        in
                        if Date.compare thisYearDate schedule.currentDate == LT then
                            currentYear + 1

                        else
                            currentYear

                    -- For September blast (previously October), use current year if September hasn't passed yet
                    septemberThisYear : Date
                    septemberThisYear =
                        Date.fromCalendarDate currentYear Sep 1

                    shouldUseNextYearForSeptember : Bool
                    shouldUseNextYearForSeptember =
                        Date.compare septemberThisYear schedule.currentDate == LT

                    result =
                        case emailType of
                            Birthday ->
                                -- Calculate birthday date then subtract 14 days
                                let
                                    nextBirthday =
                                        Date.fromCalendarDate
                                            (nextBirthdayOrAnniversaryYear baseDate)
                                            (Date.month baseDate)
                                            (Date.day baseDate)
                                in
                                Date.add Date.Days -14 nextBirthday

                            Anniversary ->
                                -- Calculate anniversary date then subtract 30 days
                                let
                                    nextAnniversary =
                                        Date.fromCalendarDate
                                            (nextBirthdayOrAnniversaryYear baseDate)
                                            (Date.month baseDate)
                                            (Date.day baseDate)
                                in
                                Date.add Date.Days -30 nextAnniversary

                            OctoberBlast ->
                                -- Now using September 1st instead of October 1st
                                Date.fromCalendarDate
                                    (if shouldUseNextYearForSeptember then
                                        currentYear + 1

                                     else
                                        currentYear
                                    )
                                    Sep
                                    1

                            NewYear ->
                                -- Not used but keeping for type safety
                                schedule.currentDate

                            NoEmails ->
                                schedule.currentDate
                in
                result

            -- Check if an email should be delayed due to birthday rules
            checkBirthdayRuleDelay : ScheduledEmailType -> Date -> ( Date, ScheduledEmailStatus )
            checkBirthdayRuleDelay emailType scheduledDate =
                let
                    -- Check if the scheduled date falls within a birthday rule window
                    isScheduledDateInWindow : Date -> Date -> Bool
                    isScheduledDateInWindow referenceDate dateToCheck =
                        -- Get the rule for the state
                        case getStateRule schedule.state of
                            Just rule ->
                                let
                                    -- Calculate the start and end dates of the window for the scheduled year
                                    scheduledYear =
                                        Date.year dateToCheck

                                    adjustedReferenceDate =
                                        Date.fromCalendarDate scheduledYear (Date.month referenceDate) (Date.day referenceDate)

                                    -- For Nevada, the window starts on the first day of the birth month
                                    windowStartDate =
                                        if rule.state == "NV" then
                                            Date.fromCalendarDate scheduledYear (Date.month referenceDate) 1

                                        else
                                            -- For other states, subtract the days before birthday from the birthday
                                            Date.add Date.Days -rule.daysBeforeBirthday adjustedReferenceDate

                                    windowEndDate =
                                        Date.add Date.Days rule.totalDays windowStartDate
                                in
                                -- Check if the scheduled date falls within the window
                                Date.compare dateToCheck windowStartDate /= LT && Date.compare dateToCheck windowEndDate /= GT

                            Nothing ->
                                False
                in
                case emailType of
                    Birthday ->
                        -- For birthday emails, check if the state is Missouri (which doesn't have a birthday rule)
                        if schedule.state == "MO" then
                            -- Missouri only has anniversary rule, not birthday rule
                            ( scheduledDate, Scheduled )
                            -- For other states, check if the scheduled date falls within the birthday rule window

                        else if isScheduledDateInWindow schedule.birthDate scheduledDate then
                            -- If it does, delay until after the window
                            let
                                delayedDate =
                                    getDelayedEmailDate schedule.state schedule.birthDate scheduledDate
                            in
                            ( delayedDate, Delayed "due to birthday rule window" )

                        else
                            ( scheduledDate, Scheduled )

                    Anniversary ->
                        -- For Missouri anniversary rule
                        if schedule.state == "MO" then
                            -- Check if the scheduled date falls within the anniversary rule window
                            if isScheduledDateInWindow schedule.effectiveDate scheduledDate then
                                -- If the contact already has Plan G and we're sending a Plan G email, delay it
                                if schedule.planType == PlanG then
                                    let
                                        delayedDate =
                                            getDelayedEmailDate schedule.state schedule.effectiveDate scheduledDate
                                    in
                                    ( delayedDate, Delayed "due to anniversary rule window" )

                                else
                                    -- If it's a different plan type, we can send it during the window
                                    ( scheduledDate, Scheduled )

                            else
                                -- Outside the window, schedule normally
                                ( scheduledDate, Scheduled )

                        else
                            -- For other states, no delay for anniversary emails
                            ( scheduledDate, Scheduled )

                    _ ->
                        -- No delay for other email types
                        ( scheduledDate, Scheduled )

            -- Create a scheduled email with the appropriate status.
            createScheduledEmail : ScheduledEmailType -> Date -> ScheduledEmail
            createScheduledEmail emailType baseDate =
                let
                    scheduledTime : Date
                    scheduledTime =
                        nextOccurrence emailType baseDate

                    ( finalScheduledTime, birthdayRuleStatus ) =
                        checkBirthdayRuleDelay emailType scheduledTime

                    status : ScheduledEmailStatus
                    status =
                        if Date.compare scheduledTime schedule.currentDate == LT then
                            -- Skip if the date is in the past
                            Skipped "Date is in the past"

                        else if
                            Date.compare scheduledTime oneYearAfterEffective
                                == LT
                                && Date.compare scheduledTime schedule.effectiveDate
                                == GT
                        then
                            Skipped "Within first year of effective date"

                        else
                            birthdayRuleStatus
                in
                { emailType = emailType
                , scheduledTime =
                    if status == Delayed "due to birthday rule window" || status == Delayed "due to anniversary rule window" then
                        finalScheduledTime

                    else
                        scheduledTime
                , status = status
                }

            -- Helper function to create plan-specific emails for each event type.
            planSpecificEmail : ScheduledEmailType -> ScheduledEmail
            planSpecificEmail emailType =
                let
                    baseDate =
                        case emailType of
                            Birthday ->
                                schedule.birthDate

                            Anniversary ->
                                schedule.effectiveDate

                            NewYear ->
                                -- For New Year, we don't need a base date since we always use Jan 1
                                Date.fromCalendarDate (Date.year schedule.currentDate) Jan 1

                            OctoberBlast ->
                                -- For October blast, we don't need a base date since we always use Oct 1
                                Date.fromCalendarDate (Date.year schedule.currentDate) Oct 1

                            NoEmails ->
                                schedule.currentDate
                in
                createScheduledEmail emailType baseDate

            emails =
                if isWithinFirstYear then
                    [ { emailType = NoEmails
                      , scheduledTime = schedule.currentDate
                      , status = Skipped "Within first year of effective date"
                      }
                    ]

                else
                    [ planSpecificEmail Birthday
                    , planSpecificEmail Anniversary
                    , planSpecificEmail OctoberBlast

                    -- New Year email removed from the list
                    ]
        in
        -- Include both scheduled and delayed emails, but filter out individual skipped ones
        -- except for our special NoEmails case
        List.filter
            (\email ->
                case email.status of
                    Scheduled ->
                        True

                    Delayed _ ->
                        True

                    Skipped reason ->
                        -- Allow through if it's our NoEmails message
                        email.emailType == NoEmails
            )
            emails
            |> List.sortWith
                (\a b ->
                    Date.compare a.scheduledTime b.scheduledTime
                )



-- VIEW FUNCTIONS


{-| Displays a table of future scheduled emails.

  - `scheduledEmails`: The list of scheduled emails to display.
    Returns an HTML view with a table showing the email type, scheduled date, and status.

-}
viewFutureActivity : List ScheduledEmail -> Html msg
viewFutureActivity scheduledEmails =
    div []
        [ h2 [ class "text-lg font-medium text-gray-900 mb-4" ] [ text "Future Activity" ]
        , table [ class "min-w-full divide-y divide-gray-300" ]
            [ thead [ class "bg-gray-50" ]
                [ tr []
                    [ th [ class "px-3 py-3.5 text-left text-sm font-semibold text-gray-900" ] [ text "TYPE" ]
                    , th [ class "px-3 py-3.5 text-left text-sm font-semibold text-gray-900" ] [ text "SCHEDULED DATE" ]
                    , th [ class "px-3 py-3.5 text-left text-sm font-semibold text-gray-900" ] [ text "STATUS" ]
                    ]
                ]
            , tbody [ class "divide-y divide-gray-200 bg-white" ]
                (List.map
                    (\email ->
                        tr [ class "hover:bg-gray-50" ]
                            [ td [ class "px-3 py-2 text-sm text-gray-900" ]
                                [ text (scheduledEmailTypeToString email.emailType) ]
                            , td [ class "px-3 py-2 text-sm text-gray-900" ]
                                [ text (Date.format "MMMM ddd, yyyy" email.scheduledTime) ]
                            , td [ class "px-3 py-2 text-sm" ]
                                [ case email.status of
                                    Scheduled ->
                                        span [ class "text-green-600" ] [ text "Scheduled" ]

                                    Skipped reason ->
                                        span [ class "text-orange-600" ] [ text ("Skipped: " ++ reason) ]

                                    Delayed reason ->
                                        span [ class "text-blue-600" ] [ text ("Scheduled - Delayed " ++ reason) ]
                                ]
                            ]
                    )
                    scheduledEmails
                )
            ]
        ]


{-| Displays a single scheduled email as a table row.

  - `email`: The scheduled email to display.
    Returns an HTML table row with the email type, scheduled date, and status.

-}
viewScheduledEmail : ScheduledEmail -> Html msg
viewScheduledEmail email =
    tr [ class "hover:bg-gray-50" ]
        [ td [ class "px-3 py-2 text-sm text-gray-900" ]
            [ text (scheduledEmailTypeToString email.emailType) ]
        , td [ class "px-3 py-2 text-sm text-gray-900" ]
            [ text (Date.format "MMMM ddd, y" email.scheduledTime) ]
        , td [ class "px-3 py-2 text-sm" ]
            [ case email.status of
                Scheduled ->
                    span [ class "text-green-600" ] [ text "Scheduled" ]

                Skipped reason ->
                    span [ class "text-orange-600" ] [ text ("Skipped: " ++ reason) ]

                Delayed reason ->
                    span [ class "text-blue-600" ] [ text ("Delayed " ++ reason) ]
            ]
        ]


{-| Converts a scheduled email type to a human-readable string.

  - `emailType`: The scheduled email type to convert.
    Returns a string representation, including the plan type (e.g., "Birthday (Plan N)").

-}
scheduledEmailTypeToString : ScheduledEmailType -> String
scheduledEmailTypeToString emailType =
    case emailType of
        Birthday ->
            "Birthday (14 days before)"

        Anniversary ->
            "Anniversary (30 days before)"

        NewYear ->
            "New Year"

        OctoberBlast ->
            "AEP Reminder"

        NoEmails ->
            "No Scheduled Emails"

================
File: frontend/src/Home.elm
================
port module Home exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onMouseEnter, onMouseLeave)
import Http
import Json.Decode as Decode
import MyIcon exposing (activity, brightArrow, chatBubbles, commandKey, envelope, heartBubble, lightning, smilieyChat)
import Ports exposing (getOrgSlug, receiveOrgSlug)
import Process
import Set exposing (Set)
import Svg exposing (Svg)
import Task
import Time


port viewingPhone : (Bool -> msg) -> Sub msg



-- MODEL


type alias Model =
    { key : Nav.Key
    , sessionState : SessionState
    , activeExperienceTab : ExperienceTab
    , carouselActive : Bool
    , expandedFaqs : Set String
    , expandedFeature : Maybe String
    }


type SessionState
    = Unknown
    | Checking
    | Valid
    | Invalid


type ExperienceTab
    = Email
    | Quote
    | Underwriting


type Msg
    = CheckSession
    | GotSessionResponse (Result Http.Error SessionResponse)
    | NavigateSignup
    | NavigateTryItOut
    | NavigatePricing
    | SetExperienceTab ExperienceTab
    | StartCarousel
    | StopCarousel
    | RotateCarousel Time.Posix
    | ToggleFaq String
    | ToggleFeature String
    | PhoneSectionVisible Bool
    | NoOp


type alias SessionResponse =
    { valid : Bool }


init : Nav.Key -> ( Model, Cmd Msg )
init key =
    ( { key = key
      , sessionState = Unknown
      , activeExperienceTab = Email
      , carouselActive = True
      , expandedFaqs = Set.empty
      , expandedFeature = Nothing
      }
    , checkSession
    )


checkSession : Cmd Msg
checkSession =
    Http.get
        { url = "/api/auth/session"
        , expect = Http.expectJson GotSessionResponse sessionResponseDecoder
        }


sessionResponseDecoder : Decode.Decoder SessionResponse
sessionResponseDecoder =
    Decode.map SessionResponse
        (Decode.field "valid" Decode.bool)



-- UPDATE


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        CheckSession ->
            ( { model | sessionState = Checking }
            , checkSession
            )

        GotSessionResponse result ->
            case result of
                Ok response ->
                    ( { model
                        | sessionState =
                            if response.valid then
                                Valid

                            else
                                Invalid
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model | sessionState = Invalid }
                    , Cmd.none
                    )

        NavigateSignup ->
            ( model
            , Nav.pushUrl model.key "/waitlist"
            )

        NavigateTryItOut ->
            ( model
            , Nav.pushUrl model.key "/self-onboarding/demo-org"
            )

        NavigatePricing ->
            ( model
            , Nav.pushUrl model.key "/pricing"
            )

        SetExperienceTab tab ->
            ( { model | activeExperienceTab = tab, carouselActive = False }
            , Cmd.batch
                [ Process.sleep 5000
                    |> Task.perform (\_ -> StartCarousel)
                ]
            )

        StartCarousel ->
            ( { model | carouselActive = True }
            , Cmd.none
            )

        StopCarousel ->
            ( { model | carouselActive = False }
            , Cmd.none
            )

        RotateCarousel _ ->
            if model.carouselActive then
                let
                    nextTab =
                        case model.activeExperienceTab of
                            Email ->
                                Quote

                            Quote ->
                                Underwriting

                            Underwriting ->
                                Email
                in
                ( { model | activeExperienceTab = nextTab }
                , Cmd.none
                )

            else
                ( model, Cmd.none )

        ToggleFaq id ->
            ( { model
                | expandedFaqs =
                    if Set.member id model.expandedFaqs then
                        Set.remove id model.expandedFaqs

                    else
                        Set.insert id model.expandedFaqs
              }
            , Cmd.none
            )

        ToggleFeature id ->
            ( { model
                | expandedFeature =
                    if model.expandedFeature == Just id then
                        Nothing

                    else
                        Just id
              }
            , Cmd.none
            )

        PhoneSectionVisible isVisible ->
            if isVisible then
                ( { model | activeExperienceTab = Email, carouselActive = True }
                , Cmd.none
                )

            else
                ( model, Cmd.none )

        NoOp ->
            ( model, Cmd.none )



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Medicare Max - Boost Your Medicare Supp Renewals with AI"
    , body =
        [ div [ class "min-h-screen bg-white md:snap-y md:snap-mandatory overflow-y-auto h-screen scroll-smooth" ]
            [ div [ class "max-w-7xl mx-auto px-6 sm:px-6 lg:px-8 pt-8 sm:pt-16 pb-16 sm:pb-32 min-h-screen flex items-center md:snap-start" ]
                [ div [ class "grid grid-cols-1 lg:grid-cols-2 gap-8 lg:gap-16 items-center" ]
                    [ div [ class "relative" ]
                        [ div [ class "flex justify-center sm:justify-start w-full" ]
                            [ div [ class "inline-flex items-center rounded-full bg-[#F9F5FF] mt-16 sm:mt-0 px-0 sm:px-0 py-1 mb-6 sm:mb-8" ]
                                [ div [ class "bg-[#03045E] rounded-full px-3 sm:px-3.5 py-1" ]
                                    [ span [ class "text-xs sm:text-sm text-white" ] [ text "Old book of business?" ]
                                    ]
                                , div [ class "flex items-center px-2 sm:px-3" ]
                                    [ span [ class "text-xs sm:text-sm font-medium text-[#03045E]" ] [ text "Renew with ease" ]
                                    , span [ class "ml-1 text-[#03045E]" ] [ text "→" ]
                                    ]
                                ]
                            ]
                        , h1
                            [ class "text-3xl sm:text-4xl lg:text-5xl xl:text-6xl tracking-tight font-semibold text-[#141B29] leading-[1.2] text-center sm:text-left" ]
                            [ text "Boost Your Medigap Renewals with AI" ]
                        , p
                            [ class "mt-4 sm:mt-6 text-base sm:text-lg text-[#475467] leading-[1.5] text-center sm:text-left" ]
                            [ text "Our AI-powered system handles client outreach, quotes, health underwriting, and e-apps — magically resetting your residuals so you can focus on growing your book." ]
                        , div [ class "mt-8 sm:mt-12 flex justify-start gap-6" ]
                            [ button
                                [ onClick NavigateSignup
                                , class "w-[220px] inline-flex items-center justify-center px-6 py-3.5 rounded-lg text-base font-semibold text-white bg-[#03045E] hover:bg-[#1a1f5f] transition-colors duration-200"
                                ]
                                [ text "Sign Up" ]
                            , button
                                [ onClick NavigateTryItOut
                                , class "w-[220px] inline-flex items-center justify-center px-6 py-3.5 rounded-lg text-base font-semibold text-[#03045E] bg-white border-2 border-[#03045E] hover:bg-gray-50 transition-colors duration-200"
                                ]
                                [ text "Login" ]
                            ]
                        ]
                    , div [ class "relative" ]
                        [ div [ class "mx-auto w-full max-w-sm sm:max-w-none relative rounded-lg overflow-hidden" ]
                            [ img
                                [ src "/images/hero.png"
                                , class "w-full"
                                , alt "Dashboard with agent statistics"
                                ]
                                []
                            ]
                        ]
                    ]
                ]
            , div [ class "bg-white py-8 sm:py-16 min-h-screen flex items-center md:snap-start" ]
                [ div [ class "max-w-7xl mx-auto px-6 sm:px-6 lg:px-8" ]
                    [ div [ class "mb-8 sm:mb-12 text-left" ]
                        [ span [ class "text-[#03045E] font-semibold text-sm sm:text-base" ] [ text "It's quite simple" ]
                        , h2 [ class "mt-2 sm:mt-3 text-2xl sm:text-3xl md:text-4xl font-semibold text-gray-900" ] [ text "Here's how it works" ]
                        , p [ class "mt-2 sm:mt-4 text-base sm:text-lg text-gray-600" ] [ text "3 easy steps to setup your book and automate your retention." ]
                        ]
                    , div [ class "grid grid-cols-1 md:grid-cols-3 gap-4 sm:gap-8 mt-8 sm:mt-16" ]
                        [ div [ class "bg-[#F9FAFB] p-4 sm:p-6 rounded-lg flex flex-row sm:flex-col items-center sm:items-center" ]
                            [ div [ class "bg-[#03045E] w-10 sm:w-12 h-10 sm:h-12 flex items-center justify-center rounded-lg mr-4 sm:mr-0 sm:mb-6 flex-shrink-0" ]
                                [ lightning 24 "#FFFFFF"
                                ]
                            , div [ class "flex-1 sm:text-center" ]
                                [ h3 [ class "text-lg sm:text-xl font-semibold text-gray-900 text-left sm:text-center" ] [ text "Upload" ]
                                , p [ class "mt-2 text-sm sm:text-base text-gray-600 text-left sm:text-center" ] [ text "Upload your book of business effortlessly. Our system tracks policy age, renewal windows, and client details automatically." ]
                                ]
                            ]
                        , div [ class "bg-[#F9FAFB] p-4 sm:p-6 rounded-lg flex flex-row sm:flex-col items-center sm:items-center" ]
                            [ div [ class "bg-[#03045E] w-10 sm:w-12 h-10 sm:h-12 flex items-center justify-center rounded-lg mr-4 sm:mr-0 sm:mb-6 flex-shrink-0" ]
                                [ envelope 24 "#FFFFFF"
                                ]
                            , div [ class "flex-1 sm:text-center" ]
                                [ h3 [ class "text-lg sm:text-xl font-semibold text-gray-900 text-left sm:text-center" ] [ text "Engage" ]
                                , p [ class "mt-2 text-sm sm:text-base text-gray-600 text-left sm:text-center" ] [ text "Clients receive personalized quotes showing your preferred carriers, underwriting pre-checks, and renewal options at key moments—without manual outreach." ]
                                ]
                            ]
                        , div [ class "bg-[#F9FAFB] p-4 sm:p-6 rounded-lg flex flex-row sm:flex-col items-center sm:items-center" ]
                            [ div [ class "bg-[#03045E] w-10 sm:w-12 h-10 sm:h-12 flex items-center justify-center rounded-lg mr-4 sm:mr-0 sm:mb-6 flex-shrink-0" ]
                                [ brightArrow 24 "#FFFFFF"
                                ]
                            , div [ class "flex-1 sm:text-center" ]
                                [ h3 [ class "text-lg sm:text-xl font-semibold text-gray-900 text-left sm:text-center" ] [ text "Retain & Reset" ]
                                , p [ class "mt-2 text-sm sm:text-base text-gray-600 text-left sm:text-center" ] [ text "Clients complete 95% of the underwriting and application on their own. You simply verify details in a quick 5-minute call and submit the application." ]
                                ]
                            ]
                        ]
                    ]
                ]
            , div [ class "py-8 max-w-7xl mx-auto px-6 sm:px-6 lg:px-8 min-h-screen flex flex-col justify-center md:snap-start" ]
                [ div [ class "lg:block hidden text-left md:mb-10 max-w-3xl" ]
                    [ h2 [ class "text-2xl sm:text-3xl md:text-4xl font-semibold text-gray-900" ]
                        [ text "Your Client's Personalized Experience" ]
                    , p [ class "mt-3 text-base sm:text-lg text-gray-600" ]
                        [ text "Hover over each section to see what your client will experience along their journey to resetting the clock." ]
                    ]
                , div [ class "relative" ]
                    [ div [ class "absolute right-0 top-0 lg:-mt-40 lg:-mr-4 z-0 hidden lg:block" ]
                        [ div
                            [ class "relative h-[650px] w-[340px] lg:w-[380px] lg:h-[770px] rounded-[40px] transform lg:rotate-[3deg] overflow-hidden"
                            ]
                            [ div [ class (phoneContentClass model.activeExperienceTab Email) ]
                                [ img
                                    [ src "/images/email.jpeg"
                                    , class "absolute inset-0 w-full h-full object-cover rounded-[40px]"
                                    , alt "Personalized email preview"
                                    ]
                                    []
                                ]
                            , div [ class (phoneContentClass model.activeExperienceTab Quote) ]
                                [ img
                                    [ src "/images/quote.jpeg"
                                    , class "absolute inset-0 w-full h-full object-cover rounded-[40px]"
                                    , alt "Medicare quote comparison"
                                    ]
                                    []
                                ]
                            , div [ class (phoneContentClass model.activeExperienceTab Underwriting) ]
                                [ img
                                    [ src "/images/underwriting.jpeg"
                                    , class "absolute inset-0 w-full h-full object-cover rounded-[40px]"
                                    , alt "Underwriting and scheduling interface"
                                    ]
                                    []
                                ]
                            , div
                                [ class "absolute inset-0 pointer-events-none z-10"
                                , style "box-shadow" "inset 0 0 25px 20px #F9FAFB"
                                , style "border-radius" "40px"
                                ]
                                []
                            , div
                                [ class "absolute bottom-0 left-0 right-0 h-[30%] pointer-events-none"
                                , style "background" "linear-gradient(to top, #F9FAFB 0%, rgba(249, 250, 251, 0) 100%)"
                                ]
                                []
                            , div
                                [ class "absolute top-0 left-0 right-0 h-[20%] pointer-events-none"
                                , style "background" "linear-gradient(to bottom, #F9FAFB 0%, rgba(249, 250, 251, 0) 100%)"
                                ]
                                []
                            , div
                                [ class "absolute -left-[50px] -right-[50px] -bottom-[50px] h-[100px] pointer-events-none"
                                , style "background" "#F9FAFB"
                                , style "filter" "blur(40px)"
                                ]
                                []
                            ]
                        ]
                    , div [ class "lg:hidden flex flex-col items-center" ]
                        [ h2 [ class "text-2xl sm:text-3xl font-semibold text-gray-900 text-center mt-2 mb-4" ]
                            [ text "Your Client's Personalized Experience" ]
                        , div
                            [ class "relative h-[400px] w-[280px] rounded-[30px] overflow-hidden mb-4"
                            , id "phone-experience-section"
                            ]
                            [ div [ class (phoneContentClass model.activeExperienceTab Email) ]
                                [ img
                                    [ src "/images/email_crop.jpeg"
                                    , class "absolute inset-0 w-full h-full object-cover object-center rounded-[30px]"
                                    , alt "Personalized email preview"
                                    ]
                                    []
                                ]
                            , div [ class (phoneContentClass model.activeExperienceTab Quote) ]
                                [ img
                                    [ src "/images/quote_crop.jpeg"
                                    , class "absolute inset-0 w-full h-full object-cover object-center rounded-[30px]"
                                    , alt "Medicare quote comparison"
                                    ]
                                    []
                                ]
                            , div [ class (phoneContentClass model.activeExperienceTab Underwriting) ]
                                [ img
                                    [ src "/images/underwriting_crop.jpeg"
                                    , class "absolute inset-0 w-full h-full object-cover object-center rounded-[30px]"
                                    , alt "Underwriting and scheduling interface"
                                    ]
                                    []
                                ]
                            , div
                                [ class "absolute inset-0 pointer-events-none z-10"
                                , style "box-shadow" "inset 0 0 15px 10px #F9FAFB"
                                , style "border-radius" "30px"
                                ]
                                []
                            ]
                        ]
                    , div [ class "lg:hidden w-full" ]
                        [ div [ class "grid grid-cols-3 gap-1 mb-1" ]
                            [ div
                                [ class (tabContainerClass model.activeExperienceTab Email)
                                , onClick (SetExperienceTab Email)
                                ]
                                [ text "Email" ]
                            , div
                                [ class (tabContainerClass model.activeExperienceTab Quote)
                                , onClick (SetExperienceTab Quote)
                                ]
                                [ text "Quotes" ]
                            , div
                                [ class (tabContainerClass model.activeExperienceTab Underwriting)
                                , onClick (SetExperienceTab Underwriting)
                                ]
                                [ text "Underwriting" ]
                            ]
                        , div [ class "bg-white p-4 rounded-b-lg shadow-sm border-t-0" ]
                            [ div
                                [ class
                                    (if model.activeExperienceTab == Email then
                                        "block"

                                     else
                                        "hidden"
                                    )
                                ]
                                [ h3 [ class "text-lg font-semibold text-gray-900" ]
                                    [ text "Your Client Receives a Personalized Email" ]
                                , p [ class "mt-2 text-gray-600" ]
                                    [ text "Your client gets a tailored email with their name, plan info, and helpful next steps—making them feel seen, supported, and confident in their Medicare decision." ]
                                ]
                            , div
                                [ class
                                    (if model.activeExperienceTab == Quote then
                                        "block"

                                     else
                                        "hidden"
                                    )
                                ]
                                [ h3 [ class "text-lg font-semibold text-gray-900" ]
                                    [ text "They Review the Quotes" ]
                                , p [ class "mt-2 text-gray-600" ]
                                    [ text "Your client can easily review their personalized Medicare quotes—clear, side-by-side comparisons that make choosing the right plan simple and stress-free." ]
                                ]
                            , div
                                [ class
                                    (if model.activeExperienceTab == Underwriting then
                                        "block"

                                     else
                                        "hidden"
                                    )
                                ]
                                [ h3 [ class "text-lg font-semibold text-gray-900" ]
                                    [ text "And Then Complete Underwriting & Schedules" ]
                                , p [ class "mt-2 text-gray-600" ]
                                    [ text "Your client answers a few quick health questions and picks a time that works best for them—keeping the process smooth, secure, and completely on their terms." ]
                                ]
                            ]
                        ]
                    , div [ class "relative w-full lg:w-3/5 space-y-8 z-10 hidden lg:block" ]
                        [ div
                            [ class (experienceTabClass model.activeExperienceTab Email)
                            , onMouseEnter (SetExperienceTab Email)
                            , onMouseLeave StartCarousel
                            , onClick (SetExperienceTab Email)
                            ]
                            [ h3 [ class "text-xl font-semibold text-gray-900" ]
                                [ text "Your Client Receives a Personalized Email" ]
                            , p [ class "mt-2 text-gray-600" ]
                                [ text "Your client gets a tailored email with their name, plan info, and helpful next steps—making them feel seen, supported, and confident in their Medicare decision." ]
                            ]
                        , div
                            [ class (experienceTabClass model.activeExperienceTab Quote)
                            , onMouseEnter (SetExperienceTab Quote)
                            , onMouseLeave StartCarousel
                            , onClick (SetExperienceTab Quote)
                            ]
                            [ h3 [ class "text-xl font-semibold text-gray-900" ]
                                [ text "They Review the Quotes" ]
                            , p [ class "mt-2 text-gray-600" ]
                                [ text "Your client can easily review their personalized Medicare quotes—clear, side-by-side comparisons that make choosing the right plan simple and stress-free." ]
                            ]
                        , div
                            [ class (experienceTabClass model.activeExperienceTab Underwriting)
                            , onMouseEnter (SetExperienceTab Underwriting)
                            , onMouseLeave StartCarousel
                            , onClick (SetExperienceTab Underwriting)
                            ]
                            [ h3 [ class "text-xl font-semibold text-gray-900" ]
                                [ text "And Then Complete Underwriting & Schedules" ]
                            , p [ class "mt-2 text-gray-600" ]
                                [ text "Your client answers a few quick health questions and picks a time that works best for them—keeping the process smooth, secure, and completely on their terms." ]
                            ]
                        ]
                    ]
                ]
            , div [ class "py-12 sm:py-16 bg-white relative overflow-hidden min-h-[50vh] sm:min-h-screen flex items-center md:snap-start" ]
                [ div [ class "max-w-7xl mx-auto px-6 sm:px-6 lg:px-8" ]
                    [ div [ class "text-center mb-8" ]
                        [ h2 [ class "text-3xl sm:text-4xl font-semibold text-gray-900" ] [ text "All you need to reset your commissions" ]
                        , p [ class "mt-4 text-lg text-gray-600" ] [ text "It's like having a new team member that's only focused on retention." ]
                        ]
                    , div [ class "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mt-16" ]
                        [ featureCard model "quote-flow" "Simple Quote to Call Flow" "Streamline your workflow with a automated process that takes clients from initial quote to final application in just a few clicks." (chatBubbles 24 "#03045E")
                        , featureCard model "protection" "Non-Commissionable Protection" "Our AI-powered logic engine only sends emails to clients that are fully commissionable." (lightning 24 "#03045E")
                        , featureCard model "analytics" "Live Analytics" "Track real-time engagement metrics, conversion rates, and upcoming renewal opportunities in your personalized dashboard." (activity 24 "#03045E")
                        , featureCard model "notifications" "Activity Notifications" "Get instant alerts when clients review quotes, complete underwriting, or request follow-ups, so you never miss an opportunity to connect." (smilieyChat 24 "#03045E")
                        , featureCard model "carrier-control" "Carrier and Licensing Control" "Customize which carriers and plans to showcase based on your licenses and preferred partnerships." (commandKey 24 "#03045E")
                        , featureCard model "agency-setup" "Agent or Agency Setup" "Configure individual agent profiles or manage your entire agency with customizable roles and white-labeled client communications." (heartBubble 24 "#03045E")
                        ]
                    ]
                ]
            , div [ class "py-12 sm:py-16 bg-white relative overflow-hidden min-h-[50vh] sm:min-h-screen flex items-center md:snap-start" ]
                [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 relative z-20 w-full" ]
                    [ div [ class "grid grid-cols-1 gap-8 mt-16" ]
                        [ -- Mobile layout (hidden on larger screens)
                          div [ class "flex flex-col items-center md:hidden" ]
                            [ div [ class "w-full text-center px-4 mb-8" ]
                                [ h2 [ class "text-2xl font-semibold text-gray-900" ]
                                    [ text "Residuals don't need to vanish. We make sure they don't." ]
                                ]
                            , div [ class "w-full mb-6" ]
                                [ div [ class "mx-auto max-w-xs" ]
                                    [ img [ src "/images/flap.png", class "w-full h-auto", alt "Dashboard interface" ] [] ]
                                ]
                            , div [ class "w-full text-center p-4" ]
                                [ div [ class "space-y-3 mt-8" ]
                                    [ div [ class "flex gap-3 items-start" ]
                                        [ div [ class "text-[#03045E] text-lg flex-shrink-0" ] [ text "✓" ]
                                        , p [ class "text-base text-gray-600 text-left" ] [ text "White-Labeled Tools" ]
                                        ]
                                    , div [ class "flex gap-3 items-start" ]
                                        [ div [ class "text-[#03045E] text-lg flex-shrink-0" ] [ text "✓" ]
                                        , p [ class "text-base text-gray-600 text-left" ] [ text "5 Minute Setup" ]
                                        ]
                                    , div [ class "flex gap-3 items-start" ]
                                        [ div [ class "text-[#03045E] text-lg flex-shrink-0" ] [ text "✓" ]
                                        , p [ class "text-base text-gray-600 text-left" ] [ text "Automated Retention" ]
                                        ]
                                    ]
                                , div [ class "mt-6 flex justify-center" ]
                                    [ button
                                        [ onClick NavigateSignup
                                        , class "inline-flex items-center px-5 py-2 rounded-lg text-base font-medium text-white bg-[#03045E] hover:bg-[#1a1f5f] transition-colors duration-200"
                                        ]
                                        [ text "Sign Up" ]
                                    ]
                                ]
                            ]

                        -- Desktop layout (hidden on small screens)
                        , div [ class "hidden md:flex flex-col items-center justify-center relative w-full min-h-[700px]" ]
                            [ div [ class "max-w-4xl mx-auto text-center" ]
                                [ h2 [ class "text-6xl font-semibold text-gray-900 mb-12" ]
                                    [ text "Residuals don't need to vanish. We make sure they don't." ]
                                , div [ class "flex justify-center items-center gap-24" ]
                                    [ div [ class "space-y-6 text-left" ]
                                        [ div [ class "flex gap-4 items-start" ]
                                            [ div [ class "text-[#03045E] text-2xl" ] [ text "✓" ]
                                            , p [ class "text-xl text-gray-600" ] [ text "White-Labeled Tools" ]
                                            ]
                                        , div [ class "flex gap-4 items-start" ]
                                            [ div [ class "text-[#03045E] text-2xl" ] [ text "✓" ]
                                            , p [ class "text-xl text-gray-600" ] [ text "5 Minute Setup" ]
                                            ]
                                        , div [ class "flex gap-4 items-start" ]
                                            [ div [ class "text-[#03045E] text-2xl" ] [ text "✓" ]
                                            , p [ class "text-xl text-gray-600" ] [ text "Automated Retention" ]
                                            ]
                                        , div [ class "mt-10" ]
                                            [ button
                                                [ onClick NavigateSignup
                                                , class "inline-flex items-center px-8 py-4 rounded-lg text-lg font-medium text-white bg-[#03045E] hover:bg-[#1a1f5f] transition-colors duration-200"
                                                ]
                                                [ text "Sign Up" ]
                                            ]
                                        ]
                                    , div [ class "relative w-[500px]" ]
                                        [ img [ src "/images/flap.png", class "w-full h-auto", alt "Dashboard interface" ] [] ]
                                    ]
                                ]
                            ]
                        ]
                    ]
                ]
            , div [ class "py-8 sm:py-16 min-h-[50vh] sm:min-h-screen flex items-center md:snap-start" ]
                [ div [ class "max-w-7xl mx-auto px-6 sm:px-6 lg:px-8" ]
                    [ div [ class "text-center mb-8 sm:mb-12" ]
                        [ h2 [ class "text-3xl sm:text-4xl font-semibold text-gray-900" ] [ text "Frequently asked questions" ]
                        , p [ class "mt-4 text-lg text-gray-600" ] [ text "Everything you need to know." ]
                        ]
                    , div [ class "max-w-3xl mx-auto divide-y divide-gray-200" ]
                        [ faqItem "How many emails can I send?"
                            "Our system sends regular, automated emails to every client in your book of business. Our pricing is based on the number of contacts you have in your book of business - you only pay for what you use. The emails continue indefinitely to keep your book engaged and ready for renewal opportunities."
                            model
                        , faqItem "How do I know my Client data is protected?"
                            "We take data security extremely seriously. All client data is encrypted both in transit and at rest using industry-standard encryption protocols. Additionally, each agency gets their own dedicated database instance and virtual machine instance for email processing, ensuring complete data separation between different agencies' client records."
                            model
                        , faqItem "Will I be notified when someone requests a quote?"
                            "Yes, our dashboard provieds real-time feedback on client activity and engagement, giving detailed insights and providing actionable reporting for tracking and independent marketing."
                            model
                        , faqItem "Will the emails come from me?"
                            "Yes, all communications are white-labeled and will appear to come directly from you. You can customize your logo, the email sender name and signature to maintain your personal brand and relationship with your clients."
                            model
                        ]
                    , div [ class "mt-16 text-center hidden md:block" ]
                        [ h3 [ class "text-2xl font-semibold text-gray-900" ] [ text "Ready to reset your book?" ]
                        , p [ class "mt-4 text-lg text-gray-600" ] [ text "Join agents all across the US ready to automate their retention." ]
                        , div [ class "mt-8" ]
                            [ button
                                [ onClick NavigateSignup
                                , class "inline-flex items-center px-6 py-3 rounded-lg text-base font-medium text-white bg-[#03045E] hover:bg-[#1a1f5f] transition-colors duration-200"
                                ]
                                [ text "Sign Up" ]
                            ]
                        ]
                    ]
                ]
            , div [ class "py-8 sm:py-14 min-h-[40vh] sm:min-h-screen flex items-center md:snap-start md:hidden" ]
                [ div [ class "max-w-7xl mx-auto px-6 sm:px-6 lg:px-8" ]
                    [ div [ class "text-center" ]
                        [ h3 [ class "text-2xl font-semibold text-gray-900" ] [ text "Want to be notified on launch day?" ]
                        , p [ class "mt-4 text-lg text-gray-600" ] [ text "Join agents all across the US ready to reset their books." ]
                        , div [ class "mt-8" ]
                            [ button
                                [ onClick NavigateSignup
                                , class "inline-flex items-center px-6 py-3 rounded-lg text-base font-medium text-white bg-[#03045E] hover:bg-[#1a1f5f] transition-colors duration-200 w-full sm:w-auto justify-center"
                                ]
                                [ text "Sign Up" ]
                            ]
                        ]
                    ]
                ]
            , footer [ class "bg-[#141B29] text-white py-6 sm:py-8 md:py-16 md:snap-start" ]
                [ div [ class "max-w-7xl mx-auto px-6 sm:px-6 lg:px-8" ]
                    [ div [ class "flex flex-col md:flex-row justify-between pb-4 sm:pb-6" ]
                        [ div [ class "mb-4 md:mb-0" ]
                            [ div [ class "flex items-center" ]
                                [ img [ src "/images/whiteIcon.svg", class "h-6 sm:h-8 w-auto", alt "Medicare Max logo" ] []
                                ]
                            , p [ class "mt-2 text-sm sm:text-base text-[#94969C]" ] [ text "Retention technology that has your back." ]
                            ]
                        ]
                    , div [ class "flex gap-3 sm:gap-4 mb-4" ]
                        [ span [ class "text-sm sm:text-base text-[#94969C]" ]
                            [ text "email: "
                            , a [ href "mailto:information@medicaremax.ai", class "text-[#94969C] hover:text-white" ] [ text "information@medicaremax.ai" ]
                            ]
                        ]
                    , div [ class "border-t border-[#1F242F] pt-4 sm:pt-5 text-[#94969C] text-sm sm:text-base" ]
                        [ p [] [ text "© 2025 Medicare Max. All rights reserved." ] ]
                    ]
                ]
            ]
        ]
    }


imageVisibilityClass : ExperienceTab -> ExperienceTab -> String
imageVisibilityClass activeTab tab =
    if activeTab == tab then
        "absolute inset-0 w-full h-full object-cover transition-opacity duration-500 opacity-100"

    else
        "absolute inset-0 w-full h-full object-cover transition-opacity duration-500 opacity-0"


experienceTabClass : ExperienceTab -> ExperienceTab -> String
experienceTabClass activeTab tab =
    let
        baseClass =
            "border-l-4 pl-4 sm:pl-6 py-4 sm:py-5 cursor-pointer transition-all duration-300 ease-in-out"
    in
    if activeTab == tab then
        baseClass ++ " border-[#03045E]"

    else
        baseClass ++ " border-gray-200 hover:border-gray-400"


phoneContentClass : ExperienceTab -> ExperienceTab -> String
phoneContentClass activeTab tab =
    if activeTab == tab then
        "absolute inset-0 w-full h-full transition-opacity duration-500 opacity-100"

    else
        "absolute inset-0 w-full h-full transition-opacity duration-500 opacity-0"


featureCard : Model -> String -> String -> String -> Svg Msg -> Html Msg
featureCard model id title description icon =
    let
        -- Base classes shared across all sizes
        baseCardClass =
            "rounded-lg transition-all duration-300 ease-in-out flex flex-col h-full"

        -- Mobile-specific classes (non-expandable, more compact)
        mobileCardClass =
            "md:hidden " ++ baseCardClass ++ " bg-[#F9FAFB] p-4 mx-4"

        -- Desktop-specific classes
        desktopCardClass =
            "hidden md:flex " ++ baseCardClass ++ " bg-[#F9FAFB] p-4 sm:p-5"

        -- Mobile title classes
        mobileTitleClass =
            "md:hidden text-base font-semibold text-gray-900 text-center"

        -- Desktop title classes
        desktopTitleClass =
            "hidden md:block text-base sm:text-lg font-semibold text-gray-900 text-center"

        -- Mobile icon container
        mobileIconContainerClass =
            "md:hidden w-10 h-10 mx-auto mb-3 rounded-lg flex items-center justify-center shadow-sm"

        -- Desktop icon container
        desktopIconContainerClass =
            "hidden md:flex w-10 h-10 sm:w-11 sm:h-11 mx-auto mb-3 sm:mb-4 rounded-lg items-center justify-center shadow-md"
    in
    div []
        [ -- Mobile version (non-expandable)
          div
            [ class mobileCardClass ]
            [ div [ class mobileIconContainerClass ] [ icon ]
            , h3 [ class mobileTitleClass ] [ text title ]
            , p [ class "md:hidden mt-2 text-xs text-gray-600 text-center" ] [ text description ]
            ]

        -- Desktop version
        , div [ class desktopCardClass ]
            [ div [ class desktopIconContainerClass ] [ icon ]
            , h3 [ class desktopTitleClass ] [ text title ]
            , p [ class "hidden md:block mt-2 text-xs sm:text-sm text-gray-600 text-center" ] [ text description ]
            ]
        ]


faqItem : String -> String -> Model -> Html Msg
faqItem question answer model =
    let
        isExpanded =
            Set.member question model.expandedFaqs
    in
    div [ class "py-4 sm:py-6" ]
        [ div
            [ class "flex justify-between items-start cursor-pointer group"
            , onClick (ToggleFaq question)
            ]
            [ h3 [ class "text-base sm:text-lg font-medium text-gray-900 group-hover:text-gray-700 transition-colors duration-200" ] [ text question ]
            , button
                [ class "ml-4 sm:ml-6 h-6 sm:h-7 w-6 sm:w-7 flex items-center justify-center rounded-full group-hover:bg-gray-100 transition-colors duration-200"
                ]
                [ span
                    [ class "text-gray-500 text-lg sm:text-xl transition-transform duration-200"
                    , style "transform"
                        (if isExpanded then
                            "rotate(180deg)"

                         else
                            "rotate(0deg)"
                        )
                    ]
                    [ text
                        (if isExpanded then
                            "-"

                         else
                            "+"
                        )
                    ]
                ]
            ]
        , div
            [ class "mt-2 text-sm sm:text-base text-gray-600 overflow-hidden transition-all duration-300 ease-in-out"
            , style "max-height"
                (if isExpanded then
                    "500px"

                 else
                    "0"
                )
            , style "opacity"
                (if isExpanded then
                    "1"

                 else
                    "0"
                )
            ]
            [ text answer ]
        ]



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        carouselMsg =
            if model.carouselActive then
                Time.every 4000 RotateCarousel

            else
                Sub.none
    in
    Sub.batch
        [ carouselMsg
        , viewingPhone PhoneSectionVisible
        ]


mobileTabButtonClass : ExperienceTab -> ExperienceTab -> String
mobileTabButtonClass activeTab tab =
    let
        baseClass =
            "px-4 py-2 text-sm font-medium rounded-lg transition-colors duration-200"
    in
    if activeTab == tab then
        baseClass ++ " bg-[#03045E] text-white"

    else
        baseClass ++ " bg-gray-100 text-gray-700 hover:bg-gray-200"


tabContainerClass : ExperienceTab -> ExperienceTab -> String
tabContainerClass activeTab tab =
    let
        baseClass =
            "py-2 text-center text-sm font-medium cursor-pointer transition-colors duration-200 border-t-2"
    in
    if activeTab == tab then
        baseClass ++ " bg-white text-gray-900 border-t-2 border-[#03045E]"

    else
        baseClass ++ " bg-gray-100 text-gray-600 border-t-2 border-transparent"

================
File: frontend/src/Landing.elm
================
module Landing exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Html exposing (Html, a, br, div, h1, img, p, span, text)
import Html.Attributes exposing (class, href, src)
import Html.Events exposing (onClick)
import Url.Builder as Builder


type alias Model =
    { quoteId : Maybe String
    }


type Msg
    = NavigateTo String


init : { quoteId : Maybe String } -> ( Model, Cmd Msg )
init flags =
    ( { quoteId = flags.quoteId }
    , Cmd.none
    )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NavigateTo path ->
            ( model, Cmd.none )



-- Navigation will be handled by parent


view : Model -> Browser.Document Msg
view model =
    { title = "Thanks for checking it out - Medicare Max"
    , body =
        [ div [ class "min-h-screen bg-white" ]
            [ div [ class "max-w-md mx-auto px-4 sm:px-6 lg:px-8 pt-12" ]
                [ div [ class "mb-16" ]
                    [ img
                        [ src "/images/medicare-max-logo.png"
                        , class "h-12"
                        ]
                        []
                    ]
                , div [ class "text-center" ]
                    [ div [ class "mb-8" ]
                        [ img
                            [ src "/images/party-popper.png"
                            , class "h-16 mx-auto"
                            ]
                            []
                        ]
                    , h1 [ class "text-[40px] leading-[48px] font-bold text-[#111111] mb-4" ]
                        [ text "Thanks for"
                        , br [] []
                        , text "checking it out."
                        ]
                    , p [ class "text-lg text-gray-600 mb-8" ]
                        [ text "Head to "
                        , span [ class "text-[#0A0F51] font-bold" ] [ text "your email" ]
                        , text " to see what"
                        , br [] []
                        , text "your clients will experience"
                        ]
                    , a
                        [ href "/"
                        , class "inline-flex items-center px-6 py-3 text-base font-medium rounded-md text-white bg-[#0A0F51] hover:bg-[#0A0F51]/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#0A0F51] mb-8"
                        , onClick (NavigateTo "/")
                        ]
                        [ text "Back to the Homepage" ]
                    , div [ class "text-gray-600 text-sm max-w-[200px] mx-auto" ]
                        [ text "Didn't receive an email yet - "
                        , case model.quoteId of
                            Just id ->
                                a
                                    [ href (Builder.absolute [ "compare" ] [ Builder.string "id" id ])
                                    , class "text-[#0A0F51] underline hover:text-[#0A0F51]/90"
                                    , onClick (NavigateTo (Builder.absolute [ "compare" ] [ Builder.string "id" id ]))
                                    ]
                                    [ text "click here" ]

                            Nothing ->
                                text ""
                        , text " for your quote"
                        ]
                    ]
                ]
            ]
        ]
    }


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/Login.elm
================
module Login exposing (Model, Msg, init, subscriptions, update, view)

import Basics
import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput, onSubmit)
import Http
import Json.Decode as Decode
import Json.Encode as Encode
import Time
import Url
import Url.Parser as Parser exposing ((</>), (<?>), Parser, s, string)
import Url.Parser.Query as Query


type alias Model =
    { email : String
    , status : Status
    , isLoggedIn : Bool
    , key : Nav.Key
    , resendAvailableAt : Maybe Time.Posix
    , isFromOnboarding : Bool
    , prefilledEmail : Maybe String
    }


type Status
    = Idle
    | Submitting
    | Success
    | Failed String
    | LinkSent


type alias LoginResponse =
    { success : Bool
    }


type alias SessionCheckResponse =
    { valid : Bool }


type Msg
    = EmailChanged String
    | SubmitForm
    | GotLoginResponse (Result Http.Error LoginResponse)
    | GotSessionCheck (Result Http.Error SessionCheckResponse)
    | LogOut
    | NoOp
    | CheckResendAvailable Time.Posix
    | ResendLink


init : Nav.Key -> Bool -> Url.Url -> ( Model, Cmd Msg )
init key isLoggedIn url =
    let
        queryParams =
            extractQueryParams url
    in
    ( { email = Maybe.withDefault "" queryParams.email
      , status = Idle
      , isLoggedIn = isLoggedIn
      , key = key
      , resendAvailableAt = Nothing
      , isFromOnboarding = queryParams.onboarding
      , prefilledEmail = queryParams.email
      }
    , Http.get
        { url = "/api/auth/session"
        , expect = Http.expectJson GotSessionCheck sessionCheckDecoder
        }
    )



-- Helper to extract query parameters


extractQueryParams : Url.Url -> { onboarding : Bool, email : Maybe String }
extractQueryParams url =
    let
        parser =
            Query.map2
                (\onboarding email -> { onboarding = onboarding == Just "completed", email = email })
                (Query.string "onboarding")
                (Query.string "email")

        route =
            { url | path = "" }
                |> Parser.parse (Parser.top <?> parser)
    in
    Maybe.withDefault { onboarding = False, email = Nothing } route


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        EmailChanged email ->
            ( { model | email = email, status = Idle }
            , Cmd.none
            )

        SubmitForm ->
            if String.isEmpty model.email then
                ( { model | status = Failed "Please enter your email address" }
                , Cmd.none
                )

            else
                ( { model | status = Submitting }
                , Http.get
                    { url = "/api/auth/session"
                    , expect = Http.expectJson GotSessionCheck sessionCheckDecoder
                    }
                )

        GotSessionCheck result ->
            case result of
                Ok response ->
                    if response.valid then
                        -- If session is valid, redirect to dashboard
                        ( model
                        , Nav.pushUrl model.key "/dashboard"
                        )

                    else
                        -- If no valid session, proceed with login
                        let
                            -- Set resend cooldown to 60 seconds from now
                            now =
                                Time.millisToPosix 0

                            -- Placeholder, would normally use actual current time
                            cooldownTime =
                                Time.millisToPosix (Time.posixToMillis now + 60000)
                        in
                        ( { model | resendAvailableAt = Just cooldownTime }
                        , Http.post
                            { url = "/api/auth/login"
                            , body = Http.jsonBody (encodeLoginBody model.email)
                            , expect = Http.expectJson GotLoginResponse loginResponseDecoder
                            }
                        )

                Err _ ->
                    -- On error checking session, proceed with normal login flow
                    let
                        -- Set resend cooldown to 60 seconds from now
                        now =
                            Time.millisToPosix 0

                        -- Placeholder, would normally use actual current time
                        cooldownTime =
                            Time.millisToPosix (Time.posixToMillis now + 60000)
                    in
                    ( { model | resendAvailableAt = Just cooldownTime }
                    , Http.post
                        { url = "/api/auth/login"
                        , body = Http.jsonBody (encodeLoginBody model.email)
                        , expect = Http.expectJson GotLoginResponse loginResponseDecoder
                        }
                    )

        NoOp ->
            ( model, Cmd.none )

        LogOut ->
            ( { model
                | isLoggedIn = False
                , status = Idle
              }
            , Http.post
                { url = "/api/auth/logout"
                , body = Http.emptyBody
                , expect = Http.expectWhatever (\_ -> NoOp)
                }
            )

        GotLoginResponse result ->
            case result of
                Ok response ->
                    if response.success then
                        ( { model | status = LinkSent }
                        , Cmd.none
                        )

                    else
                        ( { model | status = Failed "Failed to send login link. Please try again." }
                        , Cmd.none
                        )

                Err _ ->
                    ( { model | status = Failed "Failed to send login link. Please try again." }
                    , Cmd.none
                    )

        CheckResendAvailable currentTime ->
            case model.resendAvailableAt of
                Just availableAt ->
                    if Time.posixToMillis currentTime >= Time.posixToMillis availableAt then
                        ( { model | resendAvailableAt = Nothing }, Cmd.none )

                    else
                        ( model, Cmd.none )

                Nothing ->
                    ( model, Cmd.none )

        ResendLink ->
            update SubmitForm model


viewLoginForm : Model -> { title : String, body : List (Html Msg) }
viewLoginForm model =
    { title = "Login"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8" ]
            [ div [ class "sm:mx-auto sm:w-full sm:max-w-md" ]
                [ h2 [ class "mt-6 text-center text-3xl font-extrabold text-gray-900" ]
                    [ if model.isFromOnboarding then
                        text "Activate Your Account"

                      else
                        text "Welcome Back To MedicareMax"
                    ]
                ]
            , div [ class "mt-8 sm:mx-auto sm:w-full sm:max-w-md" ]
                [ div [ class "bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10" ]
                    [ if model.isFromOnboarding then
                        div [ class "mb-6 bg-blue-50 p-4 rounded-md border border-blue-200" ]
                            [ p [ class "text-blue-800" ]
                                [ text "Your account has been created successfully! Please check your email for an activation link to continue to your new account." ]
                            ]

                      else
                        text ""
                    , Html.form [ onSubmit SubmitForm ]
                        [ div []
                            [ label [ for "email", class "block text-sm font-medium text-gray-700" ]
                                [ text "Email address" ]
                            , div [ class "mt-1" ]
                                [ input
                                    [ type_ "email"
                                    , name "email"
                                    , id "email"
                                    , class "appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                                    , placeholder "you@example.com"
                                    , value model.email
                                    , onInput EmailChanged
                                    ]
                                    []
                                ]
                            ]
                        , div [ class "mt-6" ]
                            [ button
                                [ type_ "submit"
                                , class "w-full flex justify-center py-2 px-4 sm:py-2.5 sm:px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                ]
                                [ text "Send login link" ]
                            ]
                        ]
                    , viewStatus model.status model
                    , div [ class "mt-4 text-center text-sm" ]
                        [ text "Not Yet a MedicareMax User? "
                        , a [ href "/signup", class "font-medium text-indigo-600 hover:text-indigo-500" ]
                            [ text "Sign Up Here" ]
                        ]
                    ]
                ]
            ]
        ]
    }


viewStatus : Status -> Model -> Html Msg
viewStatus status model =
    case status of
        LinkSent ->
            div [ class "mt-4 p-4 bg-green-50 rounded-md" ]
                [ p [ class "text-sm text-green-700 text-center" ]
                    [ p [ class "mb-2" ] [ text "If your email is registered, you'll receive a login link soon." ]
                    , p [] [ text "Check your inbox and spam folder." ]
                    ]
                , div [ class "mt-2 text-center" ]
                    [ viewResendLink model ]
                ]

        Failed error ->
            div [ class "mt-4 p-4 bg-red-50 rounded-md" ]
                [ p [ class "text-sm text-red-700" ]
                    [ text error ]
                ]

        Submitting ->
            div [ class "mt-4 text-center text-gray-600" ]
                [ text "Sending login link..." ]

        _ ->
            text ""


viewResendLink : Model -> Html Msg
viewResendLink model =
    case model.resendAvailableAt of
        Just availableAt ->
            let
                currentTime =
                    Time.millisToPosix 0

                -- Placeholder, would normally use actual current time
                diff =
                    Basics.max 0 ((Time.posixToMillis availableAt - Time.posixToMillis currentTime) // 1000)
            in
            if diff <= 0 then
                button
                    [ onClick ResendLink
                    , class "text-sm text-blue-600 hover:text-blue-800 underline"
                    ]
                    [ text "Resend link" ]

            else
                span [ class "text-sm text-gray-600" ]
                    [ text ("Resend link in " ++ String.fromInt diff ++ " seconds") ]

        Nothing ->
            button
                [ onClick ResendLink
                , class "text-sm text-blue-600 hover:text-blue-800 underline"
                ]
                [ text "Resend link" ]


encodeLoginBody : String -> Encode.Value
encodeLoginBody email =
    Encode.object
        [ ( "email", Encode.string email )
        ]


loginResponseDecoder : Decode.Decoder LoginResponse
loginResponseDecoder =
    Decode.map LoginResponse
        (Decode.field "success" Decode.bool)


sessionCheckDecoder : Decode.Decoder SessionCheckResponse
sessionCheckDecoder =
    Decode.map SessionCheckResponse
        (Decode.field "valid" Decode.bool)


subscriptions : Model -> Sub Msg
subscriptions model =
    case model.resendAvailableAt of
        Just _ ->
            Time.every 1000 CheckResendAvailable

        Nothing ->
            Sub.none


view : Model -> { title : String, body : List (Html Msg) }
view model =
    if model.isLoggedIn then
        { title = "Already Logged In"
        , body =
            [ div [ class "min-h-screen bg-gray-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8" ]
                [ div [ class "sm:mx-auto sm:w-full sm:max-w-md" ]
                    [ h2 [ class "mt-6 text-center text-3xl font-extrabold text-gray-900" ]
                        [ text "Already Logged In" ]
                    , div [ class "mt-8 sm:mx-auto sm:w-full sm:max-w-md" ]
                        [ div [ class "bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10" ]
                            [ p [ class "text-center text-gray-600 mb-6" ]
                                [ text "You are already logged in." ]
                            , button
                                [ onClick LogOut
                                , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                                ]
                                [ text "Log Out" ]
                            ]
                        ]
                    ]
                ]
            ]
        }

    else
        viewLoginForm model

================
File: frontend/src/Logout.elm
================
module Logout exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Http


type alias Model =
    { key : Nav.Key }


type Msg
    = LogoutCompleted (Result Http.Error ())
    | NoOp


init : Nav.Key -> ( Model, Cmd Msg )
init key =
    ( { key = key }
    , Http.post
        { url = "/api/auth/logout"
        , body = Http.emptyBody
        , expect = Http.expectWhatever LogoutCompleted
        }
    )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        LogoutCompleted (Ok _) ->
            ( model
            , Nav.load "/"
            )

        LogoutCompleted (Err _) ->
            -- Even if the logout request fails, we'll redirect to home
            ( model
            , Nav.load "/"
            )

        NoOp ->
            ( model, Cmd.none )


view : Model -> Browser.Document Msg
view _ =
    { title = "Logging out..."
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex items-center justify-center" ]
            [ div [ class "animate-spin rounded-full h-8 w-8 border-2 border-purple-500 border-t-transparent" ] []
            ]
        ]
    }


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/Main.elm
================
port module Main exposing (main)

import AddAgent
import Browser exposing (Document)
import Browser.Events
import Browser.Navigation as Nav
import ChangePlan
import ChoosePlan
import Compare exposing (CompareParams)
import Components.AccountStatusBanner as AccountStatusBanner
import Components.DemoModeBanner as DemoModeBanner
import Contact
import ContactUs
import Contacts
import Dashboard
import Date exposing (Date)
import Dict exposing (Dict)
import Eligibility
import Home
import Html exposing (Html, a, button, div, h1, img, nav, p, span, text)
import Html.Attributes exposing (alt, class, href, src, target)
import Html.Events exposing (onClick, stopPropagationOn)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as E
import Landing
import Login
import Logout
import MyIcon
import Onboarding
import Pricing
import Process
import Profile
import Quote
import Schedule
import ScheduleMain
import SelfServiceOnboarding
import Settings
import Signup
import StageDemoCTA
import StageDemoHealth
import StageDemoInput
import StageDemoQuote
import Stripe
import Svg exposing (path, svg)
import Svg.Attributes exposing (d, fill, viewBox)
import Task
import TempLanding
import Url exposing (Url)
import Url.Parser as Parser exposing ((</>), (<?>), Parser, map, oneOf, s, string, top)
import Url.Parser.Query as Query
import Waitlist
import Walkthrough



-- PORTS
-- Send a message to JavaScript to clear the session cookie


port redirectToStripe :
    String
    -> Cmd msg -- ADDED: Port for Stripe redirection


type alias VerificationResponse =
    { success : Bool
    , redirectUrl : String
    , session : String
    , email : String
    , orgSlug : String
    }


type alias SessionResponse =
    { valid : Bool
    , session : String
    , email : String
    , organizationSlug : String
    , firstName : String
    , lastName : String
    , isAdmin : Bool
    , id : String
    , demoMode : Bool
    , orgCreateDate : Date
    }


verificationDecoder : Decoder VerificationResponse
verificationDecoder =
    Decode.map5 VerificationResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "redirectUrl" Decode.string)
        (Decode.field "session" Decode.string)
        (Decode.field "email" Decode.string)
        (Decode.field "orgSlug" Decode.string)


sessionDecoder : Decoder SessionResponse
sessionDecoder =
    Decode.succeed SessionResponse
        |> Pipeline.required "valid" Decode.bool
        |> Pipeline.required "session" Decode.string
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "organizationSlug" Decode.string
        |> Pipeline.custom
            (Decode.oneOf
                [ Decode.field "firstName" Decode.string
                , Decode.field "first_name" Decode.string
                ]
            )
        |> Pipeline.custom
            (Decode.oneOf
                [ Decode.field "lastName" Decode.string
                , Decode.field "last_name" Decode.string
                ]
            )
        |> Pipeline.custom
            (Decode.oneOf
                [ Decode.field "is_admin" Decode.bool
                , Decode.field "is_admin" Decode.int
                    |> Decode.map (\i -> i == 1)
                ]
            )
        |> Pipeline.required "id" (Decode.map String.fromInt Decode.int)
        |> Pipeline.custom
            (Decode.oneOf
                [ Decode.field "demo_mode" Decode.bool
                , Decode.field "demo_mode" Decode.int
                    |> Decode.map (\i -> i == 1)
                ]
            )
        |> Pipeline.required
            "orgCreateDate"
            (Decode.string
                |> Decode.andThen
                    (\s ->
                        case Date.fromIsoString s of
                            Ok date ->
                                Decode.succeed date

                            Err _ ->
                                Decode.fail "Invalid date format"
                    )
            )


type alias User =
    { id : String
    , email : String
    , isAdmin : Bool
    , isAgent : Bool
    , organizationSlug : String
    , organizationId : String
    , firstName : String
    , lastName : String
    , subscriptionTier : String
    , accountStatus : Maybe AccountStatusBanner.AccountStatusDetails
    , demoMode : Bool
    , orgCreateDate : Maybe Date
    , hasCompletedWalkthrough : Bool
    }



-- Account status types


type alias AccountStatus =
    String


type alias AccountStatusDetails =
    { status : AccountStatus
    , message : String
    , organizationId : Int
    , organizationName : String
    , organizationSlug : String
    , subscriptionTier : String
    , subscriptionStatus : String
    , agentLimit : Int
    , contactLimit : Int
    , currentAgentCount : Int
    , currentContactCount : Int
    , billingCycleEnd : Maybe String
    , paymentFailureCount : Int
    , paymentCompleted : Bool
    }


type alias Model =
    { key : Nav.Key
    , url : Url
    , page : Page
    , session : SessionState
    , currentUser : Maybe User
    , isSetup : Bool
    , intendedDestination : Maybe String
    , showDropdown : Bool
    , showStatusBanner : Bool
    , showPaymentStatus : Bool
    , demoModeBanner : DemoModeBanner.Model
    }


type SessionState
    = Unknown -- Initial state
    | Verified String -- Has valid session
    | NoSession -- Definitely no valid session


type Page
    = NotFoundPage
    | LoginPage Login.Model
    | ContactsPage Contacts.Model
    | ContactUsPage ContactUs.Model
    | TempLandingPage TempLanding.Model
    | SettingsPage Settings.Model
    | Signup Signup.Model
    | ChoosePlanPage ChoosePlan.Model
    | ChangePlanPage ChangePlan.Model
    | AddAgentsPage AddAgent.Model
    | ProfilePage Profile.Model
    | LoadingPage
    | HomePage Home.Model
    | ContactPage Contact.Model
    | ComparePage Compare.Model
    | QuotePage Quote.Model
    | EligibilityPage Eligibility.Model
    | SchedulePage Schedule.Model
    | ScheduleMainPage ScheduleMain.Model
    | DashboardPage Dashboard.Model
    | LogoutPage Logout.Model
    | OnboardingPage Onboarding.Model
    | WalkthroughPage Walkthrough.Model
    | SelfOnboardingPage SelfServiceOnboarding.Model
    | WaitlistPage Waitlist.Model
    | LandingPage Landing.Model
    | PricingPage Pricing.Model
    | StripePage Stripe.Model
    | StageDemoInputPage StageDemoInput.Model
    | StageDemoQuotePage StageDemoQuote.Model
    | StageDemoHealthPage StageDemoHealth.Model
    | StageDemoCTAPage StageDemoCTA.Model


type Msg
    = LinkClicked Browser.UrlRequest
    | InternalLinkClicked String
    | UrlChanged Url
    | LoginMsg Login.Msg
    | ContactsMsg Contacts.Msg
    | ContactUsMsg ContactUs.Msg
    | TempLandingMsg TempLanding.Msg
    | SettingsMsg Settings.Msg
    | SignupMsg Signup.Msg
    | ChoosePlanMsg ChoosePlan.Msg
    | ChangePlanMsg ChangePlan.Msg
    | AddAgentsMsg AddAgent.Msg
    | GotVerification (Result Http.Error VerificationResponse)
    | GotSession (Result Http.Error SessionResponse)
    | ProfileMsg Profile.Msg
    | HomeMsg Home.Msg
    | ContactMsg Contact.Msg
    | CompareMsg Compare.Msg
    | QuoteMsg Quote.Msg
    | EligibilityMsg Eligibility.Msg
    | ScheduleMsg Schedule.Msg
    | ScheduleMainMsg ScheduleMain.Msg
    | DashboardMsg Dashboard.Msg
    | NoOp
    | GotCurrentUser (Result Http.Error CurrentUserResponse)
    | OrgFinalized (Result Http.Error ())
    | LogoutMsg Logout.Msg
    | OnboardingMsg Onboarding.Msg
    | ToggleDropdown
    | CloseDropdown
    | InitiateLogout
    | GotAccountStatus (Result Http.Error AccountStatusResponse)
    | CloseStatusBanner
    | WalkthroughMsg Walkthrough.Msg
    | ShowDropdown
    | HideDropdown
    | ToggleStatusBanner
    | PerformRedirect String
    | DirectPageUpdate
    | SelfOnboardingMsg SelfServiceOnboarding.Msg
    | WaitlistMsg Waitlist.Msg
    | LandingMsg Landing.Msg
    | PricingMsg Pricing.Msg
    | StripeMsg Stripe.Msg
    | TogglePaymentStatus
    | SetSessionResponse (Result Http.Error SetSessionResponseAlias)
    | LogTrackingClickResult (Result Http.Error ())
    | DemoModeBannerMsg DemoModeBanner.Msg
    | StageDemoInputMsg StageDemoInput.Msg
    | StageDemoQuoteMsg StageDemoQuote.Msg
    | StageDemoHealthMsg StageDemoHealth.Msg
    | StageDemoCTAMsg StageDemoCTA.Msg


type alias Flags =
    {}


type alias CompareFlags =
    { state : String
    , zip : String
    , county : String
    , gender : String
    , tobacco : Bool
    , age : Int
    , planType : String
    , currentCarrier : Maybe String
    , dateOfBirth : String
    , quoteId : Maybe String
    }


main : Program Flags Model Msg
main =
    Browser.application
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        , onUrlChange = UrlChanged
        , onUrlRequest = LinkClicked
        }


type alias AccountStatusResponse =
    { success : Bool
    , status : AccountStatusDetails
    }


accountStatusDecoder : Decoder AccountStatusDetails
accountStatusDecoder =
    Decode.succeed AccountStatusDetails
        |> Pipeline.required "status" Decode.string
        |> Pipeline.required "message" Decode.string
        |> Pipeline.required "organizationId" Decode.int
        |> Pipeline.required "organizationName" Decode.string
        |> Pipeline.required "organizationSlug" Decode.string
        |> Pipeline.required "subscriptionTier" Decode.string
        |> Pipeline.required "subscriptionStatus" Decode.string
        |> Pipeline.required "agentLimit" Decode.int
        |> Pipeline.required "contactLimit" Decode.int
        |> Pipeline.required "currentAgentCount" Decode.int
        |> Pipeline.required "currentContactCount" Decode.int
        |> Pipeline.optional "billingCycleEnd" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "paymentFailureCount" Decode.int
        |> Pipeline.required "paymentCompleted" Decode.bool


accountStatusResponseDecoder : Decoder AccountStatusResponse
accountStatusResponseDecoder =
    Decode.succeed AccountStatusResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "status" accountStatusDecoder


init : Flags -> Url.Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url key =
    let
        initialSession =
            Unknown

        -- Parse the initial route to determine if we're on a public page
        initialRoute =
            Parser.parse routeParser url

        -- Determine if this is a public route that can be rendered immediately
        isPublicRoute =
            case initialRoute of
                Just (PublicRoute _) ->
                    True

                _ ->
                    False

        -- Set initial page appropriately
        initialPage =
            if isPublicRoute then
                -- For public routes, we'll immediately handle this in updatePageForcePublic below
                LoadingPage

            else
                -- For protected routes, we need to wait for session verification
                LoadingPage

        -- Initialize demo mode banner
        ( demoModeBannerModel, demoModeBannerCmd ) =
            DemoModeBanner.init False Nothing

        model =
            { key = key
            , url = url
            , page = initialPage
            , session = initialSession
            , currentUser = Nothing
            , isSetup = False
            , intendedDestination = Nothing
            , showDropdown = False
            , showStatusBanner = True
            , showPaymentStatus = False
            , demoModeBanner = demoModeBannerModel
            }

        checkSession =
            Http.get
                { url = "/api/auth/session"
                , expect = Http.expectJson GotSession sessionDecoder
                }

        -- Use a very short timer for the initial direct page update for public routes
        directPageUpdate =
            Task.perform (\_ -> DirectPageUpdate) (Process.sleep 50)

        currentPath =
            url.path

        queryDict : Dict String String
        queryDict =
            getQueryDict model.url.query

        maybeUserEmail : Maybe String
        maybeUserEmail =
            Dict.get "email" queryDict

        -- Check session and also immediately try to render public routes
        cmds0 =
            case initialSession of
                Verified _ ->
                    -- If we have a session, also fetch the current user immediately
                    -- But don't use directPageUpdate for protected routes to prevent duplicate initialization
                    [ fetchCurrentUser ]

                _ ->
                    []

        -- Only add directPageUpdate for public routes to prevent duplicate initialization
        cmdsWithPageUpdate =
            if isPublicRoute then
                cmds0 ++ [ directPageUpdate ]

            else
                cmds0

        cmds1 =
            case ( currentPath, maybeUserEmail ) of
                ( "/walkthrough", Just userEmail ) ->
                    cmdsWithPageUpdate ++ [ setSession userEmail ]

                _ ->
                    cmdsWithPageUpdate

        cmds =
            cmds1
    in
    -- For public routes, immediately try to render without waiting for session
    if isPublicRoute then
        -- Try to render public route immediately
        updatePageForcePublic url ( model, Cmd.batch cmds )

    else
        -- For protected routes, wait for session verification
        ( model, Cmd.batch (cmds ++ [ checkSession ]) )


getQueryDict : Maybe String -> Dict String String
getQueryDict maybeQueryString =
    case maybeQueryString of
        Just queryString ->
            queryString
                |> String.split "&"
                |> List.filterMap
                    (\param ->
                        case String.split "=" param of
                            [ key0, value ] ->
                                Just ( key0, value )

                            _ ->
                                Nothing
                    )
                |> Dict.fromList

        Nothing ->
            Dict.empty


type alias CompareParams =
    { quoteId : Maybe String
    , orgId : Maybe String
    , tid : Maybe String
    }


type alias CompareParamsPartial1 =
    { state : Maybe String
    , zip : Maybe String
    , county : Maybe String
    , gender : Maybe String
    }


type alias CompareParamsPartial2 =
    { tobacco : Bool
    , age : Maybe Int
    , planType : Maybe String
    , currentCarrier : Maybe String
    }


type Route
    = PublicRoute PublicPage
    | ProtectedRoute ProtectedPage
    | AdminRoute AdminPage
    | SetupRoute SetupPage
    | NotFound


type VerifyParams
    = VerifyParams String String


type PublicPage
    = HomeRoute
    | LoginRoute
    | SignupRoute
    | OnboardingRoute
    | VerifyRoute VerifyParams
    | CompareRoute CompareParams
    | QuoteRoute { quoteId : Maybe String, trackingId : Maybe String, planType : Maybe String, orgId : Maybe String }
    | EligibilityRoute ( Maybe String, Maybe String, Maybe String )
    | ScheduleRoute ( Maybe String, Maybe String, Maybe String )
    | ScheduleMainRoute
    | SelfOnboardingRoute String
    | WaitlistRoute
    | LandingRoute { quoteId : Maybe String }
    | PricingRoute
    | StageDemoInputRoute
    | StageDemoQuoteRoute String
    | StageDemoHealthRoute String
    | StageDemoCTARoute String


type ProtectedPage
    = ContactsRoute
    | ContactUsRoute
    | ProfileRoute
    | TempLandingRoute
    | ContactRoute String
    | DashboardRoute
    | ChangePlanRoute
    | StripeRoute
    | WalkthroughRoute


type AdminPage
    = SettingsRoute
    | AgentsRoute


type SetupPage
    = ChoosePlanRoute (Maybe SetupProgress)
    | SetupSettingsRoute (Maybe SetupProgress)
    | AddAgentsRoute (Maybe SetupProgress)


type alias SetupProgress =
    { plan : Maybe String
    , orgSettings : Bool
    }


type RouteAccess
    = Public -- No auth needed (login, home)
    | Protected -- Requires valid session
    | Setup -- Special setup flow routes


setupProgressDecoder : Query.Parser (Maybe SetupProgress)
setupProgressDecoder =
    Query.map2
        (\plan org ->
            case ( plan, org ) of
                ( Just p, Just o ) ->
                    Just
                        { plan = Just p
                        , orgSettings = o == "complete"
                        }

                _ ->
                    Nothing
        )
        (Query.string "plan")
        (Query.string "org")


compareParamsParser : Query.Parser CompareParams
compareParamsParser =
    Query.map3 CompareParams
        (Query.string "id")
        (Query.string "orgId")
        (Query.string "tid")



-- Parse the orgId


routeParser : Parser (Route -> a) a
routeParser =
    oneOf
        [ map (PublicRoute HomeRoute) top
        , map (PublicRoute WaitlistRoute) (s "waitlist")
        , map (PublicRoute LoginRoute) (s "login")
        , map (PublicRoute SignupRoute) (s "signup")
        , map (PublicRoute OnboardingRoute) (s "onboarding")
        , map (PublicRoute PricingRoute) (s "pricing")
        , map (PublicRoute ScheduleMainRoute) (s "schedule-main")
        , map (ProtectedRoute ContactUsRoute) (s "contact-us")
        , map (\orgSlug token -> PublicRoute (VerifyRoute (VerifyParams orgSlug token)))
            (s "auth" </> s "verify" </> string </> string)
        , oneOf
            [ map (\quoteId tid -> PublicRoute (CompareRoute { quoteId = Just quoteId, orgId = Nothing, tid = tid }))
                (s "compare" </> string <?> Query.string "tid")
            , map (PublicRoute << CompareRoute)
                (s "compare" <?> compareParamsParser)
            ]
        , map (PublicRoute << QuoteRoute)
            (s "quote"
                <?> Query.map4
                        (\id tid planType orgId ->
                            { quoteId = id, trackingId = tid, planType = planType, orgId = orgId }
                        )
                        (Query.string "id")
                        (Query.string "tid")
                        (Query.string "planType")
                        (Query.string "orgId")
            )
        , map (PublicRoute << EligibilityRoute)
            (s "eligibility"
                <?> Query.map3
                        (\id tid orgId ->
                            ( id, tid, orgId )
                        )
                        (Query.string "id")
                        (Query.string "tid")
                        (Query.string "orgId")
            )
        , map (PublicRoute << ScheduleRoute)
            (s "schedule"
                <?> Query.map3 (\id status tid -> ( id, status, tid ))
                        (Query.string "id")
                        (Query.string "status")
                        (Query.string "tid")
            )
        , map (\orgSlug -> PublicRoute (SelfOnboardingRoute orgSlug))
            (s "self-onboarding" </> string)
        , map (PublicRoute << LandingRoute)
            (s "landing"
                <?> Query.map (\id -> { quoteId = id })
                        (Query.string "id")
            )
        , map (ProtectedRoute ChangePlanRoute) (s "change-plan")
        , map (ProtectedRoute ContactsRoute) (s "contacts")
        , map (AdminRoute SettingsRoute) (s "settings")
        , map (ProtectedRoute ProfileRoute) (s "profile")
        , map (ProtectedRoute TempLandingRoute) (s "templanding")
        , map (ProtectedRoute WalkthroughRoute) (s "walkthrough")
        , map (ProtectedRoute StripeRoute) (s "stripe")
        , map (AdminRoute AgentsRoute) (s "add-agents")
        , map (ProtectedRoute DashboardRoute) (s "dashboard")
        , map (\id -> ProtectedRoute (ContactRoute id)) (s "contact" </> string)
        , map (\progress -> SetupRoute (ChoosePlanRoute progress))
            (s "choose-plan" <?> setupProgressDecoder)
        , map (\progress -> SetupRoute (SetupSettingsRoute progress))
            (s "setup" </> s "settings" <?> setupProgressDecoder)
        , map (\progress -> SetupRoute (AddAgentsRoute progress))
            (s "setup" </> s "add-agents" <?> setupProgressDecoder)
        , map (PublicRoute StageDemoInputRoute) (s "stage-demo")
        , map (\id -> PublicRoute (StageDemoQuoteRoute id)) (s "stage-demo" </> s "quote" </> string)
        , map (\id -> PublicRoute (StageDemoHealthRoute id)) (s "stage-demo" </> s "health" </> string)
        , map (\id -> PublicRoute (StageDemoCTARoute id)) (s "stage-demo" </> s "schedule-signup" </> string)
        ]


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        LogTrackingClickResult result ->
            case result of
                Ok _ ->
                    ( model, Cmd.none )

                Err _ ->
                    ( model, Cmd.none )

        SetSessionResponse result ->
            case result of
                Ok sessionResponse ->
                    ( model
                    , if sessionResponse.success then
                        Cmd.none

                      else
                        Nav.pushUrl model.key "/login"
                    )

                Err _ ->
                    ( model
                    , Nav.pushUrl model.key "/login"
                    )

        DirectPageUpdate ->
            -- Force updatePage even if we're in Unknown session state
            updatePageForcePublic model.url ( model, Cmd.none )

        LinkClicked urlRequest ->
            case urlRequest of
                Browser.Internal url ->
                    ( model
                    , Nav.pushUrl model.key (Url.toString url)
                    )

                Browser.External href ->
                    ( model
                    , Nav.load href
                    )

        InternalLinkClicked frag ->
            ( { model
                | showDropdown = False
                , showPaymentStatus = False
              }
            , Nav.pushUrl model.key frag
            )

        UrlChanged url ->
            ( { model | url = url }
            , Cmd.none
            )
                |> updatePage url

        LoginMsg subMsg ->
            case model.page of
                LoginPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Login.update subMsg pageModel
                    in
                    ( { model | page = LoginPage newPageModel }
                    , Cmd.map LoginMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ContactsMsg subMsg ->
            case model.page of
                ContactsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Contacts.update subMsg pageModel
                    in
                    ( { model | page = ContactsPage newPageModel }
                    , Cmd.map ContactsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ContactUsMsg subMsg ->
            case model.page of
                ContactUsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            ContactUs.update subMsg pageModel
                    in
                    ( { model | page = ContactUsPage newPageModel }
                    , Cmd.map ContactUsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        TempLandingMsg subMsg ->
            case model.page of
                TempLandingPage pageModel ->
                    case subMsg of
                        TempLanding.NavigateTo path ->
                            ( model
                            , Nav.pushUrl model.key path
                            )

                _ ->
                    ( model, Cmd.none )

        SettingsMsg subMsg ->
            case model.page of
                SettingsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Settings.update subMsg pageModel
                    in
                    ( { model | page = SettingsPage newPageModel }
                    , Cmd.map SettingsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        SignupMsg subMsg ->
            case model.page of
                Signup signupModel ->
                    let
                        ( newSignupModel, newCmd ) =
                            Signup.update subMsg signupModel
                    in
                    ( { model | page = Signup newSignupModel }
                    , Cmd.map SignupMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ChoosePlanMsg subMsg ->
            case model.page of
                ChoosePlanPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            ChoosePlan.update subMsg pageModel
                    in
                    ( { model | page = ChoosePlanPage newPageModel }
                    , Cmd.map ChoosePlanMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ChangePlanMsg subMsg ->
            case model.page of
                ChangePlanPage pageModel ->
                    let
                        ( updatedPageModel, updatedCmd ) =
                            ChangePlan.update subMsg pageModel
                    in
                    ( { model | page = ChangePlanPage updatedPageModel }
                    , Cmd.map ChangePlanMsg updatedCmd
                    )

                _ ->
                    ( model, Cmd.none )

        AddAgentsMsg subMsg ->
            case model.page of
                AddAgentsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            AddAgent.update subMsg pageModel
                    in
                    ( { model | page = AddAgentsPage newPageModel }
                    , Cmd.map AddAgentsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        GotVerification result ->
            case result of
                Ok response ->
                    if response.success then
                        let
                            ( choosePlanModel, choosePlanCmd ) =
                                ChoosePlan.init response.orgSlug response.session model.key False

                            -- Only set isSetup to True if we're being redirected to a setup route
                            isInSetup =
                                String.startsWith "/choose-plan" response.redirectUrl
                                    || String.startsWith "/setup" response.redirectUrl

                            newModel =
                                { model
                                    | session = Verified response.session
                                    , currentUser =
                                        Just
                                            { id = ""
                                            , email = response.email
                                            , isAdmin = False
                                            , isAgent = False
                                            , organizationSlug = response.orgSlug
                                            , organizationId = response.orgSlug
                                            , firstName = ""
                                            , lastName = ""
                                            , subscriptionTier = ""
                                            , accountStatus = Nothing
                                            , demoMode = False
                                            , orgCreateDate = Nothing
                                            , hasCompletedWalkthrough = False
                                            }
                                    , isSetup = isInSetup
                                    , page = LoadingPage -- Force to loading page to prevent UI flicker during redirection
                                }
                        in
                        ( newModel
                        , Cmd.batch
                            [ -- Instead of direct navigation, use a message to redirect
                              case model.intendedDestination of
                                Just destination ->
                                    Task.perform PerformRedirect (Task.succeed destination)

                                Nothing ->
                                    Task.perform PerformRedirect (Task.succeed response.redirectUrl)
                            , fetchCurrentUser
                            ]
                        )

                    else
                        ( model, Nav.pushUrl model.key "/login" )

                Err error ->
                    ( model, Nav.pushUrl model.key "/login" )

        PerformRedirect url ->
            -- Navigate to the specified URL
            ( model, Nav.pushUrl model.key url )

        GotSession result ->
            case result of
                Ok response ->
                    if response.valid then
                        let
                            user =
                                { id = response.id
                                , email = response.email
                                , isAdmin = response.isAdmin
                                , isAgent = True -- We'll get this from /api/me endpoint
                                , organizationSlug = response.organizationSlug
                                , organizationId = response.organizationSlug -- Use the org slug as org ID for now
                                , firstName = response.firstName
                                , lastName = response.lastName
                                , subscriptionTier = ""
                                , accountStatus = Nothing
                                , demoMode = response.demoMode
                                , orgCreateDate = Just response.orgCreateDate
                                , hasCompletedWalkthrough = False
                                }

                            -- Initialize demo mode banner with user's demo mode state
                            ( demoModeBannerModel, demoModeBannerCmd ) =
                                DemoModeBanner.init response.demoMode (Just response.orgCreateDate)

                            -- Only set isSetup to True if we're in the middle of setup
                            isInSetup =
                                case Parser.parse routeParser model.url of
                                    Just (SetupRoute _) ->
                                        True

                                    _ ->
                                        False

                            newModel =
                                { model
                                    | session = Verified response.session
                                    , currentUser = Just user
                                    , isSetup = isInSetup
                                    , demoModeBanner = demoModeBannerModel
                                }
                        in
                        -- Just update the page, which will handle fetching user data if needed
                        updatePage model.url ( newModel, Cmd.map DemoModeBannerMsg demoModeBannerCmd )

                    else
                        let
                            newModel =
                                { model | session = NoSession }
                        in
                        -- For invalid session, update page which will handle redirects
                        updatePage model.url ( newModel, Cmd.none )

                Err error ->
                    let
                        newModel =
                            { model | session = NoSession }
                    in
                    -- For session error, update page which will handle redirects
                    updatePage model.url ( newModel, Cmd.none )

        ProfileMsg subMsg ->
            case model.page of
                ProfilePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Profile.update subMsg pageModel
                    in
                    ( { model | page = ProfilePage newPageModel }
                    , case subMsg of
                        Profile.NavigateTo path ->
                            Nav.pushUrl model.key path

                        _ ->
                            Cmd.map ProfileMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        HomeMsg subMsg ->
            case model.page of
                HomePage pageModel ->
                    let
                        ( newPageModel, homeCmd ) =
                            Home.update subMsg pageModel
                    in
                    ( { model | page = HomePage newPageModel }
                    , Cmd.map HomeMsg homeCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ContactMsg subMsg ->
            case model.page of
                ContactPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Contact.update subMsg pageModel
                    in
                    ( { model | page = ContactPage newPageModel }
                    , Cmd.map ContactMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        CompareMsg subMsg ->
            case model.page of
                ComparePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Compare.update subMsg pageModel
                    in
                    ( { model | page = ComparePage newPageModel }
                    , Cmd.map CompareMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        QuoteMsg subMsg ->
            case model.page of
                QuotePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Quote.update subMsg pageModel
                    in
                    ( { model | page = QuotePage newPageModel }
                    , Cmd.map QuoteMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        EligibilityMsg subMsg ->
            case model.page of
                EligibilityPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Eligibility.update subMsg pageModel
                    in
                    ( { model | page = EligibilityPage newPageModel }
                    , Cmd.map EligibilityMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ScheduleMsg subMsg ->
            case model.page of
                SchedulePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Schedule.update subMsg pageModel
                    in
                    ( { model | page = SchedulePage newPageModel }
                    , Cmd.map ScheduleMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ScheduleMainMsg subMsg ->
            case model.page of
                ScheduleMainPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            ScheduleMain.update subMsg pageModel
                    in
                    ( { model | page = ScheduleMainPage newPageModel }
                    , Cmd.map ScheduleMainMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        DashboardMsg subMsg ->
            case model.page of
                DashboardPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Dashboard.update subMsg pageModel
                    in
                    ( { model | page = DashboardPage newPageModel }
                    , Cmd.map DashboardMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        WaitlistMsg subMsg ->
            case model.page of
                WaitlistPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Waitlist.update subMsg pageModel
                    in
                    ( { model | page = WaitlistPage newPageModel }
                    , Cmd.map WaitlistMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        GotCurrentUser result ->
            case result of
                Ok response ->
                    case response.user of
                        Just user ->
                            let
                                currentUser =
                                    Just
                                        { id = user.id
                                        , email = user.email
                                        , isAdmin = user.isAdmin
                                        , isAgent = user.isAgent
                                        , organizationSlug = user.organizationSlug
                                        , organizationId = user.organizationId
                                        , firstName = user.firstName
                                        , lastName = user.lastName
                                        , subscriptionTier = user.subscriptionTier
                                        , accountStatus = Nothing -- Will fetch this separately
                                        , demoMode = user.demoMode
                                        , orgCreateDate = user.orgCreateDate
                                        , hasCompletedWalkthrough = user.hasCompletedWalkthrough
                                        }

                                -- Initialize demo mode banner with the user's demo mode status
                                ( demoModeBannerModel, demoModeBannerCmd ) =
                                    DemoModeBanner.init user.demoMode user.orgCreateDate

                                newModel =
                                    { model
                                        | currentUser = currentUser
                                        , demoModeBanner = demoModeBannerModel
                                    }

                                -- Fetch account status after user is loaded
                                cmd =
                                    Cmd.batch
                                        [ Cmd.none -- fetchAccountStatus user.organizationSlug
                                        , Cmd.map DemoModeBannerMsg demoModeBannerCmd
                                        ]
                            in
                            -- Check if we were already on the right page with the right data
                            -- Only update the page if something meaningful has changed
                            case model.currentUser of
                                Just existingUser ->
                                    if existingUser.id == user.id && existingUser.organizationSlug == user.organizationSlug then
                                        -- We already have the same user, just update the model without triggering updatePage
                                        --( newModel, cmd )
                                        updatePage model.url ( newModel, cmd )

                                    else
                                        -- User has changed, update the page
                                        updatePage model.url ( newModel, cmd )

                                Nothing ->
                                    -- We didn't have a user before, update the page
                                    updatePage model.url ( newModel, cmd )

                        Nothing ->
                            -- No user data, but we should still update the page to avoid being stuck
                            updatePage model.url ( model, Cmd.none )

                Err error ->
                    -- Error retrieving user data, but we should still update the page to avoid being stuck
                    updatePage model.url ( model, Cmd.none )

        GotAccountStatus result ->
            case result of
                Ok response ->
                    if response.success then
                        -- Update user with account status
                        let
                            updatedUser =
                                model.currentUser
                                    |> Maybe.map
                                        (\user ->
                                            { user | accountStatus = Just response.status }
                                        )

                            updatedModel =
                                { model | currentUser = updatedUser }
                        in
                        -- Now that we have all data (session, user, account status), update the page
                        updatePage model.url ( updatedModel, Cmd.none )

                    else
                        ( model, Cmd.none )

                Err _ ->
                    -- Even if there's an error getting account status, we should still update the page
                    -- rather than staying on the loading screen
                    updatePage model.url ( model, Cmd.none )

        CloseStatusBanner ->
            ( { model | showStatusBanner = False }
            , Cmd.none
            )

        OrgFinalized result ->
            case result of
                Ok _ ->
                    ( model, Cmd.none )

                -- Navigation already happened
                Err _ ->
                    ( { model | page = LoadingPage }
                    , Nav.pushUrl model.key "/settings"
                      -- Redirect to settings on error
                    )

        LogoutMsg subMsg ->
            case model.page of
                LogoutPage logoutModel ->
                    let
                        ( newLogoutModel, logoutCmd ) =
                            Logout.update subMsg logoutModel
                    in
                    ( { model | page = LogoutPage newLogoutModel }
                    , Cmd.map LogoutMsg logoutCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ToggleDropdown ->
            ( { model | showDropdown = not model.showDropdown }
            , Cmd.none
            )

        CloseDropdown ->
            ( { model
                | showDropdown = False
                , showPaymentStatus = False
              }
            , Cmd.none
            )

        InitiateLogout ->
            ( { model
                | session = NoSession
                , currentUser = Nothing
                , showDropdown = False
              }
            , Cmd.batch
                [ Nav.pushUrl model.key "/"
                , Http.post
                    { url = "/api/auth/logout"
                    , body = Http.emptyBody
                    , expect = Http.expectWhatever (\_ -> NoOp)
                    }
                ]
            )

        NoOp ->
            ( model, Cmd.none )

        OnboardingMsg subMsg ->
            case model.page of
                OnboardingPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Onboarding.update subMsg pageModel
                    in
                    ( { model | page = OnboardingPage newPageModel }
                    , Cmd.map OnboardingMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        WalkthroughMsg subMsg ->
            case model.page of
                WalkthroughPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Walkthrough.update subMsg pageModel
                    in
                    ( { model | page = WalkthroughPage newPageModel }
                    , Cmd.map WalkthroughMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        SelfOnboardingMsg subMsg ->
            case model.page of
                SelfOnboardingPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            SelfServiceOnboarding.update subMsg pageModel
                    in
                    ( { model | page = SelfOnboardingPage newPageModel }
                    , Cmd.map SelfOnboardingMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ShowDropdown ->
            ( { model | showDropdown = True }, Cmd.none )

        HideDropdown ->
            ( { model | showDropdown = False }, Cmd.none )

        ToggleStatusBanner ->
            ( { model | showStatusBanner = not model.showStatusBanner }, Cmd.none )

        LandingMsg subMsg ->
            case model.page of
                LandingPage landingModel ->
                    case subMsg of
                        Landing.NavigateTo path ->
                            ( model
                            , Nav.pushUrl model.key path
                            )

                _ ->
                    ( model, Cmd.none )

        PricingMsg subMsg ->
            case model.page of
                PricingPage pricingModel ->
                    let
                        ( newPricingModel, newCmd ) =
                            Pricing.update subMsg pricingModel
                    in
                    ( { model | page = PricingPage newPricingModel }
                    , Cmd.map PricingMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        StripeMsg subMsg ->
            case model.page of
                StripePage stripeModel ->
                    let
                        ( newStripeModel, newCmd ) =
                            Stripe.update subMsg stripeModel
                    in
                    ( { model | page = StripePage newStripeModel }
                    , Cmd.map StripeMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        StageDemoInputMsg subMsg ->
            case model.page of
                StageDemoInputPage inputModel ->
                    let
                        ( newInputModel, newCmd ) =
                            StageDemoInput.update subMsg inputModel
                    in
                    ( { model | page = StageDemoInputPage newInputModel }
                    , Cmd.map StageDemoInputMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        StageDemoQuoteMsg subMsg ->
            case model.page of
                StageDemoQuotePage quoteModel ->
                    let
                        ( newQuoteModel, newCmd ) =
                            StageDemoQuote.update subMsg quoteModel
                    in
                    ( { model | page = StageDemoQuotePage newQuoteModel }
                    , Cmd.map StageDemoQuoteMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        StageDemoHealthMsg subMsg ->
            case model.page of
                StageDemoHealthPage healthModel ->
                    let
                        ( newHealthModel, newCmd ) =
                            StageDemoHealth.update subMsg healthModel
                    in
                    case subMsg of
                        StageDemoHealth.NavigateToCTA ->
                            ( model, Nav.pushUrl model.key ("/stage-demo/schedule-signup/" ++ healthModel.tempId) )

                        StageDemoHealth.AnswerQuestion _ _ ->
                            ( { model | page = StageDemoHealthPage newHealthModel }
                            , Cmd.map StageDemoHealthMsg newCmd
                            )

                _ ->
                    ( model, Cmd.none )

        StageDemoCTAMsg subMsg ->
            case model.page of
                StageDemoCTAPage ctaModel ->
                    let
                        ( newCTAModel, newCmd ) =
                            StageDemoCTA.update subMsg ctaModel
                    in
                    ( { model | page = StageDemoCTAPage newCTAModel }
                    , Cmd.map StageDemoCTAMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        TogglePaymentStatus ->
            ( { model | showPaymentStatus = not model.showPaymentStatus }, Cmd.none )

        DemoModeBannerMsg subMsg ->
            let
                ( updatedBanner, bannerCmd ) =
                    DemoModeBanner.update subMsg model.demoModeBanner

                -- Update the user model if demo mode changed
                updatedUser =
                    if model.demoModeBanner.demoMode /= updatedBanner.demoMode then
                        model.currentUser
                            |> Maybe.map (\user -> { user | demoMode = updatedBanner.demoMode })

                    else
                        model.currentUser
            in
            ( { model
                | demoModeBanner = updatedBanner
                , currentUser = updatedUser
              }
            , Cmd.map DemoModeBannerMsg bannerCmd
            )


view : Model -> Browser.Document Msg
view model =
    let
        viewPage =
            case model.page of
                NotFoundPage ->
                    viewNotFound

                WaitlistPage waitlistModel ->
                    let
                        waitlistView =
                            Waitlist.view waitlistModel
                    in
                    { title = waitlistView.title
                    , body = [ viewWithNav model (Html.map WaitlistMsg (div [] waitlistView.body)) ]
                    }

                LoginPage loginModel ->
                    let
                        loginView =
                            Login.view loginModel
                    in
                    { title = loginView.title
                    , body = List.map (Html.map LoginMsg) loginView.body
                    }

                ContactsPage contactsModel ->
                    { title = "Contacts"
                    , body = [ viewWithNav model (Html.map ContactsMsg (Contacts.view contactsModel)) ]
                    }

                ContactUsPage contactUsModel ->
                    let
                        contactUsView =
                            ContactUs.view contactUsModel
                    in
                    { title = contactUsView.title
                    , body = [ viewWithNav model (Html.map ContactUsMsg (div [] contactUsView.body)) ]
                    }

                TempLandingPage landingModel ->
                    let
                        landingView =
                            TempLanding.view landingModel
                    in
                    { title = landingView.title
                    , body = [ viewWithNav model (Html.map TempLandingMsg (div [] landingView.body)) ]
                    }

                SettingsPage settingsModel ->
                    let
                        settingsView =
                            Settings.view settingsModel
                    in
                    { title = settingsView.title
                    , body = [ viewWithNav model (Html.map SettingsMsg (div [] settingsView.body)) ]
                    }

                Signup signupModel ->
                    let
                        signupView =
                            Signup.view signupModel
                    in
                    { title = signupView.title
                    , body = List.map (Html.map SignupMsg) signupView.body
                    }

                ChoosePlanPage choosePlanModel ->
                    let
                        choosePlanView =
                            ChoosePlan.view choosePlanModel
                    in
                    { title = choosePlanView.title
                    , body = [ viewWithNav model (Html.map ChoosePlanMsg (div [] choosePlanView.body)) ]
                    }

                ChangePlanPage changePlanModel ->
                    let
                        changePlanView =
                            ChangePlan.view changePlanModel
                    in
                    { title = changePlanView.title
                    , body = [ viewWithNav model (Html.map ChangePlanMsg (div [] changePlanView.body)) ]
                    }

                AddAgentsPage addAgentModel ->
                    let
                        addAgentView =
                            AddAgent.view addAgentModel
                    in
                    { title = addAgentView.title
                    , body =
                        if addAgentModel.isSetup then
                            -- In setup flow, don't show the header
                            [ Html.map AddAgentsMsg (div [] addAgentView.body) ]

                        else
                            -- Not in setup flow, show the header
                            [ viewWithNav model (Html.map AddAgentsMsg (div [] addAgentView.body)) ]
                    }

                ProfilePage profileModel ->
                    let
                        profileView =
                            Profile.view profileModel
                    in
                    { title = profileView.title
                    , body = [ viewWithNav model (Html.map ProfileMsg (div [] profileView.body)) ]
                    }

                LoadingPage ->
                    { title = "Loading..."
                    , body = [ viewLoading ]
                    }

                HomePage homeModel ->
                    let
                        homeView =
                            Home.view homeModel
                    in
                    { title = homeView.title
                    , body = [ viewWithNav model (Html.map HomeMsg (div [] homeView.body)) ]
                    }

                ContactPage contactModel ->
                    let
                        contactView =
                            Contact.view contactModel
                    in
                    { title = contactView.title
                    , body = [ viewWithNav model (Html.map ContactMsg (div [] contactView.body)) ]
                    }

                ComparePage compareModel ->
                    let
                        compareView =
                            Compare.view compareModel
                    in
                    { title = compareView.title
                    , body = [ viewWithNav model (Html.map CompareMsg (div [] compareView.body)) ]
                    }

                QuotePage quoteModel ->
                    let
                        quoteView =
                            Quote.view quoteModel
                    in
                    { title = quoteView.title
                    , body = [ viewWithNav model (Html.map QuoteMsg (div [] quoteView.body)) ]
                    }

                EligibilityPage eligibilityModel ->
                    let
                        eligibilityView =
                            Eligibility.view eligibilityModel
                    in
                    { title = eligibilityView.title
                    , body = [ viewWithNav model (Html.map EligibilityMsg (div [] eligibilityView.body)) ]
                    }

                SchedulePage scheduleModel ->
                    let
                        scheduleView =
                            Schedule.view scheduleModel
                    in
                    { title = scheduleView.title
                    , body = [ viewWithNav model (Html.map ScheduleMsg (div [] scheduleView.body)) ]
                    }

                ScheduleMainPage scheduleMainModel ->
                    let
                        scheduleMainView =
                            ScheduleMain.view scheduleMainModel
                    in
                    { title = scheduleMainView.title
                    , body = [ viewWithNav model (Html.map ScheduleMainMsg (div [] scheduleMainView.body)) ]
                    }

                DashboardPage dashboardModel ->
                    let
                        dashboardView =
                            Dashboard.view dashboardModel
                    in
                    { title = dashboardView.title
                    , body = [ viewWithNav model (Html.map DashboardMsg (div [] dashboardView.body)) ]
                    }

                LogoutPage logoutModel ->
                    let
                        logoutView =
                            Logout.view logoutModel
                    in
                    { title = logoutView.title
                    , body = List.map (Html.map LogoutMsg) logoutView.body
                    }

                OnboardingPage pageModel ->
                    let
                        onboardingView =
                            Onboarding.view pageModel
                    in
                    { title = onboardingView.title

                    -- Use the body from the Onboarding.view Document directly
                    , body = List.map (Html.map OnboardingMsg) onboardingView.body
                    }

                WalkthroughPage pageModel ->
                    { title = "Walkthrough"
                    , body = [ viewWithNav model (Html.map WalkthroughMsg (Walkthrough.view pageModel)) ]
                    }

                SelfOnboardingPage pageModel ->
                    let
                        selfOnboardingView =
                            SelfServiceOnboarding.view pageModel
                    in
                    { title = selfOnboardingView.title
                    , body = [ viewWithNav model (Html.map SelfOnboardingMsg (div [] selfOnboardingView.body)) ]
                    }

                LandingPage landingModel ->
                    let
                        landingView =
                            Landing.view landingModel
                    in
                    { title = landingView.title
                    , body = [ viewWithNav model (Html.map LandingMsg (div [] landingView.body)) ]
                    }

                PricingPage pricingModel ->
                    let
                        pricingView =
                            Pricing.view pricingModel
                    in
                    { title = "Pricing"
                    , body = [ viewWithNav model (Html.map PricingMsg pricingView) ]
                    }

                StripePage stripeModel ->
                    let
                        stripeView =
                            Stripe.view stripeModel
                    in
                    { title = stripeView.title
                    , body = [ viewWithNav model (Html.map StripeMsg (div [] stripeView.body)) ]
                    }

                StageDemoInputPage inputModel ->
                    { title = "Medicare Quote Demo"
                    , body = [ viewStageDemoWithBanner model (Html.map StageDemoInputMsg (StageDemoInput.view inputModel)) ]
                    }

                StageDemoQuotePage quoteModel ->
                    let
                        demoQuoteView =
                            StageDemoQuote.view quoteModel
                    in
                    { title = "Your Medicare Quote"
                    , body = [ viewStageDemoWithBanner model (Html.map StageDemoQuoteMsg (div [] demoQuoteView.body)) ]
                    }

                StageDemoHealthPage healthModel ->
                    { title = "Health Questions"
                    , body = [ viewStageDemoWithBanner model (Html.map StageDemoHealthMsg (StageDemoHealth.view healthModel)) ]
                    }

                StageDemoCTAPage ctaModel ->
                    { title = "Schedule Your Sign-Up Call"
                    , body = [ viewStageDemoWithBanner model (Html.map StageDemoCTAMsg (StageDemoCTA.view ctaModel)) ]
                    }
    in
    viewPage


viewWithNav : Model -> Html Msg -> Html Msg
viewWithNav model content =
    div []
        [ if model.isSetup then
            -- Don't show header during setup flow
            content

          else
            -- Show header for regular pages
            div []
                [ viewNavHeader model
                , Html.map DemoModeBannerMsg (DemoModeBanner.view model.demoModeBanner)
                , content
                ]
        ]


viewStageDemoWithBanner : Model -> Html Msg -> Html Msg
viewStageDemoWithBanner model content =
    div []
        [ viewStageDemoBanner
        , content
        ]


viewStageDemoBanner : Html Msg
viewStageDemoBanner =
    div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4" ]
        [ div [ class "p-3 sm:p-4 border rounded-lg bg-[#F6F1FF] border-[#E9D7FE] text-[#53389E] flex items-center justify-between" ]
            [ div [ class "flex items-start" ]
                [ span [ class "inline-flex items-center justify-center h-6 w-6 rounded-full text-[#7F56D9] mt-0.5 mr-3" ]
                    [ MyIcon.calendarDays 18 "#53389E" ]
                , div []
                    [ span [ class "font-semibold text-sm leading-tight" ]
                        [ text "Stage Demo Mode - See Medicare Max in Action" ]
                    , div [ class "mt-1 text-xs leading-tight" ]
                        [ text "Experience how Medicare Max transforms your renewal process. "
                        , a
                            [ onClick (InternalLinkClicked "/stage-demo/schedule-signup/demo")
                            , class "underline font-semibold hover:text-[#7F56D9] cursor-pointer"
                            ]
                            [ text "Schedule your personalized demo call" ]
                        , text " to learn more."
                        ]
                    ]
                ]
            ]
        ]


viewPublicNav : Model -> Html Msg
viewPublicNav model =
    div []
        [ -- Desktop navigation
          nav [ class "max-w-7xl mx-auto px-6 sm:px-6 lg:px-8 py-4 sm:py-6 sticky top-0 z-50 bg-white hidden lg:block" ]
            [ div
                [ class "flex justify-between items-center" ]
                [ div [ class "flex items-center" ]
                    [ a [ href "/" ]
                        [ img
                            [ src "/images/medicare-max-logo.png"
                            , class "h-6 sm:h-8 w-auto"
                            , alt "Medicare Max logo"
                            ]
                            []
                        ]
                    ]
                , div [ class "flex items-center justify-end gap-8" ]
                    [ div [ class "flex items-center gap-2" ]
                        [ button
                            [ onClick (InternalLinkClicked "/schedule-main")
                            , class "px-4 text-gray-600 hover:text-gray-900 text-base font-medium cursor-pointer transition-all duration-200"
                            ]
                            [ text "Book a Demo" ]
                        , button
                            [ onClick (InternalLinkClicked "/pricing")
                            , class "px-4 text-gray-600 hover:text-gray-900 text-base font-medium cursor-pointer transition-all duration-200"
                            ]
                            [ text "Pricing" ]
                        ]
                    , div [ class "flex items-center gap-x-3" ]
                        [ button
                            [ onClick (InternalLinkClicked "/signup")
                            , class "bg-[#03045E] text-white border-2 border-[#03045E] px-4 py-2 rounded-lg text-sm font-medium hover:bg-[#1a1f5f] transition-colors duration-200 w-24 text-center"
                            ]
                            [ text "Sign up" ]
                        , button
                            [ onClick (InternalLinkClicked "/login")
                            , class "bg-white text-[#03045E] border-2 border-[#03045E] px-4 py-2 rounded-lg text-sm font-medium hover:bg-gray-50 transition-colors duration-200 w-24 text-center"
                            ]
                            [ text "Log in" ]
                        ]
                    ]
                ]
            ]

        -- Mobile navigation
        , nav [ class "lg:hidden sticky top-0 z-50 bg-white" ]
            [ div [ class "max-w-7xl mx-auto px-4 py-4" ]
                [ div [ class "flex justify-between items-center" ]
                    [ a [ href "/" ]
                        [ img
                            [ src "/images/medicare-max-logo.png"
                            , class "h-6 w-auto"
                            , alt "Medicare Max logo"
                            ]
                            []
                        ]
                    , button
                        [ onClick ToggleDropdown
                        , class "p-2 rounded-md text-gray-600 hover:text-gray-900 hover:bg-gray-100 focus:outline-none"
                        ]
                        [ -- Hamburger icon
                          svg
                            [ Svg.Attributes.class "h-6 w-6"
                            , Svg.Attributes.fill "none"
                            , Svg.Attributes.viewBox "0 0 24 24"
                            , Svg.Attributes.stroke "currentColor"
                            ]
                            [ path
                                [ Svg.Attributes.strokeLinecap "round"
                                , Svg.Attributes.strokeLinejoin "round"
                                , Svg.Attributes.strokeWidth "2"
                                , Svg.Attributes.d "M4 6h16M4 12h16M4 18h16"
                                ]
                                []
                            ]
                        ]
                    ]
                ]
            , if model.showDropdown then
                div
                    [ class "absolute top-full left-0 w-full bg-white shadow-lg border-t border-gray-200"
                    , stopPropagationOn "mousedown" (Decode.succeed ( NoOp, True ))
                    ]
                    [ div [ class "px-4 py-2 space-y-2" ]
                        [ button
                            [ onClick (InternalLinkClicked "/schedule-main")
                            , class "block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md"
                            ]
                            [ text "Book a Demo" ]
                        , button
                            [ onClick (InternalLinkClicked "/pricing")
                            , class "block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md"
                            ]
                            [ text "Pricing" ]
                        , button
                            [ onClick (InternalLinkClicked "/contact-us")
                            , class "block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md"
                            ]
                            [ text "Contact Us" ]
                        , button
                            [ onClick (InternalLinkClicked "/signup")
                            , class "block w-full text-left px-4 py-2 text-[#03045E] font-medium hover:bg-gray-100 rounded-md"
                            ]
                            [ text "Signup" ]
                        , button
                            [ onClick (InternalLinkClicked "/login")
                            , class "block w-full text-left px-4 py-2 text-[#03045E] font-medium hover:bg-gray-100 rounded-md"
                            ]
                            [ text "Login" ]
                        ]
                    ]

              else
                text ""
            ]
        ]


viewNavHeader : Model -> Html Msg
viewNavHeader model =
    let
        -- Check if current page is one of the quote flow pages that should have simplified header
        isQuoteFlowPage =
            case model.page of
                QuotePage _ ->
                    True

                ComparePage _ ->
                    True

                EligibilityPage _ ->
                    True

                SchedulePage _ ->
                    True

                SelfOnboardingPage _ ->
                    True

                LandingPage _ ->
                    True

                _ ->
                    False

        isPublicPage =
            case model.page of
                HomePage _ ->
                    True

                PricingPage _ ->
                    True

                WaitlistPage _ ->
                    True

                ScheduleMainPage _ ->
                    True

                _ ->
                    False

        isPaymentActive =
            model.currentUser
                |> Maybe.andThen .accountStatus
                |> Maybe.map (\status -> status.paymentCompleted)
                |> Maybe.withDefault False

        paymentStatusMessage =
            model.currentUser
                |> Maybe.andThen .accountStatus
                |> Maybe.map
                    (\status ->
                        if status.subscriptionStatus == "active" then
                            "Payments active"

                        else
                            "Payment needs to be updated. Click to update payment information."
                    )
                |> Maybe.withDefault "Payment status unknown"

        paymentStatusIcon =
            if isPaymentActive then
                MyIcon.zap 20 "#10B981"
                -- Green color for active

            else
                MyIcon.zapOff 20 "#EF4444"

        -- Red color for inactive
        paymentStatusIndicator =
            div [ class "relative" ]
                [ button
                    [ class "flex items-center space-x-2 px-3 py-1.5 text-gray-700 text-sm font-medium hover:bg-[#DCE2E5] rounded-md transition-colors duration-200"
                    , onClick TogglePaymentStatus
                    ]
                    [ div [ class "flex items-center space-x-2" ]
                        [ paymentStatusIcon
                        ]
                    ]
                , if model.showPaymentStatus then
                    div
                        [ class "absolute right-0 mt-2 w-64 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 z-50"
                        , stopPropagationOn "mousedown" (Decode.succeed ( NoOp, True ))
                        ]
                        [ div [ class "px-4 py-2 text-sm text-gray-700" ]
                            [ text paymentStatusMessage
                            , if not isPaymentActive then
                                button
                                    [ class "mt-2 w-full px-4 py-2 bg-red-100 text-red-700 rounded-md hover:bg-red-200 transition-colors duration-200"
                                    , onClick (InternalLinkClicked "/stripe")
                                    ]
                                    [ text "Update Payment" ]

                              else
                                text ""
                            ]
                        ]

                  else
                    text ""
                ]
    in
    if isPublicPage then
        viewPublicNav model

    else if isQuoteFlowPage then
        text ""

    else
        -- Full header with navigation for other pages
        nav [ class "bg-white" ]
            [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
                [ div [ class "flex justify-between h-16" ]
                    [ div [ class "flex items-center" ]
                        [ div [ class "shrink-0 flex items-center" ]
                            [ a
                                [ href "#"
                                , onClick (InternalLinkClicked "/dashboard")
                                , class "cursor-pointer"
                                ]
                                [ img
                                    [ src "/images/medicare-max-logo.png"
                                    , class "h-6 sm:h-6 w-auto mr-2 sm:mr-8"
                                    , alt "Medicare Max logo"
                                    ]
                                    []
                                ]
                            ]
                        , div [ class "hidden sm:flex items-center space-x-4" ]
                            [ button
                                [ class "px-3 py-1.5 text-gray-700 text-sm font-medium hover:bg-[#DCE2E5] rounded-md transition-colors duration-200"
                                , onClick (InternalLinkClicked "/dashboard")
                                ]
                                [ text "Dashboard" ]
                            , button
                                [ class "px-3 py-1.5 text-gray-700 text-sm font-medium hover:bg-[#DCE2E5] rounded-md transition-colors duration-200"
                                , onClick (InternalLinkClicked "/contacts")
                                ]
                                [ text "Contacts" ]
                            ]
                        ]
                    , div [ class "flex items-center space-x-2" ]
                        [ div [ class "relative" ]
                            [ button
                                [ class "flex items-center space-x-1 sm:space-x-2 px-2 sm:px-3 py-1.5 text-gray-700 text-xs sm:text-sm font-medium hover:bg-[#DCE2E5] rounded-md transition-colors duration-200"
                                , onClick ToggleDropdown
                                , stopPropagationOn "mousedown" (Decode.succeed ( NoOp, True ))
                                ]
                                [ case model.currentUser of
                                    Just user ->
                                        text (user.firstName ++ " " ++ user.lastName)

                                    Nothing ->
                                        text "Menu"
                                , div [ class "w-4 h-4 flex-shrink-0" ]
                                    [ svg
                                        [ Svg.Attributes.viewBox "0 0 20 20"
                                        , Svg.Attributes.fill "currentColor"
                                        ]
                                        [ path
                                            [ Svg.Attributes.d "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" ]
                                            []
                                        ]
                                    ]
                                ]
                            , if model.showDropdown then
                                div
                                    [ class "absolute right-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 z-50"
                                    , stopPropagationOn "mousedown" (Decode.succeed ( NoOp, True ))
                                    ]
                                    [ -- Always show on mobile
                                      div [ class "block sm:hidden" ]
                                        [ button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/dashboard")
                                            ]
                                            [ text "Dashboard" ]
                                        , button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/contacts")
                                            ]
                                            [ text "Contacts" ]
                                        ]
                                    , if isAdmin model.currentUser then
                                        button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/profile")
                                            ]
                                            [ text "Your Profile" ]

                                      else
                                        text ""
                                    , if isAdmin model.currentUser then
                                        button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/settings")
                                            ]
                                            [ text "Organization Settings" ]

                                      else
                                        text ""
                                    , if isAdmin model.currentUser then
                                        button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/add-agents")
                                            ]
                                            [ text "Manage Agents" ]

                                      else
                                        text ""
                                    , button
                                        [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                        , onClick (InternalLinkClicked "/stripe")
                                        ]
                                        [ text "Payment Settings" ]
                                    , button
                                        [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                        , onClick (InternalLinkClicked "/contact-us")
                                        ]
                                        [ text "Contact Us" ]
                                    , button
                                        [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                        , onClick InitiateLogout
                                        ]
                                        [ text "Log out" ]
                                    ]

                              else
                                text ""
                            ]
                        ]
                    ]
                ]
            ]


isAdminOrAdminAgent : Maybe User -> Bool
isAdminOrAdminAgent maybeUser =
    case maybeUser of
        Just user ->
            user.isAdmin && user.isAgent

        Nothing ->
            False


isAdmin : Maybe User -> Bool
isAdmin maybeUser =
    case maybeUser of
        Just user ->
            user.isAdmin

        Nothing ->
            False


viewNotFound : Browser.Document msg
viewNotFound =
    { title = "404 - Page Not Found"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex flex-col items-center justify-center" ]
            [ h1 [ class "text-4xl font-bold text-gray-900 mb-4" ]
                [ text "404 - Page Not Found" ]
            , p [ class "text-gray-600" ]
                [ text "The page you're looking for doesn't exist." ]
            ]
        ]
    }


viewLoading : Html msg
viewLoading =
    div [ class "min-h-screen bg-gray-50 flex items-center justify-center" ]
        [ div [ class "animate-spin rounded-full h-8 w-8 border-2 border-purple-500 border-t-transparent" ] []
        ]


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        dropdownSub =
            if model.showDropdown || model.showPaymentStatus then
                Browser.Events.onMouseDown (Decode.succeed CloseDropdown)

            else
                Sub.none

        escDropdownSub =
            if model.showDropdown then
                Browser.Events.onKeyDown (Decode.succeed CloseDropdown)

            else
                Sub.none

        pageSubs =
            case model.page of
                LoadingPage ->
                    Sub.none

                WaitlistPage pageModel ->
                    Sub.map WaitlistMsg (Waitlist.subscriptions pageModel)

                LoginPage pageModel ->
                    Sub.map LoginMsg (Login.subscriptions pageModel)

                ContactsPage pageModel ->
                    Sub.map ContactsMsg (Contacts.subscriptions pageModel)

                ContactUsPage pageModel ->
                    Sub.none

                TempLandingPage pageModel ->
                    Sub.map TempLandingMsg (TempLanding.subscriptions pageModel)

                SettingsPage pageModel ->
                    Sub.map SettingsMsg (Settings.subscriptions pageModel)

                Signup signupModel ->
                    Sub.map SignupMsg (Signup.subscriptions signupModel)

                ChoosePlanPage pageModel ->
                    Sub.map ChoosePlanMsg (ChoosePlan.subscriptions pageModel)

                ChangePlanPage pageModel ->
                    Sub.map ChangePlanMsg (ChangePlan.subscriptions pageModel)

                AddAgentsPage pageModel ->
                    Sub.map AddAgentsMsg (AddAgent.subscriptions pageModel)

                ProfilePage pageModel ->
                    Sub.map ProfileMsg (Profile.subscriptions pageModel)

                HomePage pageModel ->
                    Sub.map HomeMsg (Home.subscriptions pageModel)

                ContactPage pageModel ->
                    Sub.map ContactMsg (Contact.subscriptions pageModel)

                ComparePage pageModel ->
                    Sub.map CompareMsg (Compare.subscriptions pageModel)

                QuotePage pageModel ->
                    Sub.map QuoteMsg (Quote.subscriptions pageModel)

                EligibilityPage pageModel ->
                    Sub.map EligibilityMsg (Eligibility.subscriptions pageModel)

                SchedulePage pageModel ->
                    Sub.map ScheduleMsg (Schedule.subscriptions pageModel)

                ScheduleMainPage pageModel ->
                    Sub.map ScheduleMainMsg (ScheduleMain.subscriptions pageModel)

                DashboardPage pageModel ->
                    Sub.map DashboardMsg (Dashboard.subscriptions pageModel)

                NotFoundPage ->
                    Sub.none

                LogoutPage pageModel ->
                    Sub.map LogoutMsg (Logout.subscriptions pageModel)

                OnboardingPage pageModel ->
                    Sub.map OnboardingMsg (Onboarding.subscriptions pageModel)

                WalkthroughPage pageModel ->
                    Sub.map WalkthroughMsg (Walkthrough.subscriptions pageModel)

                SelfOnboardingPage _ ->
                    Sub.none

                LandingPage landingModel ->
                    Sub.map LandingMsg (Landing.subscriptions landingModel)

                PricingPage pricingModel ->
                    Sub.none

                StripePage stripeModel ->
                    Sub.none

                StageDemoInputPage _ ->
                    Sub.none

                StageDemoQuotePage _ ->
                    Sub.none

                StageDemoHealthPage _ ->
                    Sub.none

                StageDemoCTAPage _ ->
                    Sub.none
    in
    Sub.batch [ dropdownSub, escDropdownSub, pageSubs ]


routeAccessType : Route -> RouteAccess
routeAccessType route =
    case route of
        PublicRoute _ ->
            Public

        ProtectedRoute _ ->
            Protected

        AdminRoute _ ->
            Protected

        -- Still Protected, but we'll check admin status separately
        SetupRoute _ ->
            Setup

        NotFound ->
            Public


userDecoder : Decoder User
userDecoder =
    Decode.succeed User
        |> Pipeline.required "id" (Decode.map String.fromInt Decode.int)
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "is_admin"
            (Decode.oneOf
                [ Decode.bool
                , Decode.int |> Decode.map (\n -> n == 1)
                ]
            )
        |> Pipeline.required "is_agent"
            (Decode.oneOf
                [ Decode.bool
                , Decode.int |> Decode.map (\n -> n == 1)
                ]
            )
        |> Pipeline.required "organization_slug" Decode.string
        |> Pipeline.required "organization_id" (Decode.map String.fromInt Decode.int)
        |> Pipeline.required "firstName" Decode.string
        |> Pipeline.required "lastName" Decode.string
        |> Pipeline.required "subscription_tier" Decode.string
        |> Pipeline.optional "accountStatus" (Decode.nullable accountStatusDecoder) Nothing
        |> Pipeline.optional "demo_mode" Decode.bool False
        |> Pipeline.required
            "orgCreateDate"
            (Decode.string
                |> Decode.andThen
                    (\s ->
                        case Date.fromIsoString s of
                            Ok date ->
                                Decode.succeed (Just date)

                            Err _ ->
                                Decode.fail "Invalid date format"
                    )
            )
        |> Pipeline.optional "hasCompletedWalkthrough" Decode.bool False


type SetupStep
    = NotStarted
    | PlanSelection
    | OrganizationSetup
    | AgentSetup
    | Complete


getSetupStep : Model -> SetupStep
getSetupStep model =
    case model.currentUser of
        Nothing ->
            NotStarted

        Just user ->
            if not model.isSetup then
                PlanSelection

            else if not (hasOrganizationSettings user) then
                OrganizationSetup

            else if not (hasAgents user) then
                AgentSetup

            else
                Complete


hasOrganizationSettings : User -> Bool
hasOrganizationSettings user =
    -- Check if both organization and brand settings are configured
    case user.organizationSlug of
        "" ->
            False

        _ ->
            -- For now return True since we've merged brand settings into org settings
            -- TODO: Add actual check for required settings once API is updated
            True


hasAgents : User -> Bool
hasAgents user =
    -- TODO: Add actual check for agents
    True


redirectToSetupStep : Model -> ( Model, Cmd Msg )
redirectToSetupStep model =
    case getSetupStep model of
        NotStarted ->
            ( model, Nav.pushUrl model.key "/login" )

        PlanSelection ->
            ( model, Nav.pushUrl model.key "/choose-plan" )

        OrganizationSetup ->
            case model.currentUser of
                Just user ->
                    ( model
                    , Nav.pushUrl model.key
                        ("/setup/settings?plan=" ++ user.organizationSlug)
                    )

                Nothing ->
                    ( model, Nav.pushUrl model.key "/setup/settings" )

        AgentSetup ->
            case model.currentUser of
                Just user ->
                    ( model
                    , Nav.pushUrl model.key
                        ("/setup/add-agents?plan=" ++ user.organizationSlug ++ "&org=complete")
                    )

                Nothing ->
                    ( model, Nav.pushUrl model.key "/setup/add-agents" )

        Complete ->
            ( model, Nav.pushUrl model.key "/contacts" )


shouldRedirectAdminRoute : Route -> Model -> Maybe String
shouldRedirectAdminRoute route model =
    case route of
        AdminRoute _ ->
            case model.currentUser of
                Just user ->
                    if user.isAdmin then
                        Nothing
                        -- Admin user, no redirect needed

                    else
                        Just "/contacts"

                -- Non-admin user, redirect to contacts
                Nothing ->
                    Just "/login"

        -- Not logged in, redirect to login
        _ ->
            Nothing


shouldRedirectToLogin : Route -> Model -> Bool
shouldRedirectToLogin route model =
    let
        result =
            case route of
                PublicRoute _ ->
                    False

                NotFound ->
                    False

                AdminRoute _ ->
                    case model.session of
                        Verified _ ->
                            False

                        _ ->
                            True

                _ ->
                    case model.session of
                        Verified _ ->
                            False

                        _ ->
                            True
    in
    -- Add a debug log for the redirect check
    result


shouldRedirectToSetup : Route -> Model -> Bool
shouldRedirectToSetup route model =
    -- Only check setup state if we're in setup mode
    if model.isSetup then
        case route of
            SetupRoute _ ->
                -- Already in a setup route, no redirect needed
                False

            PublicRoute _ ->
                -- Public routes are always accessible
                False

            NotFound ->
                -- Not found routes don't redirect
                False

            AdminRoute _ ->
                -- Admin routes redirect if setup is not complete
                getSetupStep model /= Complete

            ProtectedRoute _ ->
                -- Protected routes redirect if setup is not complete
                getSetupStep model /= Complete

    else
        False


updatePage : Url -> ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
updatePage url ( model, cmd ) =
    case model.session of
        Unknown ->
            -- When session state is Unknown, still allow public routes to render
            case Parser.parse routeParser url of
                Just route ->
                    case routeAccessType route of
                        Public ->
                            -- For public routes, redirect to the force update function
                            updatePageForcePublic url ( model, cmd )

                        _ ->
                            -- For non-public routes, keep showing loading while we wait
                            ( { model | page = LoadingPage }
                            , cmd
                            )

                Nothing ->
                    ( { model | page = NotFoundPage }
                    , cmd
                    )

        -- Rest of the function remains the same for Verified and NoSession states
        _ ->
            case Parser.parse routeParser url of
                Just route ->
                    let
                        -- Update isSetup based on the route
                        modelWithUpdatedSetup =
                            updateIsSetup model route

                        adminRedirect =
                            shouldRedirectAdminRoute route modelWithUpdatedSetup

                        -- Determine if we should make authenticated requests based on session state
                        -- Only fetch user data if we have a verified session AND don't already have user info
                        authCmd =
                            case ( model.session, model.currentUser ) of
                                ( Verified _, Nothing ) ->
                                    -- Only fetch user data if we have a verified session but no user data
                                    fetchCurrentUser

                                _ ->
                                    -- Don't make authenticated requests if no session or already have user data
                                    Cmd.none
                    in
                    case adminRedirect of
                        Just redirectUrl ->
                            ( modelWithUpdatedSetup, Nav.pushUrl modelWithUpdatedSetup.key redirectUrl )

                        Nothing ->
                            let
                                needsLogin =
                                    shouldRedirectToLogin route modelWithUpdatedSetup

                                needsSetup =
                                    shouldRedirectToSetup route modelWithUpdatedSetup
                            in
                            if needsLogin then
                                ( { modelWithUpdatedSetup
                                    | intendedDestination = Just (Url.toString url)
                                    , page = LoginPage (Login.init modelWithUpdatedSetup.key False url |> Tuple.first)
                                  }
                                , if String.contains "/login" (Url.toString url) then
                                    -- Already on login page, don't redirect
                                    Cmd.none

                                  else
                                    Nav.pushUrl modelWithUpdatedSetup.key "/login"
                                )

                            else if needsSetup then
                                -- Check if we're already on a setup route to prevent redirect loops
                                case route of
                                    SetupRoute _ ->
                                        -- Already on a setup route, just update the page
                                        ( modelWithUpdatedSetup, authCmd )

                                    _ ->
                                        redirectToSetupStep modelWithUpdatedSetup

                            else
                                -- Continue with the original logic for handling different routes
                                -- Rest of the function remains the same
                                case route of
                                    PublicRoute HomeRoute ->
                                        -- Home page handles its own session checking
                                        let
                                            ( homeModel, homeCmd ) =
                                                Home.init modelWithUpdatedSetup.key
                                        in
                                        ( { modelWithUpdatedSetup | page = HomePage homeModel }
                                        , Cmd.map HomeMsg homeCmd
                                        )

                                    PublicRoute WaitlistRoute ->
                                        let
                                            ( waitlistModel, waitlistCmd ) =
                                                Waitlist.init
                                        in
                                        ( { modelWithUpdatedSetup | page = WaitlistPage waitlistModel }
                                        , Cmd.map WaitlistMsg waitlistCmd
                                        )

                                    PublicRoute LoginRoute ->
                                        let
                                            ( loginModel, loginCmd ) =
                                                Login.init modelWithUpdatedSetup.key False url
                                        in
                                        ( { modelWithUpdatedSetup | page = LoginPage loginModel }
                                        , Cmd.map LoginMsg loginCmd
                                        )

                                    PublicRoute SignupRoute ->
                                        -- Initialize signup page without making authenticated API calls
                                        let
                                            ( signupModel, signupCmd ) =
                                                Signup.init modelWithUpdatedSetup.key
                                        in
                                        ( { modelWithUpdatedSetup | page = Signup signupModel }
                                        , Cmd.map SignupMsg signupCmd
                                        )

                                    PublicRoute OnboardingRoute ->
                                        let
                                            -- Extract the query parameters from the URL
                                            queryParams =
                                                url.query
                                                    |> Maybe.map (\q -> String.split "&" q)
                                                    |> Maybe.withDefault []
                                                    |> List.filterMap
                                                        (\param ->
                                                            case String.split "=" param of
                                                                key :: value :: [] ->
                                                                    Just ( key, value )

                                                                _ ->
                                                                    Nothing
                                                        )

                                            -- Initialize the new onboarding module with query params
                                            ( onboardingModel, onboardingCmd ) =
                                                Onboarding.init modelWithUpdatedSetup.key url
                                        in
                                        ( { modelWithUpdatedSetup | page = OnboardingPage onboardingModel }
                                        , Cmd.map OnboardingMsg onboardingCmd
                                        )

                                    PublicRoute (VerifyRoute params) ->
                                        -- For verification, we need to make an API call
                                        let
                                            verifyUrl =
                                                case params of
                                                    VerifyParams orgSlug token ->
                                                        "/api/auth/verify/" ++ orgSlug ++ "/" ++ token

                                            verifyCmd =
                                                Http.get
                                                    { url = verifyUrl
                                                    , expect = Http.expectJson GotVerification verificationDecoder
                                                    }
                                        in
                                        ( model, verifyCmd )

                                    PublicRoute (CompareRoute params) ->
                                        case params.quoteId of
                                            Just quoteId ->
                                                -- We have a quote ID, which is what we prefer
                                                let
                                                    ( compareModel, compareCmd ) =
                                                        Compare.init model.key (Just params)
                                                in
                                                ( { model | page = ComparePage compareModel }
                                                , Cmd.map CompareMsg compareCmd
                                                )

                                            Nothing ->
                                                -- No quote ID, check if we have a valid orgId
                                                if isValidOrgId params.orgId then
                                                    -- We have a valid orgId but no quoteId, so use the params
                                                    let
                                                        ( compareModel, compareCmd ) =
                                                            Compare.init model.key (Just params)
                                                    in
                                                    ( { model | page = ComparePage compareModel }
                                                    , Cmd.map CompareMsg compareCmd
                                                    )

                                                else
                                                    -- No valid orgId either, redirect to 404
                                                    ( { model | page = NotFoundPage }
                                                    , Nav.pushUrl model.key "/404"
                                                    )

                                    PublicRoute (QuoteRoute params) ->
                                        -- First check if there's a valid quoteId
                                        if isValidQuoteId params.quoteId then
                                            let
                                                initialValues =
                                                    { zipCode = Nothing
                                                    , dateOfBirth = Nothing
                                                    , tobacco = Nothing
                                                    , gender = Nothing
                                                    , quoteId = params.quoteId
                                                    , planType = params.planType
                                                    , orgId = params.orgId -- Pass orgId even if it's Nothing
                                                    }

                                                ( quoteModel, quoteCmd ) =
                                                    Quote.init model.key initialValues
                                            in
                                            ( { model | page = QuotePage quoteModel }
                                            , Cmd.map QuoteMsg quoteCmd
                                            )
                                            -- If there's no valid quoteId, show error

                                        else
                                            -- Redirect to an error page or show an error
                                            ( { model | page = NotFoundPage }
                                            , Nav.pushUrl model.key "/error?message=Missing%20or%20invalid%20quote%20ID"
                                            )

                                    PublicRoute (EligibilityRoute params) ->
                                        let
                                            ( quoteId, _, orgIdStr ) =
                                                params
                                        in
                                        if isValidOrgId orgIdStr then
                                            let
                                                ( eligibilityModel, eligibilityCmd ) =
                                                    Eligibility.init model.key { quoteId = quoteId, orgId = orgIdStr }
                                            in
                                            ( { model | page = EligibilityPage eligibilityModel }
                                            , Cmd.map EligibilityMsg eligibilityCmd
                                            )

                                        else
                                            -- Redirect to an error page or show an error
                                            ( { model | page = NotFoundPage }
                                            , Nav.pushUrl model.key "/error?message=Missing%20or%20invalid%20organization%20ID"
                                            )

                                    PublicRoute (ScheduleRoute params) ->
                                        let
                                            ( scheduleModel, scheduleCmd ) =
                                                Schedule.init model.key
                                                    ((\( id, _, _ ) -> id) params)
                                                    ((\( _, status, _ ) -> status) params)
                                        in
                                        ( { model | page = SchedulePage scheduleModel }
                                        , Cmd.map ScheduleMsg scheduleCmd
                                        )

                                    PublicRoute ScheduleMainRoute ->
                                        let
                                            ( scheduleMainModel, scheduleMainCmd ) =
                                                ScheduleMain.init model.key
                                        in
                                        ( { model | page = ScheduleMainPage scheduleMainModel }
                                        , Cmd.map ScheduleMainMsg scheduleMainCmd
                                        )

                                    ProtectedRoute ContactsRoute ->
                                        let
                                            -- Convert Main.elm User to Contacts.elm User format
                                            contactsUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = String.toInt user.id |> Maybe.withDefault 0
                                                            , email = user.email
                                                            , firstName = user.firstName
                                                            , lastName = user.lastName
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , isDefault = False -- Add isDefault field
                                                            , organizationId = String.toInt user.organizationId |> Maybe.withDefault 0
                                                            , isActive = True -- Assume active
                                                            , phone = "" -- Default empty
                                                            , carriers = [] -- Default empty
                                                            , stateLicenses = [] -- Default empty
                                                            }
                                                        )

                                            ( contactsModel, contactsCmd ) =
                                                Contacts.init modelWithUpdatedSetup.key contactsUser
                                        in
                                        ( { modelWithUpdatedSetup | page = ContactsPage contactsModel }
                                        , Cmd.map ContactsMsg contactsCmd
                                        )

                                    ProtectedRoute ProfileRoute ->
                                        let
                                            ( profileModel, profileCmd ) =
                                                Profile.init ()
                                        in
                                        ( { modelWithUpdatedSetup | page = ProfilePage profileModel }
                                        , Cmd.batch
                                            [ Cmd.map ProfileMsg profileCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute TempLandingRoute ->
                                        let
                                            ( tempLandingModel, tempLandingCmd ) =
                                                TempLanding.init ()
                                        in
                                        ( { modelWithUpdatedSetup | page = TempLandingPage tempLandingModel }
                                        , Cmd.batch
                                            [ Cmd.map TempLandingMsg tempLandingCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute (ContactRoute id) ->
                                        let
                                            demoMode =
                                                case modelWithUpdatedSetup.currentUser of
                                                    Just user ->
                                                        user.demoMode

                                                    Nothing ->
                                                        False

                                            ( contactModel, contactCmd ) =
                                                Contact.init modelWithUpdatedSetup.key id demoMode
                                        in
                                        ( { modelWithUpdatedSetup | page = ContactPage contactModel }
                                        , Cmd.batch
                                            [ Cmd.map ContactMsg contactCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute ChangePlanRoute ->
                                        let
                                            ( changePlanModel, changePlanCmd ) =
                                                ChangePlan.init
                                                    { key = modelWithUpdatedSetup.key
                                                    , session = extractSession modelWithUpdatedSetup.session
                                                    , orgSlug = modelWithUpdatedSetup.currentUser |> Maybe.map .organizationSlug |> Maybe.withDefault ""
                                                    }
                                        in
                                        ( { modelWithUpdatedSetup | page = ChangePlanPage changePlanModel }
                                        , Cmd.batch
                                            [ Cmd.map ChangePlanMsg changePlanCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute DashboardRoute ->
                                        let
                                            dashboardFlags =
                                                { isPostPayment =
                                                    case
                                                        Parser.parse
                                                            (Parser.s "dashboard" <?> Query.string "payment_success")
                                                            url
                                                    of
                                                        Just (Just "true") ->
                                                            Just True

                                                        _ ->
                                                            Nothing
                                                }

                                            ( dashboardModel, dashboardCmd ) =
                                                Dashboard.init modelWithUpdatedSetup.key dashboardFlags
                                        in
                                        ( { modelWithUpdatedSetup | page = DashboardPage dashboardModel }
                                        , Cmd.batch
                                            [ Cmd.map DashboardMsg dashboardCmd
                                            , authCmd
                                            , case modelWithUpdatedSetup.currentUser of
                                                Just user ->
                                                    Cmd.map DashboardMsg (Task.perform (\hasCompleted -> Dashboard.UserDataReceived hasCompleted) (Task.succeed user.hasCompletedWalkthrough))

                                                Nothing ->
                                                    Cmd.none
                                            ]
                                        )

                                    ProtectedRoute WalkthroughRoute ->
                                        let
                                            ( walkthroughModel, walkthroughCmd ) =
                                                Walkthrough.init False
                                        in
                                        ( { modelWithUpdatedSetup | page = WalkthroughPage walkthroughModel }
                                        , Cmd.batch
                                            [ Cmd.map WalkthroughMsg walkthroughCmd
                                            , authCmd
                                            ]
                                        )

                                    AdminRoute SettingsRoute ->
                                        let
                                            -- Convert Main.elm User to Settings.elm CurrentUser format
                                            settingsUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = user.id
                                                            , email = user.email
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , organizationSlug = user.organizationSlug
                                                            , organizationId = user.organizationId
                                                            }
                                                        )

                                            ( settingsModel, settingsCmd ) =
                                                Settings.init
                                                    { isSetup = False
                                                    , key = modelWithUpdatedSetup.key
                                                    , currentUser = settingsUser
                                                    , planType =
                                                        modelWithUpdatedSetup.currentUser
                                                            |> Maybe.map .subscriptionTier
                                                            |> Maybe.withDefault ""
                                                    }
                                        in
                                        ( { modelWithUpdatedSetup | page = SettingsPage settingsModel }
                                        , Cmd.batch
                                            [ Cmd.map SettingsMsg settingsCmd
                                            , authCmd
                                            ]
                                        )

                                    AdminRoute AgentsRoute ->
                                        let
                                            -- Convert Main.elm User to AddAgent.elm CurrentUser format
                                            addAgentUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = user.id
                                                            , email = user.email
                                                            , firstName = user.firstName
                                                            , lastName = user.lastName
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , phone = ""
                                                            , orgSlug = user.organizationSlug -- ADDED
                                                            }
                                                        )

                                            ( addAgentModel, addAgentCmd ) =
                                                AddAgent.init
                                                    False
                                                    modelWithUpdatedSetup.key
                                                    addAgentUser
                                                    (modelWithUpdatedSetup.currentUser
                                                        |> Maybe.map .subscriptionTier
                                                        |> Maybe.withDefault ""
                                                    )
                                        in
                                        ( { modelWithUpdatedSetup | page = AddAgentsPage addAgentModel }
                                        , Cmd.batch
                                            [ Cmd.map AddAgentsMsg addAgentCmd
                                            , authCmd
                                            ]
                                        )

                                    SetupRoute (ChoosePlanRoute progress) ->
                                        let
                                            orgSlug =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map .organizationSlug
                                                    |> Maybe.withDefault ""

                                            session =
                                                extractSession modelWithUpdatedSetup.session

                                            ( choosePlanModel, choosePlanCmd ) =
                                                ChoosePlan.init orgSlug session modelWithUpdatedSetup.key True
                                        in
                                        ( { modelWithUpdatedSetup | page = ChoosePlanPage choosePlanModel }
                                        , Cmd.batch
                                            [ Cmd.map ChoosePlanMsg choosePlanCmd
                                            , authCmd
                                            ]
                                        )

                                    SetupRoute (SetupSettingsRoute progress) ->
                                        let
                                            -- Get plan type from progress if available, otherwise use subscription tier
                                            planType =
                                                progress
                                                    |> Maybe.andThen .plan
                                                    |> Maybe.withDefault
                                                        (modelWithUpdatedSetup.currentUser
                                                            |> Maybe.map .subscriptionTier
                                                            |> Maybe.withDefault ""
                                                        )

                                            -- Convert Main.elm User to Settings.elm CurrentUser format
                                            settingsUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = user.id
                                                            , email = user.email
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , organizationSlug = user.organizationSlug
                                                            , organizationId = user.organizationId
                                                            }
                                                        )

                                            ( settingsModel, settingsCmd ) =
                                                Settings.init
                                                    { isSetup = True
                                                    , key = modelWithUpdatedSetup.key
                                                    , currentUser = settingsUser
                                                    , planType = planType
                                                    }
                                        in
                                        ( { modelWithUpdatedSetup | page = SettingsPage settingsModel }
                                        , Cmd.batch
                                            [ Cmd.map SettingsMsg settingsCmd
                                            , authCmd
                                            ]
                                        )

                                    SetupRoute (AddAgentsRoute progress) ->
                                        let
                                            -- Get plan type from progress if available, otherwise use subscription tier
                                            planType =
                                                progress
                                                    |> Maybe.andThen .plan
                                                    |> Maybe.withDefault
                                                        (modelWithUpdatedSetup.currentUser
                                                            |> Maybe.map .subscriptionTier
                                                            |> Maybe.withDefault ""
                                                        )

                                            -- Convert Main.elm User to AddAgent.elm CurrentUser format
                                            addAgentUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = user.id
                                                            , email = user.email
                                                            , firstName = user.firstName
                                                            , lastName = user.lastName
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , phone = ""
                                                            , orgSlug = user.organizationSlug -- ADDED
                                                            }
                                                        )

                                            ( addAgentModel, addAgentCmd ) =
                                                AddAgent.init True modelWithUpdatedSetup.key addAgentUser planType
                                        in
                                        ( { modelWithUpdatedSetup | page = AddAgentsPage addAgentModel }
                                        , Cmd.batch
                                            [ Cmd.map AddAgentsMsg addAgentCmd
                                            , authCmd
                                            ]
                                        )

                                    NotFound ->
                                        ( modelWithUpdatedSetup, Cmd.none )

                                    PublicRoute (SelfOnboardingRoute orgSlug) ->
                                        let
                                            ( selfOnboardingModel, selfOnboardingCmd ) =
                                                SelfServiceOnboarding.init model.key url
                                        in
                                        ( { model | page = SelfOnboardingPage selfOnboardingModel }
                                        , Cmd.map SelfOnboardingMsg selfOnboardingCmd
                                        )

                                    PublicRoute (LandingRoute params) ->
                                        let
                                            ( landingModel, landingCmd ) =
                                                Landing.init params
                                        in
                                        ( { model | page = LandingPage landingModel }
                                        , Cmd.map LandingMsg landingCmd
                                        )

                                    PublicRoute PricingRoute ->
                                        let
                                            ( pricingModel, pricingCmd ) =
                                                Pricing.init
                                        in
                                        ( { modelWithUpdatedSetup | page = PricingPage pricingModel }
                                        , Cmd.batch
                                            [ Cmd.map PricingMsg pricingCmd
                                            , authCmd
                                            ]
                                        )

                                    PublicRoute StageDemoInputRoute ->
                                        ( { modelWithUpdatedSetup | page = StageDemoInputPage StageDemoInput.init }
                                        , Cmd.none
                                        )

                                    PublicRoute (StageDemoQuoteRoute tempId) ->
                                        let
                                            ( stageDemoQuoteModel, stageDemoQuoteCmd ) =
                                                StageDemoQuote.init tempId modelWithUpdatedSetup.key
                                        in
                                        ( { modelWithUpdatedSetup | page = StageDemoQuotePage stageDemoQuoteModel }
                                        , Cmd.map StageDemoQuoteMsg stageDemoQuoteCmd
                                        )

                                    PublicRoute (StageDemoHealthRoute tempId) ->
                                        ( { modelWithUpdatedSetup | page = StageDemoHealthPage (StageDemoHealth.init tempId) }
                                        , Cmd.none
                                        )

                                    PublicRoute (StageDemoCTARoute tempId) ->
                                        ( { modelWithUpdatedSetup | page = StageDemoCTAPage (StageDemoCTA.init tempId) }
                                        , Cmd.none
                                        )

                                    ProtectedRoute ContactUsRoute ->
                                        let
                                            ( contactUsModel, contactUsCmd ) =
                                                ContactUs.init ()
                                        in
                                        ( { modelWithUpdatedSetup | page = ContactUsPage contactUsModel }
                                        , Cmd.batch
                                            [ Cmd.map ContactUsMsg contactUsCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute StripeRoute ->
                                        let
                                            ( stripeModel, stripeCmd ) =
                                                Stripe.init modelWithUpdatedSetup.key url
                                        in
                                        ( { modelWithUpdatedSetup | page = StripePage stripeModel }
                                        , Cmd.batch
                                            [ Cmd.map StripeMsg stripeCmd
                                            , authCmd
                                            ]
                                        )

                Nothing ->
                    ( { model | page = NotFoundPage }
                    , cmd
                    )


type alias CurrentUserResponse =
    { success : Bool
    , user : Maybe User
    }


fetchCurrentUser : Cmd Msg
fetchCurrentUser =
    Http.get
        { url = "/api/me"
        , expect = Http.expectJson GotCurrentUser currentUserResponseDecoder
        }


setSession : String -> Cmd Msg
setSession email =
    Http.post
        { url = "/api/auth/set-session"
        , expect = Http.expectJson SetSessionResponse setSessionResponseDecoder
        , body = Http.jsonBody (E.object [ ( "email", E.string email ) ])
        }


type alias SetSessionResponseAlias =
    { success : Bool
    }


setSessionResponseDecoder : Decoder SetSessionResponseAlias
setSessionResponseDecoder =
    Decode.map SetSessionResponseAlias
        (Decode.field "success" Decode.bool)


fetchAccountStatus : String -> Cmd Msg
fetchAccountStatus orgSlug =
    Http.get
        { url = "/api/organizations/" ++ orgSlug ++ "/account-status"
        , expect = Http.expectJson GotAccountStatus accountStatusResponseDecoder
        }


currentUserResponseDecoder : Decoder CurrentUserResponse
currentUserResponseDecoder =
    Decode.map2 CurrentUserResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "user"
            (Decode.nullable
                (Decode.value
                    |> Decode.andThen
                        (\_ ->
                            userDecoder
                        )
                )
            )
        )



-- Wrap the user in Just since our type expects Maybe User


isBasicPlan : Model -> Bool
isBasicPlan model =
    case model.currentUser of
        Just user ->
            user.organizationSlug == "basic"

        Nothing ->
            True


finalizeOrganization : String -> Cmd Msg
finalizeOrganization orgId =
    Http.post
        { url = "/api/organizations/" ++ orgId ++ "/finalize"
        , body = Http.emptyBody
        , expect = Http.expectWhatever OrgFinalized
        }



-- Helper function to extract session string from SessionState


extractSession : SessionState -> String
extractSession sessionState =
    case sessionState of
        Verified session ->
            session

        _ ->
            ""



-- Helper function to map Document msg to Document Msg


mapDocument : (msg -> Msg) -> Browser.Document msg -> Browser.Document Msg
mapDocument toMsg document =
    { title = document.title
    , body = List.map (Html.map toMsg) document.body
    }



-- Update the isSetup flag based on the current URL and route


updateIsSetup : Model -> Route -> Model
updateIsSetup model route =
    let
        -- Determine if we're in setup mode based on the route
        newIsSetup =
            case route of
                SetupRoute _ ->
                    True

                _ ->
                    -- For non-setup routes, only keep isSetup = True if we're in the middle
                    -- of setup flow (haven't completed it yet)
                    model.isSetup && (getSetupStep model /= Complete)
    in
    { model | isSetup = newIsSetup }



-- Add a new function to force update public routes


updatePageForcePublic : Url -> ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
updatePageForcePublic url ( model, cmd ) =
    case Parser.parse routeParser url of
        Just route ->
            case route of
                PublicRoute HomeRoute ->
                    let
                        ( homeModel, homeCmd ) =
                            Home.init model.key
                    in
                    ( { model | page = HomePage homeModel }
                    , Cmd.map HomeMsg homeCmd
                    )

                PublicRoute WaitlistRoute ->
                    let
                        ( waitlistModel, waitlistCmd ) =
                            Waitlist.init
                    in
                    ( { model | page = WaitlistPage waitlistModel }
                    , Cmd.map WaitlistMsg waitlistCmd
                    )

                PublicRoute LoginRoute ->
                    let
                        ( loginModel, loginCmd ) =
                            Login.init model.key False url
                    in
                    ( { model | page = LoginPage loginModel }
                    , Cmd.map LoginMsg loginCmd
                    )

                PublicRoute SignupRoute ->
                    let
                        ( signupModel, signupCmd ) =
                            Signup.init model.key
                    in
                    ( { model | page = Signup signupModel }
                    , Cmd.map SignupMsg signupCmd
                    )

                PublicRoute OnboardingRoute ->
                    let
                        -- Extract the query parameters from the URL
                        queryParams =
                            url.query
                                |> Maybe.map (\q -> String.split "&" q)
                                |> Maybe.withDefault []
                                |> List.filterMap
                                    (\param ->
                                        case String.split "=" param of
                                            key :: value :: [] ->
                                                Just ( key, value )

                                            _ ->
                                                Nothing
                                    )

                        -- Initialize the new onboarding module with query params
                        ( onboardingModel, onboardingCmd ) =
                            Onboarding.init model.key url
                    in
                    ( { model | page = OnboardingPage onboardingModel }
                    , Cmd.map OnboardingMsg onboardingCmd
                    )

                PublicRoute (VerifyRoute params) ->
                    let
                        verifyUrl =
                            case params of
                                VerifyParams orgSlug token ->
                                    "/api/auth/verify/" ++ orgSlug ++ "/" ++ token
                    in
                    ( model
                    , Http.get
                        { url = verifyUrl
                        , expect = Http.expectJson GotVerification verificationDecoder
                        }
                    )

                PublicRoute (CompareRoute params) ->
                    case params.quoteId of
                        Just quoteId ->
                            let
                                ( compareModel, compareCmd ) =
                                    Compare.init model.key (Just params)
                            in
                            ( { model | page = ComparePage compareModel }
                            , Cmd.map CompareMsg compareCmd
                            )

                        Nothing ->
                            if isValidOrgId params.orgId then
                                let
                                    ( compareModel, compareCmd ) =
                                        Compare.init model.key (Just params)
                                in
                                ( { model | page = ComparePage compareModel }
                                , Cmd.map CompareMsg compareCmd
                                )

                            else
                                ( { model | page = NotFoundPage }
                                , Nav.pushUrl model.key "/404"
                                )

                PublicRoute (QuoteRoute params) ->
                    if isValidQuoteId params.quoteId then
                        let
                            initialValues =
                                { zipCode = Nothing
                                , dateOfBirth = Nothing
                                , tobacco = Nothing
                                , gender = Nothing
                                , quoteId = params.quoteId
                                , planType = params.planType
                                , orgId = params.orgId -- Pass orgId even if it's Nothing
                                }

                            ( quoteModel, quoteCmd ) =
                                Quote.init model.key initialValues
                        in
                        ( { model | page = QuotePage quoteModel }
                        , Cmd.map QuoteMsg quoteCmd
                        )

                    else
                        ( { model | page = NotFoundPage }
                        , Nav.pushUrl model.key "/error?message=Missing%20or%20invalid%20quote%20ID"
                        )

                PublicRoute (EligibilityRoute params) ->
                    let
                        ( quoteId, _, orgIdStr ) =
                            params
                    in
                    if isValidOrgId orgIdStr then
                        let
                            ( eligibilityModel, eligibilityCmd ) =
                                Eligibility.init model.key { quoteId = quoteId, orgId = orgIdStr }
                        in
                        ( { model | page = EligibilityPage eligibilityModel }
                        , Cmd.map EligibilityMsg eligibilityCmd
                        )

                    else
                        ( { model | page = NotFoundPage }
                        , Nav.pushUrl model.key "/error?message=Missing%20or%20invalid%20organization%20ID"
                        )

                PublicRoute (ScheduleRoute params) ->
                    let
                        ( scheduleModel, scheduleCmd ) =
                            Schedule.init model.key
                                ((\( id, _, _ ) -> id) params)
                                ((\( _, status, _ ) -> status) params)
                    in
                    ( { model | page = SchedulePage scheduleModel }
                    , Cmd.map ScheduleMsg scheduleCmd
                    )

                PublicRoute ScheduleMainRoute ->
                    let
                        ( scheduleMainModel, scheduleMainCmd ) =
                            ScheduleMain.init model.key
                    in
                    ( { model | page = ScheduleMainPage scheduleMainModel }
                    , Cmd.map ScheduleMainMsg scheduleMainCmd
                    )

                PublicRoute (SelfOnboardingRoute orgSlug) ->
                    let
                        ( selfOnboardingModel, selfOnboardingCmd ) =
                            SelfServiceOnboarding.init model.key url
                    in
                    ( { model | page = SelfOnboardingPage selfOnboardingModel }
                    , Cmd.map SelfOnboardingMsg selfOnboardingCmd
                    )

                PublicRoute (LandingRoute params) ->
                    let
                        ( landingModel, landingCmd ) =
                            Landing.init params
                    in
                    ( { model | page = LandingPage landingModel }
                    , Cmd.map LandingMsg landingCmd
                    )

                PublicRoute PricingRoute ->
                    let
                        ( pricingModel, pricingCmd ) =
                            Pricing.init
                    in
                    ( { model | page = PricingPage pricingModel }
                    , Cmd.map PricingMsg pricingCmd
                    )

                PublicRoute StageDemoInputRoute ->
                    ( { model | page = StageDemoInputPage StageDemoInput.init }
                    , Cmd.none
                    )

                PublicRoute (StageDemoQuoteRoute tempId) ->
                    let
                        ( stageDemoQuoteModel, stageDemoQuoteCmd ) =
                            StageDemoQuote.init tempId model.key
                    in
                    ( { model | page = StageDemoQuotePage stageDemoQuoteModel }
                    , Cmd.map StageDemoQuoteMsg stageDemoQuoteCmd
                    )

                PublicRoute (StageDemoHealthRoute tempId) ->
                    ( { model | page = StageDemoHealthPage (StageDemoHealth.init tempId) }
                    , Cmd.none
                    )

                PublicRoute (StageDemoCTARoute tempId) ->
                    ( { model | page = StageDemoCTAPage (StageDemoCTA.init tempId) }
                    , Cmd.none
                    )

                -- For any other route type, fall through to the main updatePage or handle as NotFound.
                _ ->
                    updatePage url ( model, cmd )

        Nothing ->
            ( { model | page = NotFoundPage }
            , cmd
            )



-- Add a helper function to check if an organization ID is valid
-- It should return True only if the orgId is not empty, not "default", and is a proper string


isValidOrgId : Maybe String -> Bool
isValidOrgId maybeOrgId =
    case maybeOrgId of
        Just orgId ->
            not (String.isEmpty orgId) && orgId /= "default"

        Nothing ->
            False



-- Add a helper function to check if a quote ID is valid


isValidQuoteId : Maybe String -> Bool
isValidQuoteId maybeQuoteId =
    case maybeQuoteId of
        Just quoteId ->
            not (String.isEmpty quoteId)

        Nothing ->
            False

================
File: frontend/src/main.ts
================
import './styles.css'
import { Elm } from './Main.elm'
import { PieChart, BarChart, LineChart, Interpolation } from 'chartist';
import 'chartist/dist/index.css';
import { setupLineChartAnimations, setupBarChartAnimations, animateFunnelChart } from './chart-animations';

// Declare Stripe for TypeScript
declare const Stripe: any;
// Declare Chartist for TypeScript
// declare const Chartist: any;

// Define the Stripe Checkout custom element
customElements.define('stripe-checkout', class extends HTMLElement {
  private stripe: any;
  private checkout: any;

  constructor() {
    super();
    console.log('[Stripe] Creating new stripe-checkout element');
    this.stripe = null;
    this.checkout = null;
  }

  async connectedCallback() {
    console.log('[Stripe] Element connected to DOM');
    // Check if there's already an active instance
    if ((this.constructor as any).activeInstance) {
      console.log('[Stripe] Cleaning up previous Stripe Checkout instance');
      const prevInstance = (this.constructor as any).activeInstance;
      if (prevInstance.checkout) {
        await prevInstance.checkout.destroy();
      }
      prevInstance.remove();
    }

    // Set this as the active instance
    (this.constructor as any).activeInstance = this;
    console.log('[Stripe] Set as active checkout instance');

    // Apply a wider style to the element
    this.style.width = '100%';
    this.style.maxWidth = '800px';
    this.style.minHeight = '500px';
    
    await this.initializeStripe();
    await this.mountCheckout();
  }

  attributeChangedCallback(name: string, oldValue: string, newValue: string) {
    console.log(`[Stripe] Attribute changed: ${name} from "${oldValue}" to "${newValue}"`);
    if (this.isConnected) {
      this.mountCheckout();
    }
  }

  static get observedAttributes() {
    return ['price-id', 'metered-price-id', 'return-url', 'first-name', 'last-name', 'email'];
  }

  async initializeStripe() {
    if (!this.stripe) {
      console.log('[Stripe] Loading Stripe.js script');
      const stripeScript = document.createElement('script');
      stripeScript.src = 'https://js.stripe.com/v3/';
      document.head.appendChild(stripeScript);
      await new Promise(resolve => stripeScript.onload = resolve);
      console.log('[Stripe] Stripe.js script loaded');
      
      // Use environment variable if available, otherwise fallback to the hardcoded key
      const publishableKey = import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY || 
        'pk_test_51Qyh7RCBUPXAZKNGAvsWikdxCCaV1R9Vc79IgPqCul8AJsln69ABDQZE0zzOtOlH5rqrlw2maRebndvPl8xDaIVl00Nn2OOBCX';
      
      console.log('[Stripe] Initializing Stripe with publishable key:', publishableKey.substring(0, 20) + '...');
      this.stripe = Stripe(publishableKey);
      console.log('[Stripe] Stripe initialized successfully');
    }
  }

  async mountCheckout() {
    console.log('[Stripe] Mounting checkout form');
    const priceId = this.getAttribute('price-id');
    // const meteredPriceId = this.getAttribute('metered-price-id');
    const firstName = this.getAttribute('first-name');
    const lastName = this.getAttribute('last-name');
    const email = this.getAttribute('email');

    console.log('[Stripe] Checkout attributes:', { 
      priceId, 
      // meteredPriceId, 
      firstName, 
      lastName, 
      email: email ? `${email.substring(0, 3)}...${email.split('@')[1] ? '@' + email.split('@')[1] : ''}` : null 
    });

    if (!priceId || !firstName || !lastName || !email) {
      console.error('[Stripe] Missing required attributes for checkout');
      this.textContent = 'Error: Missing required attributes';
      return;
    }

    try {
      console.log(`[Stripe] Creating checkout session with priceId: ${priceId}, email: ${email}`);
      
      console.log('[Stripe] Sending request to /api/create-checkout-session');
      const response = await fetch('/api/create-checkout-session', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          priceId,
          //meteredPriceId,
          customerEmail: email,
          customerName: `${firstName} ${lastName}`
        }),
      });

      console.log(`[Stripe] Create checkout session response status: ${response.status}`);
      const data = await response.json();
      console.log('[Stripe] Checkout session response data:', data);
      
      if (!response.ok) {
        console.error('[Stripe] Failed to create checkout session:', data.message || 'Unknown error');
        throw new Error(data.message || 'Failed to create checkout session');
      }

      const { clientSecret } = data;
      console.log('[Stripe] Got client secret:', clientSecret ? `${clientSecret.substring(0, 10)}...` : 'null');

      // Destroy existing checkout if it exists
      if (this.checkout) {
        console.log('[Stripe] Destroying existing checkout instance');
        await this.checkout.destroy();
      }

      // Create the checkout form
      console.log('[Stripe] Initializing embedded checkout with client secret');
      this.checkout = await this.stripe.initEmbeddedCheckout({
        clientSecret,
        onComplete: async () => {
          console.log('[Stripe] Checkout complete callback triggered');
          try {
            console.log('[Stripe] Checkout complete! Fetching session data with clientSecret:', clientSecret.substring(0, 10) + '...');
            
            // Extract the session ID from the client secret (format: cs_<id>_secret_<secret>)
            const sessionId = clientSecret.split('_secret_')[0];
            console.log('[Stripe] Extracted session ID:', sessionId);
            
            // Poll for session status to ensure payment is complete
            console.log('[Stripe] Starting to poll for session status');
            this.pollSessionStatus(sessionId, email, firstName, lastName, clientSecret);
            
          } catch (error) {
            console.error('[Stripe] Error handling checkout completion:', error);
            
            const errorData = {
              success: false,
              message: error instanceof Error ? error.message : 'Payment completion failed',
            };

            console.log('[Stripe] Sending error data to Elm:', errorData);

            // Find the Elm app instance
            const elmApp = (window as any).elmApp;
            if (elmApp && elmApp.ports && elmApp.ports.checkoutError) {
              console.log('[Stripe] Sending checkout error to Elm via port');
              elmApp.ports.checkoutError.send(errorData);
            } else {
              // Fall back to event dispatching
              console.log('[Stripe] Elm app or port not found for error, dispatching event instead');
              const event = new CustomEvent('checkout-error', {
                detail: { error: errorData }
              });
              document.dispatchEvent(event);
            }
          }
        }
      });

      // Mount the checkout form to the element
      console.log('[Stripe] Mounting checkout to DOM element');
      await this.checkout.mount(this);
      console.log('[Stripe] Checkout mounted successfully');

    } catch (error) {
      console.error('[Stripe] Error mounting checkout:', error);
      this.textContent = `Error: ${error instanceof Error ? error.message : 'Failed to load payment form'}`;
    }
  }

  // Poll for session status to confirm payment completion
  async pollSessionStatus(sessionId: string, email: string, firstName: string, lastName: string, clientSecret: string, attempts = 0) {
    if (attempts > 5) {
      console.error('[Stripe] Max polling attempts reached for session:', sessionId);
      
      const errorData = {
        success: false,
        message: 'Timeout waiting for payment confirmation',
      };
      
      // Find the Elm app instance
      const elmApp = (window as any).elmApp;
      if (elmApp && elmApp.ports && elmApp.ports.checkoutError) {
        console.log('[Stripe] Sending checkout timeout error to Elm via port');
        elmApp.ports.checkoutError.send(errorData);
      }
      
      return;
    }
    
    try {
      console.log(`[Stripe] Polling attempt ${attempts + 1} for session status: ${sessionId}`);
      
      // Check the status of the session
      const response = await fetch(`/api/session-status?session_id=${sessionId}`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (!response.ok) {
        console.error(`[Stripe] Error checking session status: ${response.status}`);
        setTimeout(() => this.pollSessionStatus(sessionId, email, firstName, lastName, clientSecret, attempts + 1), 2000);
        return;
      }
      
      const sessionData = await response.json();
      console.log('[Stripe] Session status response:', sessionData);
      
      if (sessionData.status === 'complete') {
        console.log('[Stripe] Session is complete, fetching detailed session data');
        
        // Get checkout session data which includes customer and subscription IDs
        const sessionDetailResponse = await fetch(`/api/checkout-session?clientSecret=${encodeURIComponent(sessionId + '_secret_' + clientSecret.split('_secret_')[1])}`, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (!sessionDetailResponse.ok) {
          console.error(`[Stripe] Error getting session details: ${sessionDetailResponse.status}`);
          setTimeout(() => this.pollSessionStatus(sessionId, email, firstName, lastName, clientSecret, attempts + 1), 2000);
          return;
        }
        
        const sessionDetailData = await sessionDetailResponse.json();
        console.log('[Stripe] Session details retrieved:', sessionDetailData);
        
        // Prepare the payment completion data
        const paymentData = {
          email,
          firstName,
          lastName,
          stripeCustomerId: sessionDetailData.customer,
          stripeSubscriptionId: sessionDetailData.subscription,
          stripeUsageItemId: sessionDetailData.subscription_item
        };
        
        console.log('[Stripe] Sending payment completion data:', JSON.stringify(paymentData));
        
        // Send data to payment-complete endpoint
        const paymentResponse = await fetch('/api/stripe/payment-complete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(paymentData)
        });
        
        if (!paymentResponse.ok) {
          console.error(`[Stripe] Error completing payment: ${paymentResponse.status}`);
          const errorText = await paymentResponse.text();
          console.error('[Stripe] Payment completion error details:', errorText);
          
          const errorData = {
            success: false,
            message: `Payment processing error: ${paymentResponse.status}`,
          };
          
          // Send to Elm
          const elmApp = (window as any).elmApp;
          if (elmApp && elmApp.ports && elmApp.ports.checkoutError) {
            elmApp.ports.checkoutError.send(errorData);
          }
          
          return;
        }
        
        const paymentResult = await paymentResponse.json();
        console.log('[Stripe] Payment completion result:', paymentResult);
        
        // Send success to Elm
        const paymentStatus = {
          success: paymentResult.success,
          message: paymentResult.success ? 'Payment completed successfully' : 'Payment processing failed',
          paymentCompleted: paymentResult.success
        };
        
        const elmApp = (window as any).elmApp;
        if (elmApp && elmApp.ports && elmApp.ports.paymentCompleted) {
          console.log('[Stripe] Sending payment completion status to Elm via port:', paymentStatus);
          elmApp.ports.paymentCompleted.send(paymentStatus);
        } else {
          console.log('[Stripe] Elm app or port not found, dispatching event instead');
          const event = new CustomEvent('payment-completed', {
            detail: { status: paymentStatus }
          });
          document.dispatchEvent(event);
        }
        
      } else if (sessionData.status === 'open') {
        // Session still in progress, poll again
        console.log('[Stripe] Session still open, polling again in 2 seconds');
        setTimeout(() => this.pollSessionStatus(sessionId, email, firstName, lastName, clientSecret, attempts + 1), 2000);
      } else {
        // Other status (e.g., 'expired')
        console.log(`[Stripe] Session has status: ${sessionData.status}, stopping polling`);
        
        const errorData = {
          success: false,
          message: `Payment session ${sessionData.status}`,
        };
        
        // Send to Elm
        const elmApp = (window as any).elmApp;
        if (elmApp && elmApp.ports && elmApp.ports.checkoutError) {
          elmApp.ports.checkoutError.send(errorData);
        }
      }
      
    } catch (error) {
      console.error('[Stripe] Error polling session status:', error);
      setTimeout(() => this.pollSessionStatus(sessionId, email, firstName, lastName, clientSecret, attempts + 1), 2000);
    }
  }

  async createCheckoutSession(priceId: string, meteredPriceId: string | null, email?: string, name?: string) {
    try {
      console.log(`[Stripe] Creating checkout session for base price: ${priceId}, metered price: ${meteredPriceId}, email: ${email || 'not provided'}`);
      const response = await fetch('/api/create-checkout-session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          priceId,
          meteredPriceId,
          customerEmail: email,
          customerName: name
        })
      });
      
      console.log(`[Stripe] Create checkout session response status: ${response.status}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[Stripe] Checkout session creation failed with status ${response.status}:`, errorText);
        throw new Error(`Failed to create checkout session: ${response.status} ${errorText}`);
      }
      
      const data = await response.json();
      console.log('[Stripe] Checkout session created successfully:', { success: data.success, clientSecret: data.clientSecret ? `${data.clientSecret.substring(0, 10)}...` : null });
      return data;
    } catch (error: any) {
      console.error('[Stripe] Error in createCheckoutSession:', error);
      throw error;
    }
  }

  async disconnectedCallback() {
    console.log('[Stripe] Stripe Checkout element disconnected, cleaning up...');
    if (this.checkout) {
      try {
        await this.checkout.destroy();
        this.checkout = null;
        console.log('[Stripe] Checkout instance destroyed successfully');
      } catch (error) {
        console.error('[Stripe] Error destroying checkout:', error);
      }
    }
    // Clear the active instance if this element is being removed
    if ((this.constructor as any).activeInstance === this) {
      (this.constructor as any).activeInstance = null;
      console.log('[Stripe] Cleared active instance reference');
    }
  }
});

// Define the Chartist Bar chart custom element (existing implementation)
customElements.define('chartist-bar', class extends HTMLElement {
  static get observedAttributes() { return ['data']; }
  connectedCallback() { this.renderChart(); }
  attributeChangedCallback() { this.renderChart(); }
  renderChart() {
    const dataAttr = this.getAttribute('data');
    if (!dataAttr) return;
    let chartData;
    try {
      chartData = JSON.parse(dataAttr);
    } catch (e) {
      this.textContent = 'Invalid chart data';
      return;
    }
    this.innerHTML = '';
    const chartDiv = document.createElement('div');
    chartDiv.style.height = '100%';
    chartDiv.style.width = '100%';
    this.appendChild(chartDiv);
    
    // Add custom CSS for series colors and enhanced styling
    const style = document.createElement('style');
    style.textContent = `
      .ct-series-a .ct-bar, .ct-series-a .ct-line, .ct-series-a .ct-point {
        stroke: #03045e !important;
        stroke-width: 2px;
      }
      .ct-series-b .ct-bar, .ct-series-b .ct-line, .ct-series-b .ct-point {
        stroke: #0077b6 !important;
        stroke-width: 2px;
      }
      .ct-series-c .ct-bar, .ct-series-c .ct-line, .ct-series-c .ct-point {
        stroke: #00b4d8 !important;
        stroke-width: 2px;
      }
      .ct-series-d .ct-bar, .ct-series-d .ct-line, .ct-series-d .ct-point {
        stroke: #48cae4 !important;
        stroke-width: 2px;
      }

      /* Enhanced styling for bar chart */
      .ct-bar {
        stroke-linecap: round;
      }

      /* Grid styling */
      .ct-grid {
        stroke: rgba(0,0,0,0.1) !important;
        stroke-dasharray: 2px;
      }

      /* Better label styling */
      .ct-label {
        font-size: 12px !important;
        color: #555 !important;
        fill: #555 !important;
      }
    `;
    this.appendChild(style);

    const chart = new BarChart(chartDiv, chartData, {
      stackBars: false,
      axisY: { onlyInteger: true },
      chartPadding: {
        right: 40,
        left: 20,
        top: 20,
        bottom: 20
      },
      seriesBarDistance: 15,
      // Responsive options for bar chart
      plugins: [
        // Optional: add a tooltip plugin if desired
        // Chartist.plugins?.tooltip && Chartist.plugins.tooltip()
      ]
    });

    // Apply bar chart animations
    try {
      console.log('Setting up bar chart animations');
      setupBarChartAnimations(chart);
    } catch (e) {
      console.error('Error setting up bar chart animations:', e);
    }
  }
});

// Define the Chartist Line chart custom element (new)
customElements.define('chartist-line', class extends HTMLElement {
  static get observedAttributes() { return ['data']; }
  connectedCallback() { this.renderChart(); }
  attributeChangedCallback() { this.renderChart(); }
  renderChart() {
    const dataAttr = this.getAttribute('data');
    if (!dataAttr) return;
    let chartData;
    try {
      chartData = JSON.parse(dataAttr);
    } catch (e) {
      this.textContent = 'Invalid chart data';
      return;
    }
    this.innerHTML = '';
    const chartDiv = document.createElement('div');
    chartDiv.style.height = '100%';
    chartDiv.style.width = '100%';
    this.appendChild(chartDiv);
    
    // Add custom CSS for series colors and enhanced styling
    const style = document.createElement('style');
    style.textContent = `
      .ct-series-a .ct-bar, .ct-series-a .ct-line, .ct-series-a .ct-point {
        stroke: #03045e !important;
        stroke-width: 3px;
      }
      .ct-series-b .ct-bar, .ct-series-b .ct-line, .ct-series-b .ct-point {
        stroke: #0077b6 !important;
        stroke-width: 3px;
      }
      .ct-series-c .ct-bar, .ct-series-c .ct-line, .ct-series-c .ct-point {
        stroke: #00b4d8 !important;
        stroke-width: 3px;
      }
      .ct-series-d .ct-bar, .ct-series-d .ct-line, .ct-series-d .ct-point {
        stroke: #48cae4 !important;
        stroke-width: 3px;
      }

      /* Enhanced point styling */
      .ct-point {
        stroke-width: 8px !important;
        fill: white !important;
        stroke-linecap: round;
      }

      /* Grid styling */
      .ct-grid {
        stroke: rgba(0,0,0,0.1) !important;
        stroke-dasharray: 2px;
      }

      /* Better label styling */
      .ct-label {
        font-size: 12px !important;
        color: #555 !important;
        fill: #555 !important;
      }

      /* Area under the line */
      .ct-area {
        fill-opacity: 0.1;
      }
    `;
    this.appendChild(style);

    const chart = new LineChart(chartDiv, chartData, {
      fullWidth: true,
      chartPadding: {
        right: 40,
        left: 20,
        top: 20,
        bottom: 20
      },
      lineSmooth: Interpolation.cardinal({
        tension: 0.2
      }),
      axisY: {
        onlyInteger: true
      },
      showPoint: true,
      plugins: [
        // No plugins currently to avoid build error
      ]
    });

    // Apply animated line drawing effect (Chartist example style)
    let seq = 0;
    const delays = 80;
    const durations = 500;

    chart.on('created', () => {
      seq = 0;
    });

    chart.on('draw', data => {
      seq++;
      if (data.type === 'line') {
        data.element.animate({
          opacity: {
            begin: seq * delays + 1000,
            dur: durations,
            from: 0,
            to: 1
          }
        });
      }
      // Optionally, you can animate points or labels here if desired
    });

    // Optionally, auto-update for demo (can be removed in production)
    let timerId: any;
    chart.on('created', () => {
      if (timerId) clearTimeout(timerId);
      timerId = setTimeout(chart.update.bind(chart), 12000);
    });

    // Apply line chart animations
    try {
      console.log('Setting up line chart animations');
      setupLineChartAnimations(chart);
    } catch (e) {
      console.error('Error setting up line chart animations:', e);
    }
  }
});

// Define the Chartist Funnel chart custom element
customElements.define('chartist-funnel', class extends HTMLElement {
  static get observedAttributes() { return ['data']; }
  connectedCallback() { this.renderChart(); }
  attributeChangedCallback() { this.renderChart(); }
  renderChart() {
    const dataAttr = this.getAttribute('data');
    if (!dataAttr) return;
    let chartData;
    try {
      chartData = JSON.parse(dataAttr);
    } catch (e) {
      this.textContent = 'Invalid chart data';
      return;
    }
    
    this.innerHTML = '';
    
    // Custom parent container for better layout control
    const chartContainer = document.createElement('div');
    chartContainer.className = 'funnel-chart-container';
    chartContainer.style.height = '100%';
    chartContainer.style.width = '100%';
    chartContainer.style.display = 'flex';
    chartContainer.style.flexDirection = 'column';
    chartContainer.style.justifyContent = 'space-between';
    this.appendChild(chartContainer);
    
    // Add custom CSS with improved styling and animations
    const style = document.createElement('style');
    style.textContent = `
      .funnel-chart-container {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        padding: 10px 20px;
        height: 100%;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
      }
      .funnel-bar {
        height: 35px;
        border-radius: 4px;
        margin: 10px 0;
        position: relative;
        overflow: visible;
        transition: width 0.8s cubic-bezier(0.22, 0.61, 0.36, 1), opacity 0.6s ease;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        opacity: 1;
        transform-origin: left center;
      }
      .funnel-bar-label {
        position: absolute;
        left: -140px;
        width: 130px;
        text-align: right;
        font-size: 14px;
        font-weight: 500;
        line-height: 35px;
        color: #333;
        transition: opacity 0.4s ease, transform 0.5s ease;
      }
      .funnel-bar-value {
        position: absolute;
        right: -45px;
        font-size: 14px;
        font-weight: 500;
        line-height: 35px;
        color: #666;
        transition: opacity 0.4s ease, transform 0.5s ease;
      }
      .funnel-bar-quotes-sent {
        background-color: #03045e;
        background-image: linear-gradient(to right, #03045e, #073286);
      }
      .funnel-bar-quotes-viewed {
        background-color: #0077b6;
        background-image: linear-gradient(to right, #0077b6, #0091d9);
      }
      .funnel-bar-health-completed {
        background-color: #48cae4;
        background-image: linear-gradient(to right, #48cae4, #79ddf2);
      }
    `;
    this.appendChild(style);
    
    // For a clean funnel visualization, create custom HTML bars
    if (chartData && chartData.labels && chartData.series) {
      console.log('Funnel chart data:', chartData);

      // Extract values from the chartData
      // Each series should be a single data point from the most recent data
      let values = [];

      // Try to extract values from series in the correct format
      if (Array.isArray(chartData.series)) {
        if (chartData.series.length === 1 && Array.isArray(chartData.series[0])) {
          // Format: { series: [[v1, v2, v3, v4]] }
          values = chartData.series[0].map((v: any) => parseFloat(v) || 0);
        } else if (chartData.series.length > 0 && Array.isArray(chartData.series[0]) && chartData.series[0].length === 1) {
          // Format: { series: [[v1], [v2], [v3], [v4]] }
          values = chartData.series.map((s: any[]) => parseFloat(s[0]) || 0);
        } else {
          // Format: { series: [v1, v2, v3, v4] }
          values = chartData.series.map((v: any) => parseFloat(v) || 0);
        }
      }

      // Ensure we have 4 values
      while (values.length < 4) values.push(0);
      values = values.slice(0, 4);

      console.log('Funnel values:', values);

      // Find the max value for scaling
      // Use square root scaling for a less steep drop-off
      const scale = (v: number) => Math.sqrt(v);
      const maxScaled = Math.max(...values.map(scale), 1);

      // Define custom bar data with actual values - in reverse order for proper funnel flow
      // Health Completed (smallest) at the top, Quotes Sent (largest) at the bottom
      const barData = [
        { label: 'Health Completed', class: 'funnel-bar-health-completed', value: values[3] || 0, display: Math.round(values[3] || 0) },
        { label: 'Quotes Viewed', class: 'funnel-bar-quotes-viewed', value: values[1] || 0, display: Math.round(values[1] || 0) },
        { label: 'Quotes Sent', class: 'funnel-bar-quotes-sent', value: values[0] || 0, display: Math.round(values[0] || 0) }
      ];

      // Container for better spacing
      const innerContainer = document.createElement('div');
      innerContainer.style.paddingLeft = '140px'; // Space for labels
      innerContainer.style.paddingRight = '60px'; // Space for values
      innerContainer.style.width = '100%';
      innerContainer.style.position = 'relative';
      chartContainer.appendChild(innerContainer);

      // Create a bar for each item
      barData.forEach(item => {
        const barContainer = document.createElement('div');
        barContainer.style.display = 'flex';
        barContainer.style.alignItems = 'center';
        barContainer.style.position = 'relative';
        barContainer.style.marginBottom = '25px';

        const barLabel = document.createElement('div');
        barLabel.className = 'funnel-bar-label';
        barLabel.textContent = item.label;
        barLabel.style.opacity = '0'; // Hide initially for animation
        barLabel.style.transform = 'translateY(10px)'; // Position for animation
        barContainer.appendChild(barLabel);

        const bar = document.createElement('div');
        bar.className = `funnel-bar ${item.class}`;

        // Scale the width based on value (relative to max value) using sqrt scaling
        const percentage = Math.max(15, (scale(item.value) / maxScaled) * 100);
        const percentageStr = `${percentage}%`;

        // Store the original width for animation purposes, but start with 0 width for animation
        bar.setAttribute('data-original-width', percentageStr);
        bar.style.width = '0%';  // Start with width 0 for animation
        bar.style.opacity = '0'; // Start hidden for smooth animation

        // Add the value as text inside the bar if it's large enough
        if (percentage > 15) {
          bar.style.color = 'white';
          bar.style.paddingLeft = '12px';
          bar.style.display = 'flex';
          bar.style.alignItems = 'center';
          bar.textContent = item.display.toString();
        }

        // Add a separate value label outside the bar
        const valueLabel = document.createElement('div');
        valueLabel.className = 'funnel-bar-value';
        valueLabel.textContent = item.display.toString();
        valueLabel.style.opacity = '0'; // Hide initially for animation
        valueLabel.style.transform = 'translateY(10px)'; // Position for animation
        barContainer.appendChild(valueLabel);

        barContainer.appendChild(bar);
        innerContainer.appendChild(barContainer);
      });

      // Apply animation to the funnel chart after rendering
      // Use a small timeout to ensure DOM is fully ready
      setTimeout(() => {
        animateFunnelChart(innerContainer);
      }, 50);
    }
  }
});

// Define the Activity Gauge custom element
customElements.define('activity-gauge', class extends HTMLElement {
  static get observedAttributes() { return ['data']; }
  connectedCallback() { this.renderChart(); }
  attributeChangedCallback() { this.renderChart(); }

  renderChart() {
    const dataAttr = this.getAttribute('data');
    if (!dataAttr) return;
    let chartDataFromElm;
    try {
      chartDataFromElm = JSON.parse(dataAttr);
    } catch (e) {
      this.textContent = 'Invalid chart data';
      console.error('Error parsing activity gauge data:', e);
      return;
    }

    this.innerHTML = '';
    const chartDiv = document.createElement('div');
    chartDiv.style.height = '100%';
    chartDiv.style.width = '100%';
    this.appendChild(chartDiv);

    const style = document.createElement('style');
    style.textContent = `
      .ct-series-a .ct-slice-donut {
        stroke: #03045e !important; /* Emails Sent */
      }
      .ct-series-b .ct-slice-donut {
        stroke: #0077b6 !important; /* Links Clicked */
      }
      .ct-series-c .ct-slice-donut {
        stroke: #48cae4 !important; /* Health Completed */
      }
      .ct-label {
        font-size: 14px !important;
        fill: #333 !important;
        text-anchor: middle;
      }
      .activity-gauge-center-text {
        font-size: 20px;
        font-weight: bold;
        fill: #03045e;
        text-anchor: middle;
      }
    `;
    this.appendChild(style);

    const emailsSent = chartDataFromElm.emailsSent || 0;
    const linksClicked = chartDataFromElm.linksClicked || 0;
    const healthCompleted = chartDataFromElm.healthCompleted || 0;

    const series = [emailsSent, linksClicked, healthCompleted];
    const sumOfSeries = series.reduce((a, b) => a + b, 0);

    if (sumOfSeries === 0) {
      this.textContent = 'No activity data to display.';
      this.style.display = 'flex';
      this.style.alignItems = 'center';
      this.style.justifyContent = 'center';
      this.style.height = '100%';
      this.style.color = '#888'; // Example style for the message
      this.style.fontSize = '16px';
      return;
    }

    new PieChart(chartDiv, {
      series: series,
      labels: ['Emails Sent', 'Links Clicked', 'Health Completed'] 
    }, {
      donut: true,
      donutWidth: 40,
      startAngle: 270, // Start from the top
      total: sumOfSeries * 2, // Ensures a 180-degree semi-circle representing the sum
      showLabel: false,
      chartPadding: 5, // Optional padding
      // Removed the problematic plugins section
    });
  }
});


// add chartist donut chart here
/*
simple example
import 'chartist/dist/index.css';
import { PieChart } from 'chartist';

new PieChart(
  '#chart',
  {
    series: [20, 10, 30, 40]
  },
  {
    donut: true,
    donutWidth: 60,
    startAngle: 270,
    total: 200,
    showLabel: false
  }
);

*/


const root = document.querySelector('#app');
if (!root) {
  console.error('Could not find root element');
  throw new Error('Could not find root element');
}

// Initialize Elm app
try {
  console.log('Initializing Elm application...');
  
  if (!Elm) {
    throw new Error('Elm object is not defined');
  }
  
  if (!Elm.Main) {
    throw new Error('Elm.Main is not defined. Make sure the Elm application is correctly compiled.');
  }
  
  if (typeof Elm.Main.init !== 'function') {
    throw new Error('Elm.Main.init is not a function. The Elm application might not be correctly compiled.');
  }
  
  console.log('Elm available:', !!Elm);
  console.log('Elm.Main available:', !!Elm.Main);
  console.log('Elm.Main.init available:', !!(Elm.Main && typeof Elm.Main.init === 'function'));
  
  const app = Elm.Main.init({
    node: root  
  });
  
  (window as any).elmApp = app;
  (window as any).elmDebug = Elm;
  
  console.log('app.ports', app.ports);

  // Setup IntersectionObserver for phone section
  if (app.ports && app.ports.viewingPhone) {
    setTimeout(() => {
      const phoneSection = document.getElementById('phone-experience-section')
      
      if (phoneSection) {
        console.log('Found phone section, setting up IntersectionObserver')
        
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              console.log('Phone section is now visible')
              app.ports.viewingPhone.send(true)
            } else {
              console.log('Phone section is no longer visible')
              app.ports.viewingPhone.send(false)
            }
          })
        }, {
          threshold: 0.2
        })
        
        observer.observe(phoneSection)
      } else {
        console.warn('Could not find phone section for carousel')
      }
    }, 1000)
  }

  // Get org slug
  if (app.ports && app.ports.getOrgSlug) {
    app.ports.getOrgSlug.subscribe(() => {
      app.ports.receiveOrgSlug.send("")
    })
  }
    
  // Copy to clipboard
  if (app.ports && app.ports.copyToClipboard) {
    app.ports.copyToClipboard.subscribe((text: string) => {
      console.log('Copying to clipboard:', text.substring(0, 20) + '...')
      try {
        navigator.clipboard.writeText(text)
          .then(() => {
            console.log('Text copied to clipboard')
            if (app.ports.onCopyResult) {
              app.ports.onCopyResult.send(true)
            }
          })
          .catch((error) => {
            console.error('Failed to copy text to clipboard:', error)
            if (app.ports.onCopyResult) {
              app.ports.onCopyResult.send(false)
            }
          })
      } catch (error) {
        console.error('Clipboard API not available:', error)
        if (app.ports.onCopyResult) {
          app.ports.onCopyResult.send(false)
        }
      }
    })
  }

  // Listen for payment completion from stripe-checkout
  document.addEventListener('payment-completed', (e: any) => {
    if (app.ports && app.ports.paymentCompleted) {
      console.log('Sending payment completion status to Elm via port:', e.detail.status);
      app.ports.paymentCompleted.send(e.detail.status);
    }
  });

} catch (error) {
  console.error('Error initializing Elm application:', error);
  
  if (root) {
    root.innerHTML = `
      <div style="max-width: 800px; margin: 50px auto; padding: 20px; font-family: sans-serif; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 5px;">
        <h1 style="color: #721c24;">Elm Initialization Error</h1>
        <p style="margin-bottom: 20px; font-size: 16px;">There was a problem initializing the application:</p>
        <pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; overflow: auto; max-height: 300px;">${error}</pre>
        <p style="margin-top: 20px; font-size: 14px;">Try refreshing the page or clearing your browser cache.</p>
        <button onclick="window.location.reload()" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;">Refresh Page</button>
      </div>
    `;
  }
}

================
File: frontend/src/MyIcon.elm
================
module MyIcon exposing (..)

import Svg exposing (Svg, rect, svg)
import Svg.Attributes exposing (..)


zapOff : Int -> String -> Svg msg
zapOff size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M10.513 4.856 13.12 2.17a.5.5 0 0 1 .86.46l-1.377 4.317" ] []
        , Svg.path [ d "M15.656 10H20a1 1 0 0 1 .78 1.63l-1.72 1.773" ] []
        , Svg.path [ d "M16.273 16.273 10.88 21.83a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14H4a1 1 0 0 1-.78-1.63l4.507-4.643" ] []
        , Svg.path [ d "m2 2 20 20" ] []
        ]


zap : Int -> String -> Svg msg
zap size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z" ] []
        ]


heartPulse size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z" ] []
        , Svg.path [ d "M3.22 12H9.5l.5-1 2 4.5 2-7 1.5 3.5h5.27" ] []
        ]


stethoscope : Int -> String -> Svg msg
stethoscope size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M11 2v2" ] []
        , Svg.path [ d "M5 2v2" ] []
        , Svg.path [ d "M5 3H4a2 2 0 0 0-2 2v4a6 6 0 0 0 12 0V5a2 2 0 0 0-2-2h-1" ] []
        , Svg.path [ d "M8 15a6 6 0 0 0 12 0v-3" ] []
        , Svg.circle [ cx "20", cy "10", r "2" ] []
        ]


syringe : Int -> String -> Svg msg
syringe size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "m18 2 4 4" ] []
        , Svg.path [ d "m17 7 3-3" ] []
        , Svg.path [ d "M19 9 8.7 19.3c-1 1-2.5 1-3.4 0l-.6-.6c-1-1-1-2.5 0-3.4L15 5" ] []
        , Svg.path [ d "m9 11 4 4" ] []
        , Svg.path [ d "m5 19-3 3" ] []
        , Svg.path [ d "m14 4 6 6" ] []
        ]


lungs : Int -> String -> Svg msg
lungs size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M10 10v.2A3 3 0 0 1 8.9 16H5a3 3 0 0 1-1-5.8V10a3 3 0 0 1 6 0Z" ] []
        , Svg.path [ d "M7 16v6" ] []
        , Svg.path [ d "M13 19v3" ] []
        , Svg.path [ d "M12 19h8.3a1 1 0 0 0 .7-1.7L18 14h.3a1 1 0 0 0 .7-1.7L16 9h.2a1 1 0 0 0 .8-1.7L13 3l-1.4 1.5" ] []
        ]


droplets : Int -> String -> Svg msg
droplets size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M7 16.3c2.2 0 4-1.83 4-4.05 0-1.16-.57-2.26-1.71-3.19S7.29 6.75 7 5.3c-.29 1.45-1.14 2.84-2.29 3.76S3 11.1 3 12.25c0 2.22 1.8 4.05 4 4.05z" ] []
        , Svg.path [ d "M12.56 6.6A10.97 10.97 0 0 0 14 3.02c.5 2.5 2 4.9 4 6.5s3 3.5 3 5.5a6.98 6.98 0 0 1-11.91 4.97" ] []
        ]


brain : Int -> String -> Svg msg
brain size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z" ] []
        , Svg.path [ d "M12 5a3 3 0 1 1 5.997.125 4 4 0 0 1 2.526 5.77 4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z" ] []
        , Svg.path [ d "M15 13a4.5 4.5 0 0 1-3-4 4.5 4.5 0 0 1-3 4" ] []
        , Svg.path [ d "M17.599 6.5a3 3 0 0 0 .399-1.375" ] []
        , Svg.path [ d "M6.003 5.125A3 3 0 0 0 6.401 6.5" ] []
        , Svg.path [ d "M3.477 10.896a4 4 0 0 1 .585-.396" ] []
        , Svg.path [ d "M19.938 10.5a4 4 0 0 1 .585.396" ] []
        , Svg.path [ d "M6 18a4 4 0 0 1-1.967-.516" ] []
        , Svg.path [ d "M19.967 17.484A4 4 0 0 1 18 18" ] []
        ]


building2 : Int -> String -> Svg msg
building2 size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z" ] []
        , Svg.path [ d "M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2" ] []
        , Svg.path [ d "M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2" ] []
        , Svg.path [ d "M10 6h4" ] []
        , Svg.path [ d "M10 10h4" ] []
        , Svg.path [ d "M10 14h4" ] []
        , Svg.path [ d "M10 18h4" ] []
        ]


activity : Int -> String -> Svg msg
activity size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2" ] []
        ]


heartScan : Int -> String -> Svg msg
heartScan size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M11.246 16.657a1 1 0 0 0 1.508 0l3.57-4.101A2.75 2.75 0 1 0 12 9.168a2.75 2.75 0 1 0-4.324 3.388z" ] []
        , Svg.path [ d "M17 3h2a2 2 0 0 1 2 2v2" ] []
        , Svg.path [ d "M21 17v2a2 2 0 0 1-2 2h-2" ] []
        , Svg.path [ d "M3 7V5a2 2 0 0 1 2-2h2" ] []
        , Svg.path [ d "M7 21H5a2 2 0 0 1-2-2v-2" ] []
        ]


hospital : Int -> String -> Svg msg
hospital size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M12 6v4" ] []
        , Svg.path [ d "M14 14h-4" ] []
        , Svg.path [ d "M14 18h-4" ] []
        , Svg.path [ d "M14 8h-4" ] []
        , Svg.path [ d "M18 12h2a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-9a2 2 0 0 1 2-2h2" ] []
        , Svg.path [ d "M18 22V4a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v18" ] []
        ]


squareActivity : Int -> String -> Svg msg
squareActivity size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ rect [ width "18", height "18", x "3", y "3", rx "2" ] []
        , Svg.path [ d "M17 12h-2l-2 5-2-10-2 5H7" ] []
        ]


clipboardPlus : Int -> String -> Svg msg
clipboardPlus size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.rect [ width "8", height "4", x "8", y "2", rx "1", ry "1" ] []
        , Svg.path [ d "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" ] []
        , Svg.path [ d "M9 14h6" ] []
        , Svg.path [ d "M12 17v-6" ] []
        ]


clipboardList : Int -> String -> Svg msg
clipboardList size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.rect [ width "8", height "4", x "8", y "2", rx "1", ry "1" ] []
        , Svg.path [ d "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" ] []
        , Svg.path [ d "M12 11h4" ] []
        , Svg.path [ d "M12 16h4" ] []
        , Svg.path [ d "M8 11h.01" ] []
        , Svg.path [ d "M8 16h.01" ] []
        ]


users : Int -> String -> Svg msg
users size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" ] []
        , Svg.circle [ cx "9", cy "7", r "4" ] []
        , Svg.path [ d "M22 21v-2a4 4 0 0 0-3-3.87" ] []
        , Svg.path [ d "M16 3.13a4 4 0 0 1 0 7.75" ] []
        ]


brand : Int -> String -> Svg msg
brand size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.rect [ width "3", height "8", x "13", y "2", rx "1.5" ] []
        , Svg.path [ d "M19 8.5V10h1.5A1.5 1.5 0 1 0 19 8.5" ] []
        , Svg.rect [ width "3", height "8", x "8", y "14", rx "1.5" ] []
        , Svg.path [ d "M5 15.5V14H3.5A1.5 1.5 0 1 0 5 15.5" ] []
        , Svg.rect [ width "8", height "3", x "14", y "13", rx "1.5" ] []
        , Svg.path [ d "M15.5 19H14v1.5a1.5 1.5 0 1 0 1.5-1.5" ] []
        , Svg.rect [ width "8", height "3", x "2", y "8", rx "1.5" ] []
        , Svg.path [ d "M8.5 5H10V3.5A1.5 1.5 0 1 0 8.5 5" ] []
        ]


undo2 size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M9 14 4 9l5-5" ] []
        , Svg.path [ d "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11" ] []
        ]


calendarDays : Int -> String -> Svg msg
calendarDays size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M8 2v4" ] []
        , Svg.path [ d "M16 2v4" ] []
        , Svg.rect [ width "18", height "18", x "3", y "4", rx "2" ] []
        , Svg.path [ d "M3 10h18" ] []
        , Svg.path [ d "M8 14h.01" ] []
        , Svg.path [ d "M12 14h.01" ] []
        , Svg.path [ d "M16 14h.01" ] []
        , Svg.path [ d "M8 18h.01" ] []
        , Svg.path [ d "M12 18h.01" ] []
        , Svg.path [ d "M16 18h.01" ] []
        ]


phoneOutgoing : Int -> String -> Svg msg
phoneOutgoing size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.polyline [ points "22 8 22 2 16 2" ] []
        , Svg.line [ x1 "16", x2 "22", y1 "8", y2 "2" ] []
        , Svg.path [ d "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z" ] []
        ]


phoneIncoming : Int -> String -> Svg msg
phoneIncoming size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.polyline [ points "16 2 16 8 22 8" ] []
        , Svg.line [ x1 "22", x2 "16", y1 "2", y2 "8" ] []
        , Svg.path [ d "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z" ] []
        ]


clipboardPaste : Int -> String -> Svg msg
clipboardPaste size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z" ] []
        , Svg.path [ d "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10" ] []
        , Svg.path [ d "m17 10 4 4-4 4" ] []
        ]



-- home page


lightning : Int -> String -> Svg msg
lightning size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M13 2L4.09347 12.6879C3.74466 13.1064 3.57026 13.3157 3.56759 13.4925C3.56528 13.6461 3.63375 13.7923 3.75327 13.8889C3.89076 14 4.16319 14 4.70805 14H12L11 22L19.9066 11.3121C20.2554 10.8936 20.4298 10.6843 20.4324 10.5075C20.4348 10.3539 20.3663 10.2077 20.2468 10.1111C20.1093 10 19.8368 10 19.292 10H12L13 2Z" ] []
        ]


envelope : Int -> String -> Svg msg
envelope size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 25 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M2.33334 7L10.4983 12.7154C11.1594 13.1783 11.49 13.4097 11.8496 13.4993C12.1672 13.5785 12.4994 13.5785 12.8171 13.4993C13.1767 13.4097 13.5073 13.1783 14.1684 12.7154L22.3333 7M7.13334 20H17.5333C19.2135 20 20.0536 20 20.6953 19.673C21.2598 19.3854 21.7187 18.9265 22.0064 18.362C22.3333 17.7202 22.3333 16.8802 22.3333 15.2V8.8C22.3333 7.11984 22.3333 6.27976 22.0064 5.63803C21.7187 5.07354 21.2598 4.6146 20.6953 4.32698C20.0536 4 19.2135 4 17.5333 4H7.13334C5.45319 4 4.61311 4 3.97137 4.32698C3.40689 4.6146 2.94794 5.07354 2.66032 5.63803C2.33334 6.27976 2.33334 7.11984 2.33334 8.8V15.2C2.33334 16.8802 2.33334 17.7202 2.66032 18.362C2.94794 18.9265 3.40689 19.3854 3.97137 19.673C4.61311 20 5.45319 20 7.13334 20Z" ] []
        ]


brightArrow : Int -> String -> Svg msg
brightArrow size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 25 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M11.6666 3H8.46663C6.78647 3 5.94639 3 5.30465 3.32698C4.74017 3.6146 4.28123 4.07354 3.99361 4.63803C3.66663 5.27976 3.66663 6.11984 3.66663 7.8V16.2C3.66663 17.8802 3.66663 18.7202 3.99361 19.362C4.28123 19.9265 4.74017 20.3854 5.30465 20.673C5.94639 21 6.78647 21 8.46663 21H16.8666C18.5468 21 19.3869 21 20.0286 20.673C20.5931 20.3854 21.052 19.9265 21.3396 19.362C21.6666 18.7202 21.6666 17.8802 21.6666 16.2V13M12.6666 8H16.6666V12M16.1666 3.5V2M20.106 4.56066L21.1666 3.5M21.1769 8.5H22.6769M3.66663 13.3471C4.31857 13.4478 4.9865 13.5 5.66663 13.5C10.053 13.5 13.932 11.3276 16.2863 8" ] []
        ]


chatBubbles : Int -> String -> Svg msg
chatBubbles size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M6.09436 11.2288C6.03221 10.8282 5.99996 10.4179 5.99996 10C5.99996 5.58172 9.60525 2 14.0526 2C18.4999 2 22.1052 5.58172 22.1052 10C22.1052 10.9981 21.9213 11.9535 21.5852 12.8345C21.5154 13.0175 21.4804 13.109 21.4646 13.1804C21.4489 13.2512 21.4428 13.301 21.4411 13.3735C21.4394 13.4466 21.4493 13.5272 21.4692 13.6883L21.8717 16.9585C21.9153 17.3125 21.9371 17.4895 21.8782 17.6182C21.8266 17.731 21.735 17.8205 21.6211 17.8695C21.4911 17.9254 21.3146 17.8995 20.9617 17.8478L17.7765 17.3809C17.6101 17.3565 17.527 17.3443 17.4512 17.3448C17.3763 17.3452 17.3245 17.3507 17.2511 17.3661C17.177 17.3817 17.0823 17.4172 16.893 17.4881C16.0097 17.819 15.0524 18 14.0526 18C13.6344 18 13.2237 17.9683 12.8227 17.9073M7.63158 22C10.5965 22 13 19.5376 13 16.5C13 13.4624 10.5965 11 7.63158 11C4.66668 11 2.26316 13.4624 2.26316 16.5C2.26316 17.1106 2.36028 17.6979 2.53955 18.2467C2.61533 18.4787 2.65322 18.5947 2.66566 18.6739C2.67864 18.7567 2.68091 18.8031 2.67608 18.8867C2.67145 18.9668 2.65141 19.0573 2.61134 19.2383L2 22L4.9948 21.591C5.15827 21.5687 5.24 21.5575 5.31137 21.558C5.38652 21.5585 5.42641 21.5626 5.50011 21.5773C5.5701 21.5912 5.67416 21.6279 5.88227 21.7014C6.43059 21.8949 7.01911 22 7.63158 22Z" ] []
        ]


smilieyChat : Int -> String -> Svg msg
smilieyChat size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M8.99962 14C8.99962 14 10.3121 15.5 12.4996 15.5C14.6871 15.5 15.9996 14 15.9996 14M15.2496 9H15.2596M9.74962 9H9.75962M12.4996 20C17.194 20 20.9996 16.1944 20.9996 11.5C20.9996 6.80558 17.194 3 12.4996 3C7.8052 3 3.99962 6.80558 3.99962 11.5C3.99962 12.45 4.15547 13.3636 4.443 14.2166C4.55119 14.5376 4.60529 14.6981 4.61505 14.8214C4.62469 14.9432 4.6174 15.0286 4.58728 15.1469C4.55677 15.2668 4.48942 15.3915 4.35472 15.6408L2.71906 18.6684C2.48575 19.1002 2.36909 19.3161 2.3952 19.4828C2.41794 19.6279 2.50337 19.7557 2.6288 19.8322C2.7728 19.9201 3.01692 19.8948 3.50517 19.8444L8.62619 19.315C8.78127 19.299 8.85881 19.291 8.92949 19.2937C8.999 19.2963 9.04807 19.3029 9.11586 19.3185C9.18478 19.3344 9.27145 19.3678 9.44478 19.4345C10.3928 19.7998 11.4228 20 12.4996 20ZM15.7496 9C15.7496 9.27614 15.5258 9.5 15.2496 9.5C14.9735 9.5 14.7496 9.27614 14.7496 9C14.7496 8.72386 14.9735 8.5 15.2496 8.5C15.5258 8.5 15.7496 8.72386 15.7496 9ZM10.2496 9C10.2496 9.27614 10.0258 9.5 9.74962 9.5C9.47348 9.5 9.24962 9.27614 9.24962 9C9.24962 8.72386 9.47348 8.5 9.74962 8.5C10.0258 8.5 10.2496 8.72386 10.2496 9Z" ] []
        ]


commandKey : Int -> String -> Svg msg
commandKey size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M9 9V6C9 4.34315 7.65685 3 6 3C4.34315 3 3 4.34315 3 6C3 7.65685 4.34315 9 6 9H9ZM9 9V15M9 9H15M9 15V18C9 19.6569 7.65685 21 6 21C4.34315 21 3 19.6569 3 18C3 16.3431 4.34315 15 6 15H9ZM9 15H15M15 15H18C19.6569 15 21 16.3431 21 18C21 19.6569 19.6569 21 18 21C16.3431 21 15 19.6569 15 18V15ZM15 15V9M15 9V6C15 4.34315 16.3431 3 18 3C19.6569 3 21 4.34315 21 6C21 7.65685 19.6569 9 18 9H15Z" ] []
        ]


heartBubble : Int -> String -> Svg msg
heartBubble size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M20.9996 11.5C20.9996 16.1944 17.194 20 12.4996 20C11.4228 20 10.3928 19.7998 9.44478 19.4345C9.27145 19.3678 9.18478 19.3344 9.11586 19.3185C9.04807 19.3029 8.999 19.2963 8.92949 19.2937C8.85881 19.291 8.78127 19.299 8.62619 19.315L3.50517 19.8444C3.01692 19.8948 2.7728 19.9201 2.6288 19.8322C2.50337 19.7557 2.41794 19.6279 2.3952 19.4828C2.36909 19.3161 2.48575 19.1002 2.71906 18.6684L4.35472 15.6408C4.48942 15.3915 4.55677 15.2668 4.58728 15.1469C4.6174 15.0286 4.62469 14.9432 4.61505 14.8214C4.60529 14.6981 4.55119 14.5376 4.443 14.2166C4.15547 13.3636 3.99962 12.45 3.99962 11.5C3.99962 6.80558 7.8052 3 12.4996 3C17.194 3 20.9996 6.80558 20.9996 11.5Z" ] []
        , Svg.path [ d "M12.4965 8.94925C11.5968 7.9104 10.0965 7.63095 8.96924 8.58223C7.84196 9.5335 7.68326 11.124 8.56851 12.2491C9.11696 12.9461 10.4935 14.2191 11.4616 15.087C11.8172 15.4057 11.995 15.5651 12.2084 15.6293C12.3914 15.6844 12.6017 15.6844 12.7847 15.6293C12.9981 15.5651 13.1759 15.4057 13.5315 15.087C14.4996 14.2191 15.8761 12.9461 16.4246 12.2491C17.3098 11.124 17.1705 9.5235 16.0238 8.58223C14.8772 7.64096 13.3963 7.9104 12.4965 8.94925Z" ] []
        ]


circleMinus : Int -> String -> Svg msg
circleMinus size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M8 12H16M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" ] []
        ]


circlePlus : Int -> String -> Svg msg
circlePlus size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M12 10V18M8 14H16M22 14C22 19.5228 17.5228 24 12 24C6.47715 24 2 19.5228 2 14C2 8.47715 6.47715 4 12 4C17.5228 4 22 8.47715 22 14Z" ] []
        ]


maxLogo : Int -> String -> Svg msg
maxLogo size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 246 34"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M28.0608 2.05762C27.5512 1.90329 27.0107 1.82031 26.4509 1.82031H11.6131L21.1611 19.295L28.0608 2.05762Z", fill "white" ] []
        , Svg.path [ d "M5.27168 1.82713C2.33588 1.97181 0 4.3998 0 7.37378V18.0748C0.63094 18.0398 1.35488 18.0179 2.21965 18.0179C2.95641 18.0179 3.383 17.8859 3.63477 17.7535C3.86366 17.6332 4.0932 17.4384 4.3236 17.0378C4.86375 16.0985 5.27168 14.2768 5.27168 10.9835V1.82713Z", fill "white" ] []
        , Svg.path [ d "M0 23.6386V26.6258C0 29.6929 2.48443 32.1793 5.54913 32.1793H21.8764L10.8108 11.9272C10.7435 15.0062 10.3224 17.7398 9.13305 19.808C8.43859 21.0155 7.47738 22.0066 6.21494 22.6702C4.97538 23.3217 3.61007 23.5714 2.21965 23.5714C1.31899 23.5714 0.609185 23.5976 0 23.6386Z", fill "white" ] []
        , Svg.path [ d "M21.9817 32.1793H26.4509C29.5156 32.1793 32 29.6929 32 26.6258V7.37378C32 7.30239 31.9987 7.23132 31.996 7.16059L21.9817 32.1793Z", fill "white" ] []
        , Svg.path [ d "M42.24 29V9.008H48.652L53.104 22.364H53.188L57.64 9.008H64.08V29H59.376V17.296H59.236C59.068 17.968 58.844 18.808 58.48 19.816L55.288 29H51.06L47.868 19.816C47.504 18.808 47.252 17.968 47.112 17.296H46.972V29H42.24ZM75.46 29.42C70.616 29.42 66.892 25.724 66.892 21.132C66.892 16.568 70.616 12.984 75.46 12.984C80.332 12.984 84.028 16.792 84.028 21.524C84.028 21.86 84 22.448 83.972 22.756H71.932C72.184 24.352 73.668 24.94 75.516 24.94C76.832 24.94 77.924 24.632 78.428 23.596H83.72C82.712 27.068 79.52 29.42 75.46 29.42ZM72.1 19.536H78.736C78.54 18.668 77.308 17.464 75.376 17.464C73.444 17.464 72.24 18.5 72.1 19.536ZM92.6798 29.42C88.6198 29.42 85.5678 25.78 85.5678 21.216C85.5678 16.624 88.6198 12.984 92.6798 12.984C95.0598 12.984 97.1038 14.16 97.9718 15.812H98.1118V9.008H102.928V29H98.2518V26.76H98.1118C96.6838 28.832 94.7798 29.42 92.6798 29.42ZM94.0798 24.94C96.2638 24.94 97.5518 23.4 97.5518 21.216C97.5518 19.004 96.2638 17.464 94.0798 17.464C91.8678 17.464 90.6918 19.004 90.6918 21.216C90.6918 23.4 91.8678 24.94 94.0798 24.94ZM108.923 11.36C107.439 11.36 106.235 10.156 106.235 8.672C106.235 7.216 107.439 6.012 108.923 6.012C110.379 6.012 111.583 7.216 111.583 8.672C111.583 10.156 110.379 11.36 108.923 11.36ZM106.515 28.944V13.404H111.331V28.944H106.515ZM121.965 29.364C117.401 29.364 113.677 25.668 113.677 21.076C113.677 16.512 117.401 12.816 121.965 12.816C124.345 12.816 126.501 13.824 128.013 15.42L124.905 18.556C124.261 17.8 123.309 17.324 121.965 17.324C120.033 17.324 118.493 18.892 118.493 21.076C118.493 23.288 120.033 24.856 121.965 24.856C123.197 24.856 124.065 24.464 124.709 23.82L127.817 26.956C126.305 28.468 124.261 29.364 121.965 29.364ZM135.534 29.42C131.222 29.42 128.142 25.78 128.142 21.216C128.142 16.624 131.222 12.984 135.534 12.984C137.942 12.984 139.846 14.16 140.714 15.812H140.854V13.404H145.53V29H140.854V26.76H140.714C139.286 28.832 137.662 29.42 135.534 29.42ZM136.654 24.94C138.866 24.94 140.154 23.4 140.154 21.216C140.154 19.004 138.866 17.464 136.654 17.464C134.47 17.464 133.266 19.004 133.266 21.216C133.266 23.4 134.47 24.94 136.654 24.94ZM149.144 29V13.404H158.524V17.884H153.96V29H149.144ZM167.937 29.42C163.093 29.42 159.369 25.724 159.369 21.132C159.369 16.568 163.093 12.984 167.937 12.984C172.809 12.984 176.505 16.792 176.505 21.524C176.505 21.86 176.477 22.448 176.449 22.756H164.409C164.661 24.352 166.145 24.94 167.993 24.94C169.309 24.94 170.401 24.632 170.905 23.596H176.197C175.189 27.068 171.997 29.42 167.937 29.42ZM164.577 19.536H171.213C171.017 18.668 169.785 17.464 167.853 17.464C165.921 17.464 164.717 18.5 164.577 19.536ZM185.029 29V9.008H191.441L195.893 22.364H195.977L200.429 9.008H206.869V29H202.165V17.296H202.025C201.857 17.968 201.633 18.808 201.269 19.816L198.077 29H193.849L190.657 19.816C190.293 18.808 190.041 17.968 189.901 17.296H189.761V29H185.029ZM217.073 29.42C212.761 29.42 209.681 25.78 209.681 21.216C209.681 16.624 212.761 12.984 217.073 12.984C219.481 12.984 221.385 14.16 222.253 15.812H222.393V13.404H227.069V29H222.393V26.76H222.253C220.825 28.832 219.201 29.42 217.073 29.42ZM218.193 24.94C220.405 24.94 221.693 23.4 221.693 21.216C221.693 19.004 220.405 17.464 218.193 17.464C216.009 17.464 214.805 19.004 214.805 21.216C214.805 23.4 216.009 24.94 218.193 24.94ZM228.611 29L234.071 20.992L228.835 13.404H234.575L236.703 17.044L238.831 13.404H244.571L239.335 20.992L244.795 29H239.111L236.703 25.024L234.323 29H228.611Z", fill "white" ] []
        ]


chevronDown : Int -> String -> Svg msg
chevronDown size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "m6 9 6 6 6-6" ] []
        ]


chevronLeft : Int -> String -> Svg msg
chevronLeft size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "m15 18-6-6 6-6" ] []
        ]


chevronRight : Int -> String -> Svg msg
chevronRight size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "m9 18 6-6-6-6" ] []
        ]


banknote : Int -> String -> Svg msg
banknote size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.rect [ x "2", y "6", width "20", height "12", rx "2" ] []
        , Svg.circle [ cx "12", cy "12", r "2" ] []
        , Svg.path [ d "M6 12h.01M18 12h.01" ] []
        ]


purpleIcon : Int -> String -> Svg msg
purpleIcon size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 22 22"
        , fill "none"
        ]
        [ Svg.path
            [ d "M11 21C16.5228 21 21 16.5228 21 11C21 5.47715 16.5228 1 11 1C5.47715 1 1 5.47715 1 11C1 16.5228 5.47715 21 11 21Z"
            , fill color
            ]
            []
        , Svg.path
            [ d "M11 15V11M11 7H11.01M21 11C21 16.5228 16.5228 21 11 21C5.47715 21 1 16.5228 1 11C1 5.47715 5.47715 1 11 1C16.5228 1 21 5.47715 21 11Z"
            , stroke "#F9F5FF"
            , strokeWidth "2"
            , strokeLinecap "round"
            , strokeLinejoin "round"
            ]
            []
        ]


phone : Int -> String -> Svg msg
phone size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384" ] []
        ]


mapPin : Int -> String -> Svg msg
mapPin size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "M18 8c0 3.613-3.869 7.429-5.393 8.795a1 1 0 0 1-1.214 0C9.87 15.429 6 11.613 6 8a6 6 0 0 1 12 0" ] []
        , Svg.circle [ cx "12", cy "8", r "2" ] []
        , Svg.path [ d "M8.714 14h-3.71a1 1 0 0 0-.948.683l-2.004 6A1 1 0 0 0 3 22h18a1 1 0 0 0 .948-1.316l-2-6a1 1 0 0 0-.949-.684h-3.712" ] []
        ]


clock : Int -> String -> Svg msg
clock size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.circle [ cx "12", cy "12", r "10" ] []
        , Svg.polyline [ points "12 6 12 12 16 14" ] []
        ]


mail size color =
    svg
        [ width (String.fromInt size)
        , height (String.fromInt size)
        , viewBox "0 0 24 24"
        , fill "none"
        , stroke color
        , strokeWidth "2"
        , strokeLinecap "round"
        , strokeLinejoin "round"
        ]
        [ Svg.path [ d "m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7" ] []
        , Svg.rect [ x "2", y "4", width "20", height "16", rx "2" ] []
        ]

================
File: frontend/src/Onboarding.elm
================
port module Onboarding exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import CarrierNaic exposing (Carrier(..), allCarriers, carrierToString)
import Dict exposing (Dict)
import File exposing (File)
import File.Select as Select
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import MyIcon
import Process
import Task
import Url exposing (Url)
import Url.Builder exposing (absolute, int, string)
import Url.Parser.Query as Query
import Utils.UrlStuff exposing (getQueryParams)



-- PORTS


port paymentCompleted : (PaymentResponse -> msg) -> Sub msg


port checkoutCompleted : (CheckoutData -> msg) -> Sub msg


port checkoutError : (ErrorData -> msg) -> Sub msg



-- MODEL


showStripe : Bool
showStripe =
    False


type alias PaymentResponse =
    { success : Bool
    , message : String
    , paymentCompleted : Bool
    }


type alias CheckoutData =
    { email : String
    , firstName : String
    , lastName : String
    , stripeCustomerId : String
    , stripeSubscriptionId : String
    , stripeUsageItemId : String
    }


type alias ErrorData =
    { success : Bool
    , message : String
    }



-- Moved these type definitions before Model for correct Elm compilation order


type
    EmailStatus
    -- Copied from Signup.elm
    = NotChecked
    | Checking
    | Available
    | AlreadyRegistered String
    | InvalidFormat


type alias
    EmailCheckResponse
    -- Copied from Signup.elm
    =
    { available : Bool
    , message : String
    }


type alias Model =
    { user : User
    , frame : Int
    , companyName : String
    , companyPhone : String
    , companyWebsite : String
    , primaryColor : String
    , secondaryColor : String
    , logo : Maybe String
    , uploadingLogo : Bool
    , hover : Bool
    , key : Nav.Key
    , selectedCarriers : List Carrier
    , useSmartSend : Bool
    , agents : List Agent
    , showAgentForm : Bool
    , newAgentFirstName : String
    , newAgentLastName : String
    , newAgentEmail : String
    , newAgentPhone : String
    , newAgentIsAdmin : Bool
    , loadingResumeData : Bool
    , paymentStatus : PaymentStatus
    , publishableKey : Maybe String
    , priceId : Maybe String
    , agentEmailDebounceCounter : Int -- Added for new agent email check
    , newAgentEmailStatus : EmailStatus -- Added for new agent email check
    , savingAgents : Bool -- Added for saving agents state
    , agentSaveError : Maybe String -- Added for agent save error messages
    }


type alias StripeProduct =
    { publishableKey : String
    , priceId : String
    }


type PaymentStatus
    = ReadyToComplete
    | Continuing
    | Error ApiError
    | Loading
    | Success SubscriptionStatus
    | PaymentProcessing
    | PaymentCompleted


type ApiError
    = NetworkError
    | BadStatus Int String
    | BadPayload String
    | BadUrl String
    | Timeout


type alias SubscriptionStatus =
    { isActive : Bool
    , tier : String
    , currentPeriodEnd : Maybe Int
    , cancelAtPeriodEnd : Maybe Bool
    , paymentStatus : String
    }


type alias Agent =
    { firstName : String
    , lastName : String
    , email : String
    , phone : String
    , isAdmin : Bool
    }


maxFrame : Int
maxFrame =
    4


dummyUser : User
dummyUser =
    { firstName = "John"
    , lastName = "Doe"
    , email = "john.doe@example.com"
    , phone = ""
    }


type alias User =
    { firstName : String
    , lastName : String
    , email : String
    , phone : String
    }


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    let
        -- Filter out non-digit characters
        digitsOnly =
            String.filter Char.isDigit phone

        -- Limit to 10 digits
        limitedDigits =
            String.left 10 digitsOnly

        -- Format the phone number as needed
        formattedPhone =
            if String.length limitedDigits == 10 then
                "(" ++ String.left 3 limitedDigits ++ ") " ++ String.slice 3 6 limitedDigits ++ "-" ++ String.slice 6 10 limitedDigits

            else if String.length limitedDigits >= 7 then
                "(" ++ String.left 3 limitedDigits ++ ") " ++ String.slice 3 6 limitedDigits ++ "-" ++ String.slice 6 10 limitedDigits

            else if String.length limitedDigits >= 4 then
                "(" ++ String.left 3 limitedDigits ++ ") " ++ String.slice 3 10 limitedDigits

            else if String.length limitedDigits > 0 then
                "(" ++ limitedDigits

            else
                ""
    in
    formattedPhone


init : Nav.Key -> Url -> ( Model, Cmd Msg )
init key url =
    let
        queryParams =
            url |> getQueryParams

        firstName =
            Dict.get "firstName" queryParams

        lastName =
            Dict.get "lastName" queryParams

        email =
            Dict.get "email" queryParams

        phone =
            Dict.get "phone" queryParams
                |> Maybe.andThen Url.percentDecode
                |> Maybe.withDefault ""

        organizationName =
            Dict.get "organizationName" queryParams
                |> Maybe.andThen Url.percentDecode
                |> Maybe.withDefault ""

        frame =
            case Dict.get "frame" queryParams of
                Just f ->
                    case String.toInt f of
                        Just i ->
                            Basics.clamp 1 maxFrame i

                        Nothing ->
                            1

                Nothing ->
                    1

        maybeUser =
            case ( firstName, lastName, email ) of
                ( Just f, Just l, Just e ) ->
                    Just { firstName = f, lastName = l, email = e, phone = phone |> formatPhoneNumber }

                _ ->
                    Nothing

        currentUser =
            maybeUser |> Maybe.withDefault dummyUser

        initialAgents =
            [ { firstName = currentUser.firstName
              , lastName = currentUser.lastName
              , email = currentUser.email
              , phone = currentUser.phone
              , isAdmin = True -- Make the initial user an admin by default
              }
            ]

        initialModel =
            { user = currentUser
            , frame = frame
            , companyName = organizationName
            , companyPhone = currentUser.phone
            , companyWebsite = ""
            , primaryColor = "#6B46C1"
            , secondaryColor = "#9F7AEA"
            , logo = Nothing
            , uploadingLogo = False
            , hover = False
            , key = key
            , selectedCarriers = []
            , useSmartSend = True
            , agents = initialAgents
            , showAgentForm = False
            , newAgentFirstName = ""
            , newAgentLastName = ""
            , newAgentEmail = ""
            , newAgentPhone = ""
            , newAgentIsAdmin = True
            , loadingResumeData = False
            , paymentStatus = Loading
            , publishableKey = Nothing
            , priceId = Nothing
            , agentEmailDebounceCounter = 0
            , newAgentEmailStatus = NotChecked
            , savingAgents = False
            , agentSaveError = Nothing
            }

        -- Check if this is a direct page load with frame > 1
        isDirectLoadWithHigherFrame =
            frame > 1 && (url.path == "/onboarding")

        redirectCommand =
            case maybeUser of
                Just user ->
                    Cmd.batch
                        [ fetchResumeData user.email
                        , fetchStripeProduct
                        ]

                Nothing ->
                    Nav.pushUrl key "/signup"

        ( baseModel, baseCmds ) =
            ( { initialModel | loadingResumeData = maybeUser /= Nothing }, redirectCommand )
    in
    ( baseModel, baseCmds )



-- UPDATE


type Msg
    = NoOp
    | CompanyNameChanged String
    | PhoneChanged String
    | WebsiteChanged String
    | PrimaryColorChanged String
    | SecondaryColorChanged String
    | UploadLogo
    | DragEnter
    | DragLeave
    | GotFiles File (List File)
    | GotLogo File
    | GotLogoUrl String
    | ContinueClicked
    | BackClicked
    | ToggleCarrier Carrier
    | ToggleSmartSend
    | ToggleAllCarriers
    | ShowAgentForm
    | HideAgentForm
    | AgentFirstNameChanged String
    | AgentLastNameChanged String
    | AgentEmailChanged String
    | AgentPhoneChanged String
    | AgentIsAdminToggled Bool
    | AddAgent
    | CompanyDetailsSaved (Result Http.Error SaveResponse)
    | LicensingSaved (Result Http.Error SaveResponse)
    | AgentsSaved (Result Http.Error SaveResponse)
    | GotResumeData (Result Http.Error ResumeData)
    | OnboardingLoginCompleted (Result Http.Error OnboardingLoginResponse)
    | PaymentSaved (Result Http.Error SaveResponse)
    | GotSubscriptionStatus (Result Http.Error SubscriptionStatus)
    | PaymentProcessed (Result Http.Error PaymentResponse)
    | PaymentCompletedFromPort PaymentResponse
    | RefreshPage
    | CheckoutCompletedFromPort CheckoutData
    | CheckoutErrorFromPort ErrorData
    | ProcessCheckoutData CheckoutData
    | ResponseStripeProduct (Result Http.Error StripeProduct)
    | DebounceNewAgentEmailCheck Int
    | GotNewAgentEmailCheckResponse Int (Result Http.Error EmailCheckResponse)


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        CompanyNameChanged name ->
            ( { model | companyName = name }, Cmd.none )

        PhoneChanged phone ->
            ( { model | companyPhone = formatPhoneNumber phone }, Cmd.none )

        WebsiteChanged website ->
            ( { model | companyWebsite = website }, Cmd.none )

        PrimaryColorChanged color ->
            ( { model | primaryColor = color }, Cmd.none )

        SecondaryColorChanged color ->
            ( { model | secondaryColor = color }, Cmd.none )

        UploadLogo ->
            ( model, Select.file [ "image/png" ] GotLogo )

        DragEnter ->
            ( { model | hover = True }, Cmd.none )

        DragLeave ->
            ( { model | hover = False }, Cmd.none )

        GotFiles file files ->
            ( { model | hover = False, uploadingLogo = True }, Task.perform GotLogoUrl (File.toUrl file) )

        GotLogo file ->
            ( { model | uploadingLogo = True }, Task.perform GotLogoUrl (File.toUrl file) )

        GotLogoUrl url ->
            ( { model | logo = Just url, uploadingLogo = False }, Cmd.none )

        ContinueClicked ->
            case model.frame of
                4 ->
                    case model.paymentStatus of
                        Success status ->
                            if status.isActive then
                                ( { model | frame = model.frame + 1 }
                                , completeOnboardingLogin model.user.email
                                )

                            else
                                ( { model | paymentStatus = PaymentProcessing }
                                , checkPaymentStatus model.user.email
                                )

                        PaymentCompleted ->
                            ( { model | frame = model.frame + 1 }
                            , completeOnboardingLogin model.user.email
                            )

                        _ ->
                            ( model, Cmd.none )

                1 ->
                    if String.isEmpty model.companyName || String.isEmpty model.companyPhone then
                        ( model, Cmd.none )

                    else
                        ( { model | loadingResumeData = True }
                        , Cmd.batch
                            [ saveCompanyDetails model
                            ]
                        )

                2 ->
                    if List.isEmpty model.selectedCarriers then
                        ( model, Cmd.none )

                    else
                        ( { model | frame = model.frame + 1 }
                        , saveLicensingSettings model
                        )

                3 ->
                    ( { model | savingAgents = True, agentSaveError = Nothing }
                    , saveAgents model
                    )

                _ ->
                    ( model, Cmd.none )

        BackClicked ->
            let
                newFrame =
                    Basics.max 1 (model.frame - 1)
            in
            ( { model | frame = newFrame }
            , Nav.pushUrl model.key (buildUrl model newFrame)
            )

        ToggleCarrier carrier ->
            let
                newSelectedCarriers =
                    if List.member carrier model.selectedCarriers then
                        List.filter (\c -> c /= carrier) model.selectedCarriers

                    else
                        carrier :: model.selectedCarriers
            in
            ( { model | selectedCarriers = newSelectedCarriers }, Cmd.none )

        ToggleSmartSend ->
            ( { model | useSmartSend = not model.useSmartSend }, Cmd.none )

        ToggleAllCarriers ->
            let
                newSelectedCarriers =
                    if List.length model.selectedCarriers == List.length allCarriers then
                        []

                    else
                        allCarriers
            in
            ( { model | selectedCarriers = newSelectedCarriers }, Cmd.none )

        ShowAgentForm ->
            ( { model | showAgentForm = True, agentSaveError = Nothing }, Cmd.none )

        HideAgentForm ->
            ( { model
                | showAgentForm = False
                , newAgentFirstName = ""
                , newAgentLastName = ""
                , newAgentEmail = ""
                , newAgentPhone = ""
                , newAgentIsAdmin = True
                , newAgentEmailStatus = NotChecked
                , agentEmailDebounceCounter = 0
                , agentSaveError = Nothing
              }
            , Cmd.none
            )

        AgentFirstNameChanged firstName ->
            ( { model | newAgentFirstName = firstName, agentSaveError = Nothing }, Cmd.none )

        AgentLastNameChanged lastName ->
            ( { model | newAgentLastName = lastName, agentSaveError = Nothing }, Cmd.none )

        AgentEmailChanged email ->
            let
                newCounter =
                    model.agentEmailDebounceCounter + 1

                newEmailStatus =
                    if String.isEmpty email then
                        NotChecked

                    else if not (isValidEmailFormat email) then
                        InvalidFormat

                    else
                        Checking

                updatedModel =
                    { model
                        | newAgentEmail = email
                        , newAgentEmailStatus = newEmailStatus
                        , agentEmailDebounceCounter = newCounter
                        , agentSaveError = Nothing
                    }
            in
            ( updatedModel
            , if newEmailStatus == Checking then
                debounceNewAgentEmailCheck newCounter

              else
                Cmd.none
            )

        AgentPhoneChanged phone ->
            ( { model | newAgentPhone = formatPhoneNumber phone, agentSaveError = Nothing }, Cmd.none )

        AgentIsAdminToggled isAdmin ->
            ( { model | newAgentIsAdmin = True }, Cmd.none )

        AddAgent ->
            let
                newAgent =
                    { firstName = model.newAgentFirstName
                    , lastName = model.newAgentLastName
                    , email = model.newAgentEmail
                    , phone = model.newAgentPhone
                    , isAdmin = True -- Keep the field value as True for consistency
                    }

                isValid =
                    not (String.isEmpty (String.trim model.newAgentFirstName))
                        && not (String.isEmpty (String.trim model.newAgentLastName))
                        && not (String.isEmpty (String.trim model.newAgentEmail))
                        && model.newAgentEmailStatus
                        == Available
            in
            if isValid then
                ( { model
                    | agents = model.agents ++ [ newAgent ]
                    , showAgentForm = False
                    , newAgentFirstName = ""
                    , newAgentLastName = ""
                    , newAgentEmail = ""
                    , newAgentPhone = ""
                    , newAgentIsAdmin = True
                    , newAgentEmailStatus = NotChecked
                    , agentEmailDebounceCounter = 0
                    , agentSaveError = Nothing
                  }
                , Cmd.none
                )

            else
                ( model, Cmd.none )

        CompanyDetailsSaved result ->
            case result of
                Ok response ->
                    if response.success then
                        -- Move to frame 2 and clear loading state
                        ( { model | frame = 2, loadingResumeData = False }
                        , Nav.pushUrl model.key (buildUrl { model | frame = 2 } 2)
                        )

                    else
                        -- Failed to save but stay on current page
                        ( { model | loadingResumeData = False }, Cmd.none )

                Err _ ->
                    -- Error saving but stay on current page
                    ( { model | loadingResumeData = False }, Cmd.none )

        LicensingSaved result ->
            case result of
                Ok response ->
                    if response.success then
                        ( model, Nav.pushUrl model.key (buildUrl model 3) )

                    else
                        -- Failed to save, redirect to signup
                        ( model, Nav.pushUrl model.key "/signup" )

                Err _ ->
                    -- Error saving, redirect to signup
                    ( model, Nav.pushUrl model.key "/signup" )

        AgentsSaved result ->
            case result of
                Ok response ->
                    if response.success then
                        let
                            modelAfterSave =
                                { model
                                    | frame = 4
                                    , savingAgents = False
                                    , agentSaveError = Nothing
                                    , paymentStatus = ReadyToComplete
                                }
                        in
                        ( modelAfterSave
                        , Cmd.none
                        )

                    else
                        -- Server indicated failure
                        ( { model | savingAgents = False, agentSaveError = Just response.message }
                        , Cmd.none
                        )

                Err httpError ->
                    -- Network or other HTTP error
                    ( { model | savingAgents = False, agentSaveError = Just (apiErrorToString (httpErrorToApiError httpError)) }
                    , Cmd.none
                    )

        GotResumeData result ->
            case result of
                Ok resumeData ->
                    if resumeData.onboardingComplete then
                        -- Onboarding is complete, redirect to login
                        ( model, Nav.load "/login" )

                    else if resumeData.success then
                        -- Update model with resumed data
                        let
                            -- Convert carrier strings to Carrier type
                            selectedCarriers =
                                resumeData.carrierSettings.selectedCarriers
                                    |> List.filterMap
                                        (\carrierStr ->
                                            allCarriers
                                                |> List.filter (\c -> carrierToString c == carrierStr)
                                                |> List.head
                                        )

                            -- Create agents list with the current user marked as admin if not in list
                            updatedAgents =
                                if List.isEmpty resumeData.agents then
                                    model.agents

                                else
                                    resumeData.agents
                        in
                        ( { model
                            | loadingResumeData = False
                            , companyName = resumeData.organization.name |> Url.percentDecode |> Maybe.withDefault resumeData.organization.name
                            , companyPhone = resumeData.organization.phone
                            , companyWebsite = resumeData.organization.website
                            , primaryColor = resumeData.organization.primaryColor
                            , secondaryColor = resumeData.organization.secondaryColor
                            , logo = resumeData.organization.logo
                            , selectedCarriers = selectedCarriers
                            , useSmartSend = resumeData.carrierSettings.useSmartSend
                            , agents = updatedAgents
                          }
                        , Cmd.none
                        )

                    else
                        -- Failed to get resume data, redirect to signup if not on frame 1
                        ( { model | loadingResumeData = False }
                        , if model.frame > 1 then
                            Nav.pushUrl model.key "/signup"

                          else
                            Cmd.none
                        )

                Err _ ->
                    -- Error fetching resume data, redirect to signup if not on frame 1
                    ( { model | loadingResumeData = False }
                    , if model.frame > 1 then
                        Nav.pushUrl model.key "/signup"

                      else
                        Cmd.none
                    )

        OnboardingLoginCompleted result ->
            case result of
                Ok response ->
                    if response.success then
                        ( model
                        , Nav.load response.redirectUrl
                        )

                    else
                        ( { model | loadingResumeData = False }
                        , Nav.pushUrl model.key "/signup"
                        )

                Err _ ->
                    ( { model | loadingResumeData = False }
                    , Nav.pushUrl model.key "/signup"
                    )

        PaymentSaved result ->
            case result of
                Ok response ->
                    if response.success then
                        ( model, Cmd.none )

                    else
                        -- Failed to save, redirect to signup
                        ( model, Nav.pushUrl model.key "/signup" )

                Err _ ->
                    -- Error saving, redirect to signup
                    ( model, Nav.pushUrl model.key "/signup" )

        GotSubscriptionStatus result ->
            case result of
                Ok status ->
                    ( { model | paymentStatus = Success status }, Cmd.none )

                Err httpError ->
                    -- Changed from _ to httpError to use it
                    ( { model | paymentStatus = Error (httpErrorToApiError httpError) }, Cmd.none )

        PaymentProcessed result ->
            case result of
                Ok response ->
                    if response.success then
                        ( { model | paymentStatus = PaymentCompleted }
                        , Cmd.batch
                            [ completeOnboardingLogin model.user.email
                            , fetchSubscriptionStatus
                            ]
                        )

                    else
                        ( { model | paymentStatus = Error (BadPayload "Payment processing failed. Please try again.") }
                        , Cmd.none
                        )

                Err _ ->
                    ( { model | paymentStatus = Error NetworkError }
                    , Cmd.none
                    )

        PaymentCompletedFromPort response ->
            if response.success then
                ( { model | paymentStatus = PaymentCompleted }
                , Cmd.batch
                    [ completeOnboardingLogin model.user.email
                    , fetchSubscriptionStatus
                    ]
                )

            else
                ( { model | paymentStatus = Error (BadPayload "Payment processing failed. Please try again.") }
                , Cmd.none
                )

        CheckoutCompletedFromPort checkoutData ->
            ( model, processCheckoutData checkoutData )

        CheckoutErrorFromPort errorData ->
            ( { model | paymentStatus = Error (BadPayload errorData.message) }, Cmd.none )

        ProcessCheckoutData checkoutData ->
            ( { model | paymentStatus = PaymentProcessing }
            , completePayment checkoutData
            )

        RefreshPage ->
            ( model, Nav.reload )

        ResponseStripeProduct (Ok stripeProduct) ->
            ( { model
                | publishableKey = Just stripeProduct.publishableKey
                , priceId = Just stripeProduct.priceId
              }
            , Cmd.none
            )

        ResponseStripeProduct (Err _) ->
            ( model, Cmd.none )

        DebounceNewAgentEmailCheck counter ->
            if counter == model.agentEmailDebounceCounter && model.newAgentEmailStatus == Checking then
                ( model, checkNewAgentEmailAvailability counter model.newAgentEmail )

            else
                ( model, Cmd.none )

        GotNewAgentEmailCheckResponse counter result ->
            if counter /= model.agentEmailDebounceCounter then
                -- Ignore outdated responses
                ( model, Cmd.none )

            else
                case result of
                    Ok response ->
                        ( { model
                            | newAgentEmailStatus =
                                if response.available then
                                    Available

                                else
                                    AlreadyRegistered response.message
                          }
                        , Cmd.none
                        )

                    Err _ ->
                        -- Optionally handle the error, e.g., set to NotChecked or a specific error state
                        ( { model | newAgentEmailStatus = NotChecked }, Cmd.none )



-- Calculate the price based on the number of contacts


calculatePrice : Int -> Int
calculatePrice contacts =
    let
        basePrice =
            60

        -- Base price for up to 500 contacts
        additionalTiers =
            Basics.max 0 (ceiling (toFloat (Basics.max 0 (contacts - 500)) / 500))

        additionalPrice =
            additionalTiers * 40

        -- $40 for each additional 500 contacts
    in
    basePrice + additionalPrice



-- Helper function to check if carriers are selected


hasSelectedCarriers : Model -> Bool
hasSelectedCarriers model =
    not (List.isEmpty model.selectedCarriers)



-- Calculate revenue based on contacts, average age, and rollover percent
-- Handle navigation if needed
-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Onboarding"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex flex-col items-center py-12 px-4 sm:px-6 lg:px-8" ]
            [ div [ class "flex flex-col items-center w-full mb-8" ]
                [ img [ src "/images/medicare-max-logo.png", class "h-10 w-auto" ] [] ]
            , if model.loadingResumeData then
                -- Show loading indicator when resuming data
                div [ class "max-w-6xl w-full space-y-8 bg-white p-8 rounded-lg shadow-md flex flex-col items-center justify-center min-h-[400px]" ]
                    [ div [ class "animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-700 mb-4" ] []
                    , p [ class "text-gray-600 text-center" ] [ text "Loading your settings..." ]
                    ]

              else
                div [ class "max-w-6xl w-full space-y-8 bg-white p-8 rounded-lg shadow-md" ]
                    [ case model.frame of
                        1 ->
                            viewCompany model

                        2 ->
                            viewLicensing model

                        3 ->
                            viewAddAgents model

                        4 ->
                            viewPayment model

                        _ ->
                            viewCompany model
                    , viewProgressDots model.frame
                    ]
            ]
        ]
    }


viewCompany : Model -> Html Msg
viewCompany model =
    div [ class "flex flex-col items-center" ]
        [ div [ class "text-center mb-8 w-full" ]
            [ h2 [ class "text-3xl font-semibold text-gray-900 mb-2" ] [ text "Company Settings" ]
            , p [ class "text-gray-500" ] [ text "Upload your logo and set your brand color." ]
            ]
        , div [ class "w-full max-w-md space-y-8 bg-white p-6 rounded-lg shadow-sm" ]
            [ div [ class "space-y-2" ]
                [ label [ class "block text-sm font-medium text-gray-700", for "company-name" ] [ text "Company Name" ]
                , input
                    [ class "block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                    , id "company-name"
                    , type_ "text"
                    , placeholder "Your Company Name"
                    , value model.companyName
                    , onInput CompanyNameChanged
                    ]
                    []
                ]
            , div [ class "flex space-x-4" ]
                [ div [ class "w-1/2 space-y-2" ]
                    [ label [ class "block text-sm font-medium text-gray-700", for "phone" ] [ text "Phone" ]
                    , input
                        [ class "block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        , id "phone"
                        , type_ "tel"
                        , placeholder "(555) 555-5555"
                        , value model.companyPhone
                        , onInput PhoneChanged
                        ]
                        []
                    ]
                , div [ class "w-1/2 space-y-2" ]
                    [ label [ class "block text-sm font-medium text-gray-700", for "website" ] [ text "Website" ]
                    , div [ class "flex rounded-md shadow-sm" ]
                        [ span [ class "inline-flex items-center px-3 rounded-l-md border border-r-0 border-gray-300 bg-gray-50 text-gray-500 text-sm" ]
                            [ text "https://" ]
                        , input
                            [ class "block w-full flex-1 rounded-none rounded-r-md border border-gray-300 px-3 py-2 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                            , id "website"
                            , type_ "text"
                            , placeholder "www.example.com"
                            , value model.companyWebsite
                            , onInput WebsiteChanged
                            ]
                            []
                        ]
                    ]
                ]
            , div
                [ class
                    ("mt-8 p-6 border rounded-lg border-dashed text-center cursor-pointer transition-colors "
                        ++ (if model.hover then
                                "border-indigo-600 bg-indigo-50"

                            else
                                "border-gray-200 hover:bg-gray-50"
                           )
                    )
                , onClick UploadLogo
                , hijackOn "dragenter" (Decode.succeed DragEnter)
                , hijackOn "dragover" (Decode.succeed DragEnter)
                , hijackOn "dragleave" (Decode.succeed DragLeave)
                , hijackOn "drop" dropDecoder
                ]
                [ case model.logo of
                    Just logoUrl ->
                        div [ class "flex flex-col items-center" ]
                            [ img
                                [ src logoUrl
                                , class "h-20 w-20 object-contain mb-4"
                                ]
                                []
                            , div [ class "text-indigo-600 font-medium" ] [ text "Change logo" ]
                            ]

                    Nothing ->
                        if model.uploadingLogo then
                            div [ class "flex flex-col items-center" ]
                                [ div [ class "animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-indigo-500 mb-4" ] []
                                , div [ class "text-gray-500" ] [ text "Uploading..." ]
                                ]

                        else
                            div [ class "flex flex-col items-center" ]
                                [ div [ class "rounded-full bg-gray-100 p-3 mb-3" ]
                                    [ MyIcon.clipboardList 24 "#6366F1" ]
                                , div [ class "text-indigo-600 font-medium" ] [ text "Click to upload" ]
                                , div [ class "text-gray-500 text-sm mt-1" ] [ text "or drag and drop your logo" ]
                                , div [ class "text-gray-400 text-xs mt-2" ] [ text "PNG only (Recommended: 240px width x 60px height)" ]
                                ]
                ]

            {--
            , div [ class "space-y-4 mt-8" ]
                [ div [ class "space-y-2" ]
                    [ label [ class "block text-sm font-medium text-gray-700" ] [ text "Primary Brand Color" ]
                    , div [ class "flex items-center space-x-4" ]
                        [ input
                            [ type_ "color"
                            , class "w-10 h-10 p-0 border-0 rounded-md cursor-pointer"
                            , value model.primaryColor
                            , onInput PrimaryColorChanged
                            ]
                            []
                        , div [ class "text-sm text-gray-500" ] [ text "Click to change colors" ]
                        ]
                    ]
                , div [ class "space-y-2 mt-4" ]
                    [ label [ class "block text-sm font-medium text-gray-700" ] [ text "Secondary Brand Color" ]
                    , div [ class "flex items-center space-x-4" ]
                        [ input
                            [ type_ "color"
                            , class "w-10 h-10 p-0 border-0 rounded-md cursor-pointer"
                            , value model.secondaryColor
                            , onInput SecondaryColorChanged
                            ]
                            []
                        , div [ class "text-sm text-gray-500" ] [ text "Click to change colors" ]
                        ]
                    ]
                ]
            --}
            ]
        , div [ class "mt-10 w-full max-w-md" ]
            [ case model.agentSaveError of
                Just err ->
                    div [ class "mb-4 p-3 bg-red-50 border border-red-200 rounded-md text-sm text-red-700" ]
                        [ text err ]

                Nothing ->
                    text ""
            , button
                [ classList
                    [ ( "w-full bg-[#03045e] text-white py-3 px-4 rounded-md hover:bg-[#02034e] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 font-medium", True )
                    , ( "opacity-50 cursor-not-allowed", model.savingAgents ) -- Disable if saving
                    ]
                , onClick ContinueClicked
                , disabled model.savingAgents -- Disable if saving
                ]
                [ if model.savingAgents then
                    text "Saving..."

                  else
                    text "Continue"
                ]
            ]
        ]


viewProgressDots : Int -> Html Msg
viewProgressDots currentFrame =
    let
        frames =
            List.range 1 maxFrame

        isActive frame =
            frame == currentFrame

        backButton =
            if currentFrame > 1 then
                div [ class "cursor-pointer w-10 flex justify-center items-center", onClick BackClicked ]
                    [ MyIcon.chevronLeft 32 "#4B5563" ]

            else
                div [ class "cursor-not-allowed w-10 flex justify-center items-center" ]
                    [ MyIcon.chevronLeft 32 "#E5E7EB" ]

        rightButton =
            div [ class "cursor-not-allowed w-10 flex justify-center items-center" ]
                [ MyIcon.chevronRight 32 "#E5E7EB" ]

        dots =
            List.map
                (\frame ->
                    div
                        [ class
                            (if isActive frame then
                                "w-2 h-2 rounded-full bg-indigo-600"

                             else
                                "w-2 h-2 rounded-full bg-gray-300"
                            )
                        ]
                        []
                )
                frames
    in
    div [ class "flex justify-center items-center mt-8" ]
        [ backButton
        , div [ class "flex justify-center space-x-2" ] dots
        , rightButton
        ]


viewLicensing : Model -> Html Msg
viewLicensing model =
    div [ class "flex flex-col items-center" ]
        [ h2 [ class "text-2xl font-semibold text-gray-900 mt-6" ] [ text "Carrier Information" ]
        , p [ class "text-gray-500 mt-2 mb-6" ] [ text "Tell us about your carrier relationships." ]
        , div [ class "w-full max-w-md space-y-6" ]
            [ div [ class "space-y-4" ]
                [ h3 [ class "text-xl font-medium text-gray-800" ] [ text "Carrier Contracts" ]
                , div [ class "mt-4 space-y-2 bg-gray-50 rounded-md p-4" ]
                    [ div [ class "flex items-center mb-3" ]
                        [ div [ class "flex items-center h-5" ]
                            [ input
                                [ type_ "checkbox"
                                , class "h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                , checked (List.length model.selectedCarriers == List.length allCarriers)
                                , onClick ToggleAllCarriers
                                , id "select-all-carriers"
                                ]
                                []
                            ]
                        , div [ class "ml-3 text-sm" ]
                            [ label
                                [ class "font-medium text-gray-700 cursor-pointer"
                                , for "select-all-carriers"
                                ]
                                [ text "Select All Carriers" ]
                            ]
                        ]
                    , div [ class "grid grid-cols-2 gap-2" ]
                        (List.map
                            (\carrier ->
                                let
                                    carrierId =
                                        "carrier-" ++ (carrierToString carrier |> String.toLower |> String.replace " " "-")
                                in
                                div [ class "flex items-center" ]
                                    [ div [ class "flex items-center h-5" ]
                                        [ input
                                            [ type_ "checkbox"
                                            , class "h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                            , checked (List.member carrier model.selectedCarriers)
                                            , onClick (ToggleCarrier carrier)
                                            , id carrierId
                                            ]
                                            []
                                        ]
                                    , div [ class "ml-3 text-sm" ]
                                        [ label
                                            [ class "font-medium text-gray-700 cursor-pointer"
                                            , for carrierId
                                            ]
                                            [ text (carrierToString carrier) ]
                                        ]
                                    ]
                            )
                            allCarriers
                        )
                    ]
                ]
            , div [ class "space-y-4 mt-6" ]
                [ h3 [ class "text-xl font-medium text-gray-800" ] [ text "Guaranteed Issue Settings" ]
                , div [ class "flex items-start p-4 bg-blue-50 rounded-md border border-blue-200" ]
                    [ div [ class "flex items-center h-5 mt-1" ]
                        [ input
                            [ class "h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                            , type_ "checkbox"
                            , id "smart-send"
                            , checked model.useSmartSend
                            , onClick ToggleSmartSend
                            ]
                            []
                        ]
                    , div [ class "ml-3" ]
                        [ label
                            [ class "font-medium text-gray-700 cursor-pointer"
                            , for "smart-send"
                            ]
                            [ text "Use SmartSend for Guaranteed Issue" ]
                        , p [ class "text-gray-600 text-sm mt-1" ]
                            [ text "When enabled, SmartSend will automatically avoid sending quotes to individuals in no-commission windows (for example, right before their birthday in Birthday Rule states)." ]
                        ]
                    ]
                ]
            , div [ class "w-full flex mt-8" ]
                [ button
                    [ class
                        (if hasSelectedCarriers model then
                            "w-full bg-[#03045e] text-white py-2 px-4 rounded-md hover:bg-[#02034e] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"

                         else
                            "w-full bg-[#03045e]/70 text-white py-2 px-4 rounded-md cursor-not-allowed"
                        )
                    , onClick ContinueClicked
                    , disabled (not (hasSelectedCarriers model))
                    ]
                    [ text "Continue" ]
                ]
            ]
        ]


viewAddAgents : Model -> Html Msg
viewAddAgents model =
    div [ class "flex flex-col items-center" ]
        [ div [ class "text-center mb-8 w-full" ]
            [ h2 [ class "text-3xl font-semibold text-gray-900 mb-2" ] [ text "More Team Members?" ]
            , p [ class "text-gray-500" ] [ text "Add additional agents who will be using Medicare Max" ]
            ]
        , div [ class "w-full max-w-4xl" ]
            [ div [ class "grid grid-cols-1 gap-6 mb-8" ]
                (List.map (viewAgentCard model) model.agents)
            , if model.showAgentForm then
                viewAgentForm model

              else
                div [ class "flex justify-center" ]
                    [ button
                        [ class "flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                        , onClick ShowAgentForm
                        ]
                        [ span [ class "mr-2" ] [ text "+" ]
                        , text "Add Another Agent"
                        ]
                    ]
            ]
        , div [ class "mt-10 w-full max-w-md" ]
            [ case model.agentSaveError of
                Just err ->
                    div [ class "mb-4 p-3 bg-red-50 border border-red-200 rounded-md text-sm text-red-700" ]
                        [ text err ]

                Nothing ->
                    text ""
            , button
                [ classList
                    [ ( "w-full bg-[#03045e] text-white py-3 px-4 rounded-md hover:bg-[#02034e] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 font-medium", True )
                    , ( "opacity-50 cursor-not-allowed", model.savingAgents ) -- Disable if saving
                    ]
                , onClick ContinueClicked
                , disabled model.savingAgents -- Disable if saving
                ]
                [ if model.savingAgents then
                    text "Saving..."

                  else
                    text "Continue"
                ]
            ]
        ]


viewAgentCard : Model -> Agent -> Html Msg
viewAgentCard model agent =
    let
        isCurrentUser =
            agent.email == model.user.email

        -- Decode the email address for display
        displayEmail =
            case Url.percentDecode agent.email of
                Just decoded ->
                    decoded

                Nothing ->
                    agent.email
    in
    div [ class "bg-white shadow rounded-lg p-8" ]
        -- Increased padding from p-6 to p-8
        [ div [ class "flex items-start" ]
            -- Changed from items-center to items-start
            [ div [ class "w-16 h-16 rounded-full bg-indigo-100 flex items-center justify-center text-indigo-600 font-bold text-xl" ]
                -- Increased size and font
                [ text (String.left 1 (Maybe.withDefault "" (Url.percentDecode agent.firstName)) ++ String.left 1 (Maybe.withDefault "" (Url.percentDecode agent.lastName))) ]
            , div [ class "ml-4 flex-grow" ]
                -- Added flex-grow
                [ div [ class "text-xl font-medium text-gray-900 mb-1" ]
                    -- Increased font size and added margin
                    [ text (Maybe.withDefault "" (Url.percentDecode agent.firstName) ++ " " ++ Maybe.withDefault "" (Url.percentDecode agent.lastName)) ]
                , div [ class "flex flex-col space-y-1 text-sm text-gray-500" ]
                    -- Added spacing
                    [ div [ class "break-all" ] [ text displayEmail ]
                    , div []
                        [ text
                            (if String.isEmpty agent.phone then
                                "No phone provided"

                             else
                                agent.phone
                            )
                        ]
                    ]
                ]
            ]
        , if isCurrentUser then
            div [ class "mt-4 text-xs text-gray-400 italic" ]
                [ text "Current user (you)" ]

          else
            text ""
        ]


viewAgentForm : Model -> Html Msg
viewAgentForm model =
    div [ class "bg-white shadow rounded-lg p-6 mb-6" ]
        [ div [ class "flex justify-between items-center mb-4" ]
            [ h3 [ class "text-lg font-medium text-gray-900" ]
                [ text "Add New Agent" ]
            , button
                [ class "text-gray-400 hover:text-gray-500"
                , onClick HideAgentForm
                ]
                [ text "×" ]
            ]
        , div [ class "space-y-4" ]
            [ div [ class "grid grid-cols-2 gap-4" ]
                [ div []
                    [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
                        [ text "First Name" ]
                    , input
                        [ class "shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full px-3 py-2 text-base border-gray-300 rounded-md"
                        , type_ "text"
                        , placeholder "First name"
                        , value model.newAgentFirstName
                        , onInput AgentFirstNameChanged
                        ]
                        []
                    ]
                , div []
                    [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
                        [ text "Last Name" ]
                    , input
                        [ class "shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full px-3 py-2 text-base border-gray-300 rounded-md"
                        , type_ "text"
                        , placeholder "Last name"
                        , value model.newAgentLastName
                        , onInput AgentLastNameChanged
                        ]
                        []
                    ]
                ]
            , div [ class "grid grid-cols-2 gap-4" ]
                [ div []
                    [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
                        [ text "Email" ]
                    , input
                        [ class "shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full px-3 py-2 text-base border-gray-300 rounded-md"
                        , type_ "email"
                        , placeholder "Email address"
                        , value model.newAgentEmail
                        , onInput AgentEmailChanged
                        ]
                        []
                    , viewNewAgentEmailStatusMessage model.newAgentEmailStatus
                    ]
                , div []
                    [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
                        [ text "Phone" ]
                    , input
                        [ class "shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full px-3 py-2 text-base border-gray-300 rounded-md"
                        , type_ "tel"
                        , placeholder "Phone number"
                        , value model.newAgentPhone
                        , onInput AgentPhoneChanged
                        ]
                        []
                    ]
                ]
            , div [ class "pt-4" ]
                [ button
                    [ class
                        (if
                            String.isEmpty (String.trim model.newAgentFirstName)
                                || String.isEmpty (String.trim model.newAgentLastName)
                                || String.isEmpty (String.trim model.newAgentEmail)
                                || model.newAgentEmailStatus
                                /= Available
                         then
                            "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-400 cursor-not-allowed"

                         else
                            "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                        )
                    , onClick AddAgent
                    , disabled
                        (String.isEmpty (String.trim model.newAgentFirstName)
                            || String.isEmpty (String.trim model.newAgentLastName)
                            || String.isEmpty (String.trim model.newAgentEmail)
                            || model.newAgentEmailStatus
                            /= Available
                        )
                    ]
                    [ text "Add Agent" ]
                ]
            ]
        ]


viewPayment : Model -> Html Msg
viewPayment model =
    div [ class "flex flex-col items-center" ]
        [ div [ class "text-center mb-8 w-full" ]
            [ h2 [ class "text-3xl font-semibold text-gray-900 mb-2" ] [ text "Payment Information" ]
            , p [ class "text-gray-500" ] [ text "Set up your payment method to complete your account." ]
            ]
        , div [ class "w-full max-w-md space-y-6" ]
            [ case model.paymentStatus of
                Loading ->
                    div [ class "mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md" ]
                        [ p [ class "text-blue-700" ] [ text "Loading subscription status..." ] ]

                Error apiError ->
                    div [ class "mt-4 p-3 bg-red-50 border border-red-200 rounded-md" ]
                        [ p [ class "text-red-700" ] [ text "Error" ]
                        , p [ class "mt-2 text-sm text-red-600" ]
                            [ text (apiErrorToString apiError)
                            , br [] []
                            , text "If you're using an ad blocker, please disable it for this site as it may interfere with payment processing."
                            ]
                        , div [ class "mt-4 flex justify-center" ]
                            [ button
                                [ class "px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700"
                                , onClick RefreshPage
                                ]
                                [ text "Refresh Page" ]
                            ]
                        ]

                Success status ->
                    if status.isActive then
                        div [ class "mt-4 p-3 bg-green-50 border border-green-200 rounded-md" ]
                            [ p [ class "text-green-700 font-medium" ]
                                [ text ("Active subscription: " ++ status.tier) ]
                            , case status.currentPeriodEnd of
                                Just periodEnd ->
                                    p [ class "mt-2 text-sm text-green-600" ]
                                        [ text ("Current period ends: " ++ formatUnixTimestamp periodEnd) ]

                                Nothing ->
                                    text ""
                            , case status.cancelAtPeriodEnd of
                                Just True ->
                                    p [ class "mt-2 text-sm text-yellow-600" ]
                                        [ text "Your subscription will cancel at the end of the current period" ]

                                _ ->
                                    text ""
                            ]

                    else
                        case model.priceId of
                            Just priceId ->
                                node "stripe-checkout"
                                    [ attribute "price-id" priceId

                                    --, attribute "metered-price-id" tierPriceId
                                    , attribute "first-name" model.user.firstName
                                    , attribute "last-name" model.user.lastName
                                    , attribute "email" model.user.email
                                    ]
                                    []

                            _ ->
                                div [ class "mt-4 p-3 bg-red-50 border border-red-200 rounded-md" ]
                                    [ p [ class "text-red-700" ] [ text "Error loading Stripe product IDs" ]
                                    ]

                Continuing ->
                    div [ class "mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md" ]
                        [ p [ class "text-blue-700" ] [ text "Resuming your previous setup" ]
                        , p [ class "mt-2 text-sm text-blue-600" ]
                            [ text "If the checkout doesn't appear, please disable any ad blockers for this site." ]
                        ]

                ReadyToComplete ->
                    case model.priceId of
                        Just priceId ->
                            node "stripe-checkout"
                                [ attribute "price-id" priceId

                                --, attribute "metered-price-id" tierPriceId
                                , attribute "first-name" model.user.firstName
                                , attribute "last-name" model.user.lastName
                                , attribute "email" model.user.email
                                ]
                                []

                        _ ->
                            div [ class "mt-4 p-3 bg-red-50 border border-red-200 rounded-md" ]
                                [ p [ class "text-red-700" ] [ text "Error loading Stripe product IDs" ]
                                ]

                PaymentProcessing ->
                    div [ class "mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md" ]
                        [ div [ class "animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500 mx-auto mb-4" ] []
                        , p [ class "text-blue-700 text-center" ] [ text "Processing your payment..." ]
                        ]

                PaymentCompleted ->
                    div [ class "mt-4 p-3 bg-green-50 border border-green-200 rounded-md" ]
                        [ p [ class "text-green-700 font-medium text-center" ] [ text "Payment completed successfully!" ]
                        , p [ class "mt-2 text-sm text-green-600 text-center" ] [ text "Finalizing your account setup..." ]
                        ]
            ]
        ]



-- Helper function to format Unix timestamp


formatUnixTimestamp : Int -> String
formatUnixTimestamp timestamp =
    -- Convert Unix timestamp to readable date string
    -- For now just return the raw timestamp, you can enhance this later
    String.fromInt timestamp



-- Helper function to convert API errors to strings


apiErrorToString : ApiError -> String
apiErrorToString error =
    case error of
        NetworkError ->
            "Network error occurred. Please check your connection."

        BadStatus status message ->
            "Server error: " ++ String.fromInt status ++ " - " ++ message

        BadPayload message ->
            "Failed to process server response. "
                ++ (if String.contains "JSON" message then
                        "Please try refreshing the page."

                    else
                        message
                   )

        BadUrl url ->
            "Invalid API URL: " ++ url

        Timeout ->
            "Request timed out. Please try again."



-- Helper function to convert Http.Error to ApiError


httpErrorToApiError : Http.Error -> ApiError
httpErrorToApiError httpError =
    case httpError of
        Http.BadUrl url ->
            BadUrl url

        Http.Timeout ->
            Timeout

        Http.NetworkError ->
            NetworkError

        Http.BadStatus statusCode ->
            BadStatus statusCode ("HTTP Error " ++ String.fromInt statusCode)

        -- Generic message based on status code
        Http.BadBody bodyString ->
            BadPayload bodyString



-- This is the string explaining why the body was bad
-- This is the string explaining why the body was bad
-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.batch
        [ paymentCompleted PaymentCompletedFromPort
        , checkoutCompleted CheckoutCompletedFromPort
        , checkoutError CheckoutErrorFromPort
        ]



-- Helper function to build URL with frame parameter


buildUrl : Model -> Int -> String
buildUrl model frame =
    let
        -- Determine if the email appears to be already encoded
        emailIsEncoded =
            let
                decoded =
                    Url.percentDecode model.user.email
            in
            case decoded of
                Just d ->
                    d /= model.user.email

                -- If decoding changes the value, it was encoded
                Nothing ->
                    False

        -- Invalid percent encoding, treat as not encoded
        -- Base URL parameters without email
        baseParams =
            [ int "frame" frame
            , string "firstName" model.user.firstName
            , string "lastName" model.user.lastName
            , string "phone" model.user.phone
            ]

        -- If email is already encoded, manually construct the URL to avoid re-encoding
        url =
            if emailIsEncoded then
                absolute [ "onboarding" ] baseParams ++ "&email=" ++ model.user.email

            else
                absolute [ "onboarding" ] (baseParams ++ [ string "email" model.user.email ])
    in
    url



-- Helper function to format precise money values with 2 decimal places
-- Save company details to the API


saveCompanyDetails : Model -> Cmd Msg
saveCompanyDetails model =
    Http.post
        { url = "/api/onboarding/company"
        , body =
            Http.jsonBody
                (Encode.object
                    [ ( "email", Encode.string model.user.email )
                    , ( "firstName", Encode.string model.user.firstName )
                    , ( "lastName", Encode.string model.user.lastName )
                    , ( "phone", Encode.string model.user.phone )
                    , ( "companyName", Encode.string model.companyName )
                    , ( "companyPhone", Encode.string model.companyPhone )
                    , ( "companyWebsite", Encode.string model.companyWebsite )
                    , ( "primaryColor", Encode.string model.primaryColor )
                    , ( "secondaryColor", Encode.string model.secondaryColor )
                    , ( "logo", Maybe.withDefault Encode.null (Maybe.map Encode.string model.logo) )
                    ]
                )
        , expect = Http.expectJson CompanyDetailsSaved saveResponseDecoder
        }



-- Save licensing settings to the API


saveLicensingSettings : Model -> Cmd Msg
saveLicensingSettings model =
    Http.post
        { url = "/api/onboarding/licensing"
        , body =
            Http.jsonBody
                (Encode.object
                    [ ( "email", Encode.string model.user.email )
                    , ( "selectedCarriers", Encode.list Encode.string (List.map carrierToString model.selectedCarriers) )
                    , ( "useSmartSend", Encode.bool model.useSmartSend )
                    ]
                )
        , expect = Http.expectJson LicensingSaved saveResponseDecoder
        }



-- Save agents to the API


saveAgents : Model -> Cmd Msg
saveAgents model =
    Http.post
        { url = "/api/onboarding/agents"
        , body =
            Http.jsonBody
                (Encode.object
                    [ ( "email", Encode.string model.user.email )
                    , ( "agents"
                      , Encode.list
                            (\agent ->
                                Encode.object
                                    [ ( "firstName", Encode.string agent.firstName )
                                    , ( "lastName", Encode.string agent.lastName )
                                    , ( "email", Encode.string agent.email )
                                    , ( "phone", Encode.string agent.phone )
                                    , ( "isAdmin", Encode.bool agent.isAdmin )
                                    ]
                            )
                            model.agents
                      )
                    ]
                )
        , expect = Http.expectJson AgentsSaved saveResponseDecoder
        }



-- Stripe Product


fetchStripeProduct : Cmd Msg
fetchStripeProduct =
    Http.get
        { url = "/api/subscription/pricing"
        , expect = Http.expectJson ResponseStripeProduct stripeProductDecoder
        }


stripeProductDecoder : Decoder StripeProduct
stripeProductDecoder =
    Decode.map2 StripeProduct
        (Decode.field "publishableKey" Decode.string)
        (Decode.field "priceId" Decode.string)



-- Get saved onboarding data


fetchResumeData : String -> Cmd Msg
fetchResumeData email =
    -- Use a simple HTTP request with the raw email to avoid encoding issues
    -- The plus sign in emails is problematic with URL encoding
    -- So instead of using URL Builder, we'll manually construct the URL
    -- preserving the email exactly as received
    let
        -- Use encodeUri to properly encode the email preserving the + sign
        encodedEmail =
            -- Replace + with %2B to preserve it in the URL
            email
                |> String.replace "+" "%2B"
                |> Url.percentEncode
    in
    Http.get
        { url = "/api/onboarding/resume?email=" ++ encodedEmail
        , expect = Http.expectJson GotResumeData resumeDataDecoder
        }



-- Decoder for resume data from backend


resumeDataDecoder : Decoder ResumeData
resumeDataDecoder =
    Decode.succeed ResumeData
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "onboardingComplete" Decode.bool
        |> Pipeline.optional "organization" organizationDecoder defaultOrganization
        |> Pipeline.optional "user" userDecoder defaultUser
        |> Pipeline.optional "agents" (Decode.list agentDecoder) []
        |> Pipeline.optional "carrierSettings" carrierSettingsDecoder defaultCarrierSettings


type alias ResumeData =
    { success : Bool
    , onboardingComplete : Bool
    , organization : OrganizationData
    , user : UserData
    , agents : List Agent
    , carrierSettings : CarrierSettings
    }


type alias OrganizationData =
    { id : Int
    , name : String
    , website : String
    , phone : String
    , primaryColor : String
    , secondaryColor : String
    , logo : Maybe String
    }


type alias UserData =
    { id : Int
    , firstName : String
    , lastName : String
    , email : String
    , phone : String
    }


type alias CarrierSettings =
    { selectedCarriers : List String
    , useSmartSend : Bool
    }



-- Default values


defaultOrganization : OrganizationData
defaultOrganization =
    { id = 0
    , name = ""
    , website = ""
    , phone = ""
    , primaryColor = "#6B46C1"
    , secondaryColor = "#9F7AEA"
    , logo = Nothing
    }


defaultUser : UserData
defaultUser =
    { id = 0
    , firstName = ""
    , lastName = ""
    , email = ""
    , phone = ""
    }


defaultCarrierSettings : CarrierSettings
defaultCarrierSettings =
    { selectedCarriers = []
    , useSmartSend = True
    }



-- Decoders


organizationDecoder : Decoder OrganizationData
organizationDecoder =
    Decode.succeed OrganizationData
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "name" Decode.string
        |> Pipeline.required "website" Decode.string
        |> Pipeline.required "phone" Decode.string
        |> Pipeline.required "primaryColor" Decode.string
        |> Pipeline.required "secondaryColor" Decode.string
        |> Pipeline.optional "logo" (Decode.map Just Decode.string) Nothing


userDecoder : Decoder UserData
userDecoder =
    Decode.succeed UserData
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "firstName" Decode.string
        |> Pipeline.required "lastName" Decode.string
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "phone" Decode.string


agentDecoder : Decoder Agent
agentDecoder =
    Decode.succeed Agent
        |> Pipeline.required "firstName" Decode.string
        |> Pipeline.required "lastName" Decode.string
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "phone" Decode.string
        |> Pipeline.required "isAdmin" Decode.bool


carrierSettingsDecoder : Decoder CarrierSettings
carrierSettingsDecoder =
    Decode.succeed CarrierSettings
        |> Pipeline.required "selectedCarriers" (Decode.list Decode.string)
        |> Pipeline.required "useSmartSend" Decode.bool


type alias SaveResponse =
    { success : Bool
    , message : String
    }


saveResponseDecoder : Decoder SaveResponse
saveResponseDecoder =
    Decode.map2 SaveResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "message" Decode.string)


type alias OnboardingLoginResponse =
    { success : Bool
    , redirectUrl : String
    , email : String
    }


onboardingLoginResponseDecoder : Decoder OnboardingLoginResponse
onboardingLoginResponseDecoder =
    Decode.succeed OnboardingLoginResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "redirectUrl" Decode.string
        |> Pipeline.required "email" Decode.string


completeOnboardingLogin : String -> Cmd Msg
completeOnboardingLogin email =
    Http.post
        { url = "/api/auth/onboarding-login"
        , body =
            Http.jsonBody
                (Encode.object
                    [ ( "emailRaw", Encode.string email )
                    ]
                )
        , expect = Http.expectJson OnboardingLoginCompleted onboardingLoginResponseDecoder
        }



-- Save payment settings to the API


savePaymentSettings : Model -> Cmd Msg
savePaymentSettings model =
    Http.post
        { url = "/api/onboarding/payment"
        , body =
            Http.jsonBody
                (Encode.object
                    [ ( "email", Encode.string model.user.email )
                    ]
                )
        , expect = Http.expectJson PaymentSaved saveResponseDecoder
        }



-- Add fetchSubscriptionStatus function


fetchSubscriptionStatus : Cmd Msg
fetchSubscriptionStatus =
    Http.get
        { url = "/api/stripe/subscription-status"
        , expect = Http.expectJson GotSubscriptionStatus subscriptionStatusDecoder
        }



-- Add subscription status decoder


subscriptionStatusDecoder : Decoder SubscriptionStatus
subscriptionStatusDecoder =
    Decode.field "data"
        (Decode.map5 SubscriptionStatus
            (Decode.field "isActive" Decode.bool)
            (Decode.field "tier" Decode.string)
            (Decode.maybe (Decode.field "currentPeriodEnd" Decode.int))
            (Decode.maybe (Decode.field "cancelAtPeriodEnd" Decode.bool))
            (Decode.field "paymentStatus" Decode.string)
        )



-- Add payment status check function


checkPaymentStatus : String -> Cmd Msg
checkPaymentStatus email =
    Http.get
        { url = "/api/stripe/payment-status"
        , expect = Http.expectJson PaymentProcessed paymentResponseDecoder
        }



-- Add payment response decoder


paymentResponseDecoder : Decoder PaymentResponse
paymentResponseDecoder =
    Decode.map3 PaymentResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "message" Decode.string)
        (Decode.field "paymentCompleted" Decode.bool)



-- Call the payment-complete endpoint with checkout data


completePayment : CheckoutData -> Cmd Msg
completePayment checkoutData =
    Http.post
        { url = "/api/stripe/payment-complete"
        , body = Http.jsonBody (encodeCheckoutData checkoutData)
        , expect = Http.expectJson PaymentProcessed paymentResponseDecoder
        }



-- Encode checkout data for the API


encodeCheckoutData : CheckoutData -> Encode.Value
encodeCheckoutData data =
    Encode.object
        [ ( "email", Encode.string data.email )
        , ( "firstName", Encode.string data.firstName )
        , ( "lastName", Encode.string data.lastName )
        , ( "stripeCustomerId", Encode.string data.stripeCustomerId )
        , ( "stripeSubscriptionId", Encode.string data.stripeSubscriptionId )
        , ( "stripeUsageItemId", Encode.string data.stripeUsageItemId )
        ]



-- Process checkout data by making the API call


processCheckoutData : CheckoutData -> Cmd Msg
processCheckoutData checkoutData =
    -- After a small delay to allow UI to update, process the checkout data
    Task.perform (\_ -> ProcessCheckoutData checkoutData) (Task.succeed ())



-- Helper functions for drag and drop


dropDecoder : Decode.Decoder Msg
dropDecoder =
    Decode.at [ "dataTransfer", "files" ] (Decode.oneOrMore GotFiles File.decoder)


hijackOn : String -> Decode.Decoder msg -> Attribute msg
hijackOn event decoder =
    preventDefaultOn event (Decode.map hijack decoder)


hijack : msg -> ( msg, Bool )
hijack msg =
    ( msg, True )



-- Helper functions for New Agent Email Validation (copied/adapted from Signup.elm)


isValidEmailFormat : String -> Bool
isValidEmailFormat email =
    String.contains "@" email && String.contains "." email


debounceNewAgentEmailCheck : Int -> Cmd Msg
debounceNewAgentEmailCheck counter =
    Process.sleep 500
        |> Task.perform (\_ -> DebounceNewAgentEmailCheck counter)


checkNewAgentEmailAvailability : Int -> String -> Cmd Msg
checkNewAgentEmailAvailability counter email =
    Http.get
        { url = "/api/organizations/check-email/" ++ Url.percentEncode email
        , expect = Http.expectJson (GotNewAgentEmailCheckResponse counter) emailCheckResponseDecoder
        }


emailCheckResponseDecoder : Decoder EmailCheckResponse
emailCheckResponseDecoder =
    Decode.map2 EmailCheckResponse
        (Decode.field "available" Decode.bool)
        (Decode.field "message" Decode.string)


viewNewAgentEmailStatusMessage : EmailStatus -> Html Msg
viewNewAgentEmailStatusMessage status =
    case status of
        NotChecked ->
            text ""

        Checking ->
            p [ class "mt-1 text-sm text-blue-600" ] [ text "Checking email..." ]

        Available ->
            p [ class "mt-1 text-sm text-green-600" ] [ text "Email is available" ]

        AlreadyRegistered message ->
            p [ class "mt-1 text-sm text-red-600" ] [ text message ]

        InvalidFormat ->
            p [ class "mt-1 text-sm text-red-600" ] [ text "Please enter a valid email address." ]

================
File: frontend/src/Ports.elm
================
port module Ports exposing
    ( clearDebugInfo
    , copyToClipboard
    , getOrgSlug
    , onCopyResult
    , receiveOrgSlug
    , saveDebugInfo
    , viewingPhone
    )

-- Port for requesting the orgSlug from JavaScript


port getOrgSlug : () -> Cmd msg



-- Port for receiving the orgSlug from JavaScript


port receiveOrgSlug : (String -> msg) -> Sub msg



-- Port for copying text to clipboard


port copyToClipboard : String -> Cmd msg



-- Port for receiving copy result from JavaScript


port onCopyResult : (Bool -> msg) -> Sub msg



-- Port for saving debug info


port saveDebugInfo : String -> Cmd msg



-- Port for clearing debug info


port clearDebugInfo : () -> Cmd msg



-- Port for tracking when the user is viewing the phone preview


port viewingPhone : (Bool -> msg) -> Sub msg

================
File: frontend/src/PriceModel.elm
================
module PriceModel exposing (CalculationInputs, view)

import Html exposing (Html, div, h4, p, table, tbody, td, text, tr)
import Html.Attributes exposing (class)


type alias CalculationInputs =
    { contacts : Int
    , averageAge : Float
    , rolloverPercent : Float
    , commissionRate : Float
    }



-- Calculate the price based on the number of contacts


calculatePrice : Int -> Int
calculatePrice contacts =
    let
        basePrice =
            150

        -- Base price for up to 250 contacts
        additionalTiers =
            Basics.max 0 (ceiling (toFloat (Basics.max 0 (contacts - 250)) / 250))

        additionalPrice =
            additionalTiers * 35

        -- $35 for each additional 250 contacts
    in
    basePrice + additionalPrice



-- Parse calculation inputs from the model
-- Calculate revenue based on inputs


type alias RevenueModel =
    { ltvGainPerYear : Float
    , ltvPerContact : Float
    , price : Int
    , firstYearPayout : Float
    , ltvGainPerContact : Float
    , contactsRolledOver : Float
    , roi : Float
    }


calculateRevenue : CalculationInputs -> RevenueModel
calculateRevenue inputs =
    let
        -- Constants
        price =
            calculatePrice inputs.contacts

        maxYears =
            6.0

        ltvDiscountMultiplier =
            1.0

        -- Basic calculations
        ltvPerContact =
            inputs.commissionRate * maxYears * ltvDiscountMultiplier

        rolloverFraction =
            inputs.rolloverPercent / 100.0

        contactsRolledOver =
            toFloat inputs.contacts * rolloverFraction

        -- LTV calculations
        remainingYears =
            maxYears - inputs.averageAge

        additionalYearsForRolled =
            maxYears - remainingYears

        additionalYearsDiscount =
            (1 - ltvDiscountMultiplier) * additionalYearsForRolled / maxYears

        additionalYearsDiscountMultiplier =
            1 - additionalYearsDiscount

        ltvGainPerContact =
            inputs.commissionRate * additionalYearsForRolled * additionalYearsDiscountMultiplier

        ltvGainPerYear =
            ltvGainPerContact * contactsRolledOver

        contactsAtMaxAge =
            -- assumes equal distribution across 6 years
            toFloat inputs.contacts / 6.0

        firstYearPayout =
            contactsAtMaxAge * inputs.commissionRate * rolloverFraction

        roi =
            ltvGainPerYear / toFloat (calculatePrice inputs.contacts * 12)
    in
    { ltvGainPerYear = ltvGainPerYear
    , ltvPerContact = ltvPerContact
    , price = price
    , firstYearPayout = firstYearPayout
    , ltvGainPerContact = ltvGainPerContact
    , contactsRolledOver = contactsRolledOver
    , roi = roi
    }


view : CalculationInputs -> Html msg
view inputs =
    let
        revenueModel =
            calculateRevenue inputs
    in
    div [ class "space-y-6" ]
        [ div
            [ class "bg-white p-4 rounded-md shadow-sm border border-gray-200" ]
            [ h4 [ class "text-md font-medium text-gray-800 mb-4" ] [ text "Subscription Cost" ]
            , table [ class "w-full text-sm" ]
                [ tbody []
                    [ tr [ class "border-b border-gray-200" ]
                        [ td [ class "py-2 text-gray-600" ] [ text "Base monthly subscription:" ]
                        , td [ class "py-2 text-right font-medium" ] [ text "$150/month" ]
                        ]
                    , if revenueModel.price /= 150 then
                        tr [ class "border-b border-gray-200" ]
                            [ td [ class "py-2 text-gray-600" ] [ text "Additional monthly contacts cost:" ]
                            , td [ class "py-2 text-right font-medium" ]
                                [ text <| "$" ++ addCommas (String.fromInt (revenueModel.price - 150)) ++ "/month" ]
                            ]

                      else
                        text ""

                    {--
                    , tr [ class "border-b border-gray-200" ]
                        [ td [ class "py-2 font-medium" ] [ text "Monthly total:" ]
                        , td [ class "py-2 text-right font-bold text-indigo-600" ]
                            [ text <| "$" ++ String.fromInt (Maybe.withDefault 0 model.calculatedPrice) ]
                        ]
                    --}
                    , tr []
                        [ td [ class "py-2 font-medium" ] [ text "Annual Cost:" ]
                        , td [ class "py-2 text-right font-bold text-indigo-600" ]
                            [ text <| "$" ++ addCommas (String.fromInt (revenueModel.price * 12)) ]
                        ]
                    ]
                ]
            ]
        , div [ class "bg-white p-4 rounded-md shadow-sm border border-gray-200" ]
            [ h4 [ class "text-md font-medium text-gray-800 mb-4" ] [ text "Revenue Impact" ]
            , p [ class "text-xs text-gray-600 mb-4 italic" ]
                [ text "Calculations assume an average book age of 3 years." ]
            , div [ class "space-y-4" ]
                [ div [ class "grid grid-cols-1 gap-2" ]
                    [ div [ class "flex justify-between items-center border-b border-gray-200 py-2" ]
                        [ div [ class "text-gray-600 truncate pr-4" ] [ text "Lifetime Revenue Per Contact:" ]
                        , div [ class "text-right font-medium whitespace-nowrap" ]
                            [ text <| "$" ++ formatPreciseMoney revenueModel.ltvPerContact ]
                        ]
                    , div [ class "flex justify-between items-center border-b border-gray-200 py-2" ]
                        [ div [ class "text-gray-600 truncate pr-4" ] [ text "Lifetime Gain Per Contact Rolled Over:" ]
                        , div [ class "text-right font-medium whitespace-nowrap" ]
                            [ text <| "$" ++ formatPreciseMoney revenueModel.ltvGainPerContact ]
                        ]
                    , div [ class "flex justify-between items-center border-b border-gray-200 py-2" ]
                        [ div [ class "text-gray-600 truncate pr-4" ] [ text "Contacts Rolled Over Per Year:" ]
                        , div [ class "text-right font-medium whitespace-nowrap" ]
                            [ text <| formatNumber revenueModel.contactsRolledOver ]
                        ]

                    {--
                    , div [ class "flex justify-between items-center border-b border-gray-200 py-2" ]
                        [ div [ class "text-gray-600 truncate pr-4" ] [ text "Average First Year Payout:" ]
                        , div [ class "text-right font-medium text-green-600 whitespace-nowrap" ]
                            [ text <| "$" ++ formatPreciseMoney revenueModel.firstYearPayout ]
                        ]
                    --}
                    , div [ class "flex justify-between items-center border-b border-gray-200 py-2" ]
                        [ div [ class "text-gray-600 truncate pr-4" ] [ text "Lifetime Revenue Added Per Year:" ]
                        , div [ class "text-right font-bold text-indigo-600 whitespace-nowrap" ]
                            [ text <| "$" ++ formatRoughMoney revenueModel.ltvGainPerYear ]
                        ]
                    , div [ class "flex justify-between items-center py-2" ]
                        [ div [ class "font-medium text-gray-700 truncate pr-4" ] [ text "Return on Investment:" ]
                        , div [ class "text-right font-bold text-green-600 whitespace-nowrap" ]
                            [ text <| formatNumber revenueModel.roi ++ "x" ]
                        ]
                    ]
                ]
            ]
        ]


formatPreciseMoney : Float -> String
formatPreciseMoney value =
    let
        -- Round to 2 decimal places
        roundedValue =
            round10 2 value

        -- Format the number with commas and 2 decimal places
        valueStr =
            String.fromFloat roundedValue
    in
    formatMoney valueStr


formatRoughMoney : Float -> String
formatRoughMoney value =
    let
        roundedValue =
            round10 0 value
    in
    formatMoney (String.fromFloat roundedValue)


formatNumber : Float -> String
formatNumber value =
    if value == toFloat (round value) then
        -- It's a whole number - show no decimals
        String.fromInt (round value)

    else
        -- Show with appropriate precision
        String.fromFloat (round10 1 value)



-- Helper function to format money values


formatMoney : String -> String
formatMoney valueStr =
    let
        parts =
            String.split "." valueStr

        intPart =
            List.head parts |> Maybe.withDefault ""

        decPart =
            List.drop 1 parts
                |> List.head
                |> Maybe.withDefault ""
                |> (\s ->
                        if String.length s == 0 then
                            "00"

                        else if String.length s == 1 then
                            s ++ "0"

                        else
                            String.left 2 s
                   )

        -- Format integer part with commas
        formattedInt =
            addCommas intPart
    in
    formattedInt ++ "." ++ decPart



-- Add commas to numbers for better readability


addCommas : String -> String
addCommas str =
    if String.length str <= 3 then
        str

    else
        let
            -- Recursively add commas
            addCommasHelper : String -> String -> String
            addCommasHelper acc remaining =
                if String.length remaining <= 3 then
                    remaining ++ acc

                else
                    let
                        len =
                            String.length remaining

                        front =
                            String.dropRight 3 remaining

                        back =
                            String.right 3 remaining
                    in
                    addCommasHelper ("," ++ back ++ acc) front
        in
        addCommasHelper "" str



-- Helper function to round to specific decimal places


round10 : Int -> Float -> Float
round10 n value =
    let
        factor =
            10 ^ n |> toFloat
    in
    (value * factor) |> round |> toFloat |> (\x -> x / factor)

================
File: frontend/src/Pricing.elm
================
module Pricing exposing (Model, Msg, init, subscriptions, update, view)

import Basics
import Chart as C
import Chart.Attributes as CA
import Chart.Item as CI
import Dict
import Earnings
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import List.Extra
import MyIcon
import PriceModel
import Svg
import Svg.Attributes as SA


type alias Model =
    { calculationInputs : PriceModel.CalculationInputs
    , calculatorExpanded : Bool
    , activePreset : Maybe Int
    , earningsInputs :
        { overheadCost : Float
        , customerAcquisitionCost : Float
        , earningsMultiple : Float
        }
    }


type alias Pricing =
    { contacts : Int
    , price : Float
    }


basePricing =
    { contacts = 0
    , price = 100
    }


tier1Pricing =
    { contacts = 1
    , price = 0.25
    }


init : ( Model, Cmd Msg )
init =
    ( { calculationInputs =
            { contacts = 1000
            , averageAge = 3.0
            , rolloverPercent = 7
            , commissionRate = 300
            }
      , calculatorExpanded = True
      , activePreset = Nothing
      , earningsInputs =
            { overheadCost = 1000 * 100 -- Default to number of contacts * 100
            , customerAcquisitionCost = 400 -- Default CAC of 400
            , earningsMultiple = 10 -- Default to 10x multiple
            }
      }
    , Cmd.none
    )


type Msg
    = ContactCountChanged Int
    | RolloverPercentChanged Float
    | CommissionRateChanged Float
    | ToggleCalculator
    | SelectPreset Int
    | OverheadCostChanged Float
    | CustomerAcquisitionCostChanged Float
    | EarningsMultipleChanged Float


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        ContactCountChanged count ->
            let
                oldCalculationInputs =
                    model.calculationInputs

                newCalculationInputs =
                    { oldCalculationInputs | contacts = count }

                oldEarningsInputs =
                    model.earningsInputs

                newEarningsInputs =
                    { oldEarningsInputs | overheadCost = toFloat count * 100 }
            in
            ( { model
                | calculationInputs = newCalculationInputs
                , earningsInputs = newEarningsInputs
                , activePreset = Nothing
              }
            , Cmd.none
            )

        RolloverPercentChanged percent ->
            let
                oldCalculationInputs =
                    model.calculationInputs

                newCalculationInputs =
                    { oldCalculationInputs | rolloverPercent = percent }
            in
            ( { model | calculationInputs = newCalculationInputs }
            , Cmd.none
            )

        CommissionRateChanged rate ->
            let
                oldCalculationInputs =
                    model.calculationInputs

                newCalculationInputs =
                    { oldCalculationInputs | commissionRate = rate }
            in
            ( { model | calculationInputs = newCalculationInputs }
            , Cmd.none
            )

        ToggleCalculator ->
            ( { model | calculatorExpanded = not model.calculatorExpanded }
            , Cmd.none
            )

        SelectPreset value ->
            let
                oldCalculationInputs =
                    model.calculationInputs

                newCalculationInputs =
                    { oldCalculationInputs | contacts = value }
            in
            ( { model
                | calculationInputs = newCalculationInputs
                , activePreset = Just value
              }
            , Cmd.none
            )

        OverheadCostChanged cost ->
            let
                oldEarningsInputs =
                    model.earningsInputs

                newEarningsInputs =
                    { oldEarningsInputs | overheadCost = cost }
            in
            ( { model | earningsInputs = newEarningsInputs }
            , Cmd.none
            )

        CustomerAcquisitionCostChanged cost ->
            let
                oldEarningsInputs =
                    model.earningsInputs

                newEarningsInputs =
                    { oldEarningsInputs | customerAcquisitionCost = cost }
            in
            ( { model | earningsInputs = newEarningsInputs }
            , Cmd.none
            )

        EarningsMultipleChanged multiple ->
            let
                oldEarningsInputs =
                    model.earningsInputs

                newEarningsInputs =
                    { oldEarningsInputs | earningsMultiple = multiple }
            in
            ( { model | earningsInputs = newEarningsInputs }
            , Cmd.none
            )



-- Helper functions


formatNumber : Float -> String
formatNumber value =
    if value == toFloat (round value) then
        -- It's a whole number - show no decimals
        addCommas (String.fromInt (round value))

    else
        -- Show with appropriate precision
        String.fromFloat (round10 1 value)


addCommas : String -> String
addCommas str =
    let
        parts =
            String.split "." str

        beforeDecimal =
            List.head parts |> Maybe.withDefault ""

        afterDecimal =
            List.tail parts |> Maybe.withDefault [] |> List.head |> Maybe.withDefault ""

        formatBeforeDecimal s =
            if String.length s <= 3 then
                s

            else
                let
                    reversedDigits =
                        String.reverse s

                    withCommas =
                        reversedDigits
                            |> String.toList
                            |> List.indexedMap
                                (\i c ->
                                    if i > 0 && modBy 3 i == 0 then
                                        [ ',', c ]

                                    else
                                        [ c ]
                                )
                            |> List.concat
                            |> String.fromList
                            |> String.reverse
                in
                withCommas
    in
    if String.isEmpty afterDecimal then
        formatBeforeDecimal beforeDecimal

    else
        formatBeforeDecimal beforeDecimal ++ "." ++ afterDecimal


round10 : Int -> Float -> Float
round10 n value =
    let
        factor =
            10 ^ n |> toFloat
    in
    (value * factor) |> round |> toFloat |> (\x -> x / factor)



-- New graduated pricing calculation function


calculatePricing : Int -> { basePrice : Float, tierPrices : List { contacts : Int, price : Float }, totalPrice : Float }
calculatePricing contacts =
    let
        baseSubscription =
            basePricing.price

        -- Calculate number of additional contacts beyond the first 250
        additionalContacts =
            if contacts <= 250 then
                0

            else
                contacts - 250

        -- Calculate price for additional contacts
        additionalPrice =
            toFloat additionalContacts * tier1Pricing.price

        totalPrice =
            baseSubscription + additionalPrice

        -- Create list of tier prices for display
        tierPrices =
            [ { contacts = additionalContacts
              , price = additionalPrice
              }
            ]
    in
    { basePrice = baseSubscription
    , tierPrices = tierPrices
    , totalPrice = totalPrice
    }



-- Calculate enhanced revenue metrics based on MedicareMax model


type alias EnhancedRevenue =
    { price : Float
    , annualPrice : Float
    , monthlyConverted : Float
    , annualConverted : Float
    , monthlyLtv : Float
    , annualLtv : Float
    , roi : Float
    , netBenefit : Float
    }


calculateEnhancedRevenue : PriceModel.CalculationInputs -> EnhancedRevenue
calculateEnhancedRevenue inputs =
    let
        -- Constants from MedicareMax model
        annualConversionRate =
            inputs.rolloverPercent / 100

        -- Using rollover percent as conversion rate
        monthlyRate =
            monthlyConversionRate inputs

        contactLtv =
            inputs.commissionRate * 3

        -- Pricing calculation
        pricing =
            calculatePricing inputs.contacts

        -- Converted contacts
        monthlyConverted =
            toFloat inputs.contacts * monthlyRate |> round |> toFloat

        annualConverted =
            toFloat inputs.contacts * annualConversionRate

        -- LTV calculations
        monthlyLtv =
            monthlyConverted * contactLtv

        annualLtv =
            annualConverted * contactLtv

        -- ROI and benefit
        annualPrice =
            pricing.totalPrice * 12

        roi =
            annualLtv / annualPrice

        netBenefit =
            annualLtv - annualPrice
    in
    { price = pricing.totalPrice
    , annualPrice = annualPrice
    , monthlyConverted = monthlyConverted
    , annualConverted = annualConverted
    , monthlyLtv = monthlyLtv
    , annualLtv = annualLtv
    , roi = roi
    , netBenefit = netBenefit
    }



-- Main view


view : Model -> Html Msg
view model =
    let
        pricing =
            calculatePricing model.calculationInputs.contacts

        revenue =
            calculateEnhancedRevenue model.calculationInputs

        pricePerContact =
            if model.calculationInputs.contacts > 0 then
                pricing.totalPrice / toFloat model.calculationInputs.contacts

            else
                0
    in
    div [ class "min-h-screen bg-white flex flex-col items-center py-0 px-4 sm:px-6 lg:px-8" ]
        [ div [ class "max-w-5xl w-full space-y-8" ]
            [ div [ class "flex flex-col items-center" ]
                [ h2 [ class "text-4xl sm:text-3xl font-semibold text-gray-900 mt-6" ] [ text "Special Launch Pricing" ]
                , p [ class "text-gray-500 mt-2 mb-6 text-center" ] [ text "Transparent pricing. Pay for what you use." ]

                -- Pricing Tiers - Responsive Layout
                , div [ class "w-full flex flex-col md:flex-row gap-4 sm:gap-6 mb-8 sm:mb-12" ]
                    [ div [ class "w-full md:w-1/2 p-5 sm:p-6 border rounded-lg bg-white shadow-sm" ]
                        [ div [ class "flex flex-col px-2 sm:px-3" ]
                            [ div [ class "flex justify-between items-center mb-3" ]
                                [ h3 [ class "font-bold text-lg sm:text-xl text-gray-800" ] [ text "Base Subscription" ]
                                , span [ class "px-3 py-1 bg-green-100 text-green-800 text-sm rounded-full" ]
                                    [ text "Includes 250 contacts" ]
                                ]
                            , div [ class "flex items-baseline gap-2 mb-3" ]
                                [ span [ class "text-2xl sm:text-3xl font-bold text-gray-900" ] [ text "$100" ]
                                , span [ class "text-gray-600" ] [ text "/month" ]
                                ]
                            , p [ class "text-gray-600 text-sm" ]
                                [ text "Includes all features of the Medicare Max portal platform." ]
                            ]
                        ]
                    , div [ class "w-full md:w-1/2 p-5 sm:p-6 border rounded-lg bg-white shadow-sm" ]
                        [ div [ class "flex flex-col px-2 sm:px-3" ]
                            [ div [ class "flex justify-between items-center mb-3" ]
                                [ h3 [ class "font-bold text-lg sm:text-xl text-gray-800" ] [ text "Additional Contacts" ]
                                , span [ class "px-3 py-1 bg-blue-100 text-blue-800 text-sm rounded-full" ]
                                    [ text "Pay as you go" ]
                                ]
                            , div [ class "flex items-baseline gap-2 mb-3" ]
                                [ span [ class "text-2xl sm:text-3xl font-bold text-gray-900" ] [ text "$0.25" ]
                                , span [ class "text-gray-600" ] [ text "/contact/month" ]
                                ]
                            , p [ class "text-gray-600 text-sm" ]
                                [ text "That's just $3 per contact per year." ]
                            ]
                        ]
                    ]

                -- Calculator Section - Responsive Layout
                , div [ class "w-full grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8" ]
                    [ div [ class "flex flex-col space-y-6" ]
                        [ div [ class "flex flex-col sm:flex-row gap-4 sm:gap-6 items-start" ]
                            [ div [ class "w-full sm:w-48" ]
                                [ label [ class "block text-gray-700 text-sm font-bold mb-2", for "contacts" ]
                                    [ text "Number of Contacts:" ]
                                , input
                                    [ id "contacts"
                                    , type_ "number"
                                    , value (String.fromInt model.calculationInputs.contacts)
                                    , onInput (\str -> ContactCountChanged (String.toInt str |> Maybe.withDefault 0))
                                    , class "shadow appearance-none border rounded py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline w-full"
                                    , Html.Attributes.min "0"
                                    ]
                                    []
                                ]
                            , div [ class "flex-1 w-full" ]
                                [ div [ class "grid grid-cols-2 sm:grid-cols-3 gap-2" ]
                                    ([ 250, 1000, 5000, 10000, 20000, 40000 ]
                                        |> List.map
                                            (\presetValue ->
                                                let
                                                    isActive =
                                                        model.activePreset == Just presetValue

                                                    baseClass =
                                                        "hover:bg-blue-200 text-blue-800 font-semibold py-1 px-2 rounded-full text-sm text-center"

                                                    activeClass =
                                                        "bg-blue-500 text-white"

                                                    inactiveClass =
                                                        "bg-blue-100"
                                                in
                                                button
                                                    [ onClick (SelectPreset presetValue)
                                                    , class
                                                        (baseClass
                                                            ++ " "
                                                            ++ (if isActive then
                                                                    activeClass

                                                                else
                                                                    inactiveClass
                                                               )
                                                        )
                                                    ]
                                                    [ text (formatNumber (toFloat presetValue)) ]
                                            )
                                    )
                                ]
                            ]
                        , div [ class "bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg p-4" ]
                            [ h3 [ class "text-lg font-bold text-gray-800 mb-3" ] [ text "Your Plan Summary" ]
                            , div [ class "space-y-2" ]
                                [ div [ class "flex justify-between items-center text-sm" ]
                                    [ span [ class "text-gray-600" ] [ text "Base subscription:" ]
                                    , span [ class "font-bold" ] [ text (formatCurrency pricing.basePrice) ]
                                    ]
                                , List.filterMap
                                    (\tier ->
                                        if tier.contacts > 0 && tier.price > 0 then
                                            Just
                                                (div [ class "flex justify-between items-center text-sm" ]
                                                    [ span [ class "text-gray-600" ]
                                                        [ text
                                                            (if tier.contacts <= 0 then
                                                                ""

                                                             else
                                                                String.fromInt tier.contacts
                                                                    ++ " contacts @ $0.25 each:"
                                                            )
                                                        ]
                                                    , span [ class "font-bold" ] [ text (formatCurrency tier.price) ]
                                                    ]
                                                )

                                        else
                                            Nothing
                                    )
                                    pricing.tierPrices
                                    |> div [ class "space-y-2" ]
                                ]
                            ]
                        ]
                    , div [ class "flex items-center justify-center" ]
                        [ div [ class "bg-blue-600 rounded-lg p-6 text-white text-center w-full lg:w-96" ]
                            [ h2 [ class "font-bold mb-2 text-lg" ] [ text "Monthly Price" ]
                            , div [ class "text-4xl sm:text-5xl font-bold mb-2" ] [ text (formatCurrency pricing.totalPrice) ]
                            , p [ class "text-sm text-blue-100" ]
                                [ text ("For " ++ formatNumber (toFloat model.calculationInputs.contacts) ++ " contacts") ]
                            ]
                        ]
                    ]

                -- Value Analysis Section - Responsive Layout
                , div [ class "w-full mt-8 mb-8" ]
                    [ div [ class "bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg p-4 border border-purple-100" ]
                        [ div [ class "flex flex-col gap-6" ]
                            [ div [ class "grid grid-cols-1 lg:grid-cols-3 gap-6" ]
                                [ div [ class "flex flex-col gap-4" ]
                                    [ h2 [ class "text-lg font-bold text-gray-800" ] [ text "Value Analysis" ]
                                    , div [ class "grid grid-cols-2 gap-4" ]
                                        [ div [ class "flex flex-col gap-5" ]
                                            -- Left column for inputs
                                            [ div [ class "flex flex-col" ]
                                                [ label
                                                    [ class "block text-sm font-medium text-gray-700 mb-1 cursor-pointer h-5"
                                                    , for "commission-rate"
                                                    ]
                                                    [ text "Annual Commission" ]
                                                , div [ class "flex rounded-md shadow-sm w-[100px]" ]
                                                    [ div [ class "flex-shrink-0 inline-flex items-center px-2 rounded-l-md border border-r-0 border-gray-300 bg-indigo-100 text-indigo-800 text-sm font-medium" ]
                                                        [ text "$" ]
                                                    , input
                                                        [ class "w-full border border-gray-300 rounded-none rounded-r-md shadow-sm py-1 px-2 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-center"
                                                        , id "commission-rate"
                                                        , type_ "number"
                                                        , placeholder "Commission"
                                                        , value (String.fromFloat model.calculationInputs.commissionRate)
                                                        , onInput (\str -> CommissionRateChanged (String.toFloat str |> Maybe.withDefault 0))
                                                        , Html.Attributes.min "0"
                                                        , Html.Attributes.step "5"
                                                        ]
                                                        []
                                                    ]
                                                ]
                                            , div [ class "flex flex-col" ]
                                                [ label
                                                    [ class "block text-sm font-medium text-gray-700 mb-1 cursor-pointer h-5"
                                                    , for "rollover-percent"
                                                    ]
                                                    [ text "Annual Rollover" ]
                                                , div [ class "flex rounded-md shadow-sm w-[100px]" ]
                                                    [ div [ class "flex-shrink-0 inline-flex items-center px-2 rounded-l-md border border-r-0 border-gray-300 bg-indigo-100 text-indigo-800 text-sm font-medium" ]
                                                        [ text "%" ]
                                                    , input
                                                        [ class "w-full border border-gray-300 rounded-none rounded-r-md shadow-sm py-1 px-2 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-center"
                                                        , id "rollover-percent"
                                                        , type_ "number"
                                                        , placeholder "Rollover"
                                                        , value (String.fromFloat model.calculationInputs.rolloverPercent)
                                                        , onInput (\str -> RolloverPercentChanged (String.toFloat str |> Maybe.withDefault 0))
                                                        , Html.Attributes.min "0"
                                                        , Html.Attributes.max "100"
                                                        , Html.Attributes.step "0.1"
                                                        ]
                                                        []
                                                    ]
                                                ]
                                            ]
                                        , div [ class "flex flex-col gap-6" ]
                                            -- Right column for outputs
                                            [ div [ class "flex flex-col" ]
                                                [ div [ class "text-sm font-medium text-gray-700 h-5" ] [ text "Baseline Commission" ]
                                                , div [ class "h-[30px] flex flex-col justify-start" ]
                                                    [ div [ class "text-lg font-semibold text-indigo-600 -mb-1" ]
                                                        [ text ("$" ++ formatNumber (model.calculationInputs.commissionRate * 6)) ]
                                                    , div [ class "text-sm font-normal text-gray-500" ] [ text "6 years" ]
                                                    ]
                                                ]
                                            , div [ class "flex flex-col" ]
                                                [ div [ class "text-sm font-medium text-gray-700 h-5" ] [ text "Added Commission" ]
                                                , div [ class "h-[30px] flex flex-col justify-start" ]
                                                    [ div [ class "text-lg font-semibold text-indigo-600 -mb-1" ]
                                                        [ text ("$" ++ formatNumber (model.calculationInputs.commissionRate * 3)) ]
                                                    , div [ class "text-sm font-normal text-gray-500" ] [ text "3 extra yrs (on average)" ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                , div [ class "bg-white rounded-lg p-3 shadow-sm border border-gray-200" ]
                                    [ h3 [ class "font-bold text-gray-700 mb-2 text-md" ] [ text "Monthly Impact" ]
                                    , div [ class "space-y-2 text-sm" ]
                                        [ div [ class "flex justify-between items-start" ]
                                            [ div [ class "flex flex-col" ]
                                                [ span [ class "text-gray-600" ] [ text "Investment:" ]
                                                ]
                                            , span [ class "font-bold" ] [ text (formatCurrencyRounded revenue.price) ]
                                            ]
                                        , div [ class "flex justify-between items-start" ]
                                            [ div [ class "flex flex-col" ]
                                                [ span [ class "text-gray-600" ] [ text "Converted contacts:" ]
                                                , span [ class "text-xs text-gray-500" ]
                                                    [ text
                                                        ("("
                                                            ++ formatNumber (monthlyConversionRate model.calculationInputs * 100)
                                                            ++ "% of "
                                                            ++ formatNumber (toFloat model.calculationInputs.contacts)
                                                            ++ ")"
                                                        )
                                                    ]
                                                ]
                                            , span [ class "font-bold" ] [ text (formatNumber revenue.monthlyConverted) ]
                                            ]
                                        , div [ class "flex justify-between items-start" ]
                                            [ div [ class "flex flex-col" ]
                                                [ span [ class "text-gray-600" ] [ text "New LTV Added:" ]
                                                , span [ class "text-xs text-gray-500" ]
                                                    [ text ("(" ++ formatNumber revenue.monthlyConverted ++ " × $" ++ formatNumber (model.calculationInputs.commissionRate * 3) ++ ")") ]
                                                ]
                                            , span [ class "font-bold text-purple-700" ] [ text (formatCurrencyRounded revenue.monthlyLtv) ]
                                            ]
                                        ]
                                    ]
                                , div [ class "bg-white rounded-lg p-3 shadow-sm border border-gray-200" ]
                                    [ h3 [ class "font-bold text-gray-700 mb-2 text-md" ] [ text "Annual Impact" ]
                                    , div [ class "space-y-2 text-sm" ]
                                        [ div [ class "flex justify-between items-start" ]
                                            [ div [ class "flex flex-col" ]
                                                [ span [ class "text-gray-600" ] [ text "Investment:" ]
                                                ]
                                            , span [ class "font-bold" ] [ text (formatCurrencyRounded revenue.annualPrice) ]
                                            ]
                                        , div [ class "flex justify-between items-start" ]
                                            [ div [ class "flex flex-col" ]
                                                [ span [ class "text-gray-600" ] [ text "Converted contacts:" ]
                                                , span [ class "text-xs text-gray-500" ]
                                                    [ text
                                                        ("("
                                                            ++ formatNumber model.calculationInputs.rolloverPercent
                                                            ++ "% of "
                                                            ++ formatNumber (toFloat model.calculationInputs.contacts)
                                                            ++ ")"
                                                        )
                                                    ]
                                                ]
                                            , span [ class "font-bold" ] [ text (formatNumber revenue.annualConverted) ]
                                            ]
                                        , div [ class "flex justify-between items-start" ]
                                            [ div [ class "flex flex-col" ]
                                                [ span [ class "text-gray-600" ] [ text "New LTV Added:" ]
                                                , span [ class "text-xs text-gray-500" ]
                                                    [ text ("(" ++ formatNumber revenue.annualConverted ++ " × $" ++ formatNumber (model.calculationInputs.commissionRate * 3) ++ ")") ]
                                                ]
                                            , span [ class "font-bold text-green-700" ] [ text (formatCurrencyRounded revenue.annualLtv) ]
                                            ]
                                        ]
                                    ]
                                ]
                            , div [ class "mt-6" ]
                                [ div [ class "bg-emerald-600 rounded-lg p-4 sm:p-6 text-white text-center flex flex-col sm:flex-row justify-center gap-8 sm:gap-16" ]
                                    [ div [ class "text-center" ]
                                        [ h3 [ class "text-lg mb-2 font-medium text-emerald-100" ] [ text "Return on Investment" ]
                                        , div [ class "text-3xl sm:text-4xl font-bold mb-1" ] [ text (formatNumber revenue.roi ++ "x") ]
                                        ]
                                    , div [ class "text-center" ]
                                        [ h3 [ class "text-lg mb-2 font-medium text-emerald-100" ] [ text "Net Annual Benefit" ]
                                        , div [ class "text-3xl sm:text-4xl font-bold mb-1" ] [ text (formatCurrencyRounded revenue.netBenefit) ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ]

                -- Earnings Parameters Section
                {--
                , div [ class "w-full mt-8 bg-white rounded-lg p-4 shadow-sm border border-gray-200" ]
                    [ h3 [ class "text-lg font-bold text-gray-800 mb-4" ] [ text "Earnings Model Parameters" ]
                    , div [ class "flex flex-col gap-5" ]
                        [ div [ class "flex flex-col" ]
                            [ label
                                [ class "block text-sm font-medium text-gray-700 mb-1 cursor-pointer h-5"
                                , for "annual-overhead"
                                ]
                                [ text "Annual Overhead" ]
                            , div [ class "flex rounded-md shadow-sm w-[200px]" ]
                                [ div [ class "flex-shrink-0 inline-flex items-center px-2 rounded-l-md border border-r-0 border-gray-300 bg-indigo-100 text-indigo-800 text-sm font-medium" ]
                                    [ text "$" ]
                                , input
                                    [ id "annual-overhead"
                                    , type_ "number"
                                    , class "w-full border border-gray-300 rounded-none rounded-r-md shadow-sm py-1 px-2 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-center"
                                    , value (String.fromFloat model.earningsInputs.overheadCost)
                                    , onInput (\str -> OverheadCostChanged (String.toFloat str |> Maybe.withDefault 0))
                                    , Html.Attributes.step "1000"
                                    , Html.Attributes.min "0"
                                    ]
                                    []
                                ]
                            ]
                        , div [ class "flex flex-col" ]
                            [ label
                                [ class "block text-sm font-medium text-gray-700 mb-1 cursor-pointer h-5"
                                , for "customer-acquisition-cost"
                                ]
                                [ text "Customer Acquisition Cost" ]
                            , div [ class "flex rounded-md shadow-sm w-[200px]" ]
                                [ div [ class "flex-shrink-0 inline-flex items-center px-2 rounded-l-md border border-r-0 border-gray-300 bg-indigo-100 text-indigo-800 text-sm font-medium" ]
                                    [ text "$" ]
                                , input
                                    [ id "customer-acquisition-cost"
                                    , type_ "number"
                                    , class "w-full border border-gray-300 rounded-none rounded-r-md shadow-sm py-1 px-2 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-center"
                                    , value (String.fromFloat model.earningsInputs.customerAcquisitionCost)
                                    , onInput (\str -> CustomerAcquisitionCostChanged (String.toFloat str |> Maybe.withDefault 0))
                                    , Html.Attributes.step "10"
                                    , Html.Attributes.min "0"
                                    ]
                                    []
                                ]
                            ]
                        , div [ class "flex flex-col" ]
                            [ label
                                [ class "block text-sm font-medium text-gray-700 mb-1 cursor-pointer h-5"
                                , for "earnings-multiple"
                                ]
                                [ text "Earnings Multiple" ]
                            , div [ class "flex rounded-md shadow-sm w-[200px]" ]
                                [ div [ class "flex-shrink-0 inline-flex items-center px-2 rounded-l-md border border-r-0 border-gray-300 bg-indigo-100 text-indigo-800 text-sm font-medium" ]
                                    [ text "x" ]
                                , input
                                    [ id "earnings-multiple"
                                    , type_ "number"
                                    , class "w-full border border-gray-300 rounded-none rounded-r-md shadow-sm py-1 px-2 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-center"
                                    , value (String.fromFloat model.earningsInputs.earningsMultiple)
                                    , onInput (\str -> EarningsMultipleChanged (String.toFloat str |> Maybe.withDefault 0))
                                    , Html.Attributes.step "0.1"
                                    , Html.Attributes.min "0"
                                    ]
                                    []
                                ]
                            ]
                        ]
                    ]

                -- Earnings Model Description
                , div [ class "w-full mt-4 bg-blue-50 rounded-lg p-4 text-sm text-blue-700" ]
                    [ div [ class "font-semibold mb-2" ] [ text "Model Assumptions:" ]
                    , ul [ class "list-disc list-inside space-y-1" ]
                        [ li [] [ text "Flat Case: Maintains current book size by replacing churned customers, incurring CAC" ]
                        , li [] [ text "Rollover Case: Grows through rollovers, accumulating additional revenue over time" ]
                        ]
                    ]
                , div [ class "w-full overflow-x-auto" ]
                    [ renderRevenueChart model.calculationInputs ]
                --}
                , div [ class "w-full overflow-x-auto" ]
                    [ renderLtvChart model.calculationInputs ]

                {--
                , div [ class "w-full overflow-x-auto" ]
                    [ renderEarningsChart model ]
                , div [ class "w-full overflow-x-auto" ]
                    [ renderEnterpriseValueChart model ]
                --}
                ]
            ]
        ]



-- Helper function to calculate monthly conversion rate


monthlyConversionRate : PriceModel.CalculationInputs -> Float
monthlyConversionRate inputs =
    inputs.rolloverPercent / (100 * 12)


type alias CashFlowModel =
    List ( Int, Float )


baseCase : PriceModel.CalculationInputs -> CashFlowModel
baseCase inputs =
    List.range 0 6
        |> List.map
            (\i ->
                ( i, toFloat inputs.contacts * inputs.commissionRate * (6 - toFloat i) / 6 )
            )


flatCase : PriceModel.CalculationInputs -> CashFlowModel
flatCase inputs =
    List.range 0 6
        |> List.map
            (\i ->
                ( i, toFloat inputs.contacts * inputs.commissionRate )
            )


payingContactsLadder : PriceModel.CalculationInputs -> List ( Int, Float )
payingContactsLadder inputs =
    List.range 0 6
        |> List.map
            (\i ->
                let
                    nFact =
                        List.range 0 i |> List.sum
                in
                ( i
                , (1 + (inputs.rolloverPercent / toFloat 100) / 6) ^ toFloat nFact
                )
            )


rolloverCase : PriceModel.CalculationInputs -> CashFlowModel
rolloverCase inputs =
    payingContactsLadder inputs
        |> List.map (\( i, v ) -> ( i, v * inputs.commissionRate * toFloat inputs.contacts ))


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none


formatCurrency : Float -> String
formatCurrency value =
    let
        valueCents =
            value * 100 |> round

        valueDollars =
            toFloat valueCents / 100
    in
    "$" ++ addCommas (String.fromFloat valueDollars |> padCents)


padCents : String -> String
padCents str =
    if String.contains "." str then
        let
            parts =
                String.split "." str

            beforeDecimal =
                List.head parts |> Maybe.withDefault ""

            afterDecimal =
                List.tail parts |> Maybe.withDefault [] |> List.head |> Maybe.withDefault ""

            padded =
                if String.length afterDecimal == 1 then
                    afterDecimal ++ "0"

                else
                    afterDecimal
        in
        beforeDecimal ++ "." ++ padded

    else
        str ++ ".00"


formatCurrencyRounded : Float -> String
formatCurrencyRounded value =
    "$" ++ addCommas (String.fromInt (round value))



-- Add this new function before the view function


renderRevenueChart : PriceModel.CalculationInputs -> Html Msg
renderRevenueChart inputs =
    let
        func : ( Int, Float ) -> { x : String, y : Float }
        func ( year, value ) =
            { x = String.fromInt year
            , y = Basics.max 0 (value / inputs.commissionRate / toFloat inputs.contacts)
            }

        baseCaseData =
            baseCase inputs
                |> List.map func

        rolloverCaseData =
            rolloverCase inputs
                |> List.map func

        allData =
            List.map2
                (\base rollover ->
                    { x = base.x
                    , baseCase = Basics.max 0 base.y
                    , rolloverCase = Basics.max 0 rollover.y
                    }
                )
                baseCaseData
                rolloverCaseData
    in
    div [ class "w-full bg-white rounded-lg p-2 sm:p-4 shadow-sm border border-gray-200" ]
        [ div [ class "flex justify-between items-center text-lg font-bold text-gray-700 mb-1 sm:mb-4" ]
            [ text "Cash Flow" ]
        , div [ class "flex flex-col" ]
            [ div [ class "w-full h-[120px] md:h-[350px] overflow-x-auto overflow-y-hidden" ]
                [ C.chart
                    [ CA.width 800
                    , CA.height 250
                    , CA.attrs [ SA.style "max-width: 100%" ]
                    , CA.margin { top = 20, bottom = 40, left = 60, right = 20 }
                    , CA.padding { top = 10, bottom = 20, left = 10, right = 10 }
                    , CA.htmlAttrs [ class "overflow-visible" ]
                    ]
                    [ C.grid
                        [ CA.width 1
                        , CA.color "#e5e7eb"
                        , CA.dashed [ 5, 5 ]
                        ]
                    , C.yLabels
                        [ CA.withGrid
                        , CA.format (\v -> String.fromFloat (round10 1 v) ++ "x")
                        , CA.fontSize 11
                        , CA.color "#6b7280"
                        , CA.amount 5
                        , CA.limits [ CA.lowest 0 CA.exactly ]
                        ]
                    , C.binLabels .x
                        [ CA.moveDown 25
                        , CA.fontSize 12
                        , CA.color "#374151"
                        , CA.rotate 0
                        ]
                    , C.labelAt CA.middle
                        .max
                        [ CA.moveUp 15 ]
                        [ Svg.text_ [ SA.fontSize "18", SA.fill "#1F2937" ] [ Svg.text "Cash Flow" ] ]
                    , C.bars
                        [ CA.margin 0.1
                        , CA.roundTop 0.5
                        ]
                        [ C.bar .baseCase [ CA.color "#03045e", CA.opacity 0.8 ]
                            |> C.named "Base Case"
                        , C.bar .rolloverCase [ CA.color "#7F56D9", CA.opacity 0.8 ]
                            |> C.named "Rollover Case"
                        ]
                        allData
                    ]
                ]
            , div [ class "flex flex-wrap justify-center gap-2 mt-1 sm:mt-4 text-sm" ]
                [ div [ class "flex items-center gap-2" ]
                    [ div [ class "w-3 h-3 bg-[#03045e] rounded-full opacity-80" ] []
                    , text "Base Case"
                    ]
                , div [ class "flex items-center gap-2" ]
                    [ div [ class "w-3 h-3 bg-[#7F56D9] rounded-full opacity-80" ] []
                    , text "Rollover Case"
                    ]
                ]
            ]
        ]



-- LTV Model functions


baseCaseLtv : PriceModel.CalculationInputs -> CashFlowModel
baseCaseLtv inputs =
    -- Initial book has average 3 years of LTV remaining (3x commission)
    List.range 0 6
        |> List.map
            (\i ->
                ( i
                , toFloat inputs.contacts * inputs.commissionRate * 3.0 * (6 - toFloat i) / 6
                  -- Initial 3x LTV
                )
            )


flatCaseLtv : PriceModel.CalculationInputs -> CashFlowModel
flatCaseLtv inputs =
    -- Flat case maintains the same LTV
    List.range 0 6
        |> List.map
            (\i ->
                ( i
                , toFloat inputs.contacts * inputs.commissionRate * 3.0
                  -- Constant 3x LTV
                )
            )


rolloverCaseLtv : PriceModel.CalculationInputs -> CashFlowModel
rolloverCaseLtv inputs =
    -- Each year we add (rolloverPercent)% of contacts with 6 years of LTV
    List.range 0 6
        |> List.map
            (\i ->
                let
                    baseValue =
                        toFloat inputs.contacts * inputs.commissionRate * 3.0

                    -- Initial 3x LTV
                    additionalLtv =
                        if i == 0 then
                            0

                        else
                            -- For each previous year, we've added rolloverPercent% of contacts with 6x commission
                            toFloat inputs.contacts
                                * (inputs.rolloverPercent / 100)
                                * inputs.commissionRate
                                --  New policies have a net added LTV on average of 3x
                                * toFloat i

                    -- Accumulate for each year
                in
                ( i, baseValue + additionalLtv )
            )


renderLtvChart : PriceModel.CalculationInputs -> Html Msg
renderLtvChart inputs =
    let
        func : ( Int, Float ) -> { x : String, y : Float }
        func ( year, value ) =
            { x = String.fromInt year
            , y = value / 1000000
            }

        baseCaseData =
            baseCaseLtv inputs
                |> List.map func

        rolloverCaseData =
            rolloverCaseLtv inputs
                |> List.map func

        allData =
            List.map2
                (\base rollover ->
                    { x = base.x
                    , baseCase = base.y
                    , rolloverCase = rollover.y
                    }
                )
                baseCaseData
                rolloverCaseData
    in
    div [ class "w-full bg-white rounded-lg p-2 sm:p-4 shadow-sm border border-gray-200 mt-4 sm:mt-8" ]
        [ div [ class "flex justify-between items-center text-lg font-bold text-gray-700 mb-1 sm:mb-4" ]
            [ text "Book of Business -- Remaining LTV (Millions)" ]
        , div [ class "flex flex-col" ]
            [ div [ class "w-full h-[120px] md:h-[350px] overflow-x-auto overflow-y-hidden" ]
                [ C.chart
                    [ CA.width 800
                    , CA.height 250
                    , CA.attrs [ SA.style "max-width: 100%" ]
                    , CA.margin { top = 20, bottom = 40, left = 60, right = 20 }
                    , CA.padding { top = 10, bottom = 20, left = 10, right = 10 }
                    , CA.htmlAttrs [ class "overflow-visible" ]
                    ]
                    [ C.grid
                        [ CA.width 1
                        , CA.color "#e5e7eb"
                        , CA.dashed [ 5, 5 ]
                        ]
                    , C.yLabels
                        [ CA.withGrid
                        , CA.format (\v -> "$" ++ formatNumber v ++ "M")
                        , CA.fontSize 11
                        , CA.color "#6b7280"
                        , CA.amount 5
                        , CA.limits [ CA.lowest 0 CA.exactly ]
                        ]
                    , C.binLabels .x
                        [ CA.moveDown 25
                        , CA.fontSize 12
                        , CA.color "#374151"
                        , CA.rotate 0
                        ]
                    , C.labelAt CA.middle
                        .max
                        [ CA.moveUp 15 ]
                        [ Svg.text_ [ SA.fontSize "18", SA.fill "#1F2937" ] [ Svg.text "Book Value" ] ]
                    , C.bars
                        [ CA.margin 0.1
                        , CA.roundTop 0.5
                        ]
                        [ C.bar .baseCase [ CA.color "#03045e", CA.opacity 0.8 ]
                            |> C.named "Base Case"
                        , C.bar .rolloverCase [ CA.color "#53389E", CA.opacity 0.8 ]
                            |> C.named "Rollover Case"
                        ]
                        allData
                    ]
                ]
            , div [ class "flex flex-wrap justify-center gap-2 mt-1 sm:mt-4 text-sm" ]
                [ div [ class "flex items-center gap-2" ]
                    [ div [ class "w-3 h-3 bg-[#03045e] rounded-full opacity-80" ] []
                    , text "Base Case"
                    ]
                , div [ class "flex items-center gap-2" ]
                    [ div [ class "w-3 h-3 bg-[#53389E] rounded-full opacity-80" ] []
                    , text "Rollover Case"
                    ]
                ]
            ]
        ]


renderEarningsChart : Model -> Html Msg
renderEarningsChart model =
    let
        earningsInputs =
            { calculationInputs = model.calculationInputs
            , overheadCost = model.earningsInputs.overheadCost
            , customerAcquisitionCost = model.earningsInputs.customerAcquisitionCost
            , earningsMultiple = model.earningsInputs.earningsMultiple
            }

        flatCaseData =
            Earnings.flatCase earningsInputs
                |> List.map (\data -> { x = String.fromInt data.year, y = data.earnings / 1000000 })

        rolloverCaseData =
            Earnings.rolloverCase earningsInputs
                |> List.map (\data -> { x = String.fromInt data.year, y = data.earnings / 1000000 })

        allData =
            List.map2
                (\flat rollover ->
                    { x = flat.x
                    , flatCase = flat.y
                    , rolloverCase = rollover.y
                    }
                )
                flatCaseData
                rolloverCaseData
    in
    div [ class "w-full bg-white rounded-lg p-2 sm:p-4 shadow-sm border border-gray-200 mt-4 sm:mt-8" ]
        [ div [ class "flex justify-between items-center text-lg font-bold text-gray-700 mb-1 sm:mb-4" ]
            [ text "Annual Earnings (Millions)" ]
        , div [ class "flex flex-col" ]
            [ div [ class "w-full h-[120px] md:h-[350px] overflow-x-auto overflow-y-hidden" ]
                [ C.chart
                    [ CA.height 250
                    , CA.width 800
                    , CA.margin { top = 20, bottom = 40, left = 60, right = 20 }
                    , CA.padding { top = 10, bottom = 20, left = 10, right = 10 }
                    ]
                    [ C.grid []
                    , C.yLabels [ CA.withGrid, CA.format (\v -> "$" ++ formatNumber v ++ "M") ]
                    , C.binLabels .x [ CA.moveDown 25, CA.fontSize 12 ]
                    , C.labelAt CA.middle
                        .max
                        [ CA.moveUp 15 ]
                        [ Svg.text_ [ SA.fontSize "18", SA.fill "#1F2937" ] [ Svg.text "Earnings" ] ]
                    , C.bars
                        [ CA.margin 0.1
                        ]
                        [ C.bar .flatCase [ CA.color "#22C55E", CA.opacity 0.7 ]
                            |> C.named "Flat Case"
                        , C.bar .rolloverCase [ CA.color "#A855F7", CA.opacity 0.7 ]
                            |> C.named "Rollover Case"
                        ]
                        allData
                    ]
                ]
            , div [ class "flex flex-wrap justify-center gap-2 mt-1 sm:mt-4 text-sm" ]
                [ div [ class "flex items-center gap-2" ]
                    [ div [ class "w-3 h-3 bg-[#22C55E] rounded-full opacity-70" ] []
                    , text "Flat Case"
                    ]
                , div [ class "flex items-center gap-2" ]
                    [ div [ class "w-3 h-3 bg-[#A855F7] rounded-full opacity-70" ] []
                    , text "Rollover Case"
                    ]
                ]
            ]
        ]


renderEnterpriseValueChart : Model -> Html Msg
renderEnterpriseValueChart model =
    let
        earningsInputs =
            { calculationInputs = model.calculationInputs
            , overheadCost = model.earningsInputs.overheadCost
            , customerAcquisitionCost = model.earningsInputs.customerAcquisitionCost
            , earningsMultiple = model.earningsInputs.earningsMultiple
            }

        flatCaseData =
            Earnings.flatCase earningsInputs
                |> List.map (\data -> { x = String.fromInt data.year, y = data.enterpriseValue / 1000000 })

        rolloverCaseData =
            Earnings.rolloverCase earningsInputs
                |> List.map (\data -> { x = String.fromInt data.year, y = data.enterpriseValue / 1000000 })

        allData =
            List.map2
                (\flat rollover ->
                    { x = flat.x
                    , flatCase = flat.y
                    , rolloverCase = rollover.y
                    }
                )
                flatCaseData
                rolloverCaseData
    in
    div [ class "w-full bg-white rounded-lg p-2 sm:p-4 shadow-sm border border-gray-200 mt-4 sm:mt-8" ]
        [ div [ class "flex justify-between items-center text-lg font-bold text-gray-700 mb-1 sm:mb-4" ]
            [ text "Enterprise Value (Millions)" ]
        , div [ class "flex flex-col" ]
            [ div [ class "w-full h-[120px] md:h-[350px] overflow-x-auto overflow-y-hidden" ]
                [ C.chart
                    [ CA.height 250
                    , CA.width 800
                    , CA.margin { top = 20, bottom = 40, left = 60, right = 20 }
                    , CA.padding { top = 10, bottom = 20, left = 10, right = 10 }
                    ]
                    [ C.grid []
                    , C.yLabels [ CA.withGrid, CA.format (\v -> "$" ++ formatNumber v ++ "M") ]
                    , C.binLabels .x [ CA.moveDown 25, CA.fontSize 12 ]
                    , C.labelAt CA.middle
                        .max
                        [ CA.moveUp 15 ]
                        [ Svg.text_ [ SA.fontSize "18", SA.fill "#1F2937" ] [ Svg.text "Enterprise Value" ] ]
                    , C.bars
                        [ CA.margin 0.1
                        ]
                        [ C.bar .flatCase [ CA.color "#22C55E", CA.opacity 0.7 ]
                            |> C.named "Flat Case"
                        , C.bar .rolloverCase [ CA.color "#A855F7", CA.opacity 0.7 ]
                            |> C.named "Rollover Case"
                        ]
                        allData
                    ]
                ]
            , div [ class "flex flex-wrap justify-center gap-2 mt-1 sm:mt-4 text-sm" ]
                [ div [ class "flex items-center gap-2" ]
                    [ div [ class "w-3 h-3 bg-[#22C55E] rounded-full opacity-70" ] []
                    , text "Flat Case"
                    ]
                , div [ class "flex items-center gap-2" ]
                    [ div [ class "w-3 h-3 bg-[#A855F7] rounded-full opacity-70" ] []
                    , text "Rollover Case"
                    ]
                ]
            ]
        ]

================
File: frontend/src/Pricing2.elm
================
module Pricing2 exposing (Model, Msg, init, subscriptions, update, view)

import Html exposing (Html, button, div, h2, h3, h4, img, input, label, p, span, text)
import Html.Attributes exposing (class, for, id, placeholder, type_, value)
import Html.Events exposing (onClick, onInput)
import MyIcon
import PriceModel


type alias Model =
    { calculationInputs : PriceModel.CalculationInputs
    , calculatorExpanded : Bool
    }


init : ( Model, Cmd Msg )
init =
    ( { calculationInputs =
            { contacts = 1000
            , averageAge = 3.0
            , rolloverPercent = 7
            , commissionRate = 300
            }
      , calculatorExpanded = False
      }
    , Cmd.none
    )


type Msg
    = ContactCountChanged Int
    | RolloverPercentChanged Float
    | CommissionRateChanged Float
    | ToggleCalculator


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        ContactCountChanged count ->
            let
                oldCalculationInputs =
                    model.calculationInputs

                newCalculationInputs =
                    { oldCalculationInputs | contacts = count }
            in
            ( { model | calculationInputs = newCalculationInputs }
            , Cmd.none
            )

        RolloverPercentChanged percent ->
            let
                oldCalculationInputs =
                    model.calculationInputs

                newCalculationInputs =
                    { oldCalculationInputs | rolloverPercent = percent }
            in
            ( { model | calculationInputs = newCalculationInputs }
            , Cmd.none
            )

        CommissionRateChanged rate ->
            let
                oldCalculationInputs =
                    model.calculationInputs

                newCalculationInputs =
                    { oldCalculationInputs | commissionRate = rate }
            in
            ( { model | calculationInputs = newCalculationInputs }
            , Cmd.none
            )

        ToggleCalculator ->
            ( { model | calculatorExpanded = not model.calculatorExpanded }
            , Cmd.none
            )


view : Model -> Html Msg
view model =
    div [ class "min-h-screen bg-gray-50 flex flex-col items-center py-12 px-4 sm:px-6 lg:px-8" ]
        [ div [ class "max-w-6xl w-full space-y-8 bg-white p-8 rounded-lg shadow-md" ]
            [ div [ class "flex flex-col items-center" ]
                [ MyIcon.banknote 32 "#0F172A"
                , h2 [ class "text-2xl font-semibold text-gray-900 mt-6" ] [ text "Subscription Pricing" ]
                , p [ class "text-gray-500 mt-2 mb-6" ] [ text "Simple and transparent." ]
                , div [ class "w-full max-w-3xl mt-6" ]
                    [ div [ class "flex flex-col md:flex-row gap-6" ]
                        [ div [ class "bg-white overflow-hidden shadow rounded-lg divide-y divide-gray-200 md:w-1/2" ]
                            [ div [ class "px-4 py-5 sm:px-6 bg-indigo-50" ]
                                [ h3 [ class "text-lg leading-6 font-medium text-gray-900" ]
                                    [ text "Base Subscription" ]
                                ]
                            , div [ class "px-4 py-5 sm:p-6" ]
                                [ div [ class "flex items-center justify-between" ]
                                    [ div [ class "flex items-center" ]
                                        [ span [ class "text-3xl font-bold text-gray-900" ] [ text "$150" ]
                                        , span [ class "ml-2 text-gray-500" ] [ text "/month" ]
                                        ]
                                    , span [ class "bg-green-100 text-green-800 px-2 py-1 rounded-full text-sm font-medium" ]
                                        [ text "First 250 contacts" ]
                                    ]
                                , div [ class "mt-4" ]
                                    [ p [ class "text-sm text-gray-500" ]
                                        [ text "Our base subscription includes all features of the Medicare Max portal platform and allows you to automate retention of up to 250 contacts." ]
                                    ]
                                ]
                            ]
                        , div [ class "bg-white overflow-hidden shadow rounded-lg divide-y divide-gray-200 md:w-1/2" ]
                            [ div [ class "px-4 py-5 sm:px-6 bg-indigo-50" ]
                                [ h3 [ class "text-lg leading-6 font-medium text-gray-900" ]
                                    [ text "Additional Contacts" ]
                                ]
                            , div [ class "px-4 py-5 sm:p-6" ]
                                [ div [ class "flex items-center justify-between" ]
                                    [ div [ class "flex items-center" ]
                                        [ span [ class "text-3xl font-bold text-gray-900" ] [ text "$35" ]
                                        , span [ class "ml-2 text-gray-500" ] [ text "/month" ]
                                        ]
                                    , span [ class "bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-sm font-medium" ]
                                        [ text "per 250 contacts" ]
                                    ]
                                , div [ class "mt-4" ]
                                    [ p [ class "text-sm text-gray-500" ]
                                        [ text "For every additional 250 contacts (or portion thereof), we charge $35 per month." ]
                                    ]
                                ]
                            ]
                        ]
                    , div [ class "bg-white overflow-hidden shadow rounded-lg divide-y divide-gray-200 mt-6" ]
                        [ div
                            [ class "px-4 py-5 sm:px-6 bg-indigo-50 cursor-pointer hover:bg-indigo-100 transition-colors"
                            , onClick ToggleCalculator
                            ]
                            [ div [ class "flex justify-between items-center" ]
                                [ h3 [ class "text-lg leading-6 font-medium text-gray-900" ]
                                    [ text "Price & Revenue Calculator" ]
                                , div
                                    [ class "transform transition-transform duration-200"
                                    , class
                                        (if model.calculatorExpanded then
                                            "-rotate-90"

                                         else
                                            "rotate-90"
                                        )
                                    ]
                                    [ MyIcon.chevronRight 24 "#4A5568" ]
                                ]
                            ]
                        , if model.calculatorExpanded then
                            div [ class "px-4 py-5 sm:p-6" ]
                                [ div [ class "space-y-6" ]
                                    [ div [ class "bg-white p-4 rounded-md shadow-sm border border-gray-200" ]
                                        [ h4 [ class "text-md font-medium text-gray-800 mb-3" ] [ text "Inputs" ]
                                        , div [ class "flex flex-wrap gap-4" ]
                                            [ div [ class "flex flex-col" ]
                                                [ label
                                                    [ class "block text-sm font-medium text-gray-700 mb-1 cursor-pointer"
                                                    , for "contact-count"
                                                    ]
                                                    [ text "Number of Contacts" ]
                                                , div [ class "w-[140px]" ]
                                                    [ input
                                                        [ class "w-full border border-gray-300 rounded-md shadow-sm py-1.5 px-2 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-center"
                                                        , id "contact-count"
                                                        , type_ "number"
                                                        , placeholder "Enter number"
                                                        , value (String.fromInt model.calculationInputs.contacts)
                                                        , onInput (\str -> ContactCountChanged (String.toInt str |> Maybe.withDefault 0))
                                                        , Html.Attributes.min "0"
                                                        , Html.Attributes.step "1"
                                                        ]
                                                        []
                                                    ]
                                                ]
                                            , div [ class "flex flex-col" ]
                                                [ label
                                                    [ class "block text-sm font-medium text-gray-700 mb-1 cursor-pointer"
                                                    , for "commission-rate"
                                                    ]
                                                    [ text "Commission Per Contact" ]
                                                , div [ class "flex rounded-md shadow-sm w-[140px]" ]
                                                    [ div [ class "flex-shrink-0 inline-flex items-center px-2 rounded-l-md border border-r-0 border-gray-300 bg-indigo-100 text-indigo-800 text-sm font-medium" ]
                                                        [ text "$" ]
                                                    , input
                                                        [ class "w-full border border-gray-300 rounded-none rounded-r-md shadow-sm py-1.5 px-2 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-center"
                                                        , id "commission-rate"
                                                        , type_ "number"
                                                        , placeholder "Commission"
                                                        , value (String.fromFloat model.calculationInputs.commissionRate)
                                                        , onInput (\str -> CommissionRateChanged (String.toFloat str |> Maybe.withDefault 0))
                                                        , Html.Attributes.min "0"
                                                        , Html.Attributes.step "5"
                                                        ]
                                                        []
                                                    ]
                                                ]
                                            , div [ class "flex flex-col" ]
                                                [ label
                                                    [ class "block text-sm font-medium text-gray-700 mb-1 cursor-pointer"
                                                    , for "rollover-percent"
                                                    ]
                                                    [ text "Annual Rollover" ]
                                                , div [ class "flex rounded-md shadow-sm w-[140px]" ]
                                                    [ div [ class "flex-shrink-0 inline-flex items-center px-2 rounded-l-md border border-r-0 border-gray-300 bg-indigo-100 text-indigo-800 text-sm font-medium" ]
                                                        [ text "%" ]
                                                    , input
                                                        [ class "w-full border border-gray-300 rounded-none rounded-r-md shadow-sm py-1.5 px-2 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-center"
                                                        , id "rollover-percent"
                                                        , type_ "number"
                                                        , placeholder "Rollover"
                                                        , value (String.fromFloat model.calculationInputs.rolloverPercent)
                                                        , onInput (\str -> RolloverPercentChanged (String.toFloat str |> Maybe.withDefault 0))
                                                        , Html.Attributes.min "0"
                                                        , Html.Attributes.max "100"
                                                        , Html.Attributes.step "0.1"
                                                        ]
                                                        []
                                                    ]
                                                ]
                                            ]
                                        ]
                                    , PriceModel.view model.calculationInputs
                                    ]
                                ]

                          else
                            text ""
                        ]
                    ]
                ]
            ]
        ]


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none

================
File: frontend/src/Profile.elm
================
module Profile exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Ports
import Process
import Svg exposing (path, svg)
import Svg.Attributes as SvgAttr
import Task
import Time



-- MODEL


type alias Settings =
    { carrierContracts : List String
    , stateLicenses : List String
    , forceOrgSenderDetails : Bool
    }


type alias Model =
    { currentUser : Maybe User
    , originalUser : Maybe User -- Store original user data for comparison
    , isLoading : Bool
    , error : Maybe String
    , pendingSave : Bool
    , agentProfileLinkCopied : Bool
    , showTutorialModal : Bool -- ADDED for tutorial modal
    , orgSettings : Maybe Settings
    , forceOrgSenderDetails : Bool
    }


type alias User =
    { id : Int
    , email : String
    , firstName : String
    , lastName : String
    , phone : String
    , isAdmin : Bool
    , isAgent : Bool
    , orgSlug : String
    , signature : String
    , useOrgSenderDetails : Bool -- True = use org details, False = use agent details
    , bookingLink : String
    }


init : () -> ( Model, Cmd Msg )
init _ =
    ( { currentUser = Nothing
      , originalUser = Nothing
      , isLoading = True
      , error = Nothing
      , pendingSave = False
      , agentProfileLinkCopied = False
      , showTutorialModal = False -- ADDED: Initialize tutorial modal state
      , orgSettings = Nothing
      , forceOrgSenderDetails = False
      }
    , Cmd.batch
        [ fetchCurrentUser
        , fetchOrgSettings
        ]
    )



-- UPDATE


type Msg
    = GotCurrentUser (Result Http.Error CurrentUserResponse)
    | UpdateField String String
    | UpdateSenderPreference Bool
    | SaveProfile
    | ProfileSaved (Result Http.Error ())
    | NavigateTo String
    | WatchTutorial -- This will now open the tutorial modal
    | CopyAgentProfileLink
    | AgentProfileLinkCopied Bool
    | ResetAgentProfileLinkCopiedStatus
    | OpenTutorialModal -- ADDED
    | CloseTutorialModal -- ADDED
    | GotOrgSettings (Result Http.Error Settings)


type alias CurrentUserResponse =
    { success : Bool
    , user : Maybe User
    }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GotCurrentUser (Ok response) ->
            ( { model
                | currentUser = response.user
                , originalUser = response.user
                , isLoading = False
              }
            , Cmd.none
            )

        GotCurrentUser (Err error) ->
            ( { model
                | error = Just "Failed to load profile"
                , isLoading = False
              }
            , Cmd.none
            )

        UpdateField field value ->
            case model.currentUser of
                Just user ->
                    let
                        updatedUser =
                            case field of
                                "firstName" ->
                                    { user | firstName = value }

                                "lastName" ->
                                    { user | lastName = value }

                                "phone" ->
                                    { user | phone = String.filter Char.isDigit value }

                                "signature" ->
                                    { user | signature = value }

                                "bookingLink" ->
                                    { user | bookingLink = value }

                                _ ->
                                    user
                    in
                    ( { model | currentUser = Just updatedUser }
                    , Cmd.none
                    )

                Nothing ->
                    ( model, Cmd.none )

        UpdateSenderPreference value ->
            case model.currentUser of
                Just user ->
                    ( { model | currentUser = Just { user | useOrgSenderDetails = value } }
                    , Cmd.none
                    )

                Nothing ->
                    ( model, Cmd.none )

        SaveProfile ->
            ( { model | pendingSave = True }
            , case model.currentUser of
                Just user ->
                    saveProfile user

                Nothing ->
                    Cmd.none
            )

        ProfileSaved (Ok _) ->
            ( { model
                | pendingSave = False
                , originalUser = model.currentUser
              }
            , Cmd.none
            )

        ProfileSaved (Err _) ->
            ( { model
                | pendingSave = False
                , error = Just "Failed to save profile changes"
              }
            , Cmd.none
            )

        NavigateTo path ->
            ( model, Cmd.none )

        -- Main.elm handles navigation
        WatchTutorial ->
            -- Changed to open tutorial modal
            ( { model | showTutorialModal = True }
            , Cmd.none
            )

        OpenTutorialModal ->
            -- ADDED
            ( { model | showTutorialModal = True }
            , Cmd.none
            )

        CloseTutorialModal ->
            -- ADDED
            ( { model | showTutorialModal = False }
            , Cmd.none
            )

        CopyAgentProfileLink ->
            case model.currentUser of
                Just user ->
                    let
                        agentLink =
                            "https://" ++ "medicaremax.ai/self-onboarding/" ++ user.orgSlug ++ "?agentId=" ++ String.fromInt user.id
                    in
                    ( model, Ports.copyToClipboard agentLink )

                Nothing ->
                    ( model, Cmd.none )

        AgentProfileLinkCopied success ->
            if success then
                ( { model | agentProfileLinkCopied = True }
                , Task.perform (\_ -> ResetAgentProfileLinkCopiedStatus) (Process.sleep 2000)
                )

            else
                ( { model | error = Just "Failed to copy link to clipboard." }
                , Cmd.none
                )

        ResetAgentProfileLinkCopiedStatus ->
            ( { model | agentProfileLinkCopied = False }, Cmd.none )

        GotOrgSettings (Ok settings) ->
            ( { model
                | orgSettings = Just settings
                , forceOrgSenderDetails = settings.forceOrgSenderDetails
              }
            , Cmd.none
            )

        GotOrgSettings (Err _) ->
            ( { model
                | error = Just "Failed to load organization settings"
              }
            , Cmd.none
            )



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Profile"
    , body =
        [ div [ class "min-h-screen bg-gray-50" ]
            [ div [ class "max-w-3xl mx-auto py-6 sm:py-12 px-4 sm:px-6 lg:px-8" ]
                [ h1 [ class "text-3xl font-bold text-gray-900 mb-8" ]
                    [ text "Profile" ]
                , viewContent model
                ]
            ]

        -- Tutorial modal
        , if model.showTutorialModal then
            viewTutorialModal

          else
            text ""
        ]
    }


viewContent : Model -> Html Msg
viewContent model =
    if model.isLoading then
        div [ class "flex justify-center items-center h-64" ]
            [ viewSpinner ]

    else
        case model.currentUser of
            Just user ->
                div [ class "bg-white shadow rounded-lg p-6 space-y-6" ]
                    [ div [ class "mb-4 flex justify-end space-x-4" ]
                        [ button
                            [ class "flex items-center text-sm text-blue-600 hover:text-blue-800"
                            , onClick OpenTutorialModal -- CHANGED from OpenWalkthroughModal
                            ]
                            [ div [ class "mr-2" ]
                                [ svg
                                    [ SvgAttr.class "h-5 w-5"
                                    , SvgAttr.viewBox "0 0 20 20"
                                    , SvgAttr.fill "currentColor"
                                    ]
                                    [ path
                                        [ SvgAttr.d "M10 12a2 2 0 100-4 2 2 0 000 4z" ]
                                        []
                                    , path
                                        [ SvgAttr.fillRule "evenodd"
                                        , SvgAttr.d "M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z"
                                        , SvgAttr.clipRule "evenodd"
                                        ]
                                        []
                                    ]
                                ]
                            , text "Watch Setup Tutorial"
                            ]
                        , if user.isAdmin then
                            button
                                [ class "flex items-center text-sm text-purple-600 hover:text-purple-800"
                                , onClick (NavigateTo "/stripe")
                                ]
                                [ div [ class "mr-2" ]
                                    [ svg
                                        [ SvgAttr.class "h-5 w-5"
                                        , SvgAttr.viewBox "0 0 20 20"
                                        , SvgAttr.fill "currentColor"
                                        ]
                                        [ path
                                            [ SvgAttr.d "M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4z" ]
                                            []
                                        , path
                                            [ SvgAttr.fillRule "evenodd"
                                            , SvgAttr.d "M18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z"
                                            , SvgAttr.clipRule "evenodd"
                                            ]
                                            []
                                        ]
                                    ]
                                , text "Billing & Payments"
                                ]

                          else
                            text ""
                        ]
                    , viewBasicInfo model user
                    , viewAgentProfileLinkSection model user
                    , viewSenderSettingsSection model user
                    , viewSaveButton model
                    ]

            Nothing ->
                div [ class "text-center text-gray-600" ]
                    [ text "Failed to load profile" ]


viewBasicInfo : Model -> User -> Html Msg
viewBasicInfo model user =
    div [ class "space-y-6" ]
        [ div [ class "border-b border-gray-200 pb-4" ]
            [ h2 [ class "text-lg font-medium text-gray-900" ]
                [ text "Basic Information" ]
            ]
        , div [ class "grid grid-cols-1 sm:grid-cols-2 gap-4" ]
            [ viewField "First Name" "text" user.firstName "firstName"
            , viewField "Last Name" "text" user.lastName "lastName"
            , viewField "Email" "email" user.email "email"
            , viewField "Phone" "tel" user.phone "phone"
            ]
        ]


viewField : String -> String -> String -> String -> Html Msg
viewField label inputType value field =
    div []
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text label ]
        , input
            [ type_ inputType
            , class "mt-1 px-3.5 py-2.5 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100 disabled:text-gray-500"
            , Html.Attributes.value
                (if field == "phone" then
                    formatPhoneNumber value

                 else
                    value
                )
            , onInput (UpdateField field)
            , disabled (field == "email") -- Email cannot be changed
            ]
            []
        ]


viewSaveButton : Model -> Html Msg
viewSaveButton model =
    div [ class "mt-8 flex justify-center" ]
        [ if model.pendingSave then
            div [ class "px-6 py-3 flex items-center space-x-2" ]
                [ viewSpinner ]

          else
            button
                [ class "px-4 py-2 sm:px-6 sm:py-3 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-blue-600"
                , onClick SaveProfile
                , disabled (not (hasChanges model))
                ]
                [ text "Save Changes" ]
        ]


viewSpinner : Html Msg
viewSpinner =
    div [ class "animate-spin rounded-full h-5 w-5 border-2 border-blue-500 border-t-transparent" ] []


viewAgentProfileLinkSection : Model -> User -> Html Msg
viewAgentProfileLinkSection model user =
    let
        agentProfileLink =
            "https://medicaremax.ai/self-onboarding/" ++ user.orgSlug ++ "?agentId=" ++ String.fromInt user.id
    in
    div [ class "mt-6" ]
        [ label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text "Agent Self-Onboarding Link" ]
        , div [ class "flex items-center space-x-2" ]
            [ Svg.svg [ SvgAttr.class "h-5 w-5 text-gray-400", SvgAttr.viewBox "0 0 20 20", SvgAttr.fill "currentColor" ]
                [ Svg.path [ SvgAttr.fillRule "evenodd", SvgAttr.d "M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z", SvgAttr.clipRule "evenodd" ] []
                ]
            , input
                [ type_ "text"
                , class "flex-1 px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-gray-50 text-gray-500"
                , Html.Attributes.value agentProfileLink
                , readonly True
                ]
                []
            , button
                [ class "px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                , onClick CopyAgentProfileLink
                ]
                [ text
                    (if model.agentProfileLinkCopied then
                        "Copied!"

                     else
                        "Copy Link"
                    )
                ]
            ]
        , p [ class "text-gray-500 text-xs mt-1" ]
            [ text "Share this link with clients or non-clients to gather missing information or capture new leads to your book of business. New leads created in this way will be assigned to you."
            ]
        ]


viewSenderSettingsSection : Model -> User -> Html Msg
viewSenderSettingsSection model user =
    let
        -- If org forces org sender details, always use org details
        -- If org allows choice, use user's preference
        effectiveUseOrgDetails =
            if model.forceOrgSenderDetails then
                True

            else
                user.useOrgSenderDetails

        canChoose =
            not model.forceOrgSenderDetails
    in
    div [ class "space-y-6" ]
        [ div [ class "border-b border-gray-200 pb-4" ]
            [ h2 [ class "text-lg font-medium text-gray-900" ]
                [ text "Sender Settings" ]
            ]
        , div []
            [ p [ class "text-sm text-gray-500 mb-4" ]
                [ text "The sender settings below are controlled by your organization's configuration. "
                , a [ class "text-blue-600 hover:text-blue-800 underline", href "/settings" ]
                    [ text "Visit Organization Settings" ]
                , text " to change how agent details are used across your organization. When Organization Details is selected, agents will use the organization's contact information. When Agent Details is selected, agents can use their own contact information set above."
                ]
            , div [ class "grid grid-cols-1 md:grid-cols-2 gap-4" ]
                [ -- Organization Details Card
                  div
                    ([ class
                        ("relative rounded-lg border-2 p-6 transition-all "
                            ++ (if effectiveUseOrgDetails then
                                    "border-blue-500 bg-blue-50"

                                else
                                    "border-gray-200 bg-white"
                               )
                        )
                     , classList [ ( "cursor-pointer", canChoose ) ]
                     ]
                        ++ (if canChoose then
                                [ onClick (UpdateSenderPreference True) ]

                            else
                                []
                           )
                    )
                    [ div [ class "flex items-start" ]
                        [ div [ class "flex items-center h-5" ]
                            [ input
                                [ type_ "radio"
                                , name ("senderSettings-" ++ String.fromInt user.id)
                                , checked effectiveUseOrgDetails
                                , class "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"
                                , disabled (not canChoose)
                                ]
                                []
                            ]
                        , div [ class "ml-3" ]
                            [ label [ class "font-medium text-gray-900" ] [ text "Organization Details" ]
                            , p [ class "text-sm text-gray-500 mt-1" ]
                                [ if model.forceOrgSenderDetails then
                                    span []
                                        [ text "These details are set in the organization settings. "
                                        , a [ class "text-blue-600 hover:text-blue-800", href "/settings" ] [ text "Change organization defaults" ]
                                        , text "."
                                        ]

                                  else if effectiveUseOrgDetails then
                                    text "You have chosen to use the organization's contact information for communications."

                                  else
                                    text "When this option is selected the Organization Details will be used for the signature, phone number, and scheduling link if applicable."
                                ]
                            ]
                        ]
                    ]
                , -- Agent Details Card
                  div
                    ([ class
                        ("relative rounded-lg border-2 p-6 transition-all "
                            ++ (if not effectiveUseOrgDetails then
                                    "border-blue-500 bg-blue-50"

                                else
                                    "border-gray-200 bg-white"
                               )
                        )
                     , classList [ ( "cursor-pointer", canChoose ) ]
                     ]
                        ++ (if canChoose then
                                [ onClick (UpdateSenderPreference False) ]

                            else
                                []
                           )
                    )
                    [ div [ class "flex items-start" ]
                        [ div [ class "flex items-center h-5" ]
                            [ input
                                [ type_ "radio"
                                , name ("senderSettings-" ++ String.fromInt user.id)
                                , checked (not effectiveUseOrgDetails)
                                , class "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"
                                , disabled (not canChoose)
                                ]
                                []
                            ]
                        , div [ class "ml-3" ]
                            [ label [ class "font-medium text-gray-900" ] [ text "Agent Details" ]
                            , p [ class "text-sm text-gray-500 mt-1" ]
                                [ if not effectiveUseOrgDetails then
                                    text "You have chosen to use your personal information for communications."

                                  else
                                    text "When this option is selected your personal information from your profile will be used for the signature, phone number, and scheduling link if applicable."
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        , -- Email & SMS Signature Section (only if agent details are enabled)
          if not effectiveUseOrgDetails then
            div [ class "space-y-4" ]
                [ div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Calendar Booking Link (optional)" ]
                    , input
                        [ type_ "text"
                        , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base"
                        , Html.Attributes.value user.bookingLink
                        , onInput (UpdateField "bookingLink")
                        , placeholder "https://calendly.com/yourname"
                        ]
                        []
                    , p [ class "text-gray-500 text-xs mt-1" ]
                        [ text "If provided, this link will be used as one of the options a client may select to connect with your agency. Traditionally this would be a Calendly link, Acuity link, etc." ]
                    ]
                , div []
                    [ label [ class "block text-sm font-medium text-gray-700" ]
                        [ text "Email & SMS Signature or Sign Off" ]
                    , input
                        [ type_ "text"
                        , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base"
                        , Html.Attributes.value user.signature
                        , onInput (UpdateField "signature")
                        , placeholder ("Thanks, " ++ user.firstName ++ " " ++ user.lastName)
                        ]
                        []
                    ]
                ]

          else
            text ""
        ]



-- ADDED: Tutorial Modal View (adapted from Dashboard.elm)


viewTutorialModal : Html Msg
viewTutorialModal =
    div [ class "fixed inset-0 z-50 bg-slate-100 bg-opacity-20 backdrop-blur-sm flex items-center justify-center p-4" ]
        [ div [ class "bg-white p-4 sm:p-6 rounded-lg shadow-lg max-w-2xl w-full" ]
            [ div [ class "flex justify-between items-center mb-4" ]
                [ h2 [ class "text-lg sm:text-xl font-semibold text-[#03045E]" ] [ text "Welcome to MedicareMax!" ]
                , button
                    [ class "text-gray-400 hover:text-gray-600 text-xl p-1", onClick CloseTutorialModal ]
                    [ text "×" ]
                ]
            , div [ class "mb-4 sm:mb-6" ]
                [ iframe
                    [ src "https://www.youtube.com/embed/dQw4w9WgXcQ" -- Replace with actual tutorial video
                    , class "w-full aspect-video max-h-[50vh] sm:h-96"
                    , attribute "allowfullscreen" ""
                    , attribute "frameborder" "0"
                    ]
                    []
                ]
            , p [ class "mb-4 text-gray-600 text-sm sm:text-base" ]
                [ text "This quick setup tutorial will help you get started with MedicareMax and show you how to make the most of its features." ]
            , div [ class "flex justify-end" ]
                [ button
                    [ class "px-4 py-2 bg-[#03045E] text-white rounded-md hover:bg-opacity-90 w-full sm:w-auto"
                    , onClick CloseTutorialModal
                    ]
                    [ text "Close" ]
                ]
            ]
        ]



-- HTTP


fetchCurrentUser : Cmd Msg
fetchCurrentUser =
    Http.get
        { url = "/api/me"
        , expect = Http.expectJson GotCurrentUser currentUserResponseDecoder
        }


fetchOrgSettings : Cmd Msg
fetchOrgSettings =
    Http.get
        { url = "/api/settings"
        , expect = Http.expectJson GotOrgSettings orgSettingsDecoder
        }


saveProfile : User -> Cmd Msg
saveProfile user =
    Http.request
        { method = "PUT"
        , headers = []
        , url = "/api/profile"
        , body = Http.jsonBody (encodeUser user)
        , expect = Http.expectWhatever ProfileSaved
        , timeout = Nothing
        , tracker = Nothing
        }



-- DECODERS


currentUserResponseDecoder : Decoder CurrentUserResponse
currentUserResponseDecoder =
    Decode.map2 CurrentUserResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "user" (Decode.nullable userDecoder))


userDecoder : Decoder User
userDecoder =
    Decode.succeed User
        |> Pipeline.required "id" Decode.int
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "firstName" Decode.string
        |> Pipeline.required "lastName" Decode.string
        |> Pipeline.required "phone" Decode.string
        |> Pipeline.required "is_admin" Decode.bool
        |> Pipeline.required "is_agent" Decode.bool
        |> Pipeline.required "organization_slug" Decode.string
        |> Pipeline.optional "signature" Decode.string ""
        |> Pipeline.optional "useOrgSenderDetails" Decode.bool True
        |> Pipeline.optional "booking_link" Decode.string ""


orgSettingsDecoder : Decoder Settings
orgSettingsDecoder =
    Decode.succeed Settings
        |> Pipeline.required "carrierContracts" (Decode.list Decode.string)
        |> Pipeline.required "stateLicenses" (Decode.list Decode.string)
        |> Pipeline.required "forceOrgSenderDetails" Decode.bool



-- ADDED
-- ENCODERS


encodeUser : User -> Encode.Value
encodeUser user =
    Encode.object
        [ ( "firstName", Encode.string user.firstName )
        , ( "lastName", Encode.string user.lastName )
        , ( "email", Encode.string user.email )
        , ( "phone", Encode.string user.phone )
        , ( "signature", Encode.string user.signature )
        , ( "useOrgSenderDetails", Encode.bool user.useOrgSenderDetails )
        , ( "booking_link", Encode.string user.bookingLink )
        ]



-- HELPERS


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    let
        digits =
            String.filter Char.isDigit phone
                |> String.left 10

        len =
            String.length digits
    in
    if len == 0 then
        ""

    else if len <= 3 then
        "(" ++ digits

    else if len <= 6 then
        "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

    else
        "("
            ++ String.left 3 digits
            ++ ") "
            ++ String.slice 3 6 digits
            ++ "-"
            ++ String.dropLeft 6 digits



-- Add this helper function to check for changes


hasChanges : Model -> Bool
hasChanges model =
    case ( model.currentUser, model.originalUser ) of
        ( Just current, Just original ) ->
            current.firstName
                /= original.firstName
                || current.lastName
                /= original.lastName
                || current.phone
                /= original.phone
                || current.signature
                /= original.signature
                || current.useOrgSenderDetails
                /= original.useOrgSenderDetails
                || current.bookingLink
                /= original.bookingLink

        _ ->
            False



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Ports.onCopyResult AgentProfileLinkCopied

================
File: frontend/src/Quote.elm
================
module Quote exposing (Model, Msg(..), init, subscriptions, update, view)

import AgeCalc exposing (getAgeNextMonth)
import Browser
import Browser.Navigation as Nav
import Date exposing (Date)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput, onSubmit)
import Http
import Json.Decode as D
import Task
import Time
import Url.Builder as Builder
import Url.Parser as Parser exposing ((<?>), Parser)
import Url.Parser.Query as Query


type alias Model =
    { zipCode : String
    , dateOfBirth : String
    , key : Nav.Key
    , tobacco : Bool
    , gender : String
    , currentDate : Maybe Date
    , quoteId : Maybe String
    , error : Maybe String
    , currentCarrier : Maybe String
    , planType : Maybe String
    , state : Maybe String
    , counties : List String
    , selectedCounty : Maybe String
    , isLoadingZipData : Bool
    , zipError : Maybe String
    , orgId : Maybe String
    }


type Msg
    = UpdateZipCode String
    | UpdateDateOfBirth String
    | UpdateTobacco String
    | UpdateGender String
    | SubmitForm
    | GotCurrentDate Date
    | GotQuoteInfo (Result Http.Error QuoteInfo)
    | GotZipInfo (Result Http.Error ZipInfo)
    | UpdateSelectedCounty String


type alias InitialValues =
    { zipCode : Maybe String
    , dateOfBirth : Maybe String
    , tobacco : Maybe Bool
    , gender : Maybe String
    , quoteId : Maybe String
    , planType : Maybe String
    , orgId : Maybe String
    }


type alias QuoteInfo =
    { zipCode : String
    , dateOfBirth : String
    , tobacco : Bool
    , gender : String
    , currentCarrier : Maybe String
    , orgId : String
    }


type alias ZipInfo =
    { state : String
    , counties : List String
    }


init : Nav.Key -> InitialValues -> ( Model, Cmd Msg )
init key initialValues =
    let
        model =
            { zipCode = Maybe.withDefault "" initialValues.zipCode
            , dateOfBirth = Maybe.withDefault "" initialValues.dateOfBirth
            , key = key
            , tobacco = Maybe.withDefault False initialValues.tobacco
            , gender = Maybe.withDefault "M" initialValues.gender
            , currentDate = Nothing
            , quoteId = initialValues.quoteId
            , error = Nothing
            , currentCarrier = Nothing
            , planType = initialValues.planType
            , state = Nothing
            , counties = []
            , selectedCounty = Nothing
            , isLoadingZipData = False
            , zipError = Nothing
            , orgId = initialValues.orgId
            }

        commands =
            [ Task.perform GotCurrentDate Date.today
            , case initialValues.quoteId of
                Just id ->
                    fetchQuoteInfo id

                Nothing ->
                    Cmd.none
            ]
                ++ (if String.length model.zipCode == 5 then
                        [ fetchZipInfo model.zipCode ]

                    else
                        []
                   )
    in
    ( model, Cmd.batch commands )


fetchQuoteInfo : String -> Cmd Msg
fetchQuoteInfo quoteId =
    Http.get
        { url = "/api/quotes/decode/" ++ quoteId
        , expect = Http.expectJson GotQuoteInfo quoteInfoDecoder
        }


fetchZipInfo : String -> Cmd Msg
fetchZipInfo zipCode =
    Http.get
        { url = "/api/zipinfo/" ++ zipCode
        , expect = Http.expectJson GotZipInfo zipInfoDecoder
        }


quoteInfoDecoder : D.Decoder QuoteInfo
quoteInfoDecoder =
    D.field "success" D.bool
        |> D.andThen
            (\success ->
                if success then
                    D.map6 QuoteInfo
                        (D.at [ "contact", "zipCode" ] D.string)
                        (D.at [ "contact", "dateOfBirth" ] D.string)
                        (D.at [ "contact", "tobacco" ] D.bool)
                        (D.at [ "contact", "gender" ] D.string)
                        (D.at [ "contact", "currentCarrier" ] (D.nullable D.string))
                        (D.field "orgId" D.string)

                else
                    D.field "error" D.string
                        |> D.andThen (\error -> D.fail error)
            )


zipInfoDecoder : D.Decoder ZipInfo
zipInfoDecoder =
    D.field "success" D.bool
        |> D.andThen
            (\success ->
                if success then
                    D.field "data"
                        (D.map2 ZipInfo
                            (D.field "state" D.string)
                            (D.field "counties" (D.list D.string))
                        )

                else
                    D.field "error" D.string
                        |> D.andThen (\error -> D.fail error)
            )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateZipCode zip ->
            let
                filteredZip =
                    String.filter Char.isDigit zip |> String.left 5

                cmd =
                    if String.length filteredZip == 5 && filteredZip /= model.zipCode then
                        fetchZipInfo filteredZip

                    else
                        Cmd.none
            in
            ( { model
                | zipCode = filteredZip
                , isLoadingZipData = String.length filteredZip == 5 && filteredZip /= model.zipCode
                , state =
                    if String.length filteredZip /= 5 then
                        Nothing

                    else
                        model.state
                , counties =
                    if String.length filteredZip /= 5 then
                        []

                    else
                        model.counties
                , selectedCounty =
                    if String.length filteredZip /= 5 then
                        Nothing

                    else
                        model.selectedCounty
                , zipError = Nothing
              }
            , cmd
            )

        UpdateDateOfBirth dob ->
            ( { model | dateOfBirth = dob }, Cmd.none )

        UpdateTobacco value ->
            ( { model | tobacco = value == "true" }, Cmd.none )

        UpdateGender value ->
            ( { model | gender = value }, Cmd.none )

        GotCurrentDate date ->
            ( { model | currentDate = Just date }, Cmd.none )

        GotQuoteInfo result ->
            case result of
                Ok quoteInfo ->
                    let
                        updatedModel =
                            { model
                                | zipCode = quoteInfo.zipCode
                                , dateOfBirth = quoteInfo.dateOfBirth
                                , tobacco = quoteInfo.tobacco
                                , gender = quoteInfo.gender
                                , currentCarrier = quoteInfo.currentCarrier
                                , orgId = Just quoteInfo.orgId
                            }

                        cmd =
                            if String.length quoteInfo.zipCode == 5 then
                                fetchZipInfo quoteInfo.zipCode

                            else
                                Cmd.none
                    in
                    ( updatedModel, cmd )

                Err err ->
                    let
                        errorMessage =
                            case err of
                                Http.BadBody errorBody ->
                                    if String.contains "Contact not found" errorBody then
                                        "Quote not found or expired. Please try again or contact support."

                                    else
                                        "Failed to load quote information: " ++ errorBody

                                Http.BadStatus 404 ->
                                    "Quote not found or expired. Please try again or contact support."

                                _ ->
                                    "Failed to load quote information. Please try again."
                    in
                    ( { model | error = Just errorMessage }, Cmd.none )

        GotZipInfo result ->
            case result of
                Ok zipInfo ->
                    let
                        -- Always select the first county as default
                        selectedCounty =
                            List.head zipInfo.counties
                    in
                    ( { model
                        | state = Just zipInfo.state
                        , counties = zipInfo.counties
                        , selectedCounty = selectedCounty
                        , isLoadingZipData = False
                        , zipError = Nothing
                      }
                    , Cmd.none
                    )

                Err error ->
                    ( { model
                        | state = Nothing
                        , counties = []
                        , selectedCounty = Nothing
                        , isLoadingZipData = False
                        , zipError = Just (httpErrorToString error)
                      }
                    , Cmd.none
                    )

        UpdateSelectedCounty county ->
            ( { model | selectedCounty = Just county }, Cmd.none )

        SubmitForm ->
            if String.length model.zipCode /= 5 then
                ( { model | zipError = Just "Please enter a valid 5-digit zip code" }, Cmd.none )

            else if model.state == Nothing then
                ( { model | zipError = Just "Unable to determine state from zip code" }, Cmd.none )

            else
                let
                    age =
                        case model.currentDate of
                            Just currentDate ->
                                getAgeNextMonth model.dateOfBirth currentDate
                                    |> String.fromInt

                            Nothing ->
                                "65"

                    -- Get the selected county or the first one from the list
                    county =
                        case model.selectedCounty of
                            Just c ->
                                c

                            Nothing ->
                                List.head model.counties
                                    |> Maybe.withDefault ""

                    state =
                        model.state
                            |> Maybe.withDefault ""

                    -- If we have a quoteId, use that for navigation first
                    compareUrl =
                        case model.quoteId of
                            Just id ->
                                -- When we have a quoteId, we don't need other parameters
                                Builder.absolute [ "compare" ] [ Builder.string "id" id ]

                            Nothing ->
                                -- Otherwise build the URL with all parameters
                                Builder.absolute [ "compare" ]
                                    ([ Builder.string "zip" model.zipCode
                                     , Builder.string "state" state
                                     , Builder.string "county" county
                                     , Builder.string "gender" model.gender
                                     , Builder.string "tobacco"
                                        (if model.tobacco then
                                            "true"

                                         else
                                            "false"
                                        )
                                     , Builder.string "age" age
                                     , Builder.string "dateOfBirth" model.dateOfBirth
                                     ]
                                        ++ (case model.currentCarrier of
                                                Just carrier ->
                                                    [ Builder.string "currentCarrier" carrier ]

                                                Nothing ->
                                                    []
                                           )
                                        ++ (case model.planType of
                                                Just planType ->
                                                    [ Builder.string "planType" planType ]

                                                Nothing ->
                                                    [ Builder.string "planType" "G" ]
                                            -- Default to G if no plan type provided
                                           )
                                    )
                in
                ( model
                , Nav.pushUrl model.key compareUrl
                )


view : Model -> Browser.Document Msg
view model =
    { title = "Get Your Quote - Medicare Max"
    , body =
        [ div [ class "container mx-auto px-4 py-6 sm:py-8 max-w-xl" ]
            [ h1 [ class "text-2xl sm:text-3xl font-bold text-center mb-4 sm:mb-6" ]
                [ text "Get Your Quote" ]
            , div [ class "flex justify-center mb-6 sm:mb-8" ]
                [ button
                    [ class "flex items-center gap-1 sm:gap-2 px-3 sm:px-4 py-1.5 sm:py-2 rounded-full border border-blue-500 text-blue-500 hover:bg-blue-50 transition-colors text-sm"
                    ]
                    [ span [ class "text-xs sm:text-sm" ] [ text "▶ Video" ]
                    , text "Rates and Plan Options"
                    ]
                ]
            , if model.error /= Nothing || (model.quoteId /= Nothing && String.isEmpty model.zipCode) then
                -- Show error or loading message when we have a quoteId but no data yet
                let
                    message =
                        case model.error of
                            Just error ->
                                div [ class "bg-red-100 border border-red-400 text-red-700 px-3 sm:px-4 py-2 sm:py-3 rounded mb-4 text-sm" ]
                                    [ text error ]

                            Nothing ->
                                if model.quoteId /= Nothing && String.isEmpty model.zipCode then
                                    div [ class "bg-blue-100 border border-blue-400 text-blue-700 px-3 sm:px-4 py-2 sm:py-3 rounded mb-4 text-sm" ]
                                        [ text "Loading your quote information..." ]

                                else
                                    text ""
                in
                div [] [ message, viewFormForManualEntry model ]

              else
                -- Standard form
                Html.form [ onSubmit SubmitForm, class "space-y-4 sm:space-y-6" ]
                    [ viewFormInput "Zip Code" "text" model.zipCode UpdateZipCode True

                    -- Show zip code loading state or error if any
                    , if model.isLoadingZipData then
                        div [ class "text-xs sm:text-sm text-blue-600" ]
                            [ text "Looking up location..." ]

                      else if model.zipError /= Nothing then
                        div [ class "text-xs sm:text-sm text-red-600" ]
                            [ text (Maybe.withDefault "Invalid zip code" model.zipError) ]

                      else
                        text ""

                    -- Only show the county dropdown if there are multiple counties
                    , if List.length model.counties > 1 then
                        viewCountyDropdown model.counties model.selectedCounty

                      else
                        text ""
                    , viewFormInput "Date of Birth" "date" model.dateOfBirth UpdateDateOfBirth True
                    , viewFormRadioGroup "Tobacco User"
                        (if model.tobacco then
                            "true"

                         else
                            "false"
                        )
                        UpdateTobacco
                        [ ( "true", "Yes" ), ( "false", "No" ) ]
                    , viewFormRadioGroup "Gender"
                        model.gender
                        UpdateGender
                        [ ( "M", "Male" ), ( "F", "Female" ) ]
                    , button
                        [ class "w-full bg-purple-600 text-white py-3 sm:py-4 rounded-lg hover:bg-purple-700 transition-colors mt-6 sm:mt-8 text-base sm:text-lg"
                        , type_ "submit"
                        ]
                        [ text "Next" ]
                    ]
            ]
        ]
    }


viewCountyDropdown : List String -> Maybe String -> Html Msg
viewCountyDropdown counties selectedCounty =
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-1.5 sm:mb-2" ]
            [ text "County" ]
        , select
            [ class "w-full px-3 sm:px-4 py-2.5 sm:py-3 bg-white border-[2px] sm:border-[2.5px] border-purple-300 rounded-lg text-gray-700 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200 text-sm sm:text-base"
            , onInput UpdateSelectedCounty
            , required True
            ]
            (option [ value "", disabled True, selected (selectedCounty == Nothing) ]
                [ text "Select your county" ]
                :: List.map
                    (\county ->
                        option
                            [ value county
                            , selected (selectedCounty == Just county)
                            ]
                            [ text county ]
                    )
                    counties
            )
        ]


viewFormInput : String -> String -> String -> (String -> Msg) -> Bool -> Html Msg
viewFormInput labelText inputType inputValue msg isRequired =
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-1.5 sm:mb-2" ]
            [ text labelText ]
        , if inputType == "date" then
            input
                [ type_ inputType
                , class "w-full px-3 sm:px-4 py-2.5 sm:py-3 bg-white border-[2px] sm:border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200 text-sm sm:text-base"
                , Html.Attributes.value inputValue
                , onInput msg
                , required isRequired
                ]
                []

          else if labelText == "Zip Code" then
            input
                [ type_ inputType
                , class "w-full px-3 sm:px-4 py-2.5 sm:py-3 bg-white border-[2px] sm:border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200 text-sm sm:text-base"
                , Html.Attributes.value (formatZipCode inputValue)
                , onInput msg
                , required isRequired
                , Html.Attributes.maxlength 5
                , Html.Attributes.pattern "[0-9]*"
                ]
                []

          else
            input
                [ type_ inputType
                , class "w-full px-3 sm:px-4 py-2.5 sm:py-3 bg-white border-[2px] sm:border-[2.5px] border-purple-300 rounded-lg text-gray-700 placeholder-gray-400 shadow-sm hover:border-purple-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 focus:bg-white transition-all duration-200 text-sm sm:text-base"
                , Html.Attributes.value inputValue
                , onInput msg
                , required isRequired
                ]
                []
        ]


viewFormRadioGroup : String -> String -> (String -> Msg) -> List ( String, String ) -> Html Msg
viewFormRadioGroup labelText selectedValue msg options =
    div [ class "form-group" ]
        [ Html.label [ class "block text-sm font-medium text-gray-700 mb-1.5 sm:mb-2" ]
            [ text labelText ]
        , div [ class "flex flex-col sm:flex-row gap-2 sm:gap-4 w-full" ]
            (List.map
                (\( val, txt ) ->
                    label
                        [ class
                            ("flex items-center justify-center px-3 sm:px-4 py-2 rounded-lg border-2 cursor-pointer transition-all duration-200 flex-1 "
                                ++ (if selectedValue == val then
                                        "border-purple-500 bg-purple-50 text-purple-700"

                                    else
                                        "border-gray-200 hover:border-purple-200"
                                   )
                            )
                        ]
                        [ input
                            [ type_ "radio"
                            , value val
                            , checked (selectedValue == val)
                            , onInput msg
                            , class "sr-only"
                            ]
                            []
                        , text txt
                        ]
                )
                options
            )
        ]


formatZipCode : String -> String
formatZipCode zip =
    String.filter Char.isDigit zip |> String.left 5


httpErrorToString : Http.Error -> String
httpErrorToString error =
    case error of
        Http.BadUrl url ->
            "Bad URL: " ++ url

        Http.Timeout ->
            "Request timed out"

        Http.NetworkError ->
            "Network error"

        Http.BadStatus statusCode ->
            "Bad status: " ++ String.fromInt statusCode

        Http.BadBody message ->
            "Data error: " ++ message


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none



-- Function to display a form that allows manual entry when quote loading fails


viewFormForManualEntry : Model -> Html Msg
viewFormForManualEntry model =
    div []
        [ p [ class "text-center text-gray-600 mb-6" ]
            [ text "You can manually enter your information below to get a quote." ]
        , Html.form [ onSubmit SubmitForm, class "space-y-4 sm:space-y-6" ]
            [ viewFormInput "Zip Code" "text" model.zipCode UpdateZipCode True
            , viewFormInput "Date of Birth" "date" model.dateOfBirth UpdateDateOfBirth True
            , viewFormRadioGroup "Tobacco User"
                (if model.tobacco then
                    "true"

                 else
                    "false"
                )
                UpdateTobacco
                [ ( "true", "Yes" ), ( "false", "No" ) ]
            , viewFormRadioGroup "Gender"
                model.gender
                UpdateGender
                [ ( "M", "Male" ), ( "F", "Female" ) ]
            , button
                [ class "w-full bg-purple-600 text-white py-3 sm:py-4 rounded-lg hover:bg-purple-700 transition-colors mt-6 sm:mt-8 text-base sm:text-lg"
                , type_ "submit"
                ]
                [ text "Next" ]
            ]
        ]

================
File: frontend/src/QuoteBirthdayRules.elm
================
module QuoteBirthdayRules exposing
    ( PlanRestriction(..)
    , canPresentPlan
    , getQuotePlanRestriction
    )

{-| This module handles birthday rule restrictions for the quote page.
It determines which plans can be presented based on the contact's state and current plan.
-}

import BirthdayRules exposing (canPresentDifferentPlanOnly, isInBirthdayRuleWindow)
import Date exposing (Date)


{-| Represents the plan restriction for a quote.
-}
type PlanRestriction
    = NoRestriction
    | DifferentPlanOnly
    | NoQuoteAllowed


{-| Determines which plans can be presented based on the contact's state, birth date, and current plan.
-}
getQuotePlanRestriction : String -> Date -> Date -> String -> PlanRestriction
getQuotePlanRestriction state birthDate currentDate currentPlan =
    if isInBirthdayRuleWindow state birthDate currentDate then
        if canPresentDifferentPlanOnly state then
            DifferentPlanOnly

        else
            NoQuoteAllowed

    else
        NoRestriction


{-| Checks if a plan can be presented based on the restriction and the contact's current plan.
-}
canPresentPlan : PlanRestriction -> String -> String -> Bool
canPresentPlan restriction currentPlan planToPresent =
    case restriction of
        NoRestriction ->
            True

        NoQuoteAllowed ->
            False

        DifferentPlanOnly ->
            -- Only allow presenting a different plan type
            -- For example, if current plan is "Plan G", only allow "Plan N" and vice versa
            case ( currentPlan, planToPresent ) of
                ( "Plan G", "Plan N" ) ->
                    True

                ( "G", "Plan N" ) ->
                    True

                ( "G", "N" ) ->
                    True

                ( "Plan G", "N" ) ->
                    True

                ( "Plan N", "Plan G" ) ->
                    True

                ( "N", "Plan G" ) ->
                    True

                ( "N", "G" ) ->
                    True

                ( "Plan N", "G" ) ->
                    True

                _ ->
                    False

================
File: frontend/src/Schedule.elm
================
module Schedule exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput, onSubmit)
import Http
import Json.Decode as D
import Json.Decode.Pipeline as P
import Json.Encode as E
import List.Extra
import MyIcon
import Svg
import Svg.Attributes as SvgAttr
import Url
import Utils.QuoteHeader exposing (viewHeader)


type EligibilityStatus
    = Accept
    | Decline
    | Generic


type alias OrgInfo =
    { orgName : Maybe String
    , orgLogo : Maybe String
    , orgSlug : String
    , orgPhone : String
    , orgRedirectUrl : Maybe String
    }


type alias AgentInfo =
    { name : String
    , firstName : String
    , phone : String
    , useOrgSenderDetails : Bool
    , bookingLink : String
    }


type alias ContactInfo =
    { email : String
    , firstName : String
    , lastName : String
    , phoneNumber : String
    }


type alias ScheduleInfo =
    { contact : ContactInfo
    , organization : OrgInfo
    , agent : AgentInfo
    , useOrg : Bool
    , forceOrgSenderDetails : Bool
    }


type alias Model =
    { name : Maybe String
    , email : Maybe String
    , phoneNumber : Maybe String
    , isSubmitting : Bool
    , isSubmittingAEP : Bool
    , isSubmittingFollowUp : Bool
    , error : Maybe String
    , success : Bool
    , quoteId : Maybe String
    , key : Nav.Key
    , status : EligibilityStatus
    , redirectUrl : Maybe String
    , scheduleInfo : Maybe ScheduleInfo
    , isLoading : Bool
    , demoMode : Bool
    , demoRedirectUrl : Maybe String
    , forceOrgSenderDetails : Bool
    }


type Msg
    = UpdateName String
    | UpdateEmail String
    | UpdatePhoneNumber String
    | SubmitForm
    | GotSubmitResponse (Result Http.Error SubmitResponse)
    | GotScheduleInfo (Result Http.Error ScheduleInfo)
    | RequestAEP
    | GotAEPResponse (Result Http.Error SubmitResponse)
    | RequestFollowUp
    | GotFollowUpResponse (Result Http.Error SubmitResponse)
    | CalendlyOpened


type alias SubmitResponse =
    { success : Bool
    , message : String
    }


init : Nav.Key -> Maybe String -> Maybe String -> ( Model, Cmd Msg )
init key maybeQuoteId maybeStatus =
    let
        status =
            case maybeStatus of
                Just "accept" ->
                    Accept

                Just "decline" ->
                    Decline

                _ ->
                    Generic

        commands =
            case maybeQuoteId of
                Just quoteId ->
                    [ Http.get
                        { url = "/api/schedule/info/" ++ quoteId
                        , expect = Http.expectJson GotScheduleInfo scheduleInfoDecoder
                        }
                    ]

                Nothing ->
                    []
    in
    ( { name = Nothing
      , email = Nothing
      , phoneNumber = Nothing
      , isSubmitting = False
      , isSubmittingAEP = False
      , isSubmittingFollowUp = False
      , error = Nothing
      , success = False
      , quoteId = maybeQuoteId
      , key = key
      , status = status
      , redirectUrl = Nothing --Just "https://calendly.com/josh-musick-medicaremax/medicare-max-demo?month=2025-04" --"https://calendly.com/medicareschool-max/30min"
      , scheduleInfo = Nothing
      , isLoading = True
      , demoMode = False -- sets CTA to demo mode always
      , demoRedirectUrl = Just "https://calendly.com/josh-musick-medicaremax/medicare-max-demo?month=2025-04" --"https://calendly.com/medicareschool-max/30min"
      , forceOrgSenderDetails = False
      }
    , Cmd.batch commands
    )


contactInfoDecoder : D.Decoder ContactInfo
contactInfoDecoder =
    D.map4 ContactInfo
        (D.field "email" D.string)
        (D.field "firstName" D.string)
        (D.field "lastName" D.string)
        (D.field "phoneNumber" D.string)


agentInfoDecoder : D.Decoder AgentInfo
agentInfoDecoder =
    D.succeed AgentInfo
        |> P.required "name" D.string
        |> P.required "firstName" D.string
        |> P.required "phone" D.string
        |> P.optional "use_org_sender_details" D.bool True
        |> P.optional "booking_link" D.string ""


orgInfoDecoder : D.Decoder OrgInfo
orgInfoDecoder =
    D.succeed OrgInfo
        |> P.required "name" (D.nullable D.string)
        |> P.required "logo" (D.nullable D.string)
        |> P.required "slug" D.string
        |> P.required "phone" D.string
        |> P.optional "redirectUrl" (D.nullable D.string) Nothing


scheduleInfoDecoder : D.Decoder ScheduleInfo
scheduleInfoDecoder =
    D.succeed ScheduleInfo
        |> P.required "contact" contactInfoDecoder
        |> P.required "organization" orgInfoDecoder
        |> P.required "agent" agentInfoDecoder
        |> P.optional "useOrg" D.bool True
        |> P.optional "force_org_sender_details" D.bool False


submitResponseDecoder : D.Decoder SubmitResponse
submitResponseDecoder =
    D.map2 SubmitResponse
        (D.field "success" D.bool)
        (D.field "message" D.string)


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateName name ->
            ( { model | name = Just name }, Cmd.none )

        UpdateEmail email ->
            ( { model | email = Just email }, Cmd.none )

        UpdatePhoneNumber phoneNumber ->
            ( { model | phoneNumber = Just (stripPhoneNumber phoneNumber) }, Cmd.none )

        SubmitForm ->
            ( { model | isSubmitting = True }
            , Http.post
                { url = "/api/contact-request"
                , body = Http.jsonBody (encodeForm model)
                , expect = Http.expectJson GotSubmitResponse submitResponseDecoder
                }
            )

        GotSubmitResponse result ->
            case result of
                Ok response ->
                    if response.success then
                        ( { model | isSubmitting = False, success = True }
                        , Cmd.none
                        )

                    else
                        ( { model | isSubmitting = False, error = Just response.message }
                        , Cmd.none
                        )

                Err _ ->
                    ( { model | isSubmitting = False, error = Just "Failed to submit form. Please try again." }
                    , Cmd.none
                    )

        GotScheduleInfo result ->
            case result of
                Ok info ->
                    let
                        safeRedirectUrl =
                            info.organization.orgRedirectUrl
                                |> Maybe.map
                                    (\url ->
                                        if String.startsWith "http" url then
                                            url

                                        else
                                            "https://" ++ url
                                    )

                        -- Determine effective redirect URL based on sender settings
                        effectiveRedirectUrl =
                            if info.forceOrgSenderDetails then
                                safeRedirectUrl

                            else if info.agent.useOrgSenderDetails then
                                safeRedirectUrl

                            else if String.isEmpty info.agent.bookingLink then
                                -- When using agent settings but no booking link, don't show calendar button
                                Nothing

                            else
                                Just
                                    (if String.startsWith "http" info.agent.bookingLink then
                                        info.agent.bookingLink

                                     else
                                        "https://" ++ info.agent.bookingLink
                                    )
                    in
                    ( { model
                        | scheduleInfo = Just info
                        , email = Just info.contact.email
                        , name = Just (info.contact.firstName ++ " " ++ info.contact.lastName)
                        , phoneNumber = Just info.contact.phoneNumber
                        , isLoading = False
                        , redirectUrl = effectiveRedirectUrl
                        , forceOrgSenderDetails = info.forceOrgSenderDetails
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model | isLoading = False }, Cmd.none )

        RequestAEP ->
            case model.quoteId of
                Just quoteId ->
                    ( { model | isSubmittingAEP = True }
                    , Http.post
                        { url = "/api/schedule/aep-request/" ++ quoteId
                        , body = Http.emptyBody
                        , expect = Http.expectJson GotAEPResponse submitResponseDecoder
                        }
                    )

                Nothing ->
                    ( { model | error = Just "Unable to process AEP request" }, Cmd.none )

        GotAEPResponse result ->
            case result of
                Ok response ->
                    if response.success then
                        ( { model | success = True, isSubmittingAEP = False }, Cmd.none )

                    else
                        ( { model | error = Just response.message, isSubmittingAEP = False }, Cmd.none )

                Err _ ->
                    ( { model | error = Just "Failed to submit AEP request. Please try again.", isSubmittingAEP = False }
                    , Cmd.none
                    )

        RequestFollowUp ->
            case model.quoteId of
                Just quoteId ->
                    ( { model | isSubmittingFollowUp = True }
                    , Http.post
                        { url = "/api/schedule/request-follow-up/" ++ quoteId
                        , body = Http.emptyBody
                        , expect = Http.expectJson GotFollowUpResponse submitResponseDecoder
                        }
                    )

                Nothing ->
                    ( { model | error = Just "Unable to process follow-up request" }, Cmd.none )

        GotFollowUpResponse result ->
            case result of
                Ok response ->
                    if response.success then
                        ( { model | success = True, isSubmittingFollowUp = False }, Cmd.none )

                    else
                        ( { model | error = Just response.message, isSubmittingFollowUp = False }, Cmd.none )

                Err error ->
                    ( { model | error = Just "Failed to submit follow-up request. Please try again.", isSubmittingFollowUp = False }
                    , Cmd.none
                    )

        CalendlyOpened ->
            ( { model | success = True }, Cmd.none )


stripPhoneNumber : String -> String
stripPhoneNumber phoneNumber =
    String.filter Char.isDigit phoneNumber


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    if String.isEmpty phone then
        ""

    else
        let
            digits =
                String.filter Char.isDigit phone
                    |> String.left 10

            len =
                String.length digits
        in
        if len == 0 then
            ""

        else if len <= 3 then
            "(" ++ digits

        else if len <= 6 then
            "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

        else
            "(" ++ String.left 3 digits ++ ") " ++ String.slice 3 6 digits ++ "-" ++ String.dropLeft 6 digits


encodeForm : Model -> E.Value
encodeForm model =
    E.object
        [ ( "name", model.name |> Maybe.map Url.percentEncode |> Maybe.map E.string |> Maybe.withDefault E.null )
        , ( "email", model.email |> Maybe.map Url.percentEncode |> Maybe.map E.string |> Maybe.withDefault E.null )
        , ( "phoneNumber", model.phoneNumber |> Maybe.map stripPhoneNumber |> Maybe.map E.string |> Maybe.withDefault E.null )
        , ( "type"
          , E.string
                (case model.status of
                    Accept ->
                        "accept"

                    Decline ->
                        "decline"

                    Generic ->
                        "generic"
                )
          )
        , ( "quoteId", Maybe.map E.string model.quoteId |> Maybe.withDefault E.null )
        ]


view : Model -> Browser.Document Msg
view model =
    { title = getTitle model.status
    , body =
        [ if model.isLoading then
            viewLoading

          else
            div [ class "min-h-screen bg-[#F9FAFB]" ]
                [ div [ class "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-12" ]
                    [ -- Organization Logo/Name
                      div [ class "flex justify-center items-center mb-8 px-4" ]
                        [ case model.scheduleInfo of
                            Just info ->
                                viewHeader info.organization.orgLogo info.organization.orgName

                            Nothing ->
                                text ""
                        ]
                    , if model.success then
                        div [ class "text-center" ]
                            [ h1 [ class "text-2xl sm:text-3xl font-bold text-gray-900 mb-3 sm:mb-4" ]
                                [ text "Thank You" ]
                            , p [ class "text-gray-600 text-base sm:text-lg" ]
                                [ text "We'll be in touch soon to discuss your options." ]
                            , div [ class "mt-8" ]
                                [ case model.scheduleInfo of
                                    Just info ->
                                        a
                                            [ href ("/self-onboarding/" ++ info.organization.orgSlug)
                                            , class "inline-flex items-center gap-2 text-[#03045E] hover:text-[#0077B6] transition-colors"
                                            ]
                                            [ MyIcon.clipboardPaste 24 "currentColor"
                                            , span [ class "font-medium" ] [ text "Help someone else get started" ]
                                            ]

                                    Nothing ->
                                        text ""
                                ]
                            ]

                      else if model.demoMode then
                        viewDemoCTA model

                      else
                        viewCTA model
                    ]
                ]
        ]
    }


viewDemoCTA : Model -> Html Msg
viewDemoCTA model =
    div [ class "flex flex-col max-w-xl mx-auto" ]
        [ div [ class "border border-[#DCE2E5] shadow-sm overflow-hidden rounded-lg" ]
            [ div [ class "bg-[#F9F5FF] p-6" ]
                [ h1 [ class "text-2xl sm:text-3xl font-extrabold text-black mb-4" ]
                    [ text "Let's Connect" ]
                , p [ class "text-black text-base leading-relaxed" ]
                    [ text "Interested in learning how you can use Medicare Max for your clients? Discover how our platform can help your agency maximize client retention, freeing up time to focus on what matters most." ]
                ]
            , div [ class "bg-white p-6 sm:p-8" ]
                [ p [ class "text-[#475467] text-sm mb-6" ]
                    [ text "Book a call with us to learn more" ]
                , case model.error of
                    Just error ->
                        div [ class "bg-red-50 border border-red-400 text-red-700 px-4 py-3 rounded mb-6 text-base" ]
                            [ text error ]

                    Nothing ->
                        text ""
                , div [ class "space-y-4" ]
                    [ a
                        [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                        , href (makeDemoCalendlyUrl model)
                        , target "_blank"
                        , onClick CalendlyOpened
                        ]
                        [ div [ class "flex items-center space-x-3" ]
                            [ span [ class "w-6 h-6 flex items-center justify-center" ]
                                [ MyIcon.calendarDays 24 "#03045E" ]
                            , span [ class "font-semibold text-base" ]
                                [ text "Schedule a Demo Call" ]
                            ]
                        ]
                    ]
                ]
            ]
        ]


viewCTA : Model -> Html Msg
viewCTA model =
    div [ class "flex flex-col max-w-xl mx-auto" ]
        [ div [ class "border border-[#DCE2E5] shadow-sm overflow-hidden rounded-lg" ]
            [ div [ class "bg-[#F9F5FF] p-6" ]
                [ h1 [ class "text-2xl sm:text-3xl font-extrabold text-black mb-4" ]
                    [ text (getHeading model.status) ]
                , p [ class "text-black text-base leading-relaxed" ]
                    [ text (getMessage model.status) ]
                ]
            , div [ class "bg-white p-6 sm:p-8" ]
                [ p [ class "text-[#667085] text-sm mb-6" ]
                    [ text "Select an Option Below" ]
                , case model.error of
                    Just error ->
                        div [ class "bg-red-50 border border-red-400 text-red-700 px-4 py-3 rounded mb-6 text-base" ]
                            [ text error ]

                    Nothing ->
                        text ""
                , case model.scheduleInfo of
                    Just info ->
                        case model.status of
                            Accept ->
                                viewAcceptButtons model info

                            Decline ->
                                viewDeclineButtons model info

                            Generic ->
                                viewGenericButtons model info

                    Nothing ->
                        text ""
                ]
            ]
        ]


viewAcceptButtons : Model -> ScheduleInfo -> Html Msg
viewAcceptButtons model info =
    let
        -- Determine whether to use org or agent details
        effectiveUseOrg =
            if model.forceOrgSenderDetails then
                True

            else
                info.agent.useOrgSenderDetails
    in
    if effectiveUseOrg then
        viewAcceptButtonsOrg model info

    else
        viewAcceptButtonsAgent model info


viewAcceptButtonsAgent : Model -> ScheduleInfo -> Html Msg
viewAcceptButtonsAgent model info =
    let
        -- Use agent phone if available, otherwise fall back to org phone
        effectivePhone =
            if String.isEmpty info.agent.phone then
                info.organization.orgPhone

            else
                info.agent.phone

        -- Determine the display name for calls
        phoneDisplayName =
            if String.isEmpty info.agent.phone then
                -- Using org phone, so don't personalize with agent name
                ""

            else
                info.agent.firstName ++ " "
    in
    div [ class "space-y-4" ]
        [ case model.redirectUrl of
            Just _ ->
                a
                    [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                    , href (makeCalendlyUrl model)
                    , target "_blank"
                    , onClick CalendlyOpened
                    ]
                    [ div [ class "flex items-center space-x-3" ]
                        [ span [ class "w-6 h-6 flex items-center justify-center" ]
                            [ MyIcon.calendarDays 24 "#03045E" ]
                        , span [ class "font-semibold text-base" ]
                            [ text ("Schedule a Call with " ++ info.agent.firstName) ]
                        ]
                    ]

            Nothing ->
                if model.isSubmittingFollowUp then
                    button
                        [ class "flex items-center justify-center w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] transition cursor-wait"
                        , type_ "button"
                        ]
                        [ div [ class "animate-spin rounded-full h-5 w-5 border-2 border-[#03045E] border-t-transparent" ] [] ]

                else
                    button
                        [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                        , type_ "button"
                        , onClick RequestFollowUp
                        ]
                        [ div [ class "flex items-center space-x-3" ]
                            [ span [ class "w-6 h-6 flex items-center justify-center" ]
                                [ MyIcon.phoneIncoming 24 "#03045E" ]
                            , span [ class "font-semibold text-base" ]
                                [ text ("Request a Call from " ++ info.agent.firstName) ]
                            ]
                        ]
        , if not (String.isEmpty effectivePhone) then
            a
                [ href ("tel:" ++ effectivePhone)
                , class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                ]
                [ div [ class "flex items-center space-x-3" ]
                    [ span [ class "w-6 h-6 flex items-center justify-center" ]
                        [ MyIcon.phoneOutgoing 24 "#03045E" ]
                    , span [ class "font-semibold text-base" ]
                        [ text
                            (if String.isEmpty phoneDisplayName then
                                "Call Now: " ++ formatPhoneNumber effectivePhone

                             else
                                "Give " ++ phoneDisplayName ++ "a call: " ++ formatPhoneNumber effectivePhone
                            )
                        ]
                    ]
                ]

          else
            text ""
        ]


viewAcceptButtonsOrg : Model -> ScheduleInfo -> Html Msg
viewAcceptButtonsOrg model info =
    div [ class "space-y-4" ]
        [ case info.organization.orgRedirectUrl of
            Just _ ->
                a
                    [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                    , href (makeCalendlyUrl model)
                    , target "_blank"
                    , onClick CalendlyOpened
                    ]
                    [ div [ class "flex items-center space-x-3" ]
                        [ span [ class "w-6 h-6 flex items-center justify-center" ]
                            [ MyIcon.calendarDays 24 "#03045E" ]
                        , span [ class "font-semibold text-base" ]
                            [ text "Schedule a Call" ]
                        ]
                    ]

            Nothing ->
                if model.isSubmittingFollowUp then
                    button
                        [ class "flex items-center justify-center w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] transition cursor-wait"
                        , type_ "button"
                        ]
                        [ div [ class "animate-spin rounded-full h-5 w-5 border-2 border-[#03045E] border-t-transparent" ] [] ]

                else
                    button
                        [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                        , type_ "button"
                        , onClick RequestFollowUp
                        ]
                        [ div [ class "flex items-center space-x-3" ]
                            [ span [ class "w-6 h-6 flex items-center justify-center" ]
                                [ MyIcon.phoneIncoming 24 "#03045E" ]
                            , span [ class "font-semibold text-base" ]
                                [ text "Request a Call" ]
                            ]
                        ]
        , if not (String.isEmpty info.organization.orgPhone) then
            a
                [ href ("tel:" ++ info.organization.orgPhone)
                , class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                ]
                [ div [ class "flex items-center space-x-3" ]
                    [ span [ class "w-6 h-6 flex items-center justify-center" ]
                        [ MyIcon.phoneOutgoing 24 "#03045E" ]
                    , span [ class "font-semibold text-base" ]
                        [ text ("Call Now: " ++ formatPhoneNumber info.organization.orgPhone) ]
                    ]
                ]

          else
            text ""
        ]


viewDeclineButtons : Model -> ScheduleInfo -> Html Msg
viewDeclineButtons model info =
    let
        -- Determine whether to use org or agent details
        effectiveUseOrg =
            if model.forceOrgSenderDetails then
                True

            else
                info.agent.useOrgSenderDetails
    in
    if effectiveUseOrg then
        viewDeclineButtonsOrg model info

    else
        viewDeclineButtonsAgent model info


viewDeclineButtonsAgent : Model -> ScheduleInfo -> Html Msg
viewDeclineButtonsAgent model info =
    let
        -- Use agent phone if available, otherwise fall back to org phone
        effectivePhone =
            if String.isEmpty info.agent.phone then
                info.organization.orgPhone

            else
                info.agent.phone

        -- Determine the display name for calls
        phoneDisplayName =
            if String.isEmpty info.agent.phone then
                -- Using org phone, so don't personalize with agent name
                ""

            else
                info.agent.firstName ++ " "
    in
    div [ class "space-y-4" ]
        [ case model.redirectUrl of
            Just _ ->
                a
                    [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                    , href (makeCalendlyUrl model)
                    , target "_blank"
                    , onClick CalendlyOpened
                    ]
                    [ div [ class "flex items-center space-x-3" ]
                        [ span [ class "w-6 h-6 flex items-center justify-center" ]
                            [ MyIcon.calendarDays 24 "#03045E" ]
                        , span [ class "font-semibold text-base" ]
                            [ text ("Schedule a Call with " ++ info.agent.firstName) ]
                        ]
                    ]

            Nothing ->
                text ""
        , if not (String.isEmpty effectivePhone) then
            a
                [ href ("tel:" ++ effectivePhone)
                , class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                ]
                [ div [ class "flex items-center space-x-3" ]
                    [ span [ class "w-6 h-6 flex items-center justify-center" ]
                        [ MyIcon.phoneOutgoing 24 "#03045E" ]
                    , span [ class "font-semibold text-base" ]
                        [ text
                            (if String.isEmpty phoneDisplayName then
                                "Call Now: " ++ formatPhoneNumber effectivePhone

                             else
                                "Give " ++ phoneDisplayName ++ "a call: " ++ formatPhoneNumber effectivePhone
                            )
                        ]
                    ]
                ]

          else
            text ""
        , div [ class "mt-8 mb-4" ]
            [ h3 [ class "text-[#03045E] font-bold text-base mb-3" ]
                [ text "Interested in an Advantage Plan?" ]
            , p [ class "text-[#03045E] text-sm mb-6 leading-relaxed" ]
                [ text "We can switch you to an Advantage Plan during the Annual Enrollment Period (Oct. 15 - Dec. 7) - Click below and we will be sure to reach out at the end of September to to begin the Advantage Plan Process." ]
            , if model.isSubmittingAEP then
                button
                    [ class "flex items-center justify-center w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] transition cursor-wait"
                    , type_ "button"
                    ]
                    [ div [ class "animate-spin rounded-full h-5 w-5 border-2 border-[#03045E] border-t-transparent" ] [] ]

              else
                button
                    [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                    , type_ "button"
                    , onClick RequestAEP
                    ]
                    [ div [ class "flex items-center space-x-3" ]
                        [ span [ class "w-6 h-6 flex items-center justify-center" ]
                            [ MyIcon.clipboardPlus 24 "#03045E" ]
                        , span [ class "font-semibold text-base" ]
                            [ text "Get on the Advantage Plan List" ]
                        ]
                    ]
            ]
        ]


viewDeclineButtonsOrg : Model -> ScheduleInfo -> Html Msg
viewDeclineButtonsOrg model info =
    div [ class "space-y-4" ]
        [ case info.organization.orgRedirectUrl of
            Just _ ->
                a
                    [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                    , href (makeCalendlyUrl model)
                    , target "_blank"
                    , onClick CalendlyOpened
                    ]
                    [ div [ class "flex items-center space-x-3" ]
                        [ span [ class "w-6 h-6 flex items-center justify-center" ]
                            [ MyIcon.calendarDays 24 "#03045E" ]
                        , span [ class "font-semibold text-base" ]
                            [ text "Schedule a Call" ]
                        ]
                    ]

            Nothing ->
                text ""
        , if model.isSubmittingAEP then
            button
                [ class "flex items-center justify-center w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] transition cursor-wait"
                , type_ "button"
                ]
                [ div [ class "animate-spin rounded-full h-5 w-5 border-2 border-[#03045E] border-t-transparent" ] [] ]

          else
            button
                [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                , type_ "button"
                , onClick RequestAEP
                ]
                [ div [ class "flex items-center space-x-3" ]
                    [ span [ class "w-6 h-6 flex items-center justify-center" ]
                        [ MyIcon.clipboardPlus 24 "#03045E" ]
                    , span [ class "font-semibold text-base" ]
                        [ text "Get on the Advantage Plan List" ]
                    ]
                ]
        , if not (String.isEmpty info.organization.orgPhone) then
            a
                [ href ("tel:" ++ info.organization.orgPhone)
                , class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                ]
                [ div [ class "flex items-center space-x-3" ]
                    [ span [ class "w-6 h-6 flex items-center justify-center" ]
                        [ MyIcon.phoneOutgoing 24 "#03045E" ]
                    , span [ class "font-semibold text-base" ]
                        [ text ("Call Now: " ++ formatPhoneNumber info.organization.orgPhone) ]
                    ]
                ]

          else
            text ""
        , div [ class "mt-8 mb-4" ]
            [ h3 [ class "text-[#03045E] font-bold text-base mb-3" ]
                [ text "Interested in an Advantage Plan?" ]
            , p [ class "text-[#03045E] text-sm mb-6 leading-relaxed" ]
                [ text "We can switch you to an Advantage Plan during the Annual Enrollment Period (Oct. 15 - Dec. 7) - Click below and we will be sure to reach out at the end of September to to begin the Advantage Plan Process." ]
            , if model.isSubmittingAEP then
                button
                    [ class "flex items-center justify-center w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] transition cursor-wait"
                    , type_ "button"
                    ]
                    [ div [ class "animate-spin rounded-full h-5 w-5 border-2 border-[#03045E] border-t-transparent" ] [] ]

              else
                button
                    [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                    , type_ "button"
                    , onClick RequestAEP
                    ]
                    [ div [ class "flex items-center space-x-3" ]
                        [ span [ class "w-6 h-6 flex items-center justify-center" ]
                            [ MyIcon.clipboardPlus 24 "#03045E" ]
                        , span [ class "font-semibold text-base" ]
                            [ text "Get on the Advantage Plan List" ]
                        ]
                    ]
            ]
        ]


viewGenericButtons : Model -> ScheduleInfo -> Html Msg
viewGenericButtons model info =
    let
        -- Determine whether to use org or agent details
        effectiveUseOrg =
            if model.forceOrgSenderDetails then
                True

            else
                info.agent.useOrgSenderDetails
    in
    if effectiveUseOrg then
        viewGenericButtonsOrg model info

    else
        viewGenericButtonsAgent model info


viewGenericButtonsAgent : Model -> ScheduleInfo -> Html Msg
viewGenericButtonsAgent model info =
    let
        -- Use agent phone if available, otherwise fall back to org phone
        effectivePhone =
            if String.isEmpty info.agent.phone then
                info.organization.orgPhone

            else
                info.agent.phone

        -- Determine the display name for calls
        phoneDisplayName =
            if String.isEmpty info.agent.phone then
                -- Using org phone, so don't personalize with agent name
                ""

            else
                info.agent.firstName ++ " "
    in
    div [ class "space-y-4" ]
        [ case model.redirectUrl of
            Just _ ->
                a
                    [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                    , href (makeCalendlyUrl model)
                    , target "_blank"
                    , onClick CalendlyOpened
                    ]
                    [ div [ class "flex items-center space-x-3" ]
                        [ span [ class "w-6 h-6 flex items-center justify-center" ]
                            [ MyIcon.calendarDays 24 "#03045E" ]
                        , span [ class "font-semibold text-base" ]
                            [ text ("Schedule a Call with " ++ info.agent.firstName) ]
                        ]
                    ]

            Nothing ->
                if model.isSubmittingFollowUp then
                    button
                        [ class "flex items-center justify-center w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] transition cursor-wait"
                        , type_ "button"
                        ]
                        [ div [ class "animate-spin rounded-full h-5 w-5 border-2 border-[#03045E] border-t-transparent" ] [] ]

                else
                    button
                        [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                        , type_ "button"
                        , onClick RequestFollowUp
                        ]
                        [ div [ class "flex items-center space-x-3" ]
                            [ span [ class "w-6 h-6 flex items-center justify-center" ]
                                [ MyIcon.phoneIncoming 24 "#03045E" ]
                            , span [ class "font-semibold text-base" ]
                                [ text ("Request a Call from " ++ info.agent.firstName) ]
                            ]
                        ]
        , if not (String.isEmpty effectivePhone) then
            a
                [ href ("tel:" ++ effectivePhone)
                , class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                ]
                [ div [ class "flex items-center space-x-3" ]
                    [ span [ class "w-6 h-6 flex items-center justify-center" ]
                        [ MyIcon.phoneOutgoing 24 "#03045E" ]
                    , span [ class "font-semibold text-base" ]
                        [ text
                            (if String.isEmpty phoneDisplayName then
                                "Call Now: " ++ formatPhoneNumber effectivePhone

                             else
                                "Give " ++ phoneDisplayName ++ "a call: " ++ formatPhoneNumber effectivePhone
                            )
                        ]
                    ]
                ]

          else
            text ""
        ]


viewGenericButtonsOrg : Model -> ScheduleInfo -> Html Msg
viewGenericButtonsOrg model info =
    div [ class "space-y-4" ]
        [ case info.organization.orgRedirectUrl of
            Just _ ->
                a
                    [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                    , href (makeCalendlyUrl model)
                    , target "_blank"
                    , onClick CalendlyOpened
                    ]
                    [ div [ class "flex items-center space-x-3" ]
                        [ span [ class "w-6 h-6 flex items-center justify-center" ]
                            [ MyIcon.calendarDays 24 "#03045E" ]
                        , span [ class "font-semibold text-base" ]
                            [ text "Schedule a Call" ]
                        ]
                    ]

            Nothing ->
                if model.isSubmittingFollowUp then
                    button
                        [ class "flex items-center justify-center w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] transition cursor-wait"
                        , type_ "button"
                        ]
                        [ div [ class "animate-spin rounded-full h-5 w-5 border-2 border-[#03045E] border-t-transparent" ] [] ]

                else
                    button
                        [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                        , type_ "button"
                        , onClick RequestFollowUp
                        ]
                        [ div [ class "flex items-center space-x-3" ]
                            [ span [ class "w-6 h-6 flex items-center justify-center" ]
                                [ MyIcon.phoneIncoming 24 "#03045E" ]
                            , span [ class "font-semibold text-base" ]
                                [ text "Request a Call" ]
                            ]
                        ]
        , if not (String.isEmpty info.organization.orgPhone) then
            a
                [ href ("tel:" ++ info.organization.orgPhone)
                , class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                ]
                [ div [ class "flex items-center space-x-3" ]
                    [ span [ class "w-6 h-6 flex items-center justify-center" ]
                        [ MyIcon.phoneOutgoing 24 "#03045E" ]
                    , span [ class "font-semibold text-base" ]
                        [ text ("Call Now: " ++ formatPhoneNumber info.organization.orgPhone) ]
                    ]
                ]

          else
            text ""
        ]


viewLoading : Html Msg
viewLoading =
    div [ class "fixed inset-0 bg-white flex flex-col items-center justify-center gap-4 text-center" ]
        [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-[#03045E] border-t-transparent" ] []
        , p [ class "text-center text-lg font-medium text-gray-600" ]
            [ text "Loading your schedule page..." ]
        ]


makeDemoCalendlyUrl : Model -> String
makeDemoCalendlyUrl model =
    makeCalendlyUrlHelper model model.demoRedirectUrl


makeCalendlyUrl : Model -> String
makeCalendlyUrl model =
    makeCalendlyUrlHelper model model.redirectUrl


makeCalendlyUrlHelper : Model -> Maybe String -> String
makeCalendlyUrlHelper model redirectUrl =
    let
        -- Determine which redirect URL to use based on sender settings
        effectiveRedirectUrl =
            case ( model.scheduleInfo, redirectUrl ) of
                ( Just info, _ ) ->
                    let
                        effectiveUseOrg =
                            if model.forceOrgSenderDetails then
                                True

                            else
                                info.agent.useOrgSenderDetails
                    in
                    if effectiveUseOrg then
                        info.organization.orgRedirectUrl

                    else if String.isEmpty info.agent.bookingLink then
                        -- When using agent settings but no booking link, don't show calendar button
                        Nothing

                    else
                        Just info.agent.bookingLink

                ( Nothing, _ ) ->
                    redirectUrl
    in
    case effectiveRedirectUrl of
        Just url ->
            List.Extra.zip
                [ "email", "name", "location" ]
                [ model.email
                , model.name
                , model.phoneNumber
                ]
                |> List.filterMap
                    (\( key, value ) ->
                        case value of
                            Just s ->
                                case key of
                                    "location" ->
                                        Just (key ++ "=1" ++ Url.percentEncode s)

                                    _ ->
                                        Just (key ++ "=" ++ Url.percentEncode s)

                            Nothing ->
                                Nothing
                    )
                |> String.join "&"
                |> (\s -> url ++ "?" ++ s)

        Nothing ->
            "#"


getTitle : EligibilityStatus -> String
getTitle status =
    case status of
        Accept ->
            "Good News! - Medicare Max"

        Decline ->
            "Not Eligible - Medicare Max"

        Generic ->
            "Schedule Follow-up - Medicare Max"


getHeading : EligibilityStatus -> String
getHeading status =
    case status of
        Accept ->
            "Great News..."

        Decline ->
            "Here are some options..."

        Generic ->
            "Let's Connect"


getMessage : EligibilityStatus -> String
getMessage status =
    case status of
        Accept ->
            "Based on your answers, you look like a good candidate to switch plans. Let's schedule a follow-up to discuss your options or jump on a call now."

        Decline ->
            "Based on your answers, a Medicare Advantage Plan may be a better fit for you. We'd love to help you explore your options and find a plan that's a perfect fit for your needs."

        Generic ->
            "Let's schedule a follow-up call to discuss your Medicare options and find the best plan for your needs."


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/ScheduleMain.elm
================
module ScheduleMain exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick)
import MyIcon


type alias Model =
    { success : Bool
    , redirectUrl : String
    }


type Msg
    = CalendlyOpened


init : Nav.Key -> ( Model, Cmd Msg )
init key =
    ( { success = False
      , redirectUrl = "https://calendly.com/josh-musick-medicaremax/medicare-max-demo?month=2025-04"
      }
    , Cmd.none
    )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        CalendlyOpened ->
            ( { model | success = True }, Cmd.none )


view : Model -> Browser.Document Msg
view model =
    { title = "Schedule a Demo - Medicare Max"
    , body =
        [ div [ class "min-h-screen bg-[#F9FAFB]" ]
            [ div [ class "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-12" ]
                [ if model.success then
                    div [ class "text-center" ]
                        [ h1 [ class "text-2xl sm:text-3xl font-bold text-gray-900 mb-3 sm:mb-4" ]
                            [ text "Thank You" ]
                        , p [ class "text-gray-600 text-base sm:text-lg" ]
                            [ text "We'll be in touch soon to discuss your options." ]
                        ]

                  else
                    viewDemoCTA model
                ]
            ]
        ]
    }


viewDemoCTA : Model -> Html Msg
viewDemoCTA model =
    div [ class "flex flex-col max-w-xl mx-auto" ]
        [ div [ class "border border-[#DCE2E5] shadow-sm overflow-hidden rounded-lg" ]
            [ div [ class "bg-[#F9F5FF] p-6" ]
                [ h1 [ class "text-2xl sm:text-3xl font-extrabold text-black mb-4" ]
                    [ text "Let's Connect" ]
                , p [ class "text-black text-base leading-relaxed" ]
                    [ text "Interested in learning how you can use Medicare Max for your clients? Discover how our platform can help your agency maximize client retention, freeing up time to focus on what matters most." ]
                ]
            , div [ class "bg-white p-6 sm:p-8" ]
                [ p [ class "text-[#475467] text-sm mb-6" ]
                    [ text "Book a call with us to learn more" ]
                , div [ class "space-y-4" ]
                    [ a
                        [ class "flex items-center justify-between w-full px-4 py-4 border border-[#03045E] rounded-md text-[#03045E] hover:bg-gray-50 transition"
                        , href model.redirectUrl
                        , target "_blank"
                        , onClick CalendlyOpened
                        ]
                        [ div [ class "flex items-center space-x-3" ]
                            [ span [ class "w-6 h-6 flex items-center justify-center" ]
                                [ MyIcon.calendarDays 24 "#03045E" ]
                            , span [ class "font-semibold text-base" ]
                                [ text "Schedule a Demo Call" ]
                            ]
                        ]
                    ]
                ]
            ]
        ]


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/SelfServiceOnboarding.elm
================
port module SelfServiceOnboarding exposing (..)

import Browser
import Browser.Navigation as Nav
import CarrierNaic exposing (Carrier, allCarriers, carrierDecoder, carrierToString, stringToCarrier)
import Date exposing (Date)
import Dict
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Task
import Time
import Url exposing (Url)
import Url.Builder as Builder
import Url.Parser as Parser exposing ((</>), Parser, oneOf, string)
import Utils.QuoteHeader exposing (viewHeader)



-- PORTS


port saveDebugInfo : String -> Cmd msg


port clearDebugInfo : () -> Cmd msg



-- MODEL


type CarrierChoice
    = HasCarrier Carrier
    | NoneOther


type alias Model =
    { orgId : Maybe String
    , orgSlug : Maybe String
    , logo : Maybe String
    , orgName : Maybe String
    , agentId : Maybe String
    , email : String
    , firstName : String
    , lastName : String
    , zipCode : String
    , dateOfBirth : String
    , gender : String
    , tobacco : Bool
    , phoneNumber : String
    , currentPremium : String
    , currentCarrier : String
    , carrier : Maybe CarrierChoice
    , planType : String
    , optInQuarterlyUpdates : Bool
    , emailReadOnly : Bool
    , isSubmitting : Bool
    , isGeneratingQuote : Bool
    , error : Maybe String
    , success : Bool
    , key : Nav.Key
    , currentDate : Maybe Date
    , state : Maybe String
    , counties : List String
    , selectedCounty : Maybe String
    , isLoadingZipData : Bool
    , zipError : Maybe String
    }



-- INIT


type Route
    = SlugRoute String
    | QueryRoute


routeParser : Parser (Route -> a) a
routeParser =
    oneOf
        [ Parser.map SlugRoute (Parser.s "self-onboarding" </> string)
        , Parser.map QueryRoute Parser.top
        ]


parseUrl : Url -> Route
parseUrl url =
    Parser.parse routeParser url |> Maybe.withDefault QueryRoute


type alias UrlParams =
    { orgId : Maybe String
    , email : Maybe String
    , hash : Maybe String
    , quoteId : Maybe String
    , agentId : Maybe String
    }


init : Nav.Key -> Url -> ( Model, Cmd Msg )
init key url =
    let
        route =
            parseUrl url

        queryParams =
            url.query
                |> Maybe.map (String.split "&")
                |> Maybe.withDefault []
                |> List.map (String.split "=")
                |> List.filterMap
                    (\parts ->
                        case parts of
                            [ key0, value0 ] ->
                                Just ( key0, Url.percentDecode value0 |> Maybe.withDefault value0 )

                            _ ->
                                Nothing
                    )
                |> Dict.fromList

        getParam name =
            Dict.get name queryParams

        initialModel =
            { orgId = Nothing
            , orgSlug = Nothing
            , logo = Nothing
            , orgName = Nothing
            , agentId = Nothing
            , email = ""
            , firstName = ""
            , lastName = ""
            , zipCode = ""
            , dateOfBirth = ""
            , gender = "M"
            , tobacco = False
            , phoneNumber = ""
            , currentPremium = ""
            , currentCarrier = ""
            , carrier = Nothing
            , planType = ""
            , optInQuarterlyUpdates = True
            , emailReadOnly = False
            , isSubmitting = False
            , isGeneratingQuote = False
            , error = Nothing
            , success = False
            , key = key
            , currentDate = Nothing
            , state = Nothing
            , counties = []
            , selectedCounty = Nothing
            , isLoadingZipData = False
            , zipError = Nothing
            }

        commands =
            [ Task.perform GotCurrentDate Date.today ]

        -- Clear any previous debug info
        clearCmd =
            clearDebugInfo ()
    in
    case route of
        SlugRoute slug ->
            let
                email =
                    getParam "email"

                quoteId =
                    getParam "quoteId"

                agentId =
                    getParam "agentId"

                debugInfo =
                    "Initializing with slug="
                        ++ slug
                        ++ ", email="
                        ++ (email |> Maybe.withDefault "none")
                        ++ ", quoteId="
                        ++ (quoteId |> Maybe.withDefault "none")
                        ++ ", url.query="
                        ++ (url.query |> Maybe.withDefault "none")

                fetchOrgDetailsCmd =
                    let
                        queryParamsStr =
                            url.query |> Maybe.withDefault ""

                        apiUrl =
                            "/api/self-service/"
                                ++ slug
                                ++ (if String.isEmpty queryParamsStr then
                                        ""

                                    else
                                        "?" ++ queryParamsStr
                                   )
                    in
                    Cmd.batch
                        [ saveDebugInfo <| "Fetching org details: " ++ apiUrl
                        , Http.get
                            { url = apiUrl
                            , expect = Http.expectJson GotOrgDetails orgDetailsDecoder
                            }
                        ]

                fetchContactDetailsCmd =
                    case quoteId of
                        Just qid ->
                            fetchContactDetails qid

                        Nothing ->
                            Cmd.none
            in
            ( { initialModel
                | orgSlug = Just slug
                , agentId = agentId
              }
            , Cmd.batch
                (clearCmd
                    :: saveDebugInfo debugInfo
                    :: fetchOrgDetailsCmd
                    :: fetchContactDetailsCmd
                    :: commands
                )
            )

        QueryRoute ->
            -- Handle query parameters for backward compatibility
            let
                params =
                    parseUrlParams url

                orgId =
                    getParam "orgId"

                email =
                    getParam "email"

                hash =
                    getParam "hash"

                quoteId =
                    getParam "quoteId"

                debugInfo =
                    "Initializing with orgId="
                        ++ (orgId |> Maybe.withDefault "none")
                        ++ ", email="
                        ++ (email |> Maybe.withDefault "none")
                        ++ ", quoteId="
                        ++ (quoteId |> Maybe.withDefault "none")

                initCmd =
                    case orgId of
                        Just oid ->
                            -- If we have an org ID, fetch org details which will include contact if found
                            let
                                apiQueryParams =
                                    List.filterMap identity
                                        [ Maybe.map (\e -> ( "email", e )) email
                                        , Maybe.map (\q -> ( "id", q )) quoteId
                                        , Maybe.map (\h -> ( "hash", h )) hash
                                        ]
                                        |> List.map (\( k, v ) -> k ++ "=" ++ Url.percentEncode v)
                                        |> String.join "&"

                                apiUrl =
                                    "/api/self-service/"
                                        ++ oid
                                        ++ (if String.isEmpty apiQueryParams then
                                                ""

                                            else
                                                "?" ++ apiQueryParams
                                           )
                            in
                            Cmd.batch
                                [ saveDebugInfo <| "Fetching org details: " ++ apiUrl
                                , Http.get
                                    { url = apiUrl
                                    , expect = Http.expectJson GotOrgDetails orgDetailsDecoder
                                    }
                                ]

                        Nothing ->
                            Cmd.none

                fetchContactDetailsCmd =
                    case quoteId of
                        Just qid ->
                            fetchContactDetails qid

                        Nothing ->
                            Cmd.none
            in
            ( { initialModel | orgId = orgId }
            , Cmd.batch
                (clearCmd
                    :: saveDebugInfo debugInfo
                    :: initCmd
                    :: fetchContactDetailsCmd
                    :: commands
                )
            )


parseUrlParams : Url -> UrlParams
parseUrlParams url =
    -- This function parses query parameters for backward compatibility
    let
        queryParams =
            url.query
                |> Maybe.map (String.split "&")
                |> Maybe.withDefault []
                |> List.map (String.split "=")
                |> List.filterMap
                    (\parts ->
                        case parts of
                            [ key, value ] ->
                                Just ( key, Url.percentDecode value |> Maybe.withDefault value )

                            _ ->
                                Nothing
                    )
                |> Dict.fromList

        getParam name =
            Dict.get name queryParams
    in
    { orgId = getParam "orgId"
    , email = getParam "email"
    , hash = getParam "hash"
    , quoteId = getParam "id"
    , agentId = getParam "agentId"
    }


fetchContactDetails : String -> Cmd Msg
fetchContactDetails quoteId =
    Http.get
        { url = "/api/quotes/decode/" ++ quoteId
        , expect = Http.expectJson GotContactDetails contactDetailsDecoder
        }


contactDetailsDecoder : Decoder ContactDetails
contactDetailsDecoder =
    Decode.succeed ContactDetails
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "contact" contactDecoder


type alias ContactDetails =
    { success : Bool
    , contact : Contact
    }


fetchOrgDetails : String -> Cmd Msg
fetchOrgDetails slug =
    let
        url =
            "/api/self-service/" ++ slug
    in
    Cmd.batch
        [ saveDebugInfo <| "Fetching org details: " ++ url
        , Http.get
            { url = url
            , expect = Http.expectJson GotOrgDetails orgDetailsDecoder
            }
        ]


fetchZipInfo : String -> Cmd Msg
fetchZipInfo zipCode =
    Http.get
        { url = "/api/zipinfo/" ++ zipCode
        , expect = Http.expectJson GotZipInfo zipInfoDecoder
        }



-- UPDATE


type Msg
    = GotInitResponse (Result Http.Error InitResponse)
    | GotOrgDetails (Result Http.Error OrgDetails)
    | GotContactData (Result Http.Error ContactResponse)
    | UpdateEmail String
    | UpdateFirstName String
    | UpdateLastName String
    | UpdateZipCode String
    | UpdateDateOfBirth String
    | UpdateGender String
    | UpdateTobacco String
    | UpdatePhoneNumber String
    | UpdateCurrentPremium String
    | UpdateCurrentCarrier String
    | UpdateCarrierChoice String
    | UpdatePlanType String
    | UpdateSelectedCounty String
    | SubmitForm
    | GotCurrentDate Date
    | GotZipInfo (Result Http.Error ZipInfo)
    | GotSignupResponse (Result Http.Error SignupResponse)
    | GotQuoteResponse (Result Http.Error QuoteResponse)
    | GoToQuote
    | GotContactDetails (Result Http.Error ContactDetails)


type alias InitResponse =
    { contact : Maybe Contact
    , email : Maybe String
    , emailReadOnly : Bool
    }


type alias OrgDetails =
    { orgId : String
    , orgSlug : String
    , contact : Maybe Contact
    , logo : Maybe String
    , orgName : Maybe String
    }


type alias Contact =
    { firstName : String
    , lastName : String
    , email : String
    , phone : String
    , dateOfBirth : String
    , gender : String
    , tobacco : Bool
    , state : String
    , zipCode : String
    , currentCarrier : Maybe String
    , planType : Maybe String
    , optInQuarterlyUpdates : Bool
    }


type alias ZipInfo =
    { state : String
    , counties : List String
    }


type alias SignupResponse =
    { success : Bool
    , contactId : Int
    , email : String
    }


type alias QuoteResponse =
    { success : Bool
    , contactId : Int
    , quoteId : String
    , redirectUrl : String
    , error : Maybe String
    }


type alias ContactResponse =
    { success : Bool
    , orgSlug : String
    , carrierContracts : List Carrier
    , contact : Contact
    }


zipInfoDecoder : Decoder ZipInfo
zipInfoDecoder =
    Decode.field "success" Decode.bool
        |> Decode.andThen
            (\success ->
                if success then
                    Decode.field "data"
                        (Decode.map2 ZipInfo
                            (Decode.field "state" Decode.string)
                            (Decode.field "counties" (Decode.list Decode.string))
                        )

                else
                    Decode.field "error" Decode.string
                        |> Decode.andThen (\error -> Decode.fail error)
            )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GotOrgDetails result ->
            case result of
                Ok details ->
                    let
                        -- Extract contact info if it exists
                        contact =
                            details.contact

                        debugInfo =
                            "OrgDetails: orgId="
                                ++ details.orgId
                                ++ ", orgSlug="
                                ++ details.orgSlug
                                ++ ", hasContact="
                                ++ (if details.contact /= Nothing then
                                        "true"

                                    else
                                        "false"
                                   )
                                ++ (if details.contact /= Nothing then
                                        ", contactEmail=" ++ (Maybe.map .email contact |> Maybe.withDefault "none")

                                    else
                                        ""
                                   )

                        currentCarrier =
                            Maybe.map .currentCarrier contact
                                |> Maybe.withDefault Nothing
                                |> Maybe.withDefault model.currentCarrier

                        carrier =
                            case stringToCarrier currentCarrier of
                                Just carrierValue ->
                                    Just (HasCarrier carrierValue)

                                Nothing ->
                                    Nothing
                    in
                    ( { model
                        | orgId = Just details.orgId
                        , orgSlug = Just details.orgSlug
                        , orgName = details.orgName
                        , logo = details.logo
                        , email = Maybe.map .email contact |> Maybe.withDefault model.email
                        , firstName = Maybe.map .firstName contact |> Maybe.withDefault model.firstName
                        , lastName = Maybe.map .lastName contact |> Maybe.withDefault model.lastName
                        , phoneNumber = Maybe.map .phone contact |> Maybe.withDefault model.phoneNumber
                        , dateOfBirth = Maybe.map .dateOfBirth contact |> Maybe.withDefault model.dateOfBirth
                        , gender = Maybe.map .gender contact |> Maybe.withDefault model.gender
                        , tobacco = Maybe.map .tobacco contact |> Maybe.withDefault model.tobacco
                        , zipCode = Maybe.map .zipCode contact |> Maybe.withDefault model.zipCode
                        , currentCarrier = currentCarrier
                        , carrier = carrier
                        , planType = Maybe.map .planType contact |> Maybe.withDefault Nothing |> Maybe.withDefault model.planType
                        , optInQuarterlyUpdates = Maybe.map .optInQuarterlyUpdates contact |> Maybe.withDefault model.optInQuarterlyUpdates
                        , error = Nothing
                      }
                    , Cmd.batch
                        [ saveDebugInfo debugInfo

                        -- If we have a zip code from contact, fetch the zip info
                        , case Maybe.map .zipCode contact of
                            Just zip ->
                                if String.length zip == 5 then
                                    fetchZipInfo zip

                                else
                                    Cmd.none

                            Nothing ->
                                Cmd.none
                        ]
                    )

                Err error ->
                    ( { model | error = Just "Organization not found or invalid link." }
                    , saveDebugInfo <| "OrgDetails error: " ++ httpErrorToString error
                    )

        GotInitResponse result ->
            case result of
                Ok response ->
                    let
                        email =
                            response.email |> Maybe.withDefault ""

                        contact =
                            response.contact

                        firstName =
                            contact |> Maybe.map .firstName |> Maybe.withDefault ""

                        lastName =
                            contact |> Maybe.map .lastName |> Maybe.withDefault ""

                        optIn =
                            contact |> Maybe.map .optInQuarterlyUpdates |> Maybe.withDefault False

                        debugInfo =
                            "InitResponse: email="
                                ++ email
                                ++ ", firstName="
                                ++ firstName
                                ++ ", lastName="
                                ++ lastName
                                ++ ", optIn="
                                ++ (if optIn then
                                        "true"

                                    else
                                        "false"
                                   )
                    in
                    ( { model
                        | email = email
                        , firstName = firstName
                        , lastName = lastName
                        , optInQuarterlyUpdates = optIn
                        , emailReadOnly = response.emailReadOnly
                        , error = Nothing
                      }
                    , saveDebugInfo debugInfo
                    )

                Err error ->
                    ( { model | error = Just "Failed to load existing contact details. Please try again." }
                    , saveDebugInfo <| "InitResponse error: " ++ httpErrorToString error
                    )

        UpdateEmail newEmail ->
            ( { model
                | email =
                    if model.emailReadOnly then
                        model.email

                    else
                        newEmail
              }
            , Cmd.none
            )

        UpdateFirstName newFirstName ->
            ( { model | firstName = newFirstName }, Cmd.none )

        UpdateLastName newLastName ->
            ( { model | lastName = newLastName }, Cmd.none )

        UpdateZipCode zip ->
            let
                filteredZip =
                    String.filter Char.isDigit zip |> String.left 5

                cmd =
                    if String.length filteredZip == 5 && filteredZip /= model.zipCode then
                        fetchZipInfo filteredZip

                    else
                        Cmd.none
            in
            ( { model
                | zipCode = filteredZip
                , isLoadingZipData = String.length filteredZip == 5 && filteredZip /= model.zipCode
                , state =
                    if String.length filteredZip /= 5 || (String.length filteredZip == 5 && filteredZip /= model.zipCode) then
                        Nothing

                    else
                        model.state
                , counties =
                    if String.length filteredZip /= 5 || (String.length filteredZip == 5 && filteredZip /= model.zipCode) then
                        []

                    else
                        model.counties
                , selectedCounty =
                    if String.length filteredZip /= 5 || (String.length filteredZip == 5 && filteredZip /= model.zipCode) then
                        Nothing

                    else
                        model.selectedCounty
                , zipError = Nothing
              }
            , cmd
            )

        GotZipInfo result ->
            case result of
                Ok zipInfo ->
                    let
                        -- Always select the first county as default
                        selectedCounty =
                            List.head zipInfo.counties
                    in
                    ( { model
                        | state = Just zipInfo.state
                        , counties = zipInfo.counties
                        , selectedCounty = selectedCounty
                        , isLoadingZipData = False
                        , zipError = Nothing
                      }
                    , Cmd.none
                    )

                Err error ->
                    ( { model
                        | state = Nothing
                        , counties = []
                        , selectedCounty = Nothing
                        , isLoadingZipData = False
                        , zipError = Just (httpErrorToString error)
                      }
                    , Cmd.none
                    )

        UpdateSelectedCounty county ->
            ( { model | selectedCounty = Just county }, Cmd.none )

        UpdateDateOfBirth dob ->
            ( { model | dateOfBirth = dob }, Cmd.none )

        UpdateGender value ->
            ( { model | gender = value }, Cmd.none )

        UpdateTobacco value ->
            ( { model | tobacco = value == "true" }, Cmd.none )

        UpdatePhoneNumber phone ->
            ( { model | phoneNumber = String.filter Char.isDigit phone |> String.left 10 }, Cmd.none )

        UpdateCurrentPremium value ->
            ( { model | currentPremium = String.filter (\c -> Char.isDigit c || c == '.') value }, Cmd.none )

        UpdateCurrentCarrier carrier ->
            ( { model | currentCarrier = carrier }, Cmd.none )

        UpdateCarrierChoice value ->
            case value of
                "none" ->
                    ( { model
                        | carrier = Just NoneOther
                        , currentCarrier = ""
                      }
                    , Cmd.none
                    )

                _ ->
                    case stringToCarrier value of
                        Just carrierValue ->
                            ( { model
                                | carrier = Just (HasCarrier carrierValue)
                                , currentCarrier = carrierValue |> carrierToString
                              }
                            , Cmd.none
                            )

                        Nothing ->
                            ( model, Cmd.none )

        UpdatePlanType planType ->
            ( { model | planType = planType }, Cmd.none )

        GotCurrentDate date ->
            ( { model | currentDate = Just date }, Cmd.none )

        SubmitForm ->
            if isFormValid model then
                ( { model | isSubmitting = True, error = Nothing }
                , submitForm model
                )

            else
                ( { model | error = Just "Please fill out all required fields" }
                , Cmd.none
                )

        GotSignupResponse result ->
            case result of
                Ok response ->
                    if response.success then
                        ( { model
                            | isSubmitting = False
                            , success = True
                            , error = Nothing
                            , isGeneratingQuote = True
                          }
                        , Cmd.batch
                            [ saveDebugInfo <| "SignupResponse: contactId=" ++ String.fromInt response.contactId ++ ", email=" ++ response.email
                            , generateQuote model.orgId response.contactId response.email
                            ]
                        )

                    else
                        ( { model | isSubmitting = False, error = Just "Signup failed. Please try again." }
                        , saveDebugInfo <| "SignupResponse: failed (success=false)"
                        )

                Err error ->
                    ( { model | isSubmitting = False, error = Just "Signup failed. Please try again." }
                    , saveDebugInfo <| "SignupResponse error: " ++ httpErrorToString error
                    )

        GotQuoteResponse result ->
            case result of
                Ok response ->
                    if response.success then
                        ( { model | isGeneratingQuote = False }
                        , Cmd.batch
                            [ saveDebugInfo <| "QuoteResponse: quoteId=" ++ response.quoteId ++ ", redirectUrl=" ++ response.redirectUrl
                            , Nav.pushUrl model.key (Builder.absolute [ "compare" ] [ Builder.string "id" response.quoteId ])
                            ]
                        )

                    else
                        ( { model | isGeneratingQuote = False, error = Just "Failed to generate quote. Please try again." }
                        , saveDebugInfo <| "QuoteResponse: failed (success=false), error=" ++ (response.error |> Maybe.withDefault "No error message")
                        )

                Err error ->
                    ( { model | isGeneratingQuote = False, error = Just "Failed to generate quote. Please try again." }
                    , saveDebugInfo <| "QuoteResponse error: " ++ httpErrorToString error
                    )

        GoToQuote ->
            if isFormValid model then
                let
                    county =
                        case model.selectedCounty of
                            Just c ->
                                c

                            Nothing ->
                                List.head model.counties
                                    |> Maybe.withDefault ""

                    state =
                        model.state
                            |> Maybe.withDefault ""

                    compareUrl =
                        Builder.absolute [ "compare" ]
                            [ Builder.string "zip" model.zipCode
                            , Builder.string "state" state
                            , Builder.string "county" county
                            , Builder.string "gender" model.gender
                            , Builder.string "tobacco"
                                (if model.tobacco then
                                    "true"

                                 else
                                    "false"
                                )
                            , Builder.string "dateOfBirth" model.dateOfBirth
                            ]
                in
                ( model
                , Nav.pushUrl model.key compareUrl
                )

            else
                ( { model | error = Just "Please fill out all required fields for a quote" }
                , Cmd.none
                )

        GotContactData result ->
            case result of
                Ok response ->
                    let
                        contact =
                            response.contact
                    in
                    ( { model
                        | orgId = Just response.orgSlug
                        , email = contact.email
                        , firstName = contact.firstName
                        , lastName = contact.lastName
                        , phoneNumber = contact.phone
                        , dateOfBirth = contact.dateOfBirth
                        , gender = contact.gender
                        , tobacco = contact.tobacco
                        , zipCode = contact.zipCode
                        , currentCarrier = Maybe.withDefault "" contact.currentCarrier
                        , planType = Maybe.withDefault "" contact.planType
                        , optInQuarterlyUpdates = contact.optInQuarterlyUpdates
                        , error = Nothing
                      }
                    , Cmd.batch
                        [ saveDebugInfo <|
                            "ContactData: success="
                                ++ (if response.success then
                                        "true"

                                    else
                                        "false"
                                   )
                                ++ ", orgSlug="
                                ++ response.orgSlug
                        ]
                    )

                Err error ->
                    ( { model | error = Just "Failed to load contact data. Please try again." }
                    , saveDebugInfo <| "ContactData error: " ++ httpErrorToString error
                    )

        GotContactDetails result ->
            case result of
                Ok response ->
                    ( { model
                        | firstName = response.contact.firstName
                        , lastName = response.contact.lastName
                        , email = response.contact.email
                        , phoneNumber = response.contact.phone
                        , dateOfBirth = response.contact.dateOfBirth
                        , gender = response.contact.gender
                        , error = Nothing
                      }
                    , Cmd.none
                    )

                Err error ->
                    ( { model | error = Just "Failed to load contact details. Please try again." }
                    , saveDebugInfo <| "ContactDetails error: " ++ httpErrorToString error
                    )


isFormValid : Model -> Bool
isFormValid model =
    let
        isValidDate str =
            case String.split "-" str of
                [ year, month, day ] ->
                    String.length year
                        == 4
                        && String.length month
                        == 2
                        && String.length day
                        == 2
                        && String.all Char.isDigit year
                        && String.all Char.isDigit month
                        && String.all Char.isDigit day

                _ ->
                    False
    in
    -- Contact info (required)
    not (String.isEmpty model.email)
        && not (String.isEmpty model.firstName)
        && not (String.isEmpty model.lastName)
        && String.length model.phoneNumber
        == 10
        && model.orgId
        /= Nothing
        -- Quote info (required)
        && String.length model.zipCode
        == 5
        && not (String.isEmpty model.dateOfBirth)
        && isValidDate model.dateOfBirth
        && not (String.isEmpty model.gender)
        -- Tobacco status is now explicitly required
        && (model.tobacco == True || model.tobacco == False)
        -- Carrier selection is required
        && model.carrier
        /= Nothing
        -- Must agree to receive updates
        && model.optInQuarterlyUpdates
        == True


httpErrorToString : Http.Error -> String
httpErrorToString error =
    case error of
        Http.BadUrl url ->
            "Bad URL: " ++ url

        Http.Timeout ->
            "Request timed out"

        Http.NetworkError ->
            "Network error"

        Http.BadStatus statusCode ->
            "Bad status: " ++ String.fromInt statusCode

        Http.BadBody message ->
            "Data error: " ++ message


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    if String.isEmpty phone then
        ""

    else
        let
            digits =
                String.filter Char.isDigit phone
                    |> String.left 10

            len =
                String.length digits
        in
        if len == 0 then
            ""

        else if len <= 3 then
            "(" ++ digits

        else if len <= 6 then
            "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

        else
            "(" ++ String.left 3 digits ++ ") " ++ String.slice 3 6 digits ++ "-" ++ String.dropLeft 6 digits



-- FORM SUBMISSION


submitForm : Model -> Cmd Msg
submitForm model =
    Http.post
        { url = "/api/self-service/signup"
        , body = Http.jsonBody (encodeForm model)
        , expect = Http.expectJson GotSignupResponse signupResponseDecoder
        }


generateQuote : Maybe String -> Int -> String -> Cmd Msg
generateQuote maybeOrgId contactId email =
    case maybeOrgId of
        Just orgId ->
            Http.post
                { url = "/api/self-service/generate-quote"
                , body =
                    Http.jsonBody
                        (Encode.object
                            [ ( "orgId", Encode.string orgId )
                            , ( "contactEmail", Encode.string email )
                            ]
                        )
                , expect = Http.expectJson GotQuoteResponse quoteResponseDecoder
                }

        Nothing ->
            Cmd.none


encodeForm : Model -> Encode.Value
encodeForm model =
    let
        ls0 =
            [ ( "orgId", Encode.string (Maybe.withDefault "" model.orgId) )
            , ( "email", Encode.string model.email )
            , ( "firstName", Encode.string model.firstName )
            , ( "lastName", Encode.string model.lastName )
            , ( "zipCode", Encode.string model.zipCode )
            , ( "dateOfBirth", Encode.string model.dateOfBirth )
            , ( "gender", Encode.string model.gender )
            , ( "tobacco", Encode.bool model.tobacco )
            , ( "phoneNumber", Encode.string model.phoneNumber )
            , ( "currentPremium", Encode.string model.currentPremium )
            , ( "currentCarrier", Encode.string model.currentCarrier )
            , ( "planType", Encode.string model.planType )
            , ( "state", Encode.string (Maybe.withDefault "" model.state) )
            , ( "county", Encode.string (Maybe.withDefault "" model.selectedCounty) )
            , ( "optInQuarterlyUpdates", Encode.bool model.optInQuarterlyUpdates )
            , ( "carrierChoice"
              , case model.carrier of
                    Just (HasCarrier carrier) ->
                        Encode.string (carrierToString carrier)

                    Just NoneOther ->
                        Encode.string "None/Other"

                    Nothing ->
                        Encode.null
              )
            ]

        ls1 =
            case model.agentId of
                Just agentId ->
                    [ ( "agentId", Encode.string agentId ) ]

                Nothing ->
                    []
    in
    Encode.object (ls0 ++ ls1)



-- DECODERS


initResponseDecoder : Decoder InitResponse
initResponseDecoder =
    Decode.map3 InitResponse
        (Decode.maybe (Decode.field "contact" contactDecoder))
        (Decode.maybe (Decode.field "email" Decode.string))
        (Decode.field "emailReadOnly" Decode.bool)


contactDecoder : Decoder Contact
contactDecoder =
    let
        phoneDecoder =
            Decode.oneOf
                [ Decode.field "phone" (Decode.oneOf [ Decode.string, Decode.null "" ])
                , Decode.field "phoneNumber" (Decode.oneOf [ Decode.string, Decode.null "" ])
                , Decode.succeed ""
                ]
    in
    Decode.succeed Contact
        |> Pipeline.required "firstName" (Decode.oneOf [ Decode.string, Decode.null "" ])
        |> Pipeline.required "lastName" (Decode.oneOf [ Decode.string, Decode.null "" ])
        |> Pipeline.required "email" Decode.string
        |> Pipeline.custom phoneDecoder
        |> Pipeline.optional "dateOfBirth" Decode.string ""
        |> Pipeline.optional "gender" Decode.string "M"
        |> Pipeline.optional "tobacco" Decode.bool False
        |> Pipeline.optional "state" Decode.string ""
        |> Pipeline.optional "zipCode" Decode.string ""
        |> Pipeline.optional "currentCarrier" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "planType" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "optInQuarterlyUpdates" Decode.bool True


orgDetailsDecoder : Decoder OrgDetails
orgDetailsDecoder =
    Decode.map5 OrgDetails
        (Decode.field "orgId" Decode.string)
        (Decode.field "orgSlug" Decode.string)
        (Decode.maybe (Decode.field "contact" contactDecoder))
        (Decode.maybe (Decode.field "logo" Decode.string))
        (Decode.maybe (Decode.field "orgName" Decode.string))


signupResponseDecoder : Decoder SignupResponse
signupResponseDecoder =
    Decode.map3 SignupResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "contactId" Decode.int)
        (Decode.field "email" Decode.string)


quoteResponseDecoder : Decoder QuoteResponse
quoteResponseDecoder =
    Decode.map5 QuoteResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "contactId" Decode.int)
        (Decode.field "quoteId" Decode.string)
        (Decode.field "redirectUrl" Decode.string)
        (Decode.maybe (Decode.field "error" Decode.string))


contactResponseDecoder : Decoder ContactResponse
contactResponseDecoder =
    Decode.map4 ContactResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "orgSlug" Decode.string)
        (Decode.field "carrierContracts" (Decode.list carrierDecoder))
        (Decode.field "contact" contactDecoder)


fetchContactData : String -> Cmd Msg
fetchContactData quoteId =
    Http.get
        { url = "/api/quotes/decode/" ++ quoteId
        , expect = Http.expectJson GotContactData contactResponseDecoder
        }



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Get Your Medicare Supplement Quote"
    , body =
        [ viewForm model
        ]
    }


viewForm : Model -> Html Msg
viewForm model =
    div [ class "max-w-4xl mx-auto bg-white rounded-xl shadow-md p-4 sm:p-8" ]
        [ if model.isSubmitting || model.isGeneratingQuote then
            div [ class "fixed inset-0 bg-white flex flex-col items-center justify-center gap-4 text-center" ]
                [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-[#03045E] border-t-transparent" ] []
                , p [ class "text-center text-lg font-medium text-gray-600" ]
                    [ text
                        (if model.isSubmitting then
                            "Submitting your information..."

                         else
                            "Generating your quote..."
                        )
                    ]
                ]

          else if model.orgId == Nothing && model.error == Nothing then
            div [ class "fixed inset-0 bg-white flex flex-col items-center justify-center gap-4 text-center" ]
                [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-[#03045E] border-t-transparent" ] []
                , p [ class "text-center text-lg font-medium text-gray-600" ]
                    [ text "Loading organization details..." ]
                ]

          else
            viewFormStep model
        ]


viewFormStep : Model -> Html Msg
viewFormStep model =
    div []
        [ viewHeader model.logo model.orgName

        {--
        , div [ class "text-center mb-6 px-4 sm:px-6" ]
            [ div [ class "max-w-2xl mx-auto" ]
                [ p [ class "text-[#475467] text-base sm:text-lg italic mb-2" ]
                    [ text "This is the exact form that your clients will go through if we need more info. It can also be used for new lead generation. This form will be white labeled with your branding, logo, and colors to match your agency's style." ]
                ]
            ]
        --}
        , div [ class "text-center mb-6 px-2 sm:px-0" ]
            [ h1 [ class "text-2xl sm:text-3xl font-bold text-[#101828]" ] [ text "Let's Get Some Details" ]
            , p [ class "text-[#475467] mt-2 text-sm sm:text-base" ] [ text "We use this information to get you the most accurate quote for your area." ]
            ]
        , viewCombinedForm model
        , viewError model.error
        , div [ class "flex justify-center mt-8" ]
            [ button
                [ type_ "button"
                , class
                    ("w-48 flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white "
                        ++ (if isFormValid model && not model.isSubmitting then
                                "bg-[#03045E] hover:bg-[#02034e] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#3DBDEC]"

                            else
                                "bg-[#03045E] opacity-50 cursor-not-allowed"
                           )
                    )
                , onClick SubmitForm
                , disabled (model.isSubmitting || not (isFormValid model))
                ]
                [ text
                    (if model.isSubmitting then
                        "Submitting..."

                     else
                        "Submit"
                    )
                ]
            ]
        ]


viewCombinedForm : Model -> Html Msg
viewCombinedForm model =
    div [ class "px-2 sm:px-0 space-y-6 sm:space-y-6" ]
        [ div [ class "grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-4" ]
            [ inputField "First Name" "text" model.firstName UpdateFirstName False
            , inputField "Last Name" "text" model.lastName UpdateLastName False
            , inputField "Cell Number *" "tel" (formatPhoneNumber model.phoneNumber) UpdatePhoneNumber False
            , div [ class "mb-0" ]
                [ div [ class "flex items-center" ]
                    [ label [ class "block text-sm font-medium text-[#344054] mb-1" ] [ text "Email Address" ]
                    , span [ class "ml-2 text-xs text-gray-500" ] [ text "(use a unique email for each person)" ]
                    ]
                , input
                    [ type_ "email"
                    , class "w-full px-3 py-2 border border-[#D0D5DD] rounded-md shadow-sm focus:outline-none focus:ring-[#3DBDEC] focus:border-[#3DBDEC]"
                    , placeholder "example@example.com"
                    , Html.Attributes.value model.email
                    , onInput UpdateEmail
                    , disabled model.emailReadOnly
                    , required True
                    ]
                    []
                ]
            ]
        , div [ class "grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-4" ]
            [ inputField "Date of Birth" "date" model.dateOfBirth UpdateDateOfBirth False
            , div [ class "mb-0" ]
                [ label [ class "block text-sm font-medium text-[#344054] mb-1" ] [ text "Zip Code" ]
                , input
                    [ type_ "text"
                    , class "w-full px-3 py-2 border border-[#D0D5DD] rounded-md shadow-sm focus:outline-none focus:ring-[#3DBDEC] focus:border-[#3DBDEC]"
                    , Html.Attributes.value model.zipCode
                    , onInput UpdateZipCode
                    , required True
                    ]
                    []
                , if model.isLoadingZipData then
                    div [ class "mt-1 text-sm text-gray-500" ] [ text "Loading location data..." ]

                  else if model.zipError /= Nothing then
                    div [ class "mt-1 text-sm text-red-600" ] [ text (model.zipError |> Maybe.withDefault "Invalid zip code") ]

                  else if model.state /= Nothing then
                    div [ class "mt-1 text-sm text-green-600" ]
                        [ text ("State: " ++ (model.state |> Maybe.withDefault "")) ]

                  else
                    text ""
                ]
            ]
        , if List.length model.counties > 1 then
            div [ class "mb-4" ]
                [ viewCountyDropdown model.counties model.selectedCounty ]

          else
            text ""
        , div [ class "grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-4" ]
            [ div [ class "col-span-1" ]
                [ label [ class "block text-sm font-medium text-gray-700 mb-2" ] [ text "Gender" ]
                , div [ class "grid grid-cols-2 gap-2" ]
                    [ label
                        [ class
                            ("flex items-center justify-center px-3 sm:px-4 py-2 rounded-lg border-2 cursor-pointer transition-all text-sm sm:text-base "
                                ++ (if model.gender == "M" then
                                        "border-[#03045E] bg-[#F9F5FF] text-[#03045E]"

                                    else
                                        "border-[#D0D5DD] hover:border-[#3DBDEC] text-[#344054]"
                                   )
                            )
                        ]
                        [ input
                            [ type_ "radio"
                            , value "M"
                            , checked (model.gender == "M")
                            , onInput UpdateGender
                            , class "sr-only"
                            ]
                            []
                        , text "Male"
                        ]
                    , label
                        [ class
                            ("flex items-center justify-center px-3 sm:px-4 py-2 rounded-lg border-2 cursor-pointer transition-all text-sm sm:text-base "
                                ++ (if model.gender == "F" then
                                        "border-[#03045E] bg-[#F9F5FF] text-[#03045E]"

                                    else
                                        "border-[#D0D5DD] hover:border-[#3DBDEC] text-[#344054]"
                                   )
                            )
                        ]
                        [ input
                            [ type_ "radio"
                            , value "F"
                            , checked (model.gender == "F")
                            , onInput UpdateGender
                            , class "sr-only"
                            ]
                            []
                        , text "Female"
                        ]
                    ]
                ]
            , div [ class "col-span-1" ]
                [ label [ class "block text-sm font-medium text-gray-700 mb-2" ] [ text "Do you use tobacco products?" ]
                , div [ class "grid grid-cols-2 gap-2" ]
                    [ label
                        [ class
                            ("flex items-center justify-center px-3 sm:px-4 py-2 rounded-lg border-2 cursor-pointer transition-all text-sm sm:text-base "
                                ++ (if model.tobacco then
                                        "border-[#03045E] bg-[#F9F5FF] text-[#03045E]"

                                    else
                                        "border-[#D0D5DD] hover:border-[#3DBDEC] text-[#344054]"
                                   )
                            )
                        ]
                        [ input
                            [ type_ "radio"
                            , value "true"
                            , checked model.tobacco
                            , onInput UpdateTobacco
                            , class "sr-only"
                            ]
                            []
                        , text "Yes"
                        ]
                    , label
                        [ class
                            ("flex items-center justify-center px-3 sm:px-4 py-2 rounded-lg border-2 cursor-pointer transition-all text-sm sm:text-base "
                                ++ (if not model.tobacco then
                                        "border-[#03045E] bg-[#F9F5FF] text-[#03045E]"

                                    else
                                        "border-[#D0D5DD] hover:border-[#3DBDEC] text-[#344054]"
                                   )
                            )
                        ]
                        [ input
                            [ type_ "radio"
                            , value "false"
                            , checked (not model.tobacco)
                            , onInput UpdateTobacco
                            , class "sr-only"
                            ]
                            []
                        , text "No"
                        ]
                    ]
                ]
            ]
        , div [ class "grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-4" ]
            [ div [ class "col-span-1" ]
                [ label [ class "block text-sm font-medium text-[#344054] mb-1" ] [ text "Carrier" ]
                , select
                    [ class "w-full px-3 py-2 border border-[#D0D5DD] rounded-md shadow-sm focus:outline-none focus:ring-[#3DBDEC] focus:border-[#3DBDEC]"
                    , onInput UpdateCarrierChoice
                    , required True
                    ]
                    ([ option
                        [ value "", disabled True, selected (model.carrier == Nothing) ]
                        [ text "Select a carrier" ]
                     , option
                        [ value "none", selected (model.carrier == Just NoneOther) ]
                        [ text "None/Other" ]
                     ]
                        ++ List.map
                            (\carrier ->
                                option
                                    [ value (carrierToString carrier)
                                    , selected (model.carrier == Just (HasCarrier carrier))
                                    ]
                                    [ text (carrierToString carrier) ]
                            )
                            (List.sortBy carrierToString allCarriers)
                    )
                ]
            , div [ class "col-span-1" ] [] -- Empty div to maintain grid layout
            ]

        {--
        , h3 [ class "font-medium text-base sm:text-lg mb-4 text-gray-700" ] [ text "Current Coverage" ]
        , div [ class "grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-4" ]
            [ div [ class "col-span-1" ]
                [ label [ class "block text-sm font-medium text-gray-700 mb-1" ] [ text "Current Carrier (optional)" ]
                , select
                    [ class "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500"
                    , onInput UpdateCurrentCarrier
                    ]
                    ([ option [ value "" ] [ text "Select Current Carrier" ] ]
                        ++ List.map
                            (\carrier ->
                                option
                                    [ value (carrierToString carrier)
                                    , selected (model.currentCarrier == carrierToString carrier)
                                    ]
                                    [ text (carrierToString carrier) ]
                            )
                            (List.sortBy carrierToString allCarriers)
                        ++ [ option
                                [ value "Other"
                                , selected (model.currentCarrier == "Other")
                                ]
                                [ text "Other" ]
                           ]
                    )
                ]
            , div [ class "col-span-1" ]
                [ label [ class "block text-sm font-medium text-gray-700 mb-1" ] [ text "Current Monthly Premium (optional)" ]
                , div [ class "relative" ]
                    [ div [ class "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" ]
                        [ span [ class "text-gray-500" ] [ text "$" ] ]
                    , input
                        [ type_ "text"
                        , class "w-full pl-7 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500"
                        , Html.Attributes.value model.currentPremium
                        , onInput UpdateCurrentPremium
                        , Html.Attributes.pattern "[0-9]*"
                        , Html.Attributes.attribute "inputmode" "numeric"
                        , placeholder "0.00"
                        ]
                        []
                    ]
                ]
            ]
        , div [ class "grid grid-cols-1 sm:grid-cols-1 gap-4 sm:gap-4" ]
            [ div [ class "col-span-1" ]
                [ label [ class "block text-sm font-medium text-gray-700 mb-1" ] [ text "Plan Type (optional)" ]
                , select
                    [ class "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500"
                    , onInput UpdatePlanType
                    ]
                    [ option [ value "" ] [ text "Select Plan Type" ]
                    , option [ value "G", selected (model.planType == "G") ] [ text "Plan G" ]
                    , option [ value "N", selected (model.planType == "N") ] [ text "Plan N" ]
                    , option [ value "Other", selected (model.planType == "Other") ] [ text "Other" ]
                    ]
                ]
            ]
        , div [ class "mt-6 text-center" ]
            [ p [ class "text-sm text-[#475467]" ]
                [ text "By clicking below, you agree to receive Medicare Supplement plan updates that can help you save money." ]
            ]
        --}
        ]


inputField : String -> String -> String -> (String -> Msg) -> Bool -> Html Msg
inputField labelText inputType inputValue msg isDisabled =
    div [ class "mb-0" ]
        [ label [ class "block text-sm font-medium text-[#344054] mb-1" ] [ text labelText ]
        , input
            [ type_ inputType
            , class "w-full px-3 py-2 border border-[#D0D5DD] rounded-md shadow-sm focus:outline-none focus:ring-[#3DBDEC] focus:border-[#3DBDEC]"
            , placeholder
                (case inputType of
                    "tel" ->
                        "XXX-XXX-XXXX"

                    "email" ->
                        "example@example.com"

                    _ ->
                        ""
                )
            , Html.Attributes.value inputValue
            , onInput msg
            , disabled isDisabled
            , required True
            ]
            []
        ]


viewCountyDropdown : List String -> Maybe String -> Html Msg
viewCountyDropdown counties selectedCounty =
    div [ class "mb-4" ]
        [ label [ class "block text-sm font-medium text-[#344054] mb-1" ]
            [ text "County" ]
        , select
            [ class "w-full px-3 py-2 border border-[#D0D5DD] rounded-md shadow-sm focus:outline-none focus:ring-[#3DBDEC] focus:border-[#3DBDEC]"
            , onInput UpdateSelectedCounty
            , required True
            ]
            (option [ value "", disabled True, selected (selectedCounty == Nothing) ]
                [ text "Select your county" ]
                :: List.map
                    (\county ->
                        option
                            [ value county
                            , selected (selectedCounty == Just county)
                            ]
                            [ text county ]
                    )
                    counties
            )
        ]


viewError : Maybe String -> Html msg
viewError maybeError =
    case maybeError of
        Just error ->
            div [ class "mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded" ]
                [ text error ]

        Nothing ->
            text ""


viewFormSummary : Model -> Html Msg
viewFormSummary model =
    div [ class "border rounded-md p-3 sm:p-4 mb-4" ]
        [ h3 [ class "font-medium text-base sm:text-lg mb-3" ] [ text "Review Your Information" ]
        , summaryItem "Email" model.email
        , summaryItem "Name" (model.firstName ++ " " ++ model.lastName)
        , summaryItem "Phone" (formatPhoneNumber model.phoneNumber)
        , summaryItem "Zip Code" model.zipCode
        , summaryItem "State"
            (model.state
                |> Maybe.withDefault "Unknown"
            )
        , summaryItem "County"
            (model.selectedCounty
                |> Maybe.withDefault "Unknown"
            )
        , summaryItem "Date of Birth" model.dateOfBirth
        , summaryItem "Gender"
            (if model.gender == "M" then
                "Male"

             else
                "Female"
            )
        , summaryItem "Tobacco User"
            (if model.tobacco then
                "Yes"

             else
                "No"
            )
        , summaryItem "Carrier"
            (case model.carrier of
                Just (HasCarrier carrier) ->
                    carrierToString carrier

                Just NoneOther ->
                    "None/Other"

                Nothing ->
                    "Not selected"
            )
        , if not (String.isEmpty model.currentPremium) then
            summaryItem "Current Premium" ("$" ++ model.currentPremium)

          else
            text ""
        , if not (String.isEmpty model.currentCarrier) then
            summaryItem "Current Carrier" model.currentCarrier

          else
            text ""
        , if not (String.isEmpty model.planType) then
            summaryItem "Plan Type"
                (case model.planType of
                    "G" ->
                        "Plan G"

                    "N" ->
                        "Plan N"

                    "Other" ->
                        "Other"

                    _ ->
                        model.planType
                )

          else
            text ""
        , summaryItem "Agree to Receive Updates"
            (if model.optInQuarterlyUpdates then
                "Yes"

             else
                "No"
            )
        ]


summaryItem : String -> String -> Html Msg
summaryItem label value =
    div [ class "flex justify-between py-1 border-b last:border-b-0 text-sm sm:text-base" ]
        [ span [ class "text-gray-600" ] [ text label ]
        , span [ class "font-medium" ] [ text value ]
        ]



-- MAIN


main : Program () Model Msg
main =
    Browser.application
        { init = \_ url key -> init key url
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        , onUrlChange = \_ -> GotInitResponse (Err (Http.BadUrl "URL changed"))
        , onUrlRequest = \_ -> GotInitResponse (Err (Http.BadUrl "URL requested"))
        }

================
File: frontend/src/Settings.elm
================
module Settings exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Components.ProgressIndicator
import Components.SetupLayout as SetupLayout
import File exposing (File)
import File.Select as Select
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onCheck, onClick, onInput, preventDefaultOn)
import Http exposing (expectJson, jsonBody)
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Ports
import StateRegions exposing (Region(..), getRegionStates, regionToString)
import Svg exposing (path, svg)
import Svg.Attributes exposing (clipRule, d, fill, fillRule, viewBox)
import Task



-- Constants


allCarriers : List String
allCarriers =
    [ "Aetna"
    , "Humana"
    , "UnitedHealthcare"
    , "Cigna"
    , "Aflac"
    , "Allstate"
    , "Mutual of Omaha"
    , "Ace Chubb"
    ]


type Carrier
    = Aetna
    | Humana
    | UnitedHealthcare
    | Cigna
    | Aflac
    | Allstate
    | MutualOfOmaha
    | AceChubb



-- Add new type for GI selection mode


type GISelectionMode
    = GIAll
    | GINone
    | GIRecommended


type alias InitFlags =
    { isSetup : Bool
    , key : Nav.Key
    , currentUser : Maybe CurrentUser
    , planType : String
    }


type alias CurrentUser =
    { id : String
    , email : String
    , isAdmin : Bool
    , isAgent : Bool
    , organizationSlug : String
    , organizationId : String
    }



-- Add new type for deactivated carrier-state pairs


type alias DeactivatedPair =
    { carrier : String
    }


type alias Model =
    { orgSettings : Maybe Settings
    , status : Status
    , expandedSections : List String
    , recommendedGICombos : List StateCarrierSetting
    , isSetup : Bool
    , key : Nav.Key
    , currentUser : Maybe CurrentUser
    , isLoading : Bool
    , isSaving : Bool
    , planType : String
    , error : Maybe String
    , selectedCarrier : Maybe String
    , loadedCarriers : List String
    , linkCopied : Bool
    , selfOnboardingUrl : Maybe String
    , logo : Maybe String
    , hover : Bool
    , uploadingLogo : Bool
    }


type alias StateCarrierSetting =
    { carrier : String
    , active : Bool
    , targetGI : Bool
    }


type alias Settings =
    { carrierContracts : List String
    , stateCarrierSettings : List StateCarrierSetting
    , allowAgentSettings : Bool
    , emailSendBirthday : Bool
    , emailSendPolicyAnniversary : Bool
    , emailSendAep : Bool
    , smartSendEnabled : Bool
    , brandName : String
    , primaryColor : String
    , secondaryColor : String
    , logo : Maybe String
    , orgSignature : Bool
    , phone : String
    , redirectUrl : String
    , signature : String
    , forceOrgSenderDetails : Bool
    }


type alias SaveResponse =
    { success : Bool
    , error : Maybe String
    }


type Status
    = Loading
    | Loaded
    | Saving
    | Error String


type Msg
    = GotSettings (Result Http.Error SettingsResponse)
    | SaveSettings
    | SettingsSaved (Result Http.Error SaveResponse)
    | ToggleEmailBirthday Bool
    | ToggleEmailAnniversary Bool
    | ToggleEmailAep Bool
    | ToggleSmartSend Bool
    | AddCarrierContract String
    | RemoveCarrierContract String
    | UpdateStateCarrierSetting String Bool Bool
    | ToggleSection String
    | ToggleAllCarriers Bool
    | ApplyGISelection GISelectionMode
    | GotRecommendedGICombos (Result Http.Error (List StateCarrierSetting))
    | ToggleAllowAgentSettings Bool
    | FinishSetup
    | UpdateBrandName String
    | UpdatePhone String
    | UpdateRedirectUrl String
    | UpdateSignature String
    | UploadLogo
    | GotLogo File
    | GotLogoUrl String
    | LogoUploaded (Result Http.Error String)
    | NoOp
    | OrgFinalized (Result Http.Error ())
    | SelectCarrier String
    | GotCarriers (Result Http.Error (List String))
    | CopySelfOnboardingLink
    | LinkCopied Bool
    | GotSelfOnboardingUrl (Result Http.Error SelfOnboardingUrlResponse)
    | DragEnter
    | DragLeave
    | GotFiles File (List File)
    | UpdateForceOrgSenderDetails Bool


type alias SettingsResponse =
    { orgSettings : Settings
    , logo : Maybe String
    , canEditOrgSettings : Bool
    }


type alias SelfOnboardingUrlResponse =
    { selfOnboardingUrl : String
    }


init : InitFlags -> ( Model, Cmd Msg )
init flags =
    ( { orgSettings = Nothing
      , status = Loading
      , expandedSections = []
      , recommendedGICombos = []
      , isSetup = flags.isSetup
      , key = flags.key
      , currentUser = flags.currentUser
      , isLoading = True
      , isSaving = False
      , planType = flags.planType
      , error = Nothing
      , selectedCarrier = Nothing
      , loadedCarriers = []
      , linkCopied = False
      , selfOnboardingUrl = Nothing
      , logo = Nothing
      , hover = False
      , uploadingLogo = False
      }
    , Cmd.batch
        [ fetchSettings
        , fetchRecommendedGICombos
        , fetchCarriers
        , fetchSelfOnboardingUrl
        ]
    )


fetchSettings : Cmd Msg
fetchSettings =
    Http.get
        { url = "/api/settings"
        , expect = Http.expectJson GotSettings settingsDecoder
        }


fetchRecommendedGICombos : Cmd Msg
fetchRecommendedGICombos =
    Http.get
        { url = "/api/settings/gi-recommendations"
        , expect = Http.expectJson GotRecommendedGICombos recommendationsDecoder
        }


fetchCarriers : Cmd Msg
fetchCarriers =
    Http.get
        { url = "/api/settings/carriers"
        , expect = Http.expectJson GotCarriers (Decode.list (Decode.field "name" Decode.string))
        }


fetchSelfOnboardingUrl : Cmd Msg
fetchSelfOnboardingUrl =
    Http.get
        { url = "/api/self-service-info/"
        , expect = Http.expectJson GotSelfOnboardingUrl selfOnboardingUrlDecoder
        }


selfOnboardingUrlDecoder : Decoder SelfOnboardingUrlResponse
selfOnboardingUrlDecoder =
    Decode.map SelfOnboardingUrlResponse
        (Decode.field "selfOnboardingUrl" Decode.string)


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        GotSettings result ->
            case result of
                Ok response ->
                    ( { model
                        | orgSettings = Just response.orgSettings
                        , logo = response.logo
                        , status = Loaded
                        , isLoading = False
                      }
                    , Cmd.none
                    )

                Err error ->
                    let
                        errorMsg =
                            case error of
                                Http.BadUrl url ->
                                    "Bad URL: " ++ url

                                Http.Timeout ->
                                    "Request timed out"

                                Http.NetworkError ->
                                    "Network error"

                                Http.BadStatus status ->
                                    "Bad status: " ++ String.fromInt status

                                Http.BadBody message ->
                                    "Bad body: " ++ message
                    in
                    ( { model | status = Error errorMsg, isLoading = False }
                    , Cmd.none
                    )

        GotCarriers result ->
            case result of
                Ok carriers ->
                    ( { model | loadedCarriers = carriers }
                    , Cmd.none
                    )

                Err _ ->
                    ( model, Cmd.none )

        SaveSettings ->
            ( { model | status = Saving }
            , Cmd.none
            )

        SettingsSaved result ->
            case result of
                Ok response ->
                    ( { model
                        | status =
                            if response.success then
                                Loaded

                            else
                                Error (response.error |> Maybe.withDefault "Failed to save settings")
                      }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model | status = Error "Failed to save settings" }
                    , Cmd.none
                    )

        ToggleEmailBirthday value ->
            updateSettings model (\s -> { s | emailSendBirthday = value })

        ToggleEmailAnniversary value ->
            updateSettings model (\s -> { s | emailSendPolicyAnniversary = value })

        ToggleEmailAep value ->
            updateSettings model (\s -> { s | emailSendAep = value })

        ToggleSmartSend value ->
            updateSettings model (\s -> { s | smartSendEnabled = value })

        AddCarrierContract carrier ->
            updateSettings model
                (\s ->
                    if List.member carrier s.carrierContracts then
                        s

                    else
                        { s
                            | carrierContracts = carrier :: s.carrierContracts
                            , stateCarrierSettings = List.map (\setting -> { setting | active = True }) s.stateCarrierSettings
                        }
                )

        RemoveCarrierContract carrier ->
            updateSettings model
                (\s ->
                    { s
                        | carrierContracts = List.filter (\x -> x /= carrier) s.carrierContracts
                        , stateCarrierSettings = List.filter (\setting -> setting.carrier /= carrier) s.stateCarrierSettings
                    }
                )

        UpdateStateCarrierSetting carrier active targetGI ->
            updateSettings model
                (\s ->
                    let
                        existingSetting =
                            List.filter
                                (\setting ->
                                    setting.carrier == carrier
                                )
                                s.stateCarrierSettings
                                |> List.head

                        newSettings =
                            case existingSetting of
                                Just _ ->
                                    List.map
                                        (\setting ->
                                            if setting.carrier == carrier then
                                                { setting | active = active, targetGI = targetGI }

                                            else
                                                setting
                                        )
                                        s.stateCarrierSettings

                                Nothing ->
                                    { carrier = carrier
                                    , active = active
                                    , targetGI = targetGI
                                    }
                                        :: s.stateCarrierSettings
                    in
                    { s | stateCarrierSettings = newSettings }
                )

        ToggleSection title ->
            ( { model
                | expandedSections =
                    if List.member title model.expandedSections then
                        List.filter ((/=) title) model.expandedSections

                    else
                        title :: model.expandedSections
              }
            , Cmd.none
            )

        ToggleAllCarriers checked ->
            case model.orgSettings of
                Just settings ->
                    let
                        carriersToUse =
                            if List.isEmpty model.loadedCarriers then
                                allCarriers

                            else
                                model.loadedCarriers

                        newSettings =
                            { settings
                                | carrierContracts =
                                    if checked then
                                        carriersToUse

                                    else
                                        []
                                , stateCarrierSettings =
                                    if checked then
                                        List.map
                                            (\carrier ->
                                                { carrier = carrier
                                                , active = True
                                                , targetGI = False
                                                }
                                            )
                                            carriersToUse

                                    else
                                        []
                            }
                    in
                    ( { model | orgSettings = Just newSettings }
                    , saveSettings { settings = Just newSettings, logo = model.logo }
                    )

                Nothing ->
                    ( model, Cmd.none )

        ApplyGISelection mode ->
            case model.orgSettings of
                Just settings ->
                    let
                        newSettings =
                            case mode of
                                GIAll ->
                                    { settings
                                        | stateCarrierSettings =
                                            List.map
                                                (\carrier ->
                                                    { carrier = carrier
                                                    , active = True
                                                    , targetGI = True
                                                    }
                                                )
                                                settings.carrierContracts
                                    }

                                GINone ->
                                    { settings
                                        | stateCarrierSettings =
                                            List.map
                                                (\carrier ->
                                                    { carrier = carrier
                                                    , active = True
                                                    , targetGI = False
                                                    }
                                                )
                                                settings.carrierContracts
                                    }

                                GIRecommended ->
                                    { settings
                                        | stateCarrierSettings =
                                            List.map
                                                (\carrier ->
                                                    { carrier = carrier
                                                    , active = True
                                                    , targetGI =
                                                        List.any
                                                            (\rec -> rec.carrier == carrier)
                                                            model.recommendedGICombos
                                                    }
                                                )
                                                settings.carrierContracts
                                    }
                    in
                    ( { model | orgSettings = Just newSettings }
                    , saveSettings { settings = Just newSettings, logo = model.logo }
                    )

                Nothing ->
                    ( model, Cmd.none )

        GotRecommendedGICombos result ->
            case result of
                Ok combos ->
                    ( { model | recommendedGICombos = combos }
                    , Cmd.none
                    )

                Err error ->
                    ( { model | status = Error "Failed to load GI recommendations" }
                    , Cmd.none
                    )

        ToggleAllowAgentSettings value ->
            updateSettings model (\s -> { s | allowAgentSettings = value })

        FinishSetup ->
            case model.currentUser of
                Just user ->
                    if model.planType == "basic" then
                        ( { model | isLoading = True }
                        , finalizeOrganization user.organizationSlug
                        )

                    else
                        ( model
                        , Nav.pushUrl model.key "/dashboard"
                        )

                Nothing ->
                    ( model
                    , Nav.pushUrl model.key "/dashboard"
                    )

        OrgFinalized result ->
            case result of
                Ok _ ->
                    ( { model | isLoading = False }
                    , Nav.pushUrl model.key "/dashboard"
                    )

                Err error ->
                    let
                        errorMessage =
                            case error of
                                Http.BadStatus 500 ->
                                    "Failed to set up your organization's database. Please contact support at help@medicaremax.com and we'll help you get started."

                                Http.BadBody message ->
                                    message ++ "\nPlease contact support at help@medicaremax.com and we'll help you get started."

                                _ ->
                                    "An unexpected error occurred. Please contact support at help@medicaremax.com and we'll help you get started."
                    in
                    ( { model
                        | isLoading = False
                        , error = Just errorMessage
                      }
                    , Cmd.none
                    )

        SelectCarrier carrier ->
            ( { model | selectedCarrier = Just carrier }, Cmd.none )

        UpdateBrandName name ->
            updateSettings model (\s -> { s | brandName = name })

        UpdatePhone phone ->
            updateSettings model (\s -> { s | phone = phone })

        UpdateRedirectUrl url ->
            updateSettings model (\s -> { s | redirectUrl = url })

        UpdateSignature signature ->
            updateSettings model (\s -> { s | signature = signature })

        UploadLogo ->
            ( model
            , Select.file [ "image/png", "image/jpeg" ] GotLogo
            )

        DragEnter ->
            ( { model | hover = True }, Cmd.none )

        DragLeave ->
            ( { model | hover = False }, Cmd.none )

        GotFiles file files ->
            ( { model | hover = False, uploadingLogo = True }, Task.perform GotLogoUrl (File.toUrl file) )

        GotLogo file ->
            ( { model | uploadingLogo = True }, Task.perform GotLogoUrl (File.toUrl file) )

        GotLogoUrl url ->
            case model.orgSettings of
                Just settings ->
                    ( { model | logo = Just url, uploadingLogo = False, orgSettings = Just { settings | logo = Just url } }
                    , saveSettings { settings = Just { settings | logo = Just url }, logo = Just url }
                    )

                Nothing ->
                    ( { model | logo = Just url, uploadingLogo = False }, Cmd.none )

        LogoUploaded result ->
            case result of
                Ok url ->
                    updateSettings model (\s -> { s | logo = Just url })

                Err _ ->
                    ( { model | status = Error "Failed to upload logo" }, Cmd.none )

        CopySelfOnboardingLink ->
            let
                slug =
                    model.currentUser
                        |> Maybe.map .organizationSlug
                        |> Maybe.withDefault ""

                url =
                    model.selfOnboardingUrl
                        |> Maybe.withDefault ("http://localhost:5173/self-onboarding/" ++ slug)

                -- Command to copy link to clipboard using ports
                copyCmd =
                    Ports.copyToClipboard url
            in
            ( { model | linkCopied = False }, copyCmd )

        LinkCopied success ->
            ( { model | linkCopied = success }, Cmd.none )

        GotSelfOnboardingUrl result ->
            case result of
                Ok response ->
                    ( { model | selfOnboardingUrl = Just response.selfOnboardingUrl }, Cmd.none )

                Err _ ->
                    ( model, Cmd.none )

        UpdateForceOrgSenderDetails value ->
            updateSettings model (\s -> { s | forceOrgSenderDetails = value })


updateSettings : Model -> (Settings -> Settings) -> ( Model, Cmd Msg )
updateSettings model updateFn =
    case model.orgSettings of
        Just settings ->
            let
                newSettings =
                    updateFn settings
            in
            ( { model | orgSettings = Just newSettings }
            , saveSettings { settings = Just newSettings, logo = model.logo }
            )

        Nothing ->
            ( model, Cmd.none )


saveSettings : { settings : Maybe Settings, logo : Maybe String } -> Cmd Msg
saveSettings { settings, logo } =
    Http.request
        { method = "PUT"
        , headers = []
        , url = "/api/settings/org"
        , body = jsonBody (Encode.object [ ( "settings", Maybe.withDefault Encode.null (Maybe.map encodeSettings settings) ), ( "logo", Maybe.withDefault Encode.null (Maybe.map Encode.string logo) ) ])
        , expect = expectJson SettingsSaved saveResponseDecoder
        , timeout = Nothing
        , tracker = Nothing
        }


saveResponseDecoder : Decoder SaveResponse
saveResponseDecoder =
    Decode.map2 SaveResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "error" (Decode.nullable Decode.string))


encodeSettings : Settings -> Encode.Value
encodeSettings settings =
    Encode.object
        [ ( "carrierContracts", Encode.list Encode.string settings.carrierContracts )
        , ( "stateCarrierSettings", Encode.list stateCarrierSettingEncoder settings.stateCarrierSettings )
        , ( "allowAgentSettings", Encode.bool settings.allowAgentSettings )
        , ( "emailSendBirthday", Encode.bool settings.emailSendBirthday )
        , ( "emailSendPolicyAnniversary", Encode.bool settings.emailSendPolicyAnniversary )
        , ( "emailSendAep", Encode.bool settings.emailSendAep )
        , ( "smartSendEnabled", Encode.bool settings.smartSendEnabled )
        , ( "name", Encode.string settings.brandName )
        , ( "primaryColor", Encode.string settings.primaryColor )
        , ( "secondaryColor", Encode.string settings.secondaryColor )
        , ( "logo", Maybe.withDefault Encode.null (Maybe.map Encode.string settings.logo) )
        , ( "orgSignature", Encode.bool settings.orgSignature )
        , ( "phone", Encode.string settings.phone )
        , ( "redirectUrl", Encode.string settings.redirectUrl )
        , ( "signature", Encode.string settings.signature )
        , ( "forceOrgSenderDetails", Encode.bool settings.forceOrgSenderDetails )
        ]


stateCarrierSettingEncoder : StateCarrierSetting -> Encode.Value
stateCarrierSettingEncoder setting =
    Encode.object
        [ ( "carrier", Encode.string setting.carrier )
        , ( "active", Encode.bool setting.active )
        , ( "targetGI", Encode.bool setting.targetGI )
        ]


view : Model -> Browser.Document Msg
view model =
    { title =
        if model.isSetup then
            "Organization Setup - Settings"

        else
            "Settings"
    , body =
        [ if model.isSetup then
            SetupLayout.view SetupLayout.OrganizationSetup
                (model.planType == "basic")
                5
                [ if model.isLoading then
                    viewLoading

                  else
                    viewSettings model
                ]

          else
            div [ class "min-h-screen bg-white" ]
                [ viewHeader
                , div [ class "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 pt-2 sm:pt-4 pb-16" ]
                    [ if model.isLoading then
                        viewLoading

                      else
                        viewSettings model
                    ]
                ]
        ]
    }


viewSetupHeader : Html Msg
viewSetupHeader =
    div [ class "mb-8" ]
        [ h1 [ class "text-3xl font-bold text-gray-900" ]
            [ text "Set Up Your Organization" ]
        , p [ class "mt-2 text-gray-600" ]
            [ text "Configure your organization's settings to get started" ]
        ]


viewNormalHeader : Html Msg
viewNormalHeader =
    h1 [ class "text-2xl font-semibold text-[#03045E] mb-6" ]
        [ text "Organization Settings" ]


viewBottomBar : Model -> Html Msg
viewBottomBar model =
    div
        [ class """sticky bottom-0 left-0 right-0 bg-white border-t border-gray-200 
                  px-4 py-4 sm:px-6 lg:px-8 flex justify-end items-center
                  mt-8 max-w-4xl mx-auto"""
        ]
        [ case model.error of
            Just errorMsg ->
                div [ class "text-red-600 text-sm max-w-xl" ]
                    [ text errorMsg ]

            Nothing ->
                text ""
        ]


viewSettings : Model -> Html Msg
viewSettings model =
    div [ class "space-y-12" ]
        [ case model.orgSettings of
            Just settings ->
                div [ class "space-y-12" ]
                    [ viewOrganizationDetails settings model
                    , viewCarriersOffered settings model
                    , viewSelfOnboardingLink model
                    , viewDefaultSenderSettings settings
                    ]

            Nothing ->
                div [ class "text-gray-500 italic" ]
                    [ text "Loading settings..." ]
        ]


viewOrganizationDetails : Settings -> Model -> Html Msg
viewOrganizationDetails settings model =
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ h2 [ class "text-lg font-medium text-gray-900 mb-6" ] [ text "Organization Details" ]
        , p [ class "text-sm text-gray-500 mb-6" ]
            [ text "If the Organization is at any point selected to be the sender, the following details will be used." ]
        , div [ class "space-y-6" ]
            [ div [ class "space-y-4" ]
                [ viewFormGroup "Agency Name"
                    (input
                        [ type_ "text"
                        , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base"
                        , value settings.brandName
                        , onInput UpdateBrandName
                        , placeholder "Example Biz"
                        ]
                        []
                    )
                , viewFormGroup "Phone number"
                    (div [ class "flex" ]
                        [ span [ class "inline-flex items-center px-3 py-2 rounded-l-md border border-r-0 border-gray-300 bg-gray-50 text-gray-500 shadow-sm" ]
                            [ text "US" ]
                        , input
                            [ type_ "tel"
                            , class "flex-1 px-3 py-2 rounded-r-md border border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base focus:z-10"
                            , value settings.phone
                            , onInput UpdatePhone
                            , placeholder "+1 (555) 000-0000"
                            ]
                            []
                        ]
                    )
                , viewFormGroup "Calendar Booking Link (optional)"
                    (div []
                        [ input
                            [ type_ "text"
                            , class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base"
                            , value settings.redirectUrl
                            , onInput UpdateRedirectUrl
                            , placeholder "example.biz"
                            ]
                            []
                        , p [ class "text-gray-500 text-xs mt-1" ]
                            [ text "If provided, this link will be used as one of the options a client may select to connect with your agency. Traditionally this would be a Calendly link, Acuity link, etc." ]
                        ]
                    )
                , viewFormGroup "Email & SMS Signature or Sign Off"
                    (input
                        [ class "mt-1 px-3 py-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base"
                        , value settings.signature
                        , onInput UpdateSignature
                        , placeholder
                            ("The Team at "
                                ++ (if String.isEmpty settings.brandName then
                                        "Example Biz"

                                    else
                                        settings.brandName
                                   )
                            )
                        ]
                        []
                    )
                , viewFormGroup "Organization Logo"
                    (div []
                        [ if model.uploadingLogo then
                            div [ class "flex justify-center items-center h-32" ]
                                [ div [ class "animate-spin rounded-full h-8 w-8 border-2 border-purple-500 border-t-transparent" ] []
                                ]

                          else
                            div
                                [ class "border-2 border-dashed border-gray-300 rounded-lg p-6 flex flex-col items-center justify-center"
                                , classList [ ( "bg-purple-50 border-purple-300", model.hover ) ]
                                , hijackOn "dragenter" (Decode.succeed DragEnter)
                                , hijackOn "dragover" (Decode.succeed DragEnter)
                                , hijackOn "dragleave" (Decode.succeed DragLeave)
                                , hijackOn "drop" dropDecoder
                                ]
                                [ case model.logo of
                                    Just logoUrl ->
                                        div [ class "flex flex-col items-center space-y-4" ]
                                            [ img
                                                [ src logoUrl
                                                , class "h-24 w-auto object-contain"
                                                ]
                                                []
                                            , button
                                                [ class "px-4 py-2 text-sm text-purple-600 hover:text-purple-800 border border-purple-200 rounded"
                                                , onClick UploadLogo
                                                ]
                                                [ text "Change Logo" ]
                                            ]

                                    Nothing ->
                                        div [ class "flex flex-col items-center space-y-4 text-center" ]
                                            [ svg
                                                [ Svg.Attributes.class "h-10 w-10 text-gray-400"
                                                , viewBox "0 0 20 20"
                                                , fill "currentColor"
                                                ]
                                                [ path
                                                    [ fillRule "evenodd"
                                                    , d "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                                    , clipRule "evenodd"
                                                    ]
                                                    []
                                                ]
                                            , div []
                                                [ p [ class "text-gray-500" ] [ text "Drag and drop your logo here" ]
                                                , p [ class "text-gray-400 text-xs" ] [ text "or" ]
                                                , button
                                                    [ class "mt-2 px-4 py-2 text-sm text-purple-600 hover:text-purple-800 border border-purple-200 rounded"
                                                    , onClick UploadLogo
                                                    ]
                                                    [ text "Upload Logo" ]
                                                ]
                                            ]
                                ]
                        ]
                    )
                ]
            ]
        ]


viewFormGroup : String -> Html Msg -> Html Msg
viewFormGroup labelText content =
    div [ class "mb-4" ]
        [ label [ class "block text-sm font-medium text-gray-700 mb-2" ]
            [ text labelText ]
        , content
        ]


viewEmailSettings : Settings -> Html Msg
viewEmailSettings settings =
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ h2 [ class "text-lg font-medium mb-4" ] [ text "Email Settings" ]
        , div [ class "space-y-4" ]
            [ checkbox "Enable smart send" settings.smartSendEnabled ToggleSmartSend
            ]
        ]


viewSelfOnboardingLink : Model -> Html Msg
viewSelfOnboardingLink model =
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ h2 [ class "text-lg font-medium text-gray-900 mb-2" ] [ text "Organization Self-Onboarding Link" ]
        , p [ class "text-sm text-gray-500 mb-6" ]
            [ text "Share this link with clients or non-clients to gather missing information or capture new leads to your book of business." ]
        , div [ class "space-y-4" ]
            [ p [ class "text-sm font-medium text-gray-700 mb-2" ]
                [ text "Please note: when a user uses the link and fills out the form they will be added to your book without having a specified agent. To designate an agent for a new contact share the agent's self-onboarding link." ]
            , div [ class "mt-4" ]
                [ let
                    slug =
                        model.currentUser
                            |> Maybe.map .organizationSlug
                            |> Maybe.withDefault ""

                    selfOnboardingUrl =
                        model.selfOnboardingUrl
                            |> Maybe.withDefault ("medicaremax.ai/self-onboarding/" ++ slug)
                  in
                  div [ class "flex items-center space-x-2" ]
                    [ svg [ Svg.Attributes.class "h-5 w-5 text-gray-400", Svg.Attributes.viewBox "0 0 20 20", Svg.Attributes.fill "currentColor" ]
                        [ path [ Svg.Attributes.fillRule "evenodd", Svg.Attributes.d "M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z", Svg.Attributes.clipRule "evenodd" ] []
                        ]
                    , input
                        [ type_ "text"
                        , class "flex-1 px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-gray-50 text-gray-500"
                        , value selfOnboardingUrl
                        , readonly True
                        ]
                        []
                    , button
                        [ class "px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                        , onClick CopySelfOnboardingLink
                        ]
                        [ text "Copy Link" ]
                    ]
                ]
            ]
        ]


viewDefaultSenderSettings : Settings -> Html Msg
viewDefaultSenderSettings settings =
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ h2 [ class "text-lg font-medium text-gray-900 mb-2" ] [ text "Default Sender Settings" ]
        , p [ class "text-sm text-gray-500 mb-6" ]
            [ text "When communication is sent to your book of business you can set the default sender settings for the organization." ]
        , div [ class "grid grid-cols-1 md:grid-cols-2 gap-4" ]
            [ -- Organization Only Card
              div
                [ class
                    ("relative rounded-lg border-2 p-6 cursor-pointer transition-all "
                        ++ (if settings.forceOrgSenderDetails then
                                "border-blue-500 bg-blue-50"

                            else
                                "border-gray-200 hover:border-gray-300 bg-white"
                           )
                    )
                , onClick (UpdateForceOrgSenderDetails True)
                ]
                [ div [ class "flex items-start" ]
                    [ div [ class "flex items-center h-5" ]
                        [ input
                            [ type_ "radio"
                            , name "senderSettings"
                            , checked settings.forceOrgSenderDetails
                            , class "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"
                            ]
                            []
                        ]
                    , div [ class "ml-3" ]
                        [ label [ class "font-medium text-gray-900" ] [ text "Organization Only" ]
                        , p [ class "text-sm text-gray-500 mt-1" ]
                            [ text "When this option is selected the Organization Details above will be used for the signature, phone number, and scheduling link if applicable." ]
                        , p [ class "text-sm text-gray-500 mt-3" ]
                            [ text "The Agent will not get an option to use their information." ]
                        , div [ class "mt-4 text-xs text-gray-400" ]
                            [ div [ class "mb-1" ] [ text "Recommended For:" ]
                            , div [] [ text "Agencies with a customer care or retention team." ]
                            ]
                        ]
                    ]
                ]
            , -- Agent's Choice Card
              div
                [ class
                    ("relative rounded-lg border-2 p-6 cursor-pointer transition-all "
                        ++ (if not settings.forceOrgSenderDetails then
                                "border-blue-500 bg-blue-50"

                            else
                                "border-gray-200 hover:border-gray-300 bg-white"
                           )
                    )
                , onClick (UpdateForceOrgSenderDetails False)
                ]
                [ div [ class "flex items-start" ]
                    [ div [ class "flex items-center h-5" ]
                        [ input
                            [ type_ "radio"
                            , name "senderSettings"
                            , checked (not settings.forceOrgSenderDetails)
                            , class "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"
                            ]
                            []
                        ]
                    , div [ class "ml-3" ]
                        [ label [ class "font-medium text-gray-900" ] [ text "Agent Details" ]
                        , p [ class "text-sm text-gray-500 mt-1" ]
                            [ text "When this option is selected the Agent will have the choice to use their own name or the organization's name for the signature, phone number, and scheduling link (if applicable)." ]
                        , div [ class "mt-4 text-xs text-gray-400" ]
                            [ div [ class "mb-1" ] [ text "Recommended For:" ]
                            , div [] [ text "Agencies with agents who provide ongoing support for servicing existing clients." ]
                            ]
                        ]
                    ]
                ]
            ]
        ]


checkbox : String -> Bool -> (Bool -> msg) -> Html msg
checkbox labelText isChecked onToggle =
    Html.label [ class "flex items-center space-x-3" ]
        [ input
            [ type_ "checkbox"
            , checked isChecked
            , onCheck onToggle
            , class "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
            ]
            []
        , span [ class "text-gray-700" ] [ text labelText ]
        ]


viewExpandableSection : String -> Html Msg -> List String -> Html Msg
viewExpandableSection title content expandedSections =
    let
        isExpanded =
            List.member title expandedSections
    in
    div [ class "bg-white shadow rounded-lg overflow-hidden" ]
        [ button
            [ class "w-full px-6 py-4 text-left flex justify-between items-center hover:bg-gray-50"
            , onClick (ToggleSection title)
            ]
            [ h2 [ class "text-lg font-medium" ] [ text title ]
            , div
                [ class "transform transition-transform"
                , classList [ ( "rotate-180", isExpanded ) ]
                ]
                [ text "▼" ]
            ]
        , div
            [ class "px-6 pb-6"
            , classList [ ( "hidden", not isExpanded ) ]
            ]
            [ content ]
        ]


viewCarriersOffered : Settings -> Model -> Html Msg
viewCarriersOffered settings model =
    let
        carriersToUse =
            if List.isEmpty model.loadedCarriers then
                allCarriers

            else
                model.loadedCarriers
    in
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ h2 [ class "text-lg font-medium text-gray-900 mb-6" ] [ text "Carriers Offered" ]
        , p [ class "text-sm text-gray-500 mb-6" ]
            [ text "Select the carriers you would like offered to your clients. This will be set for all agents within the organization." ]
        , div []
            [ div [ class "mb-4" ]
                [ checkbox "Select to Offer All Carriers"
                    (List.length settings.carrierContracts == List.length carriersToUse)
                    ToggleAllCarriers
                ]
            , div [ class "grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4" ]
                (List.map
                    (\carrier ->
                        checkbox carrier
                            (safeMember carrier settings.carrierContracts)
                            (\checked ->
                                if checked then
                                    AddCarrierContract carrier

                                else
                                    RemoveCarrierContract carrier
                            )
                    )
                    carriersToUse
                )
            ]
        ]


viewCarriersGrid : Settings -> Model -> Html Msg
viewCarriersGrid settings model =
    viewCarriersOffered settings model


safeMember : String -> List String -> Bool
safeMember carrier carriers =
    let
        func : String -> String
        func c =
            c
                |> String.toLower
                |> String.trim
                |> String.replace " " ""
    in
    carriers
        |> List.map func
        |> List.member (func carrier)


viewStateCarrierGrid : Settings -> Model -> Html Msg
viewStateCarrierGrid settings model =
    let
        carriersToUse =
            if List.isEmpty model.loadedCarriers then
                allCarriers

            else
                model.loadedCarriers
    in
    div []
        [ div [ class "mb-6" ]
            [ h3 [ class "text-sm font-medium text-gray-700 mb-2" ]
                [ text "SmartSend for Guaranteed Issue" ]
            , div [ class "flex items-start p-4 bg-blue-50 rounded-md mb-6" ]
                [ div [ class "flex items-center h-5" ]
                    [ input
                        [ type_ "checkbox"
                        , checked settings.smartSendEnabled
                        , onCheck ToggleSmartSend
                        , class "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
                        ]
                        []
                    ]
                , div [ class "ml-3 text-sm" ]
                    [ label [ class "font-medium text-gray-700" ]
                        [ text "Use SmartSend for Guaranteed Issue" ]
                    , p [ class "text-gray-500 mt-1" ]
                        [ text "When enabled, SmartSend will automatically identify which carriers offer full carrier compensation for Guaranteed Issue (GI) policies." ]
                    ]
                ]
            , div [ class "mt-4 p-4 bg-gray-50 rounded-md mb-8" ]
                [ h3 [ class "text-md font-medium text-gray-900 mb-2" ]
                    [ text "How SmartSend Works" ]
                , p [ class "text-gray-600" ]
                    [ text "SmartSend analyzes each carrier to determine which ones offer full carrier compensation for Guaranteed Issue policies. This helps maximize your commissions while ensuring your quotes are always compliant with the latest carrier regulations." ]
                ]
            ]
        ]


option : List (Attribute msg) -> List (Html msg) -> Html msg
option attributes children =
    Html.option attributes children



-- Helper functions for state/carrier grid


hasDefaultSettings : Settings -> Bool
hasDefaultSettings settings =
    List.all
        (\setting -> setting.active && not setting.targetGI)
        settings.stateCarrierSettings


findStateCarrierSetting : Settings -> String -> StateCarrierSetting
findStateCarrierSetting settings carrier =
    settings.stateCarrierSettings
        |> List.filter (\s -> s.carrier == carrier)
        |> List.head
        |> Maybe.withDefault
            { carrier = carrier
            , active = True
            , targetGI = False
            }


viewStateCarrierCell : StateCarrierSetting -> Html Msg
viewStateCarrierCell setting =
    div [ class "flex flex-col items-center gap-1" ]
        [ label [ class "flex items-center gap-2 cursor-pointer" ]
            [ input
                [ type_ "checkbox"
                , checked setting.active
                , onCheck (\active -> UpdateStateCarrierSetting setting.carrier active setting.targetGI)
                , class "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
                ]
                []
            , span [ class "text-sm text-gray-600" ] [ text "Active" ]
            ]
        , label [ class "flex items-center gap-2 cursor-pointer" ]
            [ input
                [ type_ "checkbox"
                , checked setting.targetGI
                , onCheck (\targetGI -> UpdateStateCarrierSetting setting.carrier setting.active targetGI)
                , class "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
                ]
                []
            , span [ class "text-xs ml-1" ] [ text "GI" ]
            ]
        ]



-- Encoders and Decoders


settingsDecoder : Decoder SettingsResponse
settingsDecoder =
    let
        boolDecoder =
            Decode.oneOf
                [ Decode.bool
                , Decode.map (\n -> n == 1) Decode.int
                ]
    in
    Decode.field "success" Decode.bool
        |> Decode.andThen
            (\success ->
                if success then
                    Decode.map3 SettingsResponse
                        (Decode.field "orgSettings" settingsObjectDecoder)
                        (Decode.field "logo" (Decode.nullable Decode.string))
                        (Decode.field "canEditOrgSettings" boolDecoder)

                else
                    Decode.fail "Settings request was not successful"
            )


settingsObjectDecoder : Decoder Settings
settingsObjectDecoder =
    let
        stateCarrierSettingsDecoder =
            Decode.field "stateCarrierSettings" <|
                Decode.oneOf
                    [ Decode.list stateCarrierSettingDecoder
                    , Decode.null []
                    ]
    in
    Decode.succeed Settings
        |> Pipeline.required "carrierContracts" (Decode.list Decode.string)
        |> Pipeline.custom stateCarrierSettingsDecoder
        |> Pipeline.optional "allowAgentSettings" Decode.bool True
        |> Pipeline.optional "emailSendBirthday" Decode.bool False
        |> Pipeline.optional "emailSendPolicyAnniversary" Decode.bool False
        |> Pipeline.optional "emailSendAep" Decode.bool False
        |> Pipeline.optional "smartSendEnabled" Decode.bool True
        |> Pipeline.optional "brandName" Decode.string ""
        |> Pipeline.optional "primaryColor" Decode.string "#6B46C1"
        |> Pipeline.optional "secondaryColor" Decode.string "#9F7AEA"
        |> Pipeline.optional "logo" (Decode.nullable Decode.string) Nothing
        |> Pipeline.optional "orgSignature" Decode.bool False
        |> Pipeline.optional "phone" Decode.string ""
        |> Pipeline.optional "redirectUrl" Decode.string ""
        |> Pipeline.optional "signature" Decode.string ""
        |> Pipeline.optional "forceOrgSenderDetails" Decode.bool False


stateCarrierSettingDecoder : Decoder StateCarrierSetting
stateCarrierSettingDecoder =
    Decode.map3 StateCarrierSetting
        (Decode.field "carrier" Decode.string)
        (Decode.field "active" Decode.bool)
        (Decode.field "targetGI" Decode.bool)


recommendationsDecoder : Decoder (List StateCarrierSetting)
recommendationsDecoder =
    Decode.list
        (Decode.map3 StateCarrierSetting
            (Decode.field "carrier" Decode.string)
            (Decode.field "active" Decode.bool)
            (Decode.field "targetGI" Decode.bool)
        )


subscriptions : Model -> Sub Msg
subscriptions _ =
    Ports.onCopyResult LinkCopied


tab : String -> Bool -> Bool -> msg -> Html msg
tab label isActive isDisabled msg =
    button
        [ class "px-3 py-2 font-medium text-sm rounded-md -mb-px"
        , classList
            [ ( "text-indigo-600 border-indigo-500 border-b-2", isActive )
            , ( "text-gray-500 hover:text-gray-700 hover:border-gray-300 border-transparent border-b-2"
              , not isActive && not isDisabled
              )
            , ( "text-gray-400 cursor-not-allowed", isDisabled )
            ]
        , onClick msg
        , disabled isDisabled
        ]
        [ text label ]


viewNavLink : String -> String -> Html Msg
viewNavLink label path =
    a
        [ class "text-gray-700 hover:text-gray-900 hover:bg-gray-50 group flex items-center px-3 py-2 text-sm font-medium rounded-md"
        , href path
        ]
        [ text label ]


viewNavigation : Model -> Html Msg
viewNavigation model =
    nav []
        [ case model.currentUser of
            Just user ->
                if user.isAdmin then
                    viewNavLink "Manage Agents" "/agents"

                else
                    text ""

            Nothing ->
                text ""
        ]


viewLoading : Html msg
viewLoading =
    div [ class "flex justify-center items-center h-64" ]
        [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent" ] []
        ]


viewHeader : Html msg
viewHeader =
    nav [ class "bg-white" ]
        [ div [ class "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8" ]
            [ div [ class "flex justify-between h-16" ]
                [ div [ class "flex" ]
                    [ div [ class "flex-shrink-0 flex items-center" ]
                        [ h1 [ class "text-2xl font-semibold" ]
                            [ text "Organization Settings" ]
                        ]
                    ]
                ]
            ]
        ]


finalizeOrganization : String -> Cmd Msg
finalizeOrganization orgSlug =
    Http.post
        { url = "/api/organizations/" ++ orgSlug ++ "/setup-database"
        , body = Http.emptyBody
        , expect = Http.expectWhatever OrgFinalized
        }



-- Helper functions for drag and drop


dropDecoder : Decode.Decoder Msg
dropDecoder =
    Decode.at [ "dataTransfer", "files" ] (Decode.oneOrMore GotFiles File.decoder)


hijackOn : String -> Decode.Decoder msg -> Attribute msg
hijackOn event decoder =
    preventDefaultOn event (Decode.map hijack decoder)


hijack : msg -> ( msg, Bool )
hijack msg =
    ( msg, True )

================
File: frontend/src/Signup.elm
================
module Signup exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Browser.Navigation as Nav
import Char
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Process
import Task
import Url
import Url.Builder exposing (absolute, string)



-- MODEL


type alias Model =
    { firstName : String
    , lastName : String
    , organizationName : String
    , email : String
    , phone : String
    , formState : FormState
    , error : Maybe String
    , key : Nav.Key
    , emailStatus : EmailStatus
    , debounceCounter : Int
    }


type FormState
    = Editing
    | Submitting
    | LinkSent
    | Success
    | Error


type EmailStatus
    = NotChecked
    | Checking
    | Available
    | AlreadyRegistered String
    | InvalidFormat


init : Nav.Key -> ( Model, Cmd Msg )
init key =
    ( { firstName = ""
      , lastName = ""
      , organizationName = ""
      , email = ""
      , phone = ""
      , formState = Editing
      , error = Nothing
      , key = key
      , emailStatus = NotChecked
      , debounceCounter = 0
      }
    , Cmd.none
    )



-- UPDATE


type Msg
    = UpdateFirstName String
    | UpdateLastName String
    | UpdateOrganizationName String
    | UpdateEmail String
    | UpdatePhone String
    | CheckEmail Int
    | DebounceCheckEmail Int
    | GotEmailCheckResponse Int (Result Http.Error EmailCheckResponse)
    | SubmitForm
    | GotSignupResponse (Result Http.Error SignupResponse)
    | BlurEmail


type alias SignupResponse =
    { success : Bool
    , message : String
    }


type alias EmailCheckResponse =
    { available : Bool
    , message : String
    }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateFirstName value ->
            ( { model | firstName = value }, Cmd.none )

        UpdateLastName value ->
            ( { model | lastName = value }, Cmd.none )

        UpdateOrganizationName value ->
            ( { model | organizationName = value }, Cmd.none )

        UpdateEmail value ->
            let
                newCounter =
                    model.debounceCounter + 1

                newModel =
                    { model
                        | email = value
                        , emailStatus =
                            if String.isEmpty value then
                                NotChecked

                            else if not (isValidEmailFormat value) then
                                InvalidFormat

                            else
                                Checking
                        , debounceCounter = newCounter
                        , error = Nothing -- Clear any previous error on email change
                    }
            in
            ( newModel
            , if String.isEmpty value || not (isValidEmailFormat value) then
                Cmd.none

              else
                debounceEmailCheck newCounter
            )

        UpdatePhone value ->
            let
                -- Filter out non-digit characters
                digitsOnly =
                    String.filter Char.isDigit value

                -- Limit to 10 digits
                limitedDigits =
                    String.left 10 digitsOnly

                -- Format the phone number as needed
                formattedPhone =
                    if String.isEmpty digitsOnly then
                        ""

                    else if String.length limitedDigits == 10 then
                        "(" ++ String.left 3 limitedDigits ++ ") " ++ String.slice 3 6 limitedDigits ++ "-" ++ String.slice 6 10 limitedDigits

                    else if String.length limitedDigits >= 7 then
                        "(" ++ String.left 3 limitedDigits ++ ") " ++ String.slice 3 6 limitedDigits ++ "-" ++ String.slice 6 10 limitedDigits

                    else if String.length limitedDigits >= 4 then
                        "(" ++ String.left 3 limitedDigits ++ ") " ++ String.slice 3 10 limitedDigits

                    else
                        "("
                            ++ limitedDigits
                            ++ (if String.length limitedDigits == 3 then
                                    ") "

                                else
                                    ""
                               )
            in
            ( { model | phone = formattedPhone }, Cmd.none )

        DebounceCheckEmail counter ->
            if counter == model.debounceCounter && model.emailStatus == Checking then
                ( model, checkEmailAvailability counter model.email )

            else
                ( model, Cmd.none )

        CheckEmail counter ->
            ( model, checkEmailAvailability counter model.email )

        GotEmailCheckResponse counter result ->
            if counter /= model.debounceCounter then
                -- Ignore outdated responses
                ( model, Cmd.none )

            else
                case result of
                    Ok response ->
                        ( { model
                            | emailStatus =
                                if response.available then
                                    Available

                                else
                                    AlreadyRegistered response.message
                          }
                        , Cmd.none
                        )

                    Err _ ->
                        ( { model | emailStatus = NotChecked }, Cmd.none )

        SubmitForm ->
            if isValidForm model then
                ( { model | formState = Submitting }
                , Cmd.none
                  -- signup model
                )

            else
                ( { model | error = Just "Please fill out all fields correctly" }
                , Cmd.none
                )

        GotSignupResponse result ->
            case result of
                Ok response ->
                    if response.success then
                        -- Show success message
                        ( { model | formState = LinkSent }
                        , Cmd.none
                        )

                    else
                        ( { model | formState = Error, error = Just response.message }
                        , Cmd.none
                        )

                Err _ ->
                    ( { model | formState = Error, error = Just "Signup failed. Please try again." }
                    , Cmd.none
                    )

        BlurEmail ->
            if isValidEmailFormat model.email then
                ( model, checkEmailAvailability model.debounceCounter model.email )

            else
                ( model, Cmd.none )



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Get Started - Medicare Max"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex items-center justify-center py-12 px-4 sm:px-6 lg:px-8" ]
            [ div [ class "max-w-md w-full space-y-8" ]
                [ div [ class "text-center" ]
                    [ img [ src "/images/medicare-max-logo.png", class "mx-auto h-12 w-auto", alt "Medicare Max Logo" ] []
                    , h1 [ class "mt-6 text-3xl font-bold text-gray-900" ] [ text "Get Started" ]
                    , p [ class "mt-2 text-sm text-gray-600" ] [ text "Sign up and start using Medicare Max" ]
                    ]
                , case model.formState of
                    LinkSent ->
                        div [ class "text-center bg-green-50 p-6 rounded-lg border border-green-100" ]
                            [ p [ class "text-green-800 mb-2 font-medium" ] [ text "Welcome to Medicare Max!" ]
                            , p [ class "text-green-700 mb-4" ] [ text "We've sent you an email with a magic link to continue your account setup." ]
                            , p [ class "text-green-700" ] [ text "Please check your inbox (and spam folder) to complete your registration." ]
                            ]

                    Success ->
                        div [ class "text-center" ]
                            [ p [ class "text-green-600" ] [ text "Account created successfully!" ]
                            , div [ class "animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500 mx-auto mt-4" ] []
                            ]

                    _ ->
                        viewForm model
                ]
            ]
        ]
    }


viewForm : Model -> Html Msg
viewForm model =
    Html.form [ onSubmit SubmitForm, class "space-y-6" ]
        [ div [ class "grid grid-cols-1 md:grid-cols-2 gap-4" ]
            [ div []
                [ label [ for "firstName", class "block text-sm font-medium text-gray-700" ] [ text "First Name" ]
                , input
                    [ type_ "text"
                    , id "firstName"
                    , value model.firstName
                    , onInput UpdateFirstName
                    , class "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base py-2.5 px-3"
                    , placeholder "John"
                    ]
                    []
                ]
            , div []
                [ label [ for "lastName", class "block text-sm font-medium text-gray-700" ] [ text "Last Name" ]
                , input
                    [ type_ "text"
                    , id "lastName"
                    , value model.lastName
                    , onInput UpdateLastName
                    , class "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base py-2.5 px-3"
                    , placeholder "Doe"
                    ]
                    []
                ]
            ]
        , div []
            [ label [ for "organizationName", class "block text-sm font-medium text-gray-700" ] [ text "Organization Name" ]
            , input
                [ type_ "text"
                , id "organizationName"
                , value model.organizationName
                , onInput UpdateOrganizationName
                , class "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base py-2.5 px-3"
                , placeholder "ABC Healthcare"
                ]
                []
            ]
        , div [ class "grid grid-cols-1 md:grid-cols-2 gap-4" ]
            [ div []
                [ label [ for "email", class "block text-sm font-medium text-gray-700" ] [ text "Email" ]
                , input
                    [ type_ "email"
                    , id "email"
                    , value model.email
                    , onInput UpdateEmail
                    , onBlur BlurEmail
                    , class "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base py-2.5 px-3"
                    , placeholder "you@example.com"
                    ]
                    []
                , viewEmailStatusMessage model.emailStatus
                ]
            , div []
                [ label [ for "phone", class "block text-sm font-medium text-gray-700" ] [ text "Phone Number" ]
                , input
                    [ type_ "tel"
                    , id "phone"
                    , value model.phone
                    , onInput UpdatePhone
                    , class "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-base py-2.5 px-3"
                    , placeholder "(555) 555-5555"
                    , pattern "\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}"
                    , attribute "aria-label" "Phone number in format (555) 555-5555"
                    , attribute "inputmode" "numeric"
                    ]
                    []
                ]
            ]
        , case model.error of
            Just err ->
                div [ class "text-red-600 text-sm" ] [ text err ]

            Nothing ->
                text ""
        , if model.formState == Submitting || not (isValidForm model) then
            button
                [ type_ "submit"
                , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-[#03045e] opacity-70 cursor-not-allowed"
                , disabled True
                ]
                [ text
                    (if model.formState == Submitting then
                        "Creating Account..."

                     else
                        "Sign Up"
                    )
                ]

          else
            let
                uri =
                    absolute [ "onboarding" ]
                        [ string "firstName" model.firstName
                        , string "lastName" model.lastName
                        , string "organizationName" model.organizationName
                        , string "email" model.email
                        , string "phone" model.phone
                        ]
            in
            a
                [ href uri
                , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-[#03045e] hover:[#03045e]/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-theme-brand"
                ]
                [ text "Sign Up" ]
        , p [ class "mt-2 text-center text-sm text-gray-600" ]
            [ text "Already have an account? "
            , a [ href "/login", class "font-medium text-blue-600 hover:text-blue-500" ]
                [ text "Log in" ]
            ]
        ]


viewEmailStatusMessage : EmailStatus -> Html Msg
viewEmailStatusMessage status =
    case status of
        NotChecked ->
            text ""

        Checking ->
            p [ class "mt-1 text-blue-500 text-sm" ] [ text "Checking email..." ]

        Available ->
            p [ class "mt-1 text-green-500 text-sm" ] [ text "Email is available" ]

        AlreadyRegistered message ->
            p [ class "mt-1 text-red-500 text-sm" ] [ text message ]

        InvalidFormat ->
            p [ class "mt-1 text-red-500 text-sm" ] [ text "Please enter a valid email address" ]



-- HELPERS


isValidForm : Model -> Bool
isValidForm model =
    not (String.isEmpty model.firstName)
        && not (String.isEmpty model.lastName)
        && not (String.isEmpty model.organizationName)
        && not (String.isEmpty model.phone)
        && (String.length (String.filter Char.isDigit model.phone) == 10)
        && (model.emailStatus == Available)


isValidEmailFormat : String -> Bool
isValidEmailFormat email =
    String.contains "@" email && String.contains "." email


debounceEmailCheck : Int -> Cmd Msg
debounceEmailCheck counter =
    Process.sleep 500
        |> Task.perform (\_ -> DebounceCheckEmail counter)



-- API CALLS


checkEmailAvailability : Int -> String -> Cmd Msg
checkEmailAvailability counter email =
    Http.get
        { url = "/api/organizations/check-email/" ++ encodeUri email
        , expect = Http.expectJson (GotEmailCheckResponse counter) emailCheckResponseDecoder
        }



-- Simple URI encoder for email parameter


encodeUri : String -> String
encodeUri string =
    string
        |> String.replace "%" "%25"
        |> String.replace "+" "%2B"
        |> String.replace " " "%20"
        |> String.replace "/" "%2F"
        |> String.replace "?" "%3F"
        |> String.replace "#" "%23"
        |> String.replace "@" "%40"
        |> String.replace ":" "%3A"
        |> String.replace "=" "%3D"
        |> String.replace "&" "%26"


emailCheckResponseDecoder : Decoder EmailCheckResponse
emailCheckResponseDecoder =
    Decode.map2 EmailCheckResponse
        (Decode.field "available" Decode.bool)
        (Decode.field "message" Decode.string)


encodeSignupData : Model -> Encode.Value
encodeSignupData model =
    Encode.object
        [ ( "firstName", Encode.string model.firstName )
        , ( "lastName", Encode.string model.lastName )
        , ( "organizationName", Encode.string model.organizationName )
        , ( "email", Encode.string model.email )
        , ( "phone", Encode.string model.phone )
        ]


signupDecoder : Decoder SignupResponse
signupDecoder =
    Decode.map2 SignupResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "message" Decode.string)



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/StageDemoCTA.elm
================
module StageDemoCTA exposing (Model, Msg, init, update, view)

import Html exposing (..)
import Html.Attributes as HA
import Svg exposing (path, svg)
import Svg.Attributes as SA


type alias Model =
    { tempId : String }


type Msg
    = NoOp


init : String -> Model
init tempId =
    { tempId = tempId }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )


view : Model -> Html Msg
view model =
    div [ HA.class "min-h-screen bg-[#F9F5FF] flex items-center justify-center px-4" ]
        [ div [ HA.class "max-w-2xl mx-auto text-center" ]
            [ -- Success Icon
              div [ HA.class "mx-auto flex items-center justify-center h-24 w-24 rounded-full bg-green-100 mb-8" ]
                [ svg [ SA.class "h-12 w-12 text-green-600", SA.fill "none", SA.stroke "currentColor", SA.viewBox "0 0 24 24" ]
                    [ path [ SA.strokeLinecap "round", SA.strokeLinejoin "round", SA.strokeWidth "2", SA.d "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" ] []
                    ]
                ]

            -- Logo
            , div [ HA.class "mb-8" ]
                [ img
                    [ HA.src "/images/medicare-max-logo.png"
                    , HA.alt "Medicare Max"
                    , HA.class "h-12 mx-auto"
                    ]
                    []
                ]

            -- Heading
            , h1 [ HA.class "text-3xl sm:text-4xl font-bold text-[#141B29] mb-4" ]
                [ text "Congratulations! You May Qualify!" ]

            -- Subheading
            , p [ HA.class "text-xl text-[#475467] mb-8" ]
                [ text "Based on your answers, you appear to be eligible for the Medicare plans shown." ]

            -- Benefits list
            , div [ HA.class "bg-white rounded-lg shadow-lg p-8 mb-8 border border-gray-100" ]
                [ h2 [ HA.class "text-2xl font-semibold text-[#141B29] mb-6" ]
                    [ text "What's Next?" ]
                , ul [ HA.class "space-y-4 text-left" ]
                    [ benefitItem "Review your personalized plan options with an expert"
                    , benefitItem "Get help comparing coverage and costs"
                    , benefitItem "Learn about available discounts and savings"
                    , benefitItem "Complete your enrollment with professional guidance"
                    ]
                ]

            -- CTA Button
            , a
                [ HA.href "https://calendly.com/your-signup-link" -- Replace with actual Calendly URL
                , HA.target "_blank"
                , HA.class "inline-flex items-center px-8 py-4 border border-transparent text-lg font-semibold rounded-md shadow-lg text-white bg-[#03045E] hover:bg-[#1a1f5f] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#03045E] transition-all transform hover:scale-105"
                ]
                [ text "Schedule Your Medicare Max Demo"
                , svg [ SA.class "ml-3 -mr-1 h-5 w-5", SA.fill "none", SA.stroke "currentColor", SA.viewBox "0 0 24 24" ]
                    [ path [ SA.strokeLinecap "round", SA.strokeLinejoin "round", SA.strokeWidth "2", SA.d "M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" ] []
                    ]
                ]

            -- Urgency text
            , p [ HA.class "mt-6 text-sm text-gray-600" ]
                [ span [ HA.class "font-semibold" ] [ text "Limited time offer: " ]
                , text "Schedule now to lock in your discounted rates!"
                ]
            ]
        ]


benefitItem : String -> Html msg
benefitItem text_ =
    li [ HA.class "flex items-start" ]
        [ svg [ SA.class "flex-shrink-0 h-6 w-6 text-green-500 mt-0.5", SA.fill "none", SA.stroke "currentColor", SA.viewBox "0 0 24 24" ]
            [ path [ SA.strokeLinecap "round", SA.strokeLinejoin "round", SA.strokeWidth "2", SA.d "M5 13l4 4L19 7" ] []
            ]
        , span [ HA.class "ml-3 text-[#475467]" ] [ text text_ ]
        ]

================
File: frontend/src/StageDemoData.elm
================
module StageDemoData exposing (standardQuoteG, standardQuoteN, Plan)

type alias Plan =
    { price : Float
    , priceDiscount : Float
    , name : String
    , image : String
    , planType : String
    , naic : String
    , discountCategory : String
    }

-- Best Plan G option (Cigna)
standardQuoteG : Plan
standardQuoteG =
    { price = 123.94
    , priceDiscount = 116.50
    , name = "Cigna Health & Life Insurance Co"
    , image = "/images/Cigna.svg"
    , planType = "G"
    , naic = "67369"
    , discountCategory = "Multi-Insured / Roommate"
    }

-- Best Plan N option (Cigna)
standardQuoteN : Plan
standardQuoteN =
    { price = 90.11
    , priceDiscount = 84.70
    , name = "Cigna Health & Life Insurance Co"
    , image = "/images/Cigna.svg"
    , planType = "N"
    , naic = "67369"
    , discountCategory = "Multi-Insured / Roommate"
    }

================
File: frontend/src/StageDemoHealth.elm
================
module StageDemoHealth exposing (Model, Msg(..), init, update, view)

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick)

type alias Model =
    { tempId : String
    , questions : List Question
    }

type alias Question =
    { id : Int
    , title : String
    , text : String
    , answer : Maybe Bool
    }

type Msg
    = AnswerQuestion Int Bool
    | NavigateToCTA

init : String -> Model
init tempId =
    { tempId = tempId
    , questions = 
        [ { id = 1
          , title = "Heart Problems"
          , text = "Have you been diagnosed with any heart conditions?"
          , answer = Nothing
          }
        , { id = 2
          , title = "Lung Problems"
          , text = "Have you been diagnosed with any lung conditions?"
          , answer = Nothing
          }
        , { id = 3
          , title = "Kidney Disease"
          , text = "Have you been diagnosed with kidney disease?"
          , answer = Nothing
          }
        , { id = 4
          , title = "Diabetes"
          , text = "Have you been diagnosed with diabetes?"
          , answer = Nothing
          }
        ]
    }

update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        AnswerQuestion questionId answer ->
            let
                updateQuestion q =
                    if q.id == questionId then
                        { q | answer = Just answer }
                    else
                        q
            in
            ( { model | questions = List.map updateQuestion model.questions }, Cmd.none )

        NavigateToCTA ->
            ( model, Cmd.none ) -- Navigation handled by Main.elm

view : Model -> Html Msg
view model =
    div [ class "min-h-screen bg-white" ]
        [ -- Header
          div [ class "bg-white shadow-sm border-b" ]
            [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6" ]
                [ -- Logo
                  div [ class "flex items-center justify-center mb-4" ]
                    [ img 
                        [ src "/images/medicare-max-logo.png"
                        , alt "Medicare Max"
                        , class "h-10"
                        ]
                        []
                    ]
                , div [ class "text-center" ]
                    [ h1 [ class "text-2xl sm:text-3xl font-bold text-[#141B29]" ] [ text "Health Qualification Questions" ]
                    , p [ class "text-[#475467] mt-2" ] [ text "Please answer these questions to see if you qualify for coverage" ]
                    ]
                ]
            ]
        
        -- Questions
        , div [ class "max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
            [ div [ class "space-y-6" ]
                (List.map viewQuestion model.questions)
            
            -- Navigation buttons
            , div [ class "mt-8 flex justify-between" ]
                [ button
                    [ class "px-6 py-3 text-[#03045E] bg-white border-2 border-[#03045E] rounded-md hover:bg-gray-50 font-semibold transition-colors duration-200"
                    , onClick NavigateToCTA
                    ]
                    [ text "Skip Questions" ]
                , button
                    [ class "px-6 py-3 bg-[#03045E] text-white rounded-md hover:bg-[#1a1f5f] font-semibold transition-colors duration-200"
                    , onClick NavigateToCTA
                    , disabled (not (allQuestionsAnswered model.questions))
                    ]
                    [ text "Next" ]
                ]
            ]
        ]

viewQuestion : Question -> Html Msg
viewQuestion question =
    div [ class "bg-white rounded-lg shadow-lg border border-gray-100 p-6" ]
        [ h3 [ class "text-lg font-semibold text-[#141B29] mb-2" ] [ text question.title ]
        , p [ class "text-[#475467] mb-4" ] [ text question.text ]
        , div [ class "flex space-x-4" ]
            [ button
                [ class (answerButtonClass question.answer True)
                , onClick (AnswerQuestion question.id True)
                ]
                [ text "Yes" ]
            , button
                [ class (answerButtonClass question.answer False)
                , onClick (AnswerQuestion question.id False)
                ]
                [ text "No" ]
            ]
        ]

answerButtonClass : Maybe Bool -> Bool -> String
answerButtonClass currentAnswer buttonValue =
    let
        baseClass = "px-6 py-2 rounded-md font-medium transition-colors "
        selectedClass = 
            case currentAnswer of
                Just answer ->
                    if answer == buttonValue then
                        if buttonValue then
                            "bg-red-600 text-white hover:bg-red-700"
                        else
                            "bg-green-600 text-white hover:bg-green-700"
                    else
                        "bg-gray-200 text-gray-700 hover:bg-gray-300"
                
                Nothing ->
                    "bg-gray-200 text-gray-700 hover:bg-gray-300"
    in
    baseClass ++ selectedClass

allQuestionsAnswered : List Question -> Bool
allQuestionsAnswered questions =
    List.all (\q -> q.answer /= Nothing) questions

================
File: frontend/src/StageDemoInput.elm
================
module StageDemoInput exposing (Model, Msg, init, update, view)

import Html exposing (..)
import Html.Attributes as Attr
import Html.Events exposing (onClick, onInput)
import Http
import Json.Decode as Decode
import Json.Encode as Encode
import Svg exposing (path, svg)
import Svg.Attributes as SA


type alias Model =
    { firstName : String
    , lastName : String
    , email : String
    , phone : String
    , submitting : Bool
    , error : Maybe String
    , success : Bool
    }


type Msg
    = UpdateFirstName String
    | UpdateLastName String
    | UpdateEmail String
    | UpdatePhone String
    | Submit
    | SubmitResponse (Result Http.Error SubmitResult)


type alias SubmitResult =
    { success : Bool
    , message : String
    }


init : Model
init =
    { firstName = ""
    , lastName = ""
    , email = ""
    , phone = ""
    , submitting = False
    , error = Nothing
    , success = False
    }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateFirstName value ->
            ( { model | firstName = value }, Cmd.none )

        UpdateLastName value ->
            ( { model | lastName = value }, Cmd.none )

        UpdateEmail value ->
            ( { model | email = value }, Cmd.none )

        UpdatePhone value ->
            ( { model | phone = value }, Cmd.none )

        Submit ->
            if String.isEmpty model.firstName || String.isEmpty model.lastName || String.isEmpty model.email || String.isEmpty model.phone then
                ( { model | error = Just "All fields are required" }, Cmd.none )

            else
                ( { model | submitting = True, error = Nothing }
                , submitForm model
                )

        SubmitResponse result ->
            case result of
                Ok submitResult ->
                    ( { model | submitting = False, success = True, error = Nothing }, Cmd.none )

                Err _ ->
                    ( { model | submitting = False, error = Just "Failed to submit. Please try again." }, Cmd.none )


submitForm : Model -> Cmd Msg
submitForm model =
    Http.post
        { url = "/api/stage-demo/submit"
        , body = Http.jsonBody (encodeFormData model)
        , expect = Http.expectJson SubmitResponse decodeSubmitResult
        }


encodeFormData : Model -> Encode.Value
encodeFormData model =
    Encode.object
        [ ( "firstName", Encode.string model.firstName )
        , ( "lastName", Encode.string model.lastName )
        , ( "email", Encode.string model.email )
        , ( "phone", Encode.string model.phone )
        ]


decodeSubmitResult : Decode.Decoder SubmitResult
decodeSubmitResult =
    Decode.map2 SubmitResult
        (Decode.field "success" Decode.bool)
        (Decode.field "message" Decode.string)


view : Model -> Html Msg
view model =
    div [ Attr.class "min-h-screen bg-white py-12 px-4 sm:px-6 lg:px-8" ]
        [ div [ Attr.class "max-w-md mx-auto" ]
            [ -- Logo
              div [ Attr.class "text-center mb-8" ]
                [ img
                    [ Attr.src "/images/medicare-max-logo.png"
                    , Attr.alt "Medicare Max"
                    , Attr.class "h-12 mx-auto"
                    ]
                    []
                ]
            , div [ Attr.class "bg-white shadow-lg rounded-lg p-8 border border-gray-100" ]
                [ if model.success then
                    successView

                  else
                    formView model
                ]
            ]
        ]


successView : Html Msg
successView =
    div [ Attr.class "text-center" ]
        [ div [ Attr.class "mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-green-100 mb-4" ]
            [ svg [ SA.class "h-6 w-6 text-green-600", SA.fill "none", SA.stroke "currentColor", SA.viewBox "0 0 24 24" ]
                [ path [ SA.strokeLinecap "round", SA.strokeLinejoin "round", SA.strokeWidth "2", SA.d "M5 13l4 4L19 7" ] []
                ]
            ]
        , h3 [ Attr.class "text-lg font-medium text-gray-900 mb-2" ] [ text "Success!" ]
        , p [ Attr.class "text-gray-600" ] [ text "Check your email and texts for your personalized Medicare quote!" ]
        ]


formView : Model -> Html Msg
formView model =
    div []
        [ h2 [ Attr.class "text-2xl font-bold text-[#141B29] mb-6 text-center" ] [ text "Get Your Personalized Medicare Quote" ]
        , p [ Attr.class "text-[#475467] text-center mb-8" ] [ text "See how much you could save on your Medicare Supplement plan" ]
        , Html.form [ Attr.class "space-y-4" ]
            [ div []
                [ label [ Attr.class "block text-sm font-medium text-gray-700 mb-1", Attr.for "firstName" ] [ text "First Name" ]
                , input
                    [ Attr.type_ "text"
                    , Attr.id "firstName"
                    , Attr.class "block w-full border-gray-300 rounded-md shadow-sm focus:ring-[#03045E] focus:border-[#03045E]"
                    , Attr.placeholder "John"
                    , Attr.value model.firstName
                    , onInput UpdateFirstName
                    , Attr.disabled model.submitting
                    ]
                    []
                ]
            , div []
                [ label [ Attr.class "block text-sm font-medium text-gray-700 mb-1", Attr.for "lastName" ] [ text "Last Name" ]
                , input
                    [ Attr.type_ "text"
                    , Attr.id "lastName"
                    , Attr.class "block w-full border-gray-300 rounded-md shadow-sm focus:ring-[#03045E] focus:border-[#03045E]"
                    , Attr.placeholder "Doe"
                    , Attr.value model.lastName
                    , onInput UpdateLastName
                    , Attr.disabled model.submitting
                    ]
                    []
                ]
            , div []
                [ label [ Attr.class "block text-sm font-medium text-gray-700 mb-1", Attr.for "email" ] [ text "Email" ]
                , input
                    [ Attr.type_ "email"
                    , Attr.id "email"
                    , Attr.class "block w-full border-gray-300 rounded-md shadow-sm focus:ring-[#03045E] focus:border-[#03045E]"
                    , Attr.placeholder "john@example.com"
                    , Attr.value model.email
                    , onInput UpdateEmail
                    , Attr.disabled model.submitting
                    ]
                    []
                ]
            , div []
                [ label [ Attr.class "block text-sm font-medium text-gray-700 mb-1", Attr.for "phone" ] [ text "Phone Number" ]
                , input
                    [ Attr.type_ "tel"
                    , Attr.id "phone"
                    , Attr.class "block w-full border-gray-300 rounded-md shadow-sm focus:ring-[#03045E] focus:border-[#03045E]"
                    , Attr.placeholder "(555) 123-4567"
                    , Attr.value model.phone
                    , onInput UpdatePhone
                    , Attr.disabled model.submitting
                    ]
                    []
                ]
            , case model.error of
                Just err ->
                    div [ Attr.class "text-red-600 text-sm" ] [ text err ]

                Nothing ->
                    text ""
            , button
                [ Attr.type_ "button"
                , Attr.class "w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-base font-semibold text-white bg-[#03045E] hover:bg-[#1a1f5f] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#03045E] disabled:opacity-50 transition-colors duration-200"
                , onClick Submit
                , Attr.disabled model.submitting
                ]
                [ if model.submitting then
                    text "Submitting..."

                  else
                    text "Get My Personalized Quote"
                ]
            ]
        ]

================
File: frontend/src/StageDemoQuote.elm
================
module StageDemoQuote exposing
    ( CompareParams
    , Model
    , Msg(..)
    , PlanType(..)
    , init
    , subscriptions
    , update
    , view
    )

-- ADDED FOR STAGE DEMO

import BirthdayRules exposing (isInBirthdayRuleWindow)
import Browser
import Browser.Dom as Dom
import Browser.Events
import Browser.Navigation as Nav
import CarrierNaic exposing (Carrier(..), carrierDecoder, carrierToNaics, carrierToString, naicToCarrier, stringToCarrier)
import Date exposing (Date)
import Dict
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput)
import Http
import Json.Decode as D exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as E
import List.Extra
import Svg exposing (path, svg)
import Svg.Attributes exposing (clipRule, d, fill, fillRule, height, stroke, strokeLinecap, viewBox, width)
import Task
import Time
import Url exposing (Url)
import Url.Parser as UrlParser
import Url.Parser.Query as Query
import Utils.DiscountDescription exposing (discountDescription)
import Utils.QuoteHeader exposing (viewHeader)



-- TYPES


type PlanType
    = PlanG
    | PlanN


type alias CompareParams =
    { quoteId : Maybe String
    , orgId : Maybe String
    , tid : Maybe String
    }


type alias ContactResponse =
    { contact : Maybe Contact
    , agent : Agent
    , orgSlug : String
    , orgName : String
    , orgLogo : Maybe String
    , orgPhone : Maybe String
    , orgSignature : Bool
    , orgSignatureText : Maybe String
    , carrierContracts : List Carrier
    , forceOrgSenderDetails : Bool
    }


type alias Agent =
    { firstName : String
    , lastName : String
    , email : String
    , phone : String
    , signature : String
    , useOrgSenderDetails : Bool
    , bookingLink : String
    }


type alias Contact =
    { id : Int
    , firstName : String
    , lastName : String
    , email : String
    , phoneNumber : String
    , age : Int
    , gender : String
    , tobacco : Bool
    , state : String
    , zipCode : String
    , county : Maybe String
    , currentCarrier : Maybe String
    , planType : Maybe String
    }


type alias CoverageItem =
    { name : String
    , percentageCovered : Int
    , note : Maybe String
    }


type alias CoverageList =
    List CoverageItem


type alias Plan =
    { price : Float
    , priceDiscount : Float
    , flag : Maybe String
    , age : Int
    , description : String
    , gender : String
    , id : Int
    , image : String
    , naic : String
    , name : String
    , planType : String
    , premiumStability : String
    , ratingCategory : String
    , score : Int
    , select : Bool
    , state : String
    , tobacco : Bool
    , coverageSummary : CoverageList
    , discountDescription : Maybe String
    , originalPlanName : Maybe String
    }


type alias Plans =
    { planG : List Plan
    , planN : List Plan
    }


type alias LocationUpdateResponse =
    { success : Bool
    , zipCode : String
    , state : String
    , counties : List String
    }


type alias Model =
    { tempId : String
    , isLoading : Bool
    , error : Maybe String
    , plans : Plans
    , state : Maybe String
    , county : Maybe String
    , zip : Maybe String
    , age : Maybe Int
    , gender : Maybe String
    , tobacco : Maybe Bool
    , selectedPlanType : PlanType
    , selectedPlan : Maybe Plan
    , showReviewVideo : Bool
    , showQualificationVideo : Bool
    , showGvsNVideo : Bool
    , showFAQ : Bool
    , currentCardIndex : Int
    , showRatesVideo : Bool
    , key : Nav.Key
    , showDiscount : Bool
    , currentCarrier : Maybe String
    , planType : Maybe String
    , dateOfBirth : Maybe String
    , quoteId : Maybe String
    , carrierContracts : List Carrier
    , currentDate : Maybe Date
    , effectiveDate : Maybe Date
    , discountCsvString : Maybe String
    , orgId : Maybe String
    , orgName : Maybe String
    , orgLogo : Maybe String
    , orgPhone : Maybe String
    , useOrg : Bool
    , orgSignatureText : Maybe String
    , name : Maybe String
    , contact : Maybe Contact
    , agent : Maybe Agent
    , orgSlug : Maybe String
    , loadingContact : Bool
    , showDiscountInfo : Bool
    , showLocationModal : Bool
    , editingZipCode : Maybe String
    , editingCounty : Maybe String
    , availableCounties : List String
    , locationUpdateError : Maybe String
    , submittingLocation : Bool
    , editingEffectiveDate : Maybe String
    , fetchNewPlans : Bool
    , activeTooltipPlan : Maybe Plan
    , forceOrgSenderDetails : Bool
    }


type Msg
    = GotDiscountCsvString (Result Http.Error String)
    | FetchedPlans (Result Http.Error (List QuoteResponse))
    | TogglePlanType
    | SelectPlan Plan
    | SelectPlanCard Plan
    | ScrollDown Dom.Viewport
    | OpenGvsNVideo
    | CloseGvsNVideo
    | ShowFAQ
    | CloseFAQ
    | NextCard
    | PreviousCard
    | CloseRatesVideo
    | NavigateTo String
    | ToggleDiscount
    | ToggleDiscountInfo
    | GotCurrentDate Date
    | ToggleMobileTooltip (Maybe Plan)
    | NavigateToHealth
    | NoOp


init : String -> Nav.Key -> ( Model, Cmd Msg )
init tempId key =
    let
        -- Empty model with loading state
        emptyModel =
            { tempId = tempId
            , isLoading = True
            , error = Nothing
            , plans = { planG = [], planN = [] }
            , state = Nothing
            , county = Nothing
            , zip = Nothing
            , age = Nothing
            , gender = Nothing
            , tobacco = Nothing
            , selectedPlanType = PlanG
            , selectedPlan = Nothing
            , showReviewVideo = False
            , showQualificationVideo = False
            , showGvsNVideo = False
            , showFAQ = False
            , currentCardIndex = 0
            , showRatesVideo = False
            , key = key
            , showDiscount = False
            , currentCarrier = Nothing
            , planType = Nothing
            , dateOfBirth = Nothing
            , quoteId = Nothing
            , carrierContracts = []
            , currentDate = Nothing
            , effectiveDate = Nothing
            , discountCsvString = Nothing
            , orgId = Nothing
            , orgName = Nothing
            , orgLogo = Nothing
            , orgPhone = Nothing
            , useOrg = False
            , orgSignatureText = Nothing
            , name = Nothing
            , contact = Nothing
            , agent = Nothing
            , orgSlug = Nothing
            , loadingContact = True
            , showDiscountInfo = False
            , showLocationModal = False
            , editingZipCode = Nothing
            , editingCounty = Nothing
            , availableCounties = []
            , locationUpdateError = Nothing
            , submittingLocation = False
            , editingEffectiveDate = Nothing
            , fetchNewPlans = False
            , activeTooltipPlan = Nothing
            , forceOrgSenderDetails = False
            }
    in
    ( emptyModel
    , Cmd.batch
        [ Task.perform GotCurrentDate Date.today
        , fetchDiscountCsvString
        , fetchPlans
        ]
    )



-- HTTP


fetchPlans : Cmd Msg
fetchPlans =
    Http.get
        { url = "/api/stage-demo/plans" -- Updated endpoint
        , expect = Http.expectJson FetchedPlans (D.list quoteResponseDecoder)
        }


fetchDiscountCsvString : Cmd Msg
fetchDiscountCsvString =
    Http.get
        { url = "/api/data/public/hhd.csv"
        , expect = Http.expectString GotDiscountCsvString
        }


getEffectiveDate : Date -> String
getEffectiveDate date =
    date
        |> Date.add Date.Months 1
        |> Date.floor Date.Month
        |> Date.toIsoString



-- DECODERS


type alias QuoteResponse =
    { naic : String
    , group : Int
    , companyName : String
    , quotes : List QuoteData
    }


type alias QuoteData =
    { rate : Float
    , discountRate : Float
    , discountCategory : Maybe String
    , age : Int
    , gender : String
    , plan : String
    , tobacco : Int
    , originalPlanName : Maybe String
    }


quoteDataDecoder : Decoder QuoteData
quoteDataDecoder =
    D.succeed QuoteData
        |> Pipeline.required "rate" D.float
        |> Pipeline.required "discount_rate" D.float
        |> Pipeline.required "discount_category" (D.nullable D.string)
        |> Pipeline.required "age" D.int
        |> Pipeline.required "gender" D.string
        |> Pipeline.required "plan" D.string
        |> Pipeline.required "tobacco" D.int
        |> Pipeline.optional "original_plan_name" (D.nullable D.string) Nothing


quoteResponseDecoder : Decoder QuoteResponse
quoteResponseDecoder =
    D.succeed QuoteResponse
        |> Pipeline.required "naic" D.string
        |> Pipeline.required "group" D.int
        |> Pipeline.required "companyName" D.string
        |> Pipeline.required "quotes" (D.list quoteDataDecoder)


blacklistCarriers : List Carrier
blacklistCarriers =
    [ Allstate ]


isCarrierSupported : String -> List Carrier -> Bool
isCarrierSupported naic carrierContracts =
    case naicToCarrier naic of
        Just carrierName ->
            List.member carrierName carrierContracts
                && not (List.member carrierName blacklistCarriers)

        Nothing ->
            False


filterPlansByCarrier : Plans -> List Carrier -> Plans
filterPlansByCarrier plans carrierContracts =
    { planG = List.filter (\plan -> isCarrierSupported plan.naic carrierContracts) plans.planG |> List.Extra.unique
    , planN = List.filter (\plan -> isCarrierSupported plan.naic carrierContracts) plans.planN |> List.Extra.unique
    }


groupQuotesByPlan : List QuoteResponse -> Model -> Plans
groupQuotesByPlan responses model =
    let
        convertToPlan : QuoteResponse -> QuoteData -> Plan
        convertToPlan response quote =
            let
                carrierImagePath =
                    case naicToCarrier response.naic of
                        Just carrier ->
                            "/images/" ++ (carrier |> carrierToString |> String.filter (\c -> c /= ' ')) ++ ".svg"

                        Nothing ->
                            -- Fallback to png if we can't match the carrier
                            "/images/medicare-max-logo.png"
            in
            { price = quote.rate / 100
            , priceDiscount = quote.discountRate / 100
            , flag = quote.discountCategory
            , age = quote.age
            , description = ""
            , gender = quote.gender
            , id = 0
            , image = carrierImagePath
            , naic = response.naic
            , name = response.companyName
            , planType = quote.plan
            , premiumStability = ""
            , ratingCategory = ""
            , score = 0
            , select = False
            , state = Maybe.withDefault "" model.state
            , tobacco = quote.tobacco == 1
            , coverageSummary =
                if String.toUpper quote.plan == "G" then
                    planGCoverageList

                else
                    planNCoverageList
            , discountDescription = Nothing
            , originalPlanName = quote.originalPlanName
            }

        allQuotes =
            List.concatMap
                (\response ->
                    List.concatMap
                        (\quote ->
                            let
                                upperPlan =
                                    String.toUpper quote.plan
                            in
                            if List.member upperPlan [ "G", "N" ] then
                                [ convertToPlan response quote ]

                            else
                                []
                        )
                        response.quotes
                )
                responses

        groupedPlanG =
            List.filter (\q -> String.toUpper q.planType == "G") allQuotes
                |> List.sortBy .price

        groupedPlanN =
            List.filter (\q -> String.toUpper q.planType == "N") allQuotes
                |> List.sortBy .price

        result =
            { planG = groupedPlanG
            , planN = groupedPlanN
            }
    in
    result



-- COVERAGE LISTS


planGCoverageList : CoverageList
planGCoverageList =
    [ { name = "Part A Deductible", percentageCovered = 100, note = Nothing }
    , { name = "Hospital Co-Pays", percentageCovered = 100, note = Nothing }
    , { name = "Skilled Nursing Facility Co-Pays", percentageCovered = 100, note = Nothing }
    , { name = "Part B Annual Deductible", percentageCovered = 0, note = Just "$240 annual deductible" }
    , { name = "Part B Coinsurance", percentageCovered = 100, note = Nothing }
    , { name = "Excess Charges", percentageCovered = 100, note = Nothing }
    , { name = "Foreign Travel Emergency", percentageCovered = 80, note = Nothing }
    ]


planNCoverageList : CoverageList
planNCoverageList =
    [ { name = "Part A Deductible", percentageCovered = 100, note = Nothing }
    , { name = "Hospital Co-Pays", percentageCovered = 100, note = Nothing }
    , { name = "Skilled Nursing Facility Co-Pays", percentageCovered = 100, note = Nothing }
    , { name = "Part B Annual Deductible", percentageCovered = 0, note = Just "$240 annual deductible" }
    , { name = "Part B Coinsurance", percentageCovered = 100, note = Just "w/ some copayments" }
    , { name = "Excess Charges", percentageCovered = 0, note = Nothing }
    , { name = "Foreign Travel Emergency", percentageCovered = 80, note = Nothing }
    ]



-- UPDATE


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GotDiscountCsvString (Ok discountCsvString) ->
            ( { model
                | discountCsvString = Just discountCsvString
              }
            , Cmd.none
            )

        GotDiscountCsvString (Err _) ->
            ( { model | error = Just "Failed to load discount CSV", isLoading = False }
            , Cmd.none
            )

        FetchedPlans (Ok responses) ->
            let
                newPlans =
                    groupQuotesByPlan responses model
            in
            ( { model
                | plans = newPlans
                , isLoading = False
              }
            , Cmd.none
            )

        FetchedPlans (Err httpError) ->
            ( { model
                | error = Just ("Failed to fetch plans: " ++ httpErrorToString httpError)
                , isLoading = False
              }
            , Cmd.none
            )

        ToggleDiscount ->
            ( { model | showDiscount = not model.showDiscount }
            , Cmd.none
            )

        ToggleDiscountInfo ->
            ( { model | showDiscountInfo = not model.showDiscountInfo }
            , Cmd.none
            )

        TogglePlanType ->
            ( { model
                | selectedPlanType = togglePlanType model.selectedPlanType
                , currentCardIndex = 0
                , selectedPlan = Nothing
              }
            , Cmd.none
            )

        SelectPlan plan ->
            ( { model | showQualificationVideo = True }
            , Cmd.batch
                [ Nav.pushUrl model.key
                    (case model.quoteId of
                        Just id ->
                            let
                                orgIdParam =
                                    case model.orgId of
                                        Just orgId ->
                                            "&orgId=" ++ orgId

                                        Nothing ->
                                            -- Try to extract orgId from the quoteId as a fallback
                                            case String.split "-" id |> List.head of
                                                Just extractedOrgId ->
                                                    "&orgId=" ++ extractedOrgId

                                                Nothing ->
                                                    ""
                            in
                            "/eligibility?id=" ++ id ++ orgIdParam

                        Nothing ->
                            let
                                orgIdParam =
                                    case model.orgId of
                                        Just orgId ->
                                            "?orgId=" ++ orgId

                                        Nothing ->
                                            ""
                            in
                            "/eligibility" ++ orgIdParam
                    )
                , Task.perform (\_ -> NoOp) (Dom.setViewport 0 0)
                ]
            )

        SelectPlanCard plan ->
            ( { model
                | selectedPlan =
                    if Just plan == model.selectedPlan then
                        Nothing
                        -- Deselect if clicking the same plan again

                    else
                        Just plan

                -- Otherwise select the new plan
              }
            , Cmd.none
            )

        ScrollDown viewport ->
            ( model, Cmd.none )

        OpenGvsNVideo ->
            ( { model | showGvsNVideo = True }, Cmd.none )

        CloseGvsNVideo ->
            ( { model | showGvsNVideo = False }, Cmd.none )

        ShowFAQ ->
            ( { model | showFAQ = True }
            , Cmd.none
            )

        CloseFAQ ->
            ( { model | showFAQ = False }
            , Cmd.none
            )

        NextCard ->
            ( { model | currentCardIndex = Basics.min (model.currentCardIndex + 1) (List.length (getSelectedPlans model) - 1) }
            , Cmd.none
            )

        PreviousCard ->
            ( { model | currentCardIndex = Basics.max (model.currentCardIndex - 1) 0 }
            , Cmd.none
            )

        CloseRatesVideo ->
            ( { model | showRatesVideo = False }, Cmd.none )

        NavigateTo path ->
            ( model, Nav.pushUrl model.key path )

        GotCurrentDate date ->
            let
                effectiveDate =
                    date
                        |> Date.add Date.Months 1
                        |> Date.floor Date.Month
            in
            ( { model
                | currentDate = Just date
                , effectiveDate = Just effectiveDate
              }
            , Cmd.none
            )

        ToggleMobileTooltip plan ->
            ( { model | activeTooltipPlan = plan }
            , Cmd.none
            )

        NavigateToHealth ->
            ( model, Nav.pushUrl model.key ("/stage-demo/health/" ++ model.tempId) )

        NoOp ->
            ( model, Cmd.none )



-- HELPERS


togglePlanType : PlanType -> PlanType
togglePlanType planType =
    case planType of
        PlanG ->
            PlanN

        PlanN ->
            PlanG


getSelectedPlans : Model -> List Plan
getSelectedPlans model =
    let
        plans =
            case model.selectedPlan of
                Just plan ->
                    [ plan ]

                Nothing ->
                    case model.selectedPlanType of
                        PlanG ->
                            model.plans.planG

                        PlanN ->
                            model.plans.planN

        carrierNaics =
            model.currentCarrier
                |> Maybe.andThen stringToCarrier
                |> Maybe.map carrierToNaics

        filteredPlans =
            case carrierNaics of
                Just naicList ->
                    List.filter
                        (\plan ->
                            not (List.member plan.naic naicList)
                        )
                        plans

                Nothing ->
                    plans

        sortedAndLimited =
            List.sortBy .price filteredPlans
                |> List.take 3
    in
    sortedAndLimited



-- Get the top N cheapest plans for a specific plan type


getTopPlans : Model -> List Plan -> Int -> List Plan
getTopPlans model plans count =
    let
        carrierNaics =
            model.currentCarrier
                |> Maybe.andThen stringToCarrier
                |> Maybe.map carrierToNaics

        filteredPlans =
            case carrierNaics of
                Just naicList ->
                    List.filter
                        (\plan ->
                            not (List.member plan.naic naicList)
                        )
                        plans

                Nothing ->
                    plans
    in
    List.sortBy
        (\plan ->
            {--
            if model.showDiscount then
                plan.priceDiscount

            else
            --}
            plan.price
        )
        filteredPlans
        |> List.take count


httpErrorToString : Http.Error -> String
httpErrorToString error =
    case error of
        Http.BadUrl url ->
            "Bad URL: " ++ url ++ ". Please check the URL and try again."

        Http.Timeout ->
            "Request timed out. The server took too long to respond. Please try again later or check your internet connection."

        Http.NetworkError ->
            "Network error. Unable to connect to the server. Please check your internet connection and try again."

        Http.BadStatus statusCode ->
            "Bad status: " ++ String.fromInt statusCode ++ ". The server returned an unexpected status code. Please try again later or contact support if the issue persists."

        Http.BadBody message ->
            "Bad body: " ++ message ++ ". The server response was not in the expected format. Please try again or contact support if the issue persists."



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        closeModalOnEscape : String -> Msg
        closeModalOnEscape key =
            if key == "Escape" then
                case model of
                    _ ->
                        if model.showGvsNVideo then
                            CloseGvsNVideo

                        else if model.showRatesVideo then
                            CloseRatesVideo

                        else if model.showFAQ then
                            CloseFAQ

                        else
                            NoOp

            else
                NoOp

        shouldListenForEscape =
            model.showLocationModal
                || model.showGvsNVideo
                || model.showQualificationVideo
                || model.showRatesVideo
                || model.showFAQ
    in
    if shouldListenForEscape then
        Browser.Events.onKeyDown
            (D.map closeModalOnEscape (D.field "key" D.string))

    else
        Sub.none



-- VIEW


viewPersonalInfo : Model -> Html Msg
viewPersonalInfo model =
    div [ class "flex flex-col gap-4 sm:gap-10" ]
        [ div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)]" ]
            [ -- Personal Quote Header
              div [ class "border-b border-[#DCE2E5] bg-[#F9F5FF] px-4 sm:px-6 py-4 rounded-t-[10px]" ]
                [ h2 [ class "text-2xl font-extrabold -tracking-[0.04em] text-[#101828] leading-[1.2]" ] [ text "Personal Quote" ]
                ]
            , div
                [ class "p-4 sm:p-6 flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4 sm:gap-6 bg-white rounded-b-[10px]" ]
                [ div [ class "flex flex-col sm:flex-row gap-4 sm:gap-12" ]
                    [ -- Quote For section
                      div [ class "flex flex-col" ]
                        [ div [ class "mb-2" ]
                            [ p [ class "text-sm text-[#667085] mb-1" ] [ text "Quote For" ]
                            , p [ class "text-[16px] font-medium" ] [ text (Maybe.withDefault "Loading..." model.name) ]
                            , p [ class "text-[12px] text-[#667085]" ]
                                [ text
                                    (if String.contains "F" (model.gender |> Maybe.withDefault "" |> String.toUpper) then
                                        "F"

                                     else
                                        "M"
                                    )
                                , span [ class "text-[#475569] mx-2 font-medium" ] [ text "│" ]
                                , text
                                    (if Maybe.withDefault False model.tobacco then
                                        "Tobacco"

                                     else
                                        "Non-Tobacco"
                                    )
                                , span [ class "text-[#475569] mx-2 font-medium" ] [ text "│" ]
                                , text (String.fromInt (Maybe.withDefault 0 model.age))
                                , text " years"
                                , span [ class "text-[#475569] mx-2 font-medium" ] [ text "│" ]
                                , text (Maybe.withDefault "" model.state)
                                , text " "
                                , text (Maybe.withDefault "" model.zip)
                                ]
                            ]
                        , div [ class "flex flex-col gap-2" ]
                            [ div [ class "flex gap-2" ]
                                [ case model.effectiveDate of
                                    Just date ->
                                        p [ class "text-xs text-[#667085]" ]
                                            [ span [ class "font-medium" ] [ text "Effective Date: " ]
                                            , text (date |> Date.toIsoString |> formatEffectiveDate)
                                            ]

                                    Nothing ->
                                        text ""
                                , button [ class "text-xs text-[#2563EB] underline text-left" ] [ text "Change" ]
                                ]
                            , div [ class "hidden sm:block" ]
                                [ div [ class "flex flex-col mt-4 gap-1" ]
                                    [ p [ class "text-xs text-[#667085]" ] [ text "Need a Quote for Someone else?" ]
                                    , a [ href ("/self-onboarding/" ++ Maybe.withDefault "" model.orgSlug), class "text-xs text-[#667085] underline" ] [ text "Start Here" ]
                                    ]
                                ]
                            ]
                        ]

                    -- Mobile divider
                    , div [ class "block sm:hidden h-[1px] bg-[#DCE2E5] my-4" ] []

                    -- Desktop divider
                    , div [ class "hidden sm:block w-[1px] bg-[#DCE2E5]" ] []

                    -- Quote From section
                    , div [ class "flex flex-col min-w-[200px]" ]
                        [ p [ class "text-sm text-[#667085] mb-1" ] [ text "Quote From" ]
                        , let
                            -- Determine whether to use org or agent details
                            effectiveUseOrg =
                                if model.forceOrgSenderDetails then
                                    True

                                else
                                    case model.agent of
                                        Just agent ->
                                            agent.useOrgSenderDetails

                                        Nothing ->
                                            model.useOrg

                            -- fallback to old logic
                          in
                          if effectiveUseOrg then
                            -- Organization information
                            div []
                                [ case model.orgSignatureText of
                                    Just signature ->
                                        div [ class "mb-2" ]
                                            [ text signature ]

                                    Nothing ->
                                        p [ class "text-[16px] font-medium mb-2" ]
                                            [ text (Maybe.withDefault "Organization" model.orgName) ]
                                , case model.orgPhone of
                                    Just phone ->
                                        div [ class "flex flex-col gap-3" ]
                                            [ a
                                                [ href ("tel:" ++ String.filter (\c -> c >= '0' && c <= '9') phone)
                                                , class "flex items-center gap-1.5 bg-[#F9F5FF] px-2.5 py-2 rounded hover:bg-[#F4EBFF] transition-colors min-w-[200px] w-fit"
                                                ]
                                                [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 12 12", Svg.Attributes.fill "none" ]
                                                    [ path
                                                        [ Svg.Attributes.fillRule "evenodd"
                                                        , Svg.Attributes.clipRule "evenodd"
                                                        , Svg.Attributes.d "M1.75442 1.13022C2.80442 0.0802194 4.57692 0.160219 5.30817 1.47022L5.7138 2.19709C6.19067 3.05209 5.98755 4.13147 5.2888 4.83897C5.24752 4.90156 5.22497 4.97463 5.2238 5.04959C5.21567 5.20959 5.27255 5.58022 5.84692 6.15397C6.42067 6.72772 6.79067 6.78522 6.9513 6.77709C7.02626 6.77592 7.09934 6.75337 7.16192 6.71209C7.8688 6.01334 8.9488 5.81022 9.8038 6.28709L10.5307 6.69334C11.8407 7.42459 11.9207 9.19584 10.8707 10.2465C10.3088 10.8077 9.56255 11.3071 8.68442 11.3402C7.38442 11.3896 5.22442 11.0533 3.08567 8.91522C0.947548 6.77647 0.611298 4.61709 0.660673 3.31647C0.693798 2.43834 1.19317 1.69147 1.75442 1.13022ZM4.48942 1.92709C4.11442 1.25584 3.10817 1.10209 2.41755 1.79334C1.93317 2.27772 1.61755 2.81209 1.59755 3.35147C1.5563 4.43647 1.82442 6.32772 3.7488 8.25147C5.6738 10.1765 7.56442 10.4446 8.6488 10.4033C9.18817 10.3827 9.7238 10.0677 10.2075 9.58334C10.8988 8.89209 10.745 7.88584 10.0738 7.51147L9.34692 7.10584C8.89505 6.85397 8.25942 6.93959 7.8138 7.38584C7.77005 7.42959 7.4913 7.68959 6.99692 7.71334C6.49067 7.73834 5.87755 7.51084 5.18442 6.81709C4.49005 6.12334 4.26255 5.51022 4.28755 5.00334C4.3113 4.50897 4.57192 4.23022 4.61505 4.18647C5.0613 3.74084 5.14692 3.10584 4.89505 2.65397L4.48942 1.92709Z"
                                                        , Svg.Attributes.fill "#03045E"
                                                        ]
                                                        []
                                                    ]
                                                , span [ class "text-sm text-[#03045E]" ]
                                                    [ text (formatPhoneNumber phone) ]
                                                ]
                                            ]

                                    Nothing ->
                                        text ""
                                ]

                          else
                            -- Agent information
                            div []
                                [ p [ class "text-[16px] font-medium mb-2" ]
                                    [ text
                                        (case model.agent of
                                            Just agent ->
                                                agent.firstName ++ " " ++ agent.lastName

                                            Nothing ->
                                                "Loading..."
                                        )
                                    ]
                                , div [ class "flex flex-col gap-3" ]
                                    [ a
                                        [ href
                                            (case model.agent of
                                                Just agent ->
                                                    "mailto:" ++ agent.email

                                                Nothing ->
                                                    "#"
                                            )
                                        , class "flex items-center gap-1.5 bg-[#F9F5FF] px-2.5 py-2 rounded hover:bg-[#F4EBFF] transition-colors min-w-[200px] w-fit"
                                        ]
                                        [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 12 12", Svg.Attributes.fill "none" ]
                                            [ path [ Svg.Attributes.d "M1 6C1 4.1145 1 3.1715 1.586 2.586C2.1715 2 3.1145 2 5 2H7C8.8855 2 9.8285 2 10.414 2.586C11 3.1715 11 4.1145 11 6C11 7.8855 11 8.8285 10.414 9.414C9.8285 10 8.8855 10 7 10H5C3.1145 10 2.1715 10 1.586 9.414C1 8.8285 1 7.8855 1 6Z", Svg.Attributes.stroke "#03045E" ] []
                                            , path [ Svg.Attributes.d "M3 4L4.0795 4.9C4.998 5.665 5.457 6.0475 6 6.0475C6.543 6.0475 7.0025 5.665 7.9205 4.8995L9 4", Svg.Attributes.stroke "#03045E", Svg.Attributes.strokeLinecap "round", Svg.Attributes.strokeLinejoin "round" ] []
                                            ]
                                        , span [ class "text-sm text-[#03045E]" ]
                                            [ text
                                                (case model.agent of
                                                    Just agent ->
                                                        agent.email

                                                    Nothing ->
                                                        "Loading..."
                                                )
                                            ]
                                        ]
                                    , a
                                        [ href
                                            (case model.agent of
                                                Just agent ->
                                                    "tel:" ++ String.filter (\c -> c >= '0' && c <= '9') agent.phone

                                                Nothing ->
                                                    "#"
                                            )
                                        , class "flex items-center gap-1.5 bg-[#F9F5FF] px-2.5 py-2 rounded hover:bg-[#F4EBFF] transition-colors min-w-[200px] w-fit"
                                        ]
                                        [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 12 12", Svg.Attributes.fill "none" ]
                                            [ path
                                                [ Svg.Attributes.fillRule "evenodd"
                                                , Svg.Attributes.clipRule "evenodd"
                                                , Svg.Attributes.d "M1.75442 1.13022C2.80442 0.0802194 4.57692 0.160219 5.30817 1.47022L5.7138 2.19709C6.19067 3.05209 5.98755 4.13147 5.2888 4.83897C5.24752 4.90156 5.22497 4.97463 5.2238 5.04959C5.21567 5.20959 5.27255 5.58022 5.84692 6.15397C6.42067 6.72772 6.79067 6.78522 6.9513 6.77709C7.02626 6.77592 7.09934 6.75337 7.16192 6.71209C7.8688 6.01334 8.9488 5.81022 9.8038 6.28709L10.5307 6.69334C11.8407 7.42459 11.9207 9.19584 10.8707 10.2465C10.3088 10.8077 9.56255 11.3071 8.68442 11.3402C7.38442 11.3896 5.22442 11.0533 3.08567 8.91522C0.947548 6.77647 0.611298 4.61709 0.660673 3.31647C0.693798 2.43834 1.19317 1.69147 1.75442 1.13022ZM4.48942 1.92709C4.11442 1.25584 3.10817 1.10209 2.41755 1.79334C1.93317 2.27772 1.61755 2.81209 1.59755 3.35147C1.5563 4.43647 1.82442 6.32772 3.7488 8.25147C5.6738 10.1765 7.56442 10.4446 8.6488 10.4033C9.18817 10.3827 9.7238 10.0677 10.2075 9.58334C10.8988 8.89209 10.745 7.88584 10.0738 7.51147L9.34692 7.10584C8.89505 6.85397 8.25942 6.93959 7.8138 7.38584C7.77005 7.42959 7.4913 7.68959 6.99692 7.71334C6.49067 7.73834 5.87755 7.51084 5.18442 6.81709C4.49005 6.12334 4.26255 5.51022 4.28755 5.00334C4.3113 4.50897 4.57192 4.23022 4.61505 4.18647C5.0613 3.74084 5.14692 3.10584 4.89505 2.65397L4.48942 1.92709Z"
                                                , Svg.Attributes.fill "#03045E"
                                                ]
                                                []
                                            ]
                                        , span [ class "text-sm text-[#03045E]" ]
                                            [ text
                                                (case model.agent of
                                                    Just agent ->
                                                        formatPhoneNumber agent.phone

                                                    Nothing ->
                                                        "Loading..."
                                                )
                                            ]
                                        ]
                                    ]
                                ]
                        ]

                    -- Desktop divider before video
                    , div [ class "hidden sm:block w-[1px] bg-[#DCE2E5]" ] []

                    -- Video button section
                    , div [ class "hidden sm:flex flex-col justify-center items-center cursor-pointer gap-2 bg-[#F9F5FF] rounded-[10px] p-4 border border-[#DCE2E5] min-w-[200px] min-h-[160px]", onClick OpenGvsNVideo ]
                        [ p [ class "text-base font-bold text-[#03045E] -tracking-[0.03em] leading-[1.21] text-center" ] [ text "Learn About Plan G vs Plan N" ]
                        , div [ class "w-[33px] h-[33px] rounded-full border border-[#03045E] flex items-center justify-center" ]
                            [ div [ class "w-0 h-0 border-t-[8px] border-t-transparent border-l-[12px] border-l-[#03045E] border-b-[8px] border-b-transparent ml-1" ] []
                            ]
                        , p [ class "text-xs text-[#667085] -tracking-[0.03em] leading-[1.21] text-center" ] [ text "Watch the Video" ]
                        ]
                    ]
                ]
            , div [ class "block sm:hidden mt-2 mb-6 justify-center flex items-center w-full" ]
                [ div [ class "text-sm text-[#667085] text-center flex flex-wrap justify-center items-center gap-1" ]
                    [ text "Need a Quote for Someone else? "
                    , a [ href ("/self-onboarding/" ++ Maybe.withDefault "" model.orgSlug), class " underline" ] [ text "Start Here" ]
                    ]
                ]
            ]
        ]


viewPlanCard : Model -> String -> Plan -> Html Msg
viewPlanCard model planTypeCode plan =
    let
        isSelected =
            model.selectedPlan == Just plan

        displayPlanBadgeText =
            case plan.originalPlanName of
                Just originalName ->
                    formatOriginalPlanName originalName

                Nothing ->
                    "PLAN " ++ planTypeCode

        ( badgeTextColor, badgeBgColor ) =
            if planTypeCode == "G" then
                ( "text-[#363F72]", "bg-[#F8F9FC]" )

            else
                ( "text-[#363F72]", "bg-[#F8F9FC]" )

        borderClass =
            if isSelected then
                "border-2 border-[#2563EB]"

            else
                "border border-[#D4D4D4]"

        isTooltipActive =
            case model.activeTooltipPlan of
                Just activePlan ->
                    activePlan.id == plan.id

                Nothing ->
                    False
    in
    div [ class "flex flex-col" ]
        [ div
            [ class ("relative bg-white rounded-lg " ++ borderClass ++ " overflow-hidden cursor-pointer w-[calc(100vw-72px)] sm:w-[340px]")
            , onClick (SelectPlanCard plan)
            ]
            [ -- Top row with Plan type badge and radio
              div [ class "flex items-center justify-between p-2 sm:p-4" ]
                [ div [ class ("px-2.5 py-0.5 rounded-lg text-xs font-medium leading-5 " ++ badgeTextColor ++ " " ++ badgeBgColor) ]
                    [ text displayPlanBadgeText ]
                , div [ class "flex items-center gap-1.5" ]
                    [ span [ class "text-sm sm:text-sm font-medium text-[#667085]" ] [ text "Select This Plan" ]
                    , if isSelected then
                        svg [ Svg.Attributes.width "18", Svg.Attributes.height "19", Svg.Attributes.viewBox "0 0 14 15", Svg.Attributes.fill "none" ]
                            [ Svg.rect [ Svg.Attributes.x "0.5", Svg.Attributes.y "1", Svg.Attributes.width "13", Svg.Attributes.height "13", Svg.Attributes.rx "6.5", Svg.Attributes.fill "#F9F5FF" ] []
                            , Svg.rect [ Svg.Attributes.x "0.5", Svg.Attributes.y "1", Svg.Attributes.width "13", Svg.Attributes.height "13", Svg.Attributes.rx "6.5", Svg.Attributes.stroke "#7F56D9" ] []
                            , Svg.path [ Svg.Attributes.d "M10.5 5.25L6 9.75L3.5 7.25", Svg.Attributes.stroke "#7F56D9", Svg.Attributes.strokeWidth "1.6666", Svg.Attributes.strokeLinecap "round", Svg.Attributes.strokeLinejoin "round" ] []
                            ]

                      else
                        svg [ Svg.Attributes.width "18", Svg.Attributes.height "19", Svg.Attributes.viewBox "0 0 14 15", Svg.Attributes.fill "none" ]
                            [ Svg.rect [ Svg.Attributes.x "0.5", Svg.Attributes.y "1", Svg.Attributes.width "13", Svg.Attributes.height "13", Svg.Attributes.rx "6.5", Svg.Attributes.fill "white" ] []
                            , Svg.rect [ Svg.Attributes.x "0.5", Svg.Attributes.y "1", Svg.Attributes.width "13", Svg.Attributes.height "13", Svg.Attributes.rx "6.5", Svg.Attributes.stroke "#D4D4D4" ] []
                            ]
                    ]
                ]

            -- Carrier Logo
            , div [ class "px-4 flex justify-center items-center min-h-[120px] py-4" ]
                [ img [ src plan.image, alt (plan.name ++ " logo"), class "h-20 max-w-[240px] object-contain" ] [] ]

            -- Rates
            , div [ class "flex justify-between items-center px-6 py-4 bg-[#F9FAFB]" ]
                [ div [ class "flex items-center" ]
                    [ span [ class "text-sm font-medium text-[#667085]" ] [ text "Standard:" ]
                    , span [ class "text-lg font-bold text-[#667085] ml-1" ] [ text ("$" ++ String.fromInt (floor plan.price)) ]
                    ]
                , div [ class "flex items-center" ]
                    [ div [ class "w-[1px] h-[24px] bg-[#DCE2E5] mx-4" ] [] ]
                , div [ class "flex items-center relative group" ]
                    [ span [ class "text-sm font-medium text-[#667085]" ] [ text "Discount:" ]
                    , span [ class "text-lg font-bold text-[#667085] ml-1" ] [ text ("$" ++ String.fromInt (floor plan.priceDiscount)) ]
                    , case plan.discountDescription of
                        Just description ->
                            div [ class "inline-flex ml-1 relative" ]
                                [ -- Desktop hover tooltip (hidden on mobile)
                                  div [ class "hidden sm:inline-flex text-blue-500 cursor-help" ]
                                    [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 24 24", Svg.Attributes.fill "none" ]
                                        [ Svg.circle [ Svg.Attributes.cx "12", Svg.Attributes.cy "12", Svg.Attributes.r "10", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2" ] []
                                        , Svg.path [ Svg.Attributes.d "M12 8v4", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2", Svg.Attributes.strokeLinecap "round" ] []
                                        , Svg.path [ Svg.Attributes.d "M12 16h.01", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2", Svg.Attributes.strokeLinecap "round" ] []
                                        ]
                                    , div [ class "absolute bottom-full mb-2 right-0 w-48 p-2 bg-gray-800 text-white text-xs rounded shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200" ]
                                        [ text description
                                        , div [ class "absolute right-3 top-full -mt-1 border-4 border-transparent border-t-gray-800" ] []
                                        ]
                                    ]

                                -- Mobile tap tooltip icon (hidden on desktop)
                                , div
                                    [ class "sm:hidden inline-flex text-blue-500 cursor-pointer z-10"
                                    , Html.Events.stopPropagationOn "click"
                                        (D.succeed ( ToggleMobileTooltip (Just plan), True ))
                                    ]
                                    [ svg [ Svg.Attributes.width "16", Svg.Attributes.height "16", Svg.Attributes.viewBox "0 0 24 24", Svg.Attributes.fill "none" ]
                                        [ Svg.circle [ Svg.Attributes.cx "12", Svg.Attributes.cy "12", Svg.Attributes.r "10", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2" ] []
                                        , Svg.path [ Svg.Attributes.d "M12 8v4", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2", Svg.Attributes.strokeLinecap "round" ] []
                                        , Svg.path [ Svg.Attributes.d "M12 16h.01", Svg.Attributes.stroke "currentColor", Svg.Attributes.strokeWidth "2", Svg.Attributes.strokeLinecap "round" ] []
                                        ]
                                    ]
                                ]

                        Nothing ->
                            text ""
                    ]
                ]
            ]
        , div
            [ class
                ("overflow-hidden transition-all duration-300 ease-in-out "
                    ++ (if isSelected then
                            "max-h-[100px] opacity-100 mt-8 mb-8"

                        else
                            "max-h-0 opacity-0 mt-0 mb-0"
                       )
                )
            ]
            [ div [ class "flex justify-center" ]
                [ button
                    [ class "w-[200px] bg-[#03045E] text-white text-sm font-medium px-4 py-4 rounded-lg hover:bg-[#02034D] transition-colors"
                    , onClick (SelectPlan plan)
                    ]
                    [ text "See if I Qualify" ]
                ]
            ]
        ]


viewPlansSection : Model -> Html Msg
viewPlansSection model =
    let
        hasPlanG =
            not (List.isEmpty model.plans.planG)

        hasPlanN =
            not (List.isEmpty model.plans.planN)

        hasAnyPlans =
            hasPlanG || hasPlanN

        hasOriginalPlanNames =
            List.any (\p -> p.originalPlanName /= Nothing) model.plans.planG
                || List.any (\p -> p.originalPlanName /= Nothing) model.plans.planN

        stateSpecificNotice =
            if hasOriginalPlanNames then
                div [ class "bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4" ]
                    [ div [ class "flex items-start gap-3" ]
                        [ svg [ Svg.Attributes.width "20", Svg.Attributes.height "20", Svg.Attributes.viewBox "0 0 20 20", Svg.Attributes.fill "none", Svg.Attributes.class "flex-shrink-0 mt-0.5" ]
                            [ path
                                [ Svg.Attributes.d "M10 0C4.477 0 0 4.477 0 10s4.477 10 10 10 10-4.477 10-10S15.523 0 10 0zm1 15H9v-2h2v2zm0-4H9V5h2v6z"
                                , Svg.Attributes.fill "#2563EB"
                                ]
                                []
                            ]
                        , div [ class "flex-1 space-y-2" ]
                            [ h4 [ class "text-sm font-semibold text-blue-900 mb-1" ]
                                [ text "State-Specific Plan Names" ]
                            , p [ class "text-sm text-blue-800" ]
                                [ text "Your state uses slightly different variations from standardized Medicare Supplement plans. The plans shown reflect these state-specific names and do include additional optional riders that may be available in your state. Premiums may vary accordingly."
                                ]
                            , p [ class "text-sm text-blue-800" ]
                                [ text "We would be happy to discuss these details further with you to help you find the best plan for your needs."
                                ]
                            ]
                        ]
                    ]

            else
                text ""

        planGHeader =
            case List.head model.plans.planG of
                Just firstPlanG ->
                    firstPlanG.originalPlanName
                        |> Maybe.map formatOriginalPlanName
                        |> Maybe.withDefault "Plan G"
                        |> (\name -> name ++ " Monthly Premiums")

                Nothing ->
                    "Plan G Monthly Premiums"

        planNHeader =
            case List.head model.plans.planN of
                Just firstPlanN ->
                    firstPlanN.originalPlanName
                        |> Maybe.map formatOriginalPlanName
                        |> Maybe.withDefault "Plan N"
                        |> (\name -> name ++ " Monthly Premiums")

                Nothing ->
                    "Plan N Monthly Premiums"
    in
    if not hasAnyPlans then
        -- No plans found, display a message with contact info and button
        div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)] mt-6 p-6 sm:p-8 text-center" ]
            [ div [ class "w-12 h-12 rounded-full bg-[#F9F5FF] flex items-center justify-center mx-auto mb-4" ]
                [ svg [ Svg.Attributes.width "26", Svg.Attributes.height "26", Svg.Attributes.viewBox "0 0 24 24", Svg.Attributes.fill "none" ]
                    [ path
                        [ Svg.Attributes.d "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"
                        , Svg.Attributes.stroke "#7F56D9"
                        , Svg.Attributes.strokeWidth "2"
                        , Svg.Attributes.strokeLinecap "round"
                        , Svg.Attributes.strokeLinejoin "round"
                        ]
                        []
                    , path
                        [ Svg.Attributes.d "M12 8V12"
                        , Svg.Attributes.stroke "#7F56D9"
                        , Svg.Attributes.strokeWidth "2"
                        , Svg.Attributes.strokeLinecap "round"
                        , Svg.Attributes.strokeLinejoin "round"
                        ]
                        []
                    , path
                        [ Svg.Attributes.d "M12 16H12.01"
                        , Svg.Attributes.stroke "#7F56D9"
                        , Svg.Attributes.strokeWidth "2"
                        , Svg.Attributes.strokeLinecap "round"
                        , Svg.Attributes.strokeLinejoin "round"
                        ]
                        []
                    ]
                ]
            , h3 [ class "text-lg sm:text-xl font-bold text-[#101828] -tracking-[0.02em] mb-2" ]
                [ text "We couldn't find plans for your specific criteria." ]
            , p [ class "text-sm sm:text-base text-[#667085] mb-4" ]
                [ text "Please give us a call at ", span [ class "font-semibold" ] [ text (getPhoneNumberForDisplay model |> formatPhoneNumber) ], text ". We're happy to help you find the best plan for your needs." ]
            , a
                [ href (getScheduleLink model)
                , class "whitespace-nowrap bg-[#03045E] text-white px-5 sm:px-4 py-3 sm:py-2 rounded-lg hover:bg-[#02034D] transition-colors text-sm sm:text-base w-full sm:w-auto text-center max-w-xs mx-auto block font-semibold"
                ]
                [ text "Connect With Us" ]
            ]

    else
        div [ class "flex flex-col gap-4 sm:gap-0" ]
            [ -- State-specific notice
              stateSpecificNotice

            -- Plan G Section - Desktop and Mobile
            , if hasPlanG then
                div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)]" ]
                    [ -- Header (desktop only)
                      div [ class "hidden sm:flex px-4 sm:px-6 py-4 flex-row items-center justify-between border-b border-[#DCE2E5] bg-[#F9F5FF] rounded-t-[10px]" ]
                        [ div [ class "flex items-end gap-3" ]
                            [ h2 [ class "text-2xl font-extrabold -tracking-[0.04em] text-[#101828] leading-[1.2]" ] [ text "Recommended Plans for You" ]
                            , p [ class "text-[16px] font-medium text-[#667085] -tracking-[0.04em] leading-[1.2] pb-[2px]" ] [ text "Select one to see if you qualify" ]
                            ]
                        ]

                    -- Mobile header
                    , div [ class "block sm:hidden px-4 py-4 border-b border-[#DCE2E5] bg-[#F9F5FF] rounded-t-[10px]" ]
                        [ h2 [ class "text-2xl font-extrabold -tracking-[0.04em] text-[#101828] leading-[1.2]" ] [ text "Recommended Plans" ]
                        , p [ class "text-[16px] font-medium text-[#667085] -tracking-[0.04em] leading-[1.2]" ] [ text "Select one to continue" ]
                        ]

                    -- Plan G Section
                    , div [ class "px-3 sm:px-4 py-6 bg-white" ]
                        [ h3 [ class "text-xl font-extrabold -tracking-[0.02em] mb-6 text-[#101828]" ] [ text planGHeader ]
                        , div [ class "flex flex-wrap gap-8 justify-center sm:justify-start sm:pl-8" ]
                            (List.map (viewPlanCard model "G") (getTopPlans model model.plans.planG 3))
                        ]
                    ]

              else
                text ""

            -- Mobile video button (standalone between Plan G and Plan N)
            -- Only show if both G and N plans are available
            , if hasPlanG && hasPlanN then
                div [ class "block sm:hidden py-4 px-3" ]
                    [ div [ class "mx-auto max-w-[280px] bg-[#F9F5FF] rounded-[10px] p-4 flex flex-row items-center cursor-pointer gap-4", onClick OpenGvsNVideo ]
                        [ div [ class "w-[33px] h-[33px] rounded-full border border-[#03045E] flex items-center justify-center flex-shrink-0" ]
                            [ div [ class "w-0 h-0 border-t-[8px] border-t-transparent border-l-[12px] border-l-[#03045E] border-b-[8px] border-b-transparent ml-1" ] []
                            ]
                        , div [ class "flex flex-col items-start" ]
                            [ p [ class "text-[16px] font-bold text-[#03045E] -tracking-[0.03em] leading-[1.21] text-left" ] [ text "Learn About Plan G vs N" ]
                            , p [ class "text-[12px] text-[#667085] -tracking-[0.03em] leading-[1.21]" ] [ text "Watch the Video" ]
                            ]
                        ]
                    ]

              else
                text ""

            -- Plan N Section (separate container for mobile)
            , if hasPlanN then
                div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)]" ]
                    [ -- Plan N Section Header (Mobile only)
                      div [ class "block sm:hidden px-4 py-4 border-b border-[#DCE2E5] bg-[#F9F5FF] rounded-t-[10px]" ]
                        [ h2 [ class "text-2xl font-extrabold -tracking-[0.04em] text-[#101828] leading-[1.2]" ] [ text "Plan N Options" ]
                        ]

                    -- Plan N Content
                    , div [ class "px-3 sm:px-4 py-6 bg-white" ]
                        [ h3 [ class "text-xl font-extrabold -tracking-[0.02em] mb-6 text-[#101828]" ] [ text planNHeader ]
                        , div [ class "flex flex-wrap gap-8 justify-center sm:justify-start sm:pl-8" ]
                            (List.map (viewPlanCard model "N") (getTopPlans model model.plans.planN 3))
                        ]
                    ]

              else
                text ""

            -- Medicare Advantage Off Ramp Section
            -- This will also be hidden if no plans were found initially by the top-level `if not hasAnyPlans`
            , viewMedicareAdvantageOffRamp model
            ]



-- Medicare Advantage Off Ramp component


viewMedicareAdvantageOffRamp : Model -> Html Msg
viewMedicareAdvantageOffRamp model =
    div [ class "bg-white rounded-[10px] border border-[#DCE2E5] shadow-[0_1px_2px_rgba(16,24,40,0.05)] mt-6" ]
        [ div [ class "px-4 sm:px-6 py-4 sm:py-5 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 sm:gap-0" ]
            [ div [ class "flex items-start gap-4" ]
                [ -- Icon for the section
                  div [ class "w-12 h-12 rounded-full bg-[#F9F5FF] flex items-center justify-center flex-shrink-0" ]
                    [ svg [ Svg.Attributes.width "26", Svg.Attributes.height "26", Svg.Attributes.viewBox "0 0 24 24", Svg.Attributes.fill "none" ]
                        [ path
                            [ Svg.Attributes.d "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"
                            , Svg.Attributes.stroke "#7F56D9"
                            , Svg.Attributes.strokeWidth "2"
                            , Svg.Attributes.strokeLinecap "round"
                            , Svg.Attributes.strokeLinejoin "round"
                            ]
                            []
                        , path
                            [ Svg.Attributes.d "M12 8V12"
                            , Svg.Attributes.stroke "#7F56D9"
                            , Svg.Attributes.strokeWidth "2"
                            , Svg.Attributes.strokeLinecap "round"
                            , Svg.Attributes.strokeLinejoin "round"
                            ]
                            []
                        , path
                            [ Svg.Attributes.d "M12 16H12.01"
                            , Svg.Attributes.stroke "#7F56D9"
                            , Svg.Attributes.strokeWidth "2"
                            , Svg.Attributes.strokeLinecap "round"
                            , Svg.Attributes.strokeLinejoin "round"
                            ]
                            []
                        ]
                    ]
                , div [ class "flex flex-col" ]
                    [ h3 [ class "text-lg sm:text-xl font-bold text-[#101828] -tracking-[0.02em]" ]
                        [ text "Looking to dramatically lower your monthly costs?" ]
                    , p [ class "text-sm sm:text-base text-[#667085]" ]
                        [ text "Medicare Advantage plans offer $0 monthly premiums with drug coverage included. These plans have improved a lot over recent years, with more benefits and flexibility than ever. If saving money is your priority, let's find the right plan for you." ]
                    ]
                ]
            , div [ class "sm:ml-4 flex justify-center sm:justify-start" ]
                [ a
                    [ href
                        (case model.quoteId of
                            Just id ->
                                let
                                    orgQ =
                                        String.split "-" id
                                            |> List.head
                                            |> Maybe.map
                                                (\org ->
                                                    "?org=" ++ org ++ "&"
                                                )
                                            |> Maybe.withDefault "?"
                                in
                                "/schedule" ++ orgQ ++ "id=" ++ id ++ "&status=decline"

                            Nothing ->
                                "/contact"
                        )
                    , class "whitespace-nowrap bg-[#03045E] text-white px-5 sm:px-4 py-3 sm:py-2 rounded-lg hover:bg-[#02034D] transition-colors text-sm sm:text-base w-full sm:w-auto text-center"
                    ]
                    [ text "Explore Options" ]
                ]
            ]
        ]


view : Model -> Browser.Document Msg
view model =
    { title = "Quote - Medicare Max"
    , body =
        [ viewHeader model.orgLogo model.orgName
        , div [ class "bg-white min-h-screen pb-12 scroll-smooth" ]
            [ if model.loadingContact || model.isLoading then
                viewLoading

              else
                div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3 space-y-8 sm:space-y-10" ]
                    [ -- Personal Quote Card
                      viewPersonalInfo model

                    -- Plans Section (mobile video button moved inside viewPlansSection)
                    , viewPlansSection model
                    ]
            ]
        , viewGvsNModal model
        , viewMobileTooltip model
        ]
    }


viewLoading : Html Msg
viewLoading =
    div [ class "fixed inset-0 bg-white flex flex-col items-center justify-center gap-4 text-center" ]
        [ div [ class "animate-spin rounded-full h-12 w-12 border-4 border-purple-600 border-t-transparent" ] []
        , p [ class "text-center text-lg font-medium text-gray-600" ]
            [ text "Loading your personalized quote..." ]
        , div
            [ class "sm:hidden opacity-0 transition-opacity duration-500 delay-[10000ms] mt-6 px-4 max-w-xs text-center text-sm text-gray-500"
            , style "animation" "fadeIn 0.5s 5s forwards"
            ]
            [ text "If page fails to load, please try refreshing or opening in your device's default browser." ]
        , Html.node "style"
            []
            [ text """
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
              """
            ]
        ]


viewError : String -> Maybe String -> Html Msg
viewError error orgSlug =
    div [ class "fixed inset-0 bg-white flex flex-col items-center justify-center gap-6 text-center px-4" ]
        [ div [ class "max-w-lg" ]
            [ h1 [ class "text-2xl font-semibold text-[#1A1A1A] mb-4" ]
                [ text "Unable to Load Quote" ]
            , p [ class "text-lg text-gray-600 mb-8" ]
                [ text "This quote link appears to be invalid or has expired. Please get a new quote to continue." ]
            , case orgSlug of
                Just slug ->
                    a
                        [ href ("/self-onboarding/" ++ slug)
                        , class "inline-block bg-[#03045E] text-white text-sm font-medium px-6 py-3 rounded hover:bg-[#02034D] transition-colors"
                        ]
                        [ text "Get a New Quote" ]

                Nothing ->
                    text ""
            ]
        ]


viewGvsNModal : Model -> Html Msg
viewGvsNModal model =
    if model.showGvsNVideo then
        div [ class "fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4 backdrop-blur-sm" ]
            [ div [ class "bg-white rounded-lg p-4 pt-8 sm:p-8 w-[95%] h-auto max-w-5xl mx-auto shadow-lg relative" ]
                [ button
                    [ class "absolute top-4 right-4 text-gray-500 hover:text-gray-700 text-xl p-1"
                    , onClick CloseGvsNVideo
                    ]
                    [ text "×" ]
                , h2 [ class "text-xl sm:text-2xl font-bold mb-1 sm:mb-2 text-center" ] [ text "Plan G vs. Plan N" ]
                , p [ class "mb-2 text-center text-sm sm:text-base" ] [ text "Watch this video to learn about the key differences between plans" ]
                , div [ class "w-full mx-auto my-auto h-[450px] sm:h-[500px] mt-2 sm:mt-4 sm:max-w-[90%]" ]
                    [ div [ class "w-full h-full" ]
                        [ iframe
                            -- [ src "https://player.vimeo.com/video/1075091871?autoplay=0&title=0&byline=0&portrait=0&responsive=1" -- education example
                            [ src "https://player.vimeo.com/video/1089216242?autoplay=0&title=0&byline=0&portrait=0&responsive=1"
                            , class "w-full h-full"
                            , attribute "frameborder" "0"
                            , attribute "allow" "autoplay; fullscreen; picture-in-picture"
                            , attribute "allowfullscreen" ""
                            ]
                            []
                        ]
                    ]
                ]
            ]

    else
        text ""


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    let
        cleanPhone =
            String.filter (\c -> c >= '0' && c <= '9') phone
    in
    String.slice 0 3 cleanPhone ++ "-" ++ String.slice 3 6 cleanPhone ++ "-" ++ String.slice 6 10 cleanPhone


contactResponseDecoder : Decoder ContactResponse
contactResponseDecoder =
    D.succeed ContactResponse
        |> Pipeline.optional "contact" (D.oneOf [ D.map Just contactDecoder, D.succeed Nothing ]) Nothing
        |> Pipeline.required "agent" agentDecoder
        |> Pipeline.required "orgSlug" D.string
        |> Pipeline.required "orgName" D.string
        |> Pipeline.required "orgLogo" (D.nullable D.string)
        |> Pipeline.optional "orgPhone" (D.nullable D.string) Nothing
        |> Pipeline.required "orgSignature" D.bool
        |> Pipeline.optional "orgSignatureText" (D.nullable D.string) Nothing
        |> Pipeline.required "carrierContracts" (D.list carrierDecoder)
        |> Pipeline.required "forceOrgSenderDetails" D.bool


contactDecoder : Decoder Contact
contactDecoder =
    D.succeed Contact
        |> Pipeline.required "id" D.int
        |> Pipeline.required "firstName" D.string
        |> Pipeline.required "lastName" D.string
        |> Pipeline.required "email" D.string
        |> Pipeline.required "phoneNumber" D.string
        |> Pipeline.required "age" D.int
        |> Pipeline.required "gender" D.string
        |> Pipeline.required "tobacco" D.bool
        |> Pipeline.required "state" D.string
        |> Pipeline.required "zipCode" D.string
        |> Pipeline.optional "county" (D.nullable D.string) Nothing
        |> Pipeline.optional "currentCarrier" (D.nullable D.string) Nothing
        |> Pipeline.optional "planType" (D.nullable D.string) Nothing


agentDecoder : Decoder Agent
agentDecoder =
    D.succeed Agent
        |> Pipeline.required "firstName" D.string
        |> Pipeline.required "lastName" D.string
        |> Pipeline.required "email" D.string
        |> Pipeline.required "phone" D.string
        |> Pipeline.optional "signature" D.string ""
        |> Pipeline.optional "useOrgSenderDetails" D.bool True
        |> Pipeline.optional "bookingLink" D.string ""


locationUpdateResponseDecoder : Decoder LocationUpdateResponse
locationUpdateResponseDecoder =
    D.map4 LocationUpdateResponse
        (D.field "success" D.bool)
        (D.field "zipCode" D.string)
        (D.field "state" D.string)
        (D.field "counties" (D.list D.string))



-- Helper function to format the date in a more readable way


formatEffectiveDate : String -> String
formatEffectiveDate isoDate =
    case Date.fromIsoString isoDate of
        Ok date ->
            Date.format "MMMM 1, yyyy" date

        Err _ ->
            isoDate



-- Helper function to get next N months of effective dates


getNextEffectiveDates : Date -> Int -> List String
getNextEffectiveDates currentDate count =
    List.range 0 (count - 1)
        |> List.map
            (\n ->
                currentDate
                    |> Date.add Date.Months n
                    |> Date.add Date.Months 1
                    |> Date.floor Date.Month
                    |> Date.toIsoString
            )



-- Mobile tooltip overlay


viewMobileTooltip : Model -> Html Msg
viewMobileTooltip model =
    case model.activeTooltipPlan of
        Just tooltipPlan ->
            case tooltipPlan.discountDescription of
                Just description ->
                    div
                        [ class "sm:hidden fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4"
                        , onClick (ToggleMobileTooltip Nothing)
                        ]
                        [ div
                            [ class "bg-white rounded-lg p-4 max-w-xs w-full shadow-lg text-sm relative"
                            , Html.Events.stopPropagationOn "click" (D.succeed ( NoOp, True ))
                            ]
                            [ button
                                [ class "absolute top-2 right-2 text-gray-500"
                                , onClick (ToggleMobileTooltip Nothing)
                                ]
                                [ text "×" ]
                            , div [ class "font-bold text-gray-800 text-base pb-2" ] [ text (tooltipPlan.name ++ " Discount") ]

                            --, div [ class "text-sm text-gray-700" ] [ text ("Plan " ++ tooltipPlan.planType ++ " Discount") ]
                            , div [ class "pt-3" ] [ text description ]
                            ]
                        ]

                Nothing ->
                    -- If no description, close the tooltip
                    div [ onClick (ToggleMobileTooltip Nothing) ] []

        Nothing ->
            -- No active tooltip
            text ""



-- Helper function to format state-specific plan names for display


formatOriginalPlanName : String -> String
formatOriginalPlanName originalName =
    case String.toUpper originalName of
        "MN_BASIC" ->
            "Minnesota Basic Plan"

        "MN_EXTB" ->
            "Minnesota Extended Basic Plan"

        "WI_BASE" ->
            "Wisconsin Basic Plan"

        "WI_HDED" ->
            "Wisconsin High Deductible Plan"

        "MA_CORE" ->
            "Massachusetts Core Plan"

        "MA_SUPP1" ->
            "Massachusetts Supplement 1 Plan"

        _ ->
            originalName



-- Helper to determine which phone number to display based on org/agent settings


getPhoneNumberForDisplay : Model -> String
getPhoneNumberForDisplay model =
    let
        effectiveUseOrg =
            if model.forceOrgSenderDetails then
                True

            else
                case model.agent of
                    Just agent ->
                        agent.useOrgSenderDetails

                    Nothing ->
                        model.useOrg
    in
    if effectiveUseOrg then
        Maybe.withDefault "" model.orgPhone

    else
        case model.agent of
            Just agent ->
                agent.phone

            Nothing ->
                ""



-- Helper to get the schedule/contact link


getScheduleLink : Model -> String
getScheduleLink model =
    case model.quoteId of
        Just id ->
            let
                orgQ =
                    String.split "-" id
                        |> List.head
                        |> Maybe.map
                            (\org ->
                                "?org=" ++ org ++ "&"
                            )
                        |> Maybe.withDefault "?"
            in
            "/schedule" ++ orgQ ++ "id=" ++ id ++ "&status=decline"

        -- Using "decline" status as per MA off-ramp button
        Nothing ->
            "/contact"

================
File: frontend/src/StageDemoQuote.elm.backup
================
module StageDemoQuote exposing (Model, Msg(..), init, update, view)

import Html exposing (..)
import Html.Attributes as Attr
import Html.Events exposing (onClick)
import StageDemoData exposing (Plan, standardQuoteG, standardQuoteN)
import Svg exposing (path, svg)
import Svg.Attributes as SA


type alias Model =
    { tempId : String
    , planG : Plan
    , planN : Plan
    }


type Msg
    = NavigateToHealth


init : String -> Model
init tempId =
    { tempId = tempId
    , planG = standardQuoteG
    , planN = standardQuoteN
    }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NavigateToHealth ->
            ( model, Cmd.none )



-- Navigation handled by Main.elm


formatPrice : Float -> String
formatPrice price =
    "$" ++ String.fromFloat (price / 100)


view : Model -> Html Msg
view model =
    div [ Attr.class "min-h-screen bg-white" ]
        [ -- Header
          div [ Attr.class "bg-white shadow-sm border-b" ]
            [ div [ Attr.class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6" ]
                [ -- Logo
                  div [ Attr.class "flex items-center justify-center mb-6" ]
                    [ img
                        [ Attr.src "/images/medicare-max-logo.png"
                        , Attr.alt "Medicare Max"
                        , Attr.class "h-10"
                        ]
                        []
                    ]
                , div [ Attr.class "text-center" ]
                    [ h1 [ Attr.class "text-2xl sm:text-3xl font-bold text-[#141B29]" ] [ text "Your Personalized Medicare Quote" ]
                    , p [ Attr.class "text-[#475467] mt-2" ] [ text "Prepared for: Valued Client" ]
                    , p [ Attr.class "text-sm text-[#475467] mt-1" ] [ text "Powered by Medicare Max • 888-888-8888" ]
                    ]
                ]
            ]

        -- AI Video Section
        , div [ Attr.class "bg-[#F9F5FF] py-12" ]
            [ div [ Attr.class "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8" ]
                [ h2 [ Attr.class "text-xl font-semibold text-[#141B29] mb-4 text-center" ] [ text "Watch Your Personalized Video" ]
                , div [ Attr.class "bg-white rounded-lg shadow-lg overflow-hidden" ]
                    [ -- Placeholder for AI video - in real implementation this would be an iframe
                      div [ Attr.class "aspect-w-16 aspect-h-9 bg-gray-200" ]
                        [ div [ Attr.class "flex items-center justify-center h-96" ]
                            [ div [ Attr.class "text-center" ]
                                [ svg [ SA.class "mx-auto h-12 w-12 text-gray-400", SA.fill "none", SA.stroke "currentColor", SA.viewBox "0 0 24 24" ]
                                    [ path [ SA.strokeLinecap "round", SA.strokeLinejoin "round", SA.strokeWidth "2", SA.d "M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" ] []
                                    , path [ SA.strokeLinecap "round", SA.strokeLinejoin "round", SA.strokeWidth "2", SA.d "M21 12a9 9 0 11-18 0 9 9 0 0118 0z" ] []
                                    ]
                                , p [ Attr.class "mt-2 text-gray-600" ] [ text "AI Video Player" ]
                                ]
                            ]
                        ]
                    ]
                ]
            ]

        -- Quote Cards
        , div [ Attr.class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12" ]
            [ h2 [ Attr.class "text-2xl sm:text-3xl font-bold text-[#141B29] mb-8 text-center" ] [ text "Your Best Medicare Supplement Options" ]
            , div [ Attr.class "grid md:grid-cols-2 gap-8" ]
                [ -- Plan G Card
                  planCard model.planG True
                , -- Plan N Card
                  planCard model.planN False
                ]
            ]

        -- CTA Section
        , div [ Attr.class "bg-[#F9FAFB] py-12" ]
            [ div [ Attr.class "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 text-center" ]
                [ h3 [ Attr.class "text-xl font-semibold text-[#141B29] mb-4" ] [ text "Ready to secure your Medicare coverage?" ]
                , button
                    [ Attr.class "inline-flex items-center px-6 py-3 border border-transparent text-base font-semibold rounded-md shadow-sm text-white bg-[#03045E] hover:bg-[#1a1f5f] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#03045E] transition-colors duration-200"
                    , onClick NavigateToHealth
                    ]
                    [ text "See if I Qualify" ]
                ]
            ]
        ]


planCard : Plan -> Bool -> Html Msg
planCard plan isPrimary =
    div
        [ Attr.class <|
            "bg-white rounded-lg shadow-lg overflow-hidden "
                ++ (if isPrimary then
                        "ring-2 ring-[#03045E]"

                    else
                        ""
                   )
        ]
        [ if isPrimary then
            div [ Attr.class "bg-[#03045E] text-white text-center py-2 text-sm font-semibold" ]
                [ text "MOST POPULAR" ]

          else
            text ""
        , div [ Attr.class "p-6" ]
            [ -- Carrier Logo
              div [ Attr.class "flex items-center justify-between mb-4" ]
                [ img
                    [ Attr.src plan.image
                    , Attr.alt plan.name
                    , Attr.class "h-12 object-contain"
                    ]
                    []
                , div [ Attr.class "text-right" ]
                    [ h3 [ Attr.class "text-2xl font-bold text-gray-900" ] [ text ("Plan " ++ plan.planType) ]
                    ]
                ]

            -- Pricing
            , div [ Attr.class "mb-6" ]
                [ div [ Attr.class "flex items-baseline" ]
                    [ span [ Attr.class "text-3xl font-bold text-gray-900" ] [ text (formatPrice plan.priceDiscount) ]
                    , span [ Attr.class "text-gray-600 ml-2" ] [ text "/month" ]
                    ]
                , if plan.price > plan.priceDiscount then
                    div [ Attr.class "mt-1" ]
                        [ span [ Attr.class "text-sm text-gray-500 line-through" ] [ text (formatPrice plan.price) ]
                        , span [ Attr.class "text-sm text-green-600 ml-2" ] [ text (plan.discountCategory ++ " Discount Applied!") ]
                        ]

                  else
                    text ""
                ]

            -- Features
            , div [ Attr.class "space-y-3 mb-6" ]
                [ featureItem "Comprehensive coverage"
                , featureItem "No network restrictions"
                , featureItem "Coverage while traveling"
                , if plan.planType == "G" then
                    featureItem "Covers Medicare Part B deductible"

                  else
                    featureItem "Lower premium option"
                ]

            -- CTA
            , button
                [ Attr.class "w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-semibold text-white bg-[#03045E] hover:bg-[#1a1f5f] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#03045E] transition-colors duration-200"
                , onClick NavigateToHealth
                ]
                [ text "Select This Plan" ]
            ]
        ]


featureItem : String -> Html msg
featureItem text_ =
    div [ Attr.class "flex items-start" ]
        [ svg [ SA.class "flex-shrink-0 h-5 w-5 text-green-500 mt-0.5", SA.fill "none", SA.stroke "currentColor", SA.viewBox "0 0 24 24" ]
            [ path [ SA.strokeLinecap "round", SA.strokeLinejoin "round", SA.strokeWidth "2", SA.d "M5 13l4 4L19 7" ] []
            ]
        , span [ Attr.class "ml-3 text-gray-700 text-sm" ] [ Html.text text_ ]
        ]

================
File: frontend/src/StateRegions.elm
================
module StateRegions exposing (Region(..), allRegions, getRegionStates, regionToString, stringToRegion)


type Region
    = WestCoast
    | EastCoast
    | South
    | Midwest


allRegions : List Region
allRegions =
    [ WestCoast, EastCoast, South, Midwest ]


regionToString : Region -> String
regionToString region =
    case region of
        WestCoast ->
            "West Coast"

        EastCoast ->
            "East Coast"

        South ->
            "South"

        Midwest ->
            "Midwest"


stringToRegion : String -> Maybe Region
stringToRegion str =
    case str of
        "west" ->
            Just WestCoast

        "east" ->
            Just EastCoast

        "south" ->
            Just South

        "midwest" ->
            Just Midwest

        _ ->
            Nothing


getRegionStates : Region -> List String
getRegionStates region =
    case region of
        WestCoast ->
            [ "CA", "OR", "WA", "AK", "HI" ]

        EastCoast ->
            [ "ME", "NH", "VT", "MA", "RI", "CT", "NY", "NJ", "PA", "DE", "MD", "DC" ]

        South ->
            [ "VA", "NC", "SC", "GA", "FL", "AL", "MS", "LA", "AR", "TN", "KY", "WV", "TX", "OK" ]

        Midwest ->
            [ "OH", "MI", "IN", "IL", "WI", "MN", "IA", "MO", "ND", "SD", "NE", "KS", "MT", "WY", "CO", "ID", "NV", "NM", "AZ", "UT" ]

================
File: frontend/src/stripe-integration.d.ts
================
export function loadStripeScript(): void;

export interface StripeResult {
  success: boolean;
  error?: string;
}

export interface StripeIntegration {
  initializeStripe(publishableKey: string): boolean;
  redirectToCheckout(sessionId: string): Promise<StripeResult>;
  processPayment(clientSecret: string): Promise<StripeResult>;
  cleanupStripe(): void;
}

export const stripeIntegration: StripeIntegration;

declare global {
  interface Window {
    Stripe: any;
    stripeIntegration: StripeIntegration;
  }
}

================
File: frontend/src/stripe-integration.js
================
// Load and manage the Stripe.js library
let stripeInstance = null;

// Load the Stripe.js script dynamically
export function loadStripeScript() {
  if (document.getElementById('stripe-js')) {
    console.log('Stripe script already loaded');
    return;
  }

  console.log('Loading Stripe script');
  const script = document.createElement('script');
  script.id = 'stripe-js';
  script.src = 'https://js.stripe.com/v3/';
  script.async = true;
  document.head.appendChild(script);
}

// Initialize Stripe with the provided publishable key
function initializeStripe(publishableKey) {
  try {
    if (!window.Stripe) {
      console.error('Stripe not loaded yet');
      return false;
    }
    
    stripeInstance = window.Stripe(publishableKey);
    console.log('Stripe initialized successfully');
    return true;
  } catch (error) {
    console.error('Error initializing Stripe:', error);
    return false;
  }
}

// Redirect to Stripe Checkout using sessionId
async function redirectToCheckout(sessionId) {
  try {
    if (!stripeInstance) {
      console.error('Stripe not initialized');
      return { success: false, error: 'Stripe not initialized' };
    }
    
    console.log('Redirecting to Checkout with session:', sessionId);
    const { error } = await stripeInstance.redirectToCheckout({ sessionId });
    
    if (error) {
      console.error('Checkout error:', error);
      return { success: false, error: error.message };
    }
    
    return { success: true };
  } catch (error) {
    console.error('Redirect to checkout error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

// Process a payment using Stripe Elements
async function processPayment(clientSecret) {
  try {
    if (!stripeInstance) {
      console.error('Stripe not initialized');
      return { success: false, error: 'Stripe not initialized' };
    }
    
    // Set up payment element
    const elements = stripeInstance.elements({
      clientSecret,
      appearance: {
        theme: 'stripe',
      },
    });
    
    const paymentElement = elements.create('payment');
    
    // Create a container for the payment element
    const paymentContainer = document.createElement('div');
    paymentContainer.id = 'payment-element';
    document.body.appendChild(paymentContainer);
    
    // Mount the payment element
    paymentElement.mount('#payment-element');
    
    // Handle the form submission
    const { error } = await stripeInstance.confirmPayment({
      elements,
      confirmParams: {
        return_url: window.location.origin + '/dashboard?payment_success=true',
      },
    });
    
    // Clean up
    document.body.removeChild(paymentContainer);
    
    if (error) {
      console.error('Payment error:', error);
      return { success: false, error: error.message };
    }
    
    return { success: true };
  } catch (error) {
    console.error('Process payment error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

// Clean up Stripe resources
function cleanupStripe() {
  stripeInstance = null;
}

// Export the Stripe integration object to be attached to the window
export const stripeIntegration = {
  initializeStripe,
  redirectToCheckout,
  processPayment,
  cleanupStripe
};

// Attach to window for access from Elm ports
if (typeof window !== 'undefined') {
  window.stripeIntegration = stripeIntegration;
}

================
File: frontend/src/stripe-integration.ts
================
// Load and manage the Stripe.js library
let stripeInstance: any = null;

// Load the Stripe.js script dynamically
export function loadStripeScript() {
  if (document.getElementById('stripe-js')) {
    console.log('Stripe script already loaded');
    return;
  }

  console.log('Loading Stripe script');
  const script = document.createElement('script');
  script.id = 'stripe-js';
  script.src = 'https://js.stripe.com/v3/';
  script.async = true;
  document.head.appendChild(script);
}

// Initialize Stripe with the provided publishable key
function initializeStripe(publishableKey: string) {
  try {
    if (!window.Stripe) {
      console.error('Stripe not loaded yet');
      return false;
    }
    
    stripeInstance = window.Stripe(publishableKey);
    console.log('Stripe initialized successfully');
    return true;
  } catch (error) {
    console.error('Error initializing Stripe:', error);
    return false;
  }
}

// Redirect to Stripe Checkout using sessionId
async function redirectToCheckout(sessionId: string) {
  try {
    if (!stripeInstance) {
      console.error('Stripe not initialized');
      return { success: false, error: 'Stripe not initialized' };
    }
    
    console.log('Redirecting to Checkout with session:', sessionId);
    const { error } = await stripeInstance.redirectToCheckout({ sessionId });
    
    if (error) {
      console.error('Checkout error:', error);
      return { success: false, error: error.message };
    }
    
    return { success: true };
  } catch (error) {
    console.error('Redirect to checkout error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

// Process a payment using Stripe Elements
async function processPayment(clientSecret: string) {
  try {
    if (!stripeInstance) {
      console.error('Stripe not initialized');
      return { success: false, error: 'Stripe not initialized' };
    }
    
    // Set up payment element
    const elements = stripeInstance.elements({
      clientSecret,
      appearance: {
        theme: 'stripe',
      },
    });
    
    const paymentElement = elements.create('payment');
    
    // Create a container for the payment element
    const paymentContainer = document.createElement('div');
    paymentContainer.id = 'payment-element';
    document.body.appendChild(paymentContainer);
    
    // Mount the payment element
    paymentElement.mount('#payment-element');
    
    // Handle the form submission
    const { error } = await stripeInstance.confirmPayment({
      elements,
      confirmParams: {
        return_url: window.location.origin + '/dashboard?payment_success=true',
      },
    });
    
    // Clean up
    document.body.removeChild(paymentContainer);
    
    if (error) {
      console.error('Payment error:', error);
      return { success: false, error: error.message };
    }
    
    return { success: true };
  } catch (error) {
    console.error('Process payment error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

// Clean up Stripe resources
function cleanupStripe() {
  stripeInstance = null;
}

// Export the Stripe integration object to be attached to the window
const stripeIntegration = {
  initializeStripe,
  redirectToCheckout,
  processPayment,
  cleanupStripe
};

// Attach to window for access from Elm ports
if (typeof window !== 'undefined') {
  (window as any).stripeIntegration = stripeIntegration;
}

export { stripeIntegration };

// Add TypeScript declarations for Stripe
declare global {
  interface Window {
    Stripe: any;
  }
}

================
File: frontend/src/Stripe.elm
================
module Stripe exposing (Model, Msg, init, subscriptions, update, view)

-- Alias for Svg.Attributes

import Browser
import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Svg exposing (path, svg)
import Svg.Attributes as SA
import Url exposing (Url)



-- MODEL


type alias Model =
    { planInfo : RemoteData PlanInfo
    , paymentMethod : RemoteData (Maybe PaymentMethod)
    , invoices : RemoteData (List Invoice)
    , downloadingInvoiceId : Maybe String
    }


type RemoteData a
    = NotAsked
    | Loading
    | Success a
    | Failure Http.Error


type alias PlanInfo =
    { name : String
    , contactCount : Int
    , totalClients : Int -- Overall limit
    , priceDescription : String
    , basePrice : Maybe Float -- Made Maybe for decoder convenience
    , contactsIncluded : Maybe Int
    , pricePerAdditionalContact : Maybe Float
    }


type alias PaymentMethod =
    { id : String
    , type_ : String
    , last4 : String
    , brand : String
    , expiryMonth : Int
    , expiryYear : Int
    , email : String
    }


type alias Invoice =
    { id : String
    , number : String
    , date : String
    , status : InvoiceStatus
    , amount : Float
    , currency : String
    , plan : String
    , pdfUrl : Maybe String
    }


type InvoiceStatus
    = Pending
    | Paid
    | Failed


init : Nav.Key -> Url -> ( Model, Cmd Msg )
init key url =
    ( { planInfo = Loading
      , paymentMethod = Loading
      , invoices = Loading
      , downloadingInvoiceId = Nothing
      }
    , Cmd.batch
        [ fetchPlanInfo
        , fetchPaymentMethod
        , fetchInvoices
        ]
    )



-- UPDATE


type Msg
    = GotPlanInfo (Result Http.Error PlanInfo)
    | GotPaymentMethod (Result Http.Error (Maybe PaymentMethod))
    | GotInvoices (Result Http.Error (List Invoice))
    | ClickedDownloadInvoice String
    | GotInvoiceDownloadUrl (Result Http.Error String)
    | ClickedAnnualPlan


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GotPlanInfo result ->
            ( { model | planInfo = remoteDataFromResult result }, Cmd.none )

        GotPaymentMethod result ->
            ( { model | paymentMethod = remoteDataFromResult result }, Cmd.none )

        GotInvoices result ->
            ( { model | invoices = remoteDataFromResult result }, Cmd.none )

        ClickedDownloadInvoice invoiceId ->
            ( { model | downloadingInvoiceId = Just invoiceId }
            , downloadInvoice invoiceId
            )

        GotInvoiceDownloadUrl result ->
            case result of
                Ok url ->
                    ( { model | downloadingInvoiceId = Nothing }
                    , Nav.load url
                    )

                Err _ ->
                    ( { model | downloadingInvoiceId = Nothing }, Cmd.none )

        ClickedAnnualPlan ->
            -- TODO: Implement annual plan upgrade
            ( model, Cmd.none )


remoteDataFromResult : Result Http.Error a -> RemoteData a
remoteDataFromResult result =
    case result of
        Ok data ->
            Success data

        Err error ->
            Failure error



-- HTTP


fetchPlanInfo : Cmd Msg
fetchPlanInfo =
    Http.get
        { url = "/api/billing/plan"
        , expect = Http.expectJson GotPlanInfo planInfoDecoder
        }


fetchPaymentMethod : Cmd Msg
fetchPaymentMethod =
    Http.get
        { url = "/api/billing/payment-method"
        , expect = Http.expectJson GotPaymentMethod maybePaymentMethodDecoder
        }


fetchInvoices : Cmd Msg
fetchInvoices =
    Http.get
        { url = "/api/billing/invoices"
        , expect = Http.expectJson GotInvoices invoicesDecoder
        }


downloadInvoice : String -> Cmd Msg
downloadInvoice invoiceId =
    Http.get
        { url = "/api/billing/invoices/" ++ invoiceId ++ "/download"
        , expect = Http.expectJson GotInvoiceDownloadUrl downloadUrlDecoder
        }


planInfoDecoder : Decoder PlanInfo
planInfoDecoder =
    Decode.field "data"
        (Decode.map7 PlanInfo
            (Decode.field "name" Decode.string)
            (Decode.field "contactCount" Decode.int)
            (Decode.field "totalClients" Decode.int)
            (Decode.field "priceDescription" Decode.string)
            (Decode.maybe (Decode.field "basePrice" Decode.float))
            -- Handling potentially missing fields
            (Decode.maybe (Decode.field "contactsIncluded" Decode.int))
            (Decode.maybe (Decode.field "pricePerAdditionalContact" Decode.float))
        )


paymentMethodDecoder : Decoder PaymentMethod
paymentMethodDecoder =
    Decode.map7 PaymentMethod
        (Decode.field "id" Decode.string)
        (Decode.field "type" Decode.string)
        (Decode.field "last4" Decode.string)
        (Decode.field "brand" Decode.string)
        (Decode.field "expiryMonth" Decode.int)
        (Decode.field "expiryYear" Decode.int)
        (Decode.field "email" Decode.string)


maybePaymentMethodDecoder : Decoder (Maybe PaymentMethod)
maybePaymentMethodDecoder =
    Decode.field "data" (Decode.nullable paymentMethodDecoder)


invoicesDecoder : Decoder (List Invoice)
invoicesDecoder =
    Decode.field "data" (Decode.list invoiceDecoder)


invoiceDecoder : Decoder Invoice
invoiceDecoder =
    Decode.map8 Invoice
        (Decode.field "id" Decode.string)
        (Decode.field "number" Decode.string)
        (Decode.field "date" Decode.string)
        (Decode.field "status" invoiceStatusDecoder)
        (Decode.field "amount" Decode.float)
        (Decode.field "currency" Decode.string)
        (Decode.field "plan" Decode.string)
        (Decode.maybe (Decode.field "pdfUrl" Decode.string))


invoiceStatusDecoder : Decoder InvoiceStatus
invoiceStatusDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case str of
                    "pending" ->
                        Decode.succeed Pending

                    "paid" ->
                        Decode.succeed Paid

                    "failed" ->
                        Decode.succeed Failed

                    _ ->
                        Decode.fail ("Unknown invoice status: " ++ str)
            )


downloadUrlDecoder : Decoder String
downloadUrlDecoder =
    Decode.at [ "data", "url" ] Decode.string



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Billing"
    , body =
        [ div [ class "min-h-screen bg-gray-50" ]
            [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
                [ h1 [ class "text-3xl font-bold text-gray-900 mb-8" ] [ text "Billing" ]
                , div [ class "space-y-6" ]
                    -- Main container for vertical spacing
                    [ div [ class "grid grid-cols-1 lg:grid-cols-2 gap-6" ]
                        -- Row for Plan Settings and Payment Method
                        [ viewPlanSettings model.planInfo
                        , viewPaymentMethod model.paymentMethod
                        ]
                    , viewInvoices model.invoices model.downloadingInvoiceId -- Invoices below, takes full width due to parent flow
                    ]
                ]
            ]
        ]
    }


viewPlanSettings : RemoteData PlanInfo -> Html Msg
viewPlanSettings planInfo =
    div [ class "bg-white shadow rounded-lg p-6 h-full flex flex-col" ]
        [ case planInfo of
            Loading ->
                div [ class "animate-pulse flex-grow flex flex-col justify-between" ]
                    [ div []
                        [ div [ class "flex items-center justify-between" ]
                            [ div [ class "h-6 bg-gray-200 rounded w-1/3" ] []
                            , div [ class "h-10 bg-gray-200 rounded w-1/4" ] []
                            ]
                        , div [ class "h-4 bg-gray-200 rounded w-3/4 mt-3" ] []
                        ]
                    , div [ class "h-4 bg-gray-200 rounded w-1/2 mt-4" ] []
                    ]

            Success info ->
                div [ class "flex-grow flex flex-col justify-between" ]
                    [ div []
                        [ div [ class "flex justify-between items-start" ]
                            [ div [ class "flex items-center gap-x-2" ]
                                [ h3 [ class "text-lg font-semibold text-gray-900" ] [ text info.name ]
                                , span [ class "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800" ]
                                    [ text
                                        (String.fromInt info.contactCount
                                            ++ (if info.contactCount == 1 then
                                                    " Contact"

                                                else
                                                    " Contacts"
                                               )
                                        )
                                    ]
                                ]
                            , div [ class "text-right" ]
                                [ case info.basePrice of
                                    Just bp ->
                                        p [ class "text-4xl font-bold text-gray-900" ] [ text ("$" ++ String.fromFloat bp) ]

                                    Nothing ->
                                        p [ class "text-4xl font-bold text-gray-900" ] [ text "-" ]
                                , p [ class "text-sm text-gray-500" ] [ text "per month" ]
                                ]
                            ]
                        , p [ class "text-sm text-gray-500 mt-1" ] [ text (formatPriceDescriptionShort info) ]
                        ]
                    , div [ class "mt-4" ]
                        [ text "" ]
                    ]

            Failure httpError ->
                div [ class "text-red-600" ] [ text "Failed to load plan information. Please try again later." ]

            NotAsked ->
                text ""
        ]


viewPaymentMethod : RemoteData (Maybe PaymentMethod) -> Html Msg
viewPaymentMethod paymentMethodData =
    div [ class "bg-white shadow rounded-lg p-6 h-full flex flex-col" ]
        [ div [ class "mb-4" ]
            [ h2 [ class "text-lg font-semibold text-gray-900" ] [ text "Payment method" ]
            , p [ class "text-sm text-gray-500" ] [ text "Change how you pay for your plan." ]
            ]
        , div [ class "flex-grow flex flex-col justify-center items-center" ]
            [ case paymentMethodData of
                Loading ->
                    div [ class "animate-pulse w-full" ]
                        [ div [ class "flex items-center space-x-4 mb-4" ]
                            [ div [ class "h-10 w-16 bg-gray-200 rounded" ] []
                            , div [ class "flex-1 space-y-2 py-1" ]
                                [ div [ class "h-4 bg-gray-200 rounded w-3/4" ] []
                                , div [ class "h-4 bg-gray-200 rounded w-1/2" ] []
                                ]
                            ]
                        , div [ class "h-4 bg-gray-200 rounded w-3/4 mb-6" ] []
                        , div [ class "h-10 bg-blue-200 rounded w-1/2" ] []
                        ]

                Success maybePm ->
                    div [ class "w-full text-left" ]
                        [ case maybePm of
                            Just pm ->
                                div [ class "mb-6" ]
                                    [ div [ class "flex items-center justify-center space-x-3" ]
                                        [ viewCardIcon pm.brand
                                        , div [ class "text-sm text-left" ]
                                            [ p [ class "font-medium text-gray-700" ] [ text (formatCardBrand pm.brand ++ " ending in " ++ pm.last4) ]
                                            , p [ class "text-gray-500" ] [ text ("Expiry " ++ String.fromInt pm.expiryMonth ++ "/" ++ String.fromInt pm.expiryYear) ]
                                            ]
                                        ]
                                    , if String.isEmpty pm.email then
                                        text ""

                                      else
                                        p [ class "text-sm text-gray-500 mt-3" ] [ text pm.email ]
                                    ]

                            Nothing ->
                                text ""
                        , a
                            [ class "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                            , href "https://billing.stripe.com/p/login/cNidR88q09BV2d32OA7Zu00"
                            , target "_blank"
                            ]
                            [ text "Manage Payment Method"
                            , svg [ SA.class "ml-2 -mr-0.5 h-4 w-4", SA.viewBox "0 0 20 20", SA.fill "currentColor", SA.stroke "currentColor", SA.strokeWidth "1" ]
                                [ path [ SA.fillRule "evenodd", SA.d "M6 14l8-8m0 0H6m8 0v8", SA.clipRule "evenodd" ] []
                                ]
                            ]
                        ]

                Failure _ ->
                    div [ class "text-red-600" ] [ text "Failed to load payment method information." ]

                NotAsked ->
                    text ""
            ]
        ]


viewInvoices : RemoteData (List Invoice) -> Maybe String -> Html Msg
viewInvoices invoices downloadingId =
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ h2 [ class "text-lg font-semibold text-gray-900 mb-4" ] [ text "Invoices" ]
        , p [ class "text-sm text-gray-500 mb-4" ] [ text "Click Download on the far right to receive a pdf of the invoice." ]
        , case invoices of
            Loading ->
                div [ class "animate-pulse space-y-2" ]
                    [ div [ class "h-12 bg-gray-200 rounded" ] []
                    , div [ class "h-12 bg-gray-200 rounded" ] []
                    , div [ class "h-12 bg-gray-200 rounded" ] []
                    ]

            Success invoiceList ->
                if List.isEmpty invoiceList then
                    p [ class "text-gray-500" ] [ text "No invoices yet." ]

                else
                    div [ class "overflow-x-auto" ]
                        [ table [ class "min-w-full divide-y divide-gray-200" ]
                            [ thead [ class "bg-gray-50" ]
                                [ tr []
                                    [ th [ scope "col", class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ] [ text "Invoice" ]
                                    , th [ scope "col", class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ] [ text "Date" ]
                                    , th [ scope "col", class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ] [ text "Status" ]
                                    , th [ scope "col", class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ] [ text "Amount" ]
                                    , th [ scope "col", class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ] [ text "Plan" ]
                                    , th [ scope "col", class "relative px-6 py-3" ] [ span [ class "sr-only" ] [ text "Download" ] ]
                                    ]
                                ]
                            , tbody [ class "bg-white divide-y divide-gray-200" ]
                                (List.map (viewInvoiceRow downloadingId) invoiceList)
                            ]
                        ]

            Failure _ ->
                div [ class "text-red-600" ] [ text "Failed to load invoices" ]

            NotAsked ->
                text ""
        ]


viewInvoiceRow : Maybe String -> Invoice -> Html Msg
viewInvoiceRow downloadingId invoice =
    tr []
        [ td [ class "px-6 py-4 whitespace-nowrap" ]
            [ div [ class "flex items-center" ]
                [ svg [ SA.class "w-5 h-5 text-gray-400 mr-2", SA.fill "none", SA.stroke "currentColor", SA.viewBox "0 0 24 24" ]
                    [ path [ SA.strokeLinecap "round", SA.strokeLinejoin "round", SA.strokeWidth "2", SA.d "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" ] []
                    ]
                , button
                    [ class "text-sm text-blue-600 hover:text-blue-900 hover:underline focus:outline-none"
                    , onClick (ClickedDownloadInvoice invoice.id)
                    , disabled (downloadingId == Just invoice.id) -- Disable if this invoice is downloading
                    ]
                    [ text ("Invoice " ++ invoice.number) ]
                ]
            ]
        , td [ class "px-6 py-4 whitespace-nowrap text-sm text-gray-500" ]
            [ text (formatDate invoice.date) ]
        , td [ class "px-6 py-4 whitespace-nowrap" ]
            [ viewInvoiceStatus invoice.status ]
        , td [ class "px-6 py-4 whitespace-nowrap text-sm text-gray-900" ]
            [ text (invoice.currency ++ " $" ++ String.fromFloat invoice.amount) ]
        , td [ class "px-6 py-4 whitespace-nowrap text-sm text-gray-500" ]
            [ text invoice.plan ]
        , td [ class "px-6 py-4 whitespace-nowrap text-right text-sm font-medium" ]
            [ if downloadingId == Just invoice.id then
                span [ class "text-gray-400" ] [ text "Downloading..." ]

              else
                button
                    [ class "text-blue-600 hover:text-blue-900"
                    , onClick (ClickedDownloadInvoice invoice.id)
                    ]
                    [ text "Download" ]
            ]
        ]


viewInvoiceStatus : InvoiceStatus -> Html msg
viewInvoiceStatus status =
    case status of
        Pending ->
            span [ class "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800" ]
                [ span [ class "w-2 h-2 bg-yellow-400 rounded-full mr-1.5" ] []
                , text "Pending"
                ]

        Paid ->
            span [ class "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800" ]
                [ span [ class "w-2 h-2 bg-green-400 rounded-full mr-1.5" ] []
                , text "Paid"
                ]

        Failed ->
            span [ class "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800" ]
                [ span [ class "w-2 h-2 bg-red-400 rounded-full mr-1.5" ] []
                , text "Failed"
                ]


viewCardIcon : String -> Html msg
viewCardIcon brand =
    let
        iconClass =
            "w-10 h-6 flex items-center justify-center rounded border"

        brandClass =
            case String.toLower brand of
                "visa" ->
                    "bg-blue-50 border-blue-200 text-blue-600"

                "mastercard" ->
                    "bg-red-50 border-red-200 text-red-600"

                "amex" ->
                    "bg-blue-50 border-blue-200 text-blue-600"

                _ ->
                    "bg-gray-50 border-gray-200 text-gray-600"
    in
    div [ class (iconClass ++ " " ++ brandClass) ]
        [ text (String.toUpper (String.left 4 brand)) ]



-- HELPERS


formatCardBrand : String -> String
formatCardBrand brand =
    case String.toLower brand of
        "visa" ->
            "Visa"

        "mastercard" ->
            "Mastercard"

        "amex" ->
            "American Express"

        _ ->
            brand


formatDate : String -> String
formatDate isoDate =
    -- Simple date formatting - you might want to use a proper date library
    String.left 10 isoDate


formatPriceDescription : PlanInfo -> String
formatPriceDescription info =
    case ( info.basePrice, info.contactsIncluded, info.pricePerAdditionalContact ) of
        ( Just bp, Just ci, Just ppac ) ->
            "$" ++ String.fromFloat bp ++ "/month for first " ++ String.fromInt ci ++ " contacts, then $" ++ String.fromFloat ppac ++ "/contact."

        ( Just bp, Nothing, Nothing ) ->
            -- Only base price known
            "$" ++ String.fromFloat bp ++ "/month"

        _ ->
            info.priceDescription


formatPriceDescriptionShort : PlanInfo -> String
formatPriceDescriptionShort info =
    if String.isEmpty info.priceDescription then
        "Simply charged per contact, each month"

    else if String.contains "$" info.priceDescription && String.contains "/month" info.priceDescription && String.contains "contacts" info.priceDescription then
        info.priceDescription

    else
        "Simply charged per contact, each month"



-- Fallback to the raw description from backend
-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/styles.css
================
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;600;700&display=swap');
@import "tailwindcss";

/* Custom styles can go here */
.form-group {
  @apply mb-4;
}

/* Configure default fonts */
@layer base {
  /* Default body text */
  html {
    font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Segoe UI', 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  }
  
  /* Headlines */
  h1, h2, h3, h4, h5, h6 {
    font-family: 'Inter', system-ui, sans-serif;
  }
}

/* Add any other custom styles as needed */

================
File: frontend/src/Subscription.elm
================
module Subscription exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as Encode
import Svg exposing (path, svg)
import Svg.Attributes exposing (clipRule, d, fill, fillRule, viewBox)
import Time



-- MODEL


type alias Model =
    { subscriptionData : Maybe SubscriptionData
    , paymentMethods : List PaymentMethod
    , billingHistory : List BillingRecord
    , isLoading : Bool
    , error : Maybe String
    , activeTab : Tab
    , contactCount : Int
    , autoUpgradeLimit : Int
    , upgradeModalOpen : Bool
    , selectedTier : Int
    }


type Tab
    = PlanTab
    | PaymentTab
    | BillingTab


type alias SubscriptionData =
    { id : String
    , status : String
    , tier : Int
    , contactLimit : Int
    , currentPeriodEnd : String
    , cancelAtPeriodEnd : Bool
    , features : List String
    }


type alias PaymentMethod =
    { id : String
    , brand : String
    , last4 : String
    , expiryMonth : Int
    , expiryYear : Int
    , isDefault : Bool
    }


type alias BillingRecord =
    { id : String
    , date : String
    , amount : Float
    , status : String
    , description : String
    , invoiceUrl : Maybe String
    }


init : () -> ( Model, Cmd Msg )
init _ =
    ( { subscriptionData = Nothing
      , paymentMethods = []
      , billingHistory = []
      , isLoading = True
      , error = Nothing
      , activeTab = PlanTab
      , contactCount = 0
      , autoUpgradeLimit = 0
      , upgradeModalOpen = False
      , selectedTier = 1
      }
    , Cmd.batch
        [ fetchSubscriptionData
        , fetchPaymentMethods
        , fetchBillingHistory
        ]
    )



-- UPDATE


type Msg
    = GotSubscriptionData (Result Http.Error SubscriptionDataResponse)
    | GotPaymentMethods (Result Http.Error (List PaymentMethod))
    | GotBillingHistory (Result Http.Error (List BillingRecord))
    | ChangeTier Int
    | UpgradeTier Int
    | UpgradeTierResult (Result Http.Error UpgradeResponse)
    | AddPaymentMethod
    | RemovePaymentMethod String
    | SetDefaultPaymentMethod String
    | PaymentMethodUpdated (Result Http.Error (List PaymentMethod))
    | DownloadInvoice String
    | ChangeTab Tab
    | OpenUpgradeModal Int
    | CloseUpgradeModal
    | SetAutoUpgradeLimit Int
    | AutoUpgradeLimitUpdated (Result Http.Error AutoUpgradeResponse)
    | CreateCheckoutSession Int
    | GotCheckoutSession (Result Http.Error CheckoutResponse)
    | NoOp


type alias SubscriptionDataResponse =
    { subscription : Maybe SubscriptionData
    , contactCount : Int
    , autoUpgradeLimit : Int
    }


type alias UpgradeResponse =
    { success : Bool
    , previousTier : Maybe Int
    , newTier : Maybe Int
    , contactLimit : Maybe Int
    , message : Maybe String
    }


type alias AutoUpgradeResponse =
    { success : Bool
    , autoUpgradeLimit : Int
    }


type alias CheckoutResponse =
    { clientSecret : String
    , subscriptionId : String
    }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GotSubscriptionData (Ok response) ->
            ( { model
                | subscriptionData = response.subscription
                , contactCount = response.contactCount
                , autoUpgradeLimit = response.autoUpgradeLimit
                , isLoading = False
              }
            , Cmd.none
            )

        GotSubscriptionData (Err _) ->
            ( { model | error = Just "Failed to load subscription data", isLoading = False }, Cmd.none )

        GotPaymentMethods (Ok methods) ->
            ( { model | paymentMethods = methods, isLoading = False }, Cmd.none )

        GotPaymentMethods (Err _) ->
            ( { model | error = Just "Failed to load payment methods", isLoading = False }, Cmd.none )

        GotBillingHistory (Ok history) ->
            ( { model | billingHistory = history, isLoading = False }, Cmd.none )

        GotBillingHistory (Err _) ->
            ( { model | error = Just "Failed to load billing history", isLoading = False }, Cmd.none )

        ChangeTier tier ->
            ( { model | selectedTier = tier }, Cmd.none )

        OpenUpgradeModal tier ->
            ( { model | upgradeModalOpen = True, selectedTier = tier }, Cmd.none )

        CloseUpgradeModal ->
            ( { model | upgradeModalOpen = False }, Cmd.none )

        UpgradeTier tier ->
            ( { model | isLoading = True, upgradeModalOpen = False }
            , upgradeTier tier
            )

        UpgradeTierResult (Ok response) ->
            if response.success then
                case model.subscriptionData of
                    Just subscription ->
                        let
                            updatedSubscription =
                                { subscription
                                    | tier = Maybe.withDefault subscription.tier response.newTier
                                    , contactLimit = Maybe.withDefault subscription.contactLimit response.contactLimit
                                }
                        in
                        ( { model
                            | subscriptionData = Just updatedSubscription
                            , isLoading = False
                          }
                        , Cmd.none
                        )

                    Nothing ->
                        -- Should not happen, but handle it gracefully
                        ( { model | isLoading = False }
                        , fetchSubscriptionData
                        )

            else
                ( { model
                    | error = Just (Maybe.withDefault "Failed to upgrade subscription" response.message)
                    , isLoading = False
                  }
                , Cmd.none
                )

        UpgradeTierResult (Err _) ->
            ( { model | error = Just "Failed to upgrade subscription", isLoading = False }, Cmd.none )

        AddPaymentMethod ->
            -- In a real implementation, this would open a Stripe form or similar
            ( model, Cmd.none )

        RemovePaymentMethod id ->
            ( { model | isLoading = True }, removePaymentMethod id )

        SetDefaultPaymentMethod id ->
            ( { model | isLoading = True }, setDefaultPaymentMethod id )

        PaymentMethodUpdated (Ok methods) ->
            ( { model | paymentMethods = methods, isLoading = False }, Cmd.none )

        PaymentMethodUpdated (Err _) ->
            ( { model | error = Just "Failed to update payment method", isLoading = False }, Cmd.none )

        DownloadInvoice url ->
            -- This would trigger a download in a real implementation
            ( model, Cmd.none )

        ChangeTab tab ->
            ( { model | activeTab = tab }, Cmd.none )

        SetAutoUpgradeLimit limit ->
            ( { model | isLoading = True }
            , updateAutoUpgradeLimit limit
            )

        AutoUpgradeLimitUpdated (Ok response) ->
            if response.success then
                ( { model
                    | autoUpgradeLimit = response.autoUpgradeLimit
                    , isLoading = False
                  }
                , Cmd.none
                )

            else
                ( { model
                    | error = Just "Failed to update auto-upgrade limit"
                    , isLoading = False
                  }
                , Cmd.none
                )

        AutoUpgradeLimitUpdated (Err _) ->
            ( { model
                | error = Just "Failed to update auto-upgrade limit"
                , isLoading = False
              }
            , Cmd.none
            )

        CreateCheckoutSession tier ->
            ( { model | isLoading = True }
            , createCheckoutSession tier
            )

        GotCheckoutSession (Ok response) ->
            -- In a real implementation, this would redirect to Stripe checkout
            -- For now, we just update the state and let JavaScript handle it
            ( model, Cmd.none )

        GotCheckoutSession (Err _) ->
            ( { model
                | error = Just "Failed to create checkout session"
                , isLoading = False
              }
            , Cmd.none
            )

        NoOp ->
            ( model, Cmd.none )



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Subscription & Payments"
    , body =
        [ div [ class "min-h-screen bg-gray-50" ]
            [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" ]
                [ h1 [ class "text-2xl font-semibold text-[#03045E] mb-6" ]
                    [ text "Subscription & Payments" ]
                , if model.isLoading then
                    viewLoading

                  else
                    div []
                        [ viewTabs model
                        , viewTabContent model
                        ]
                , if model.upgradeModalOpen then
                    viewUpgradeModal model

                  else
                    text ""
                ]
            ]
        ]
    }


viewTabs : Model -> Html Msg
viewTabs model =
    div [ class "border-b border-gray-200 mb-6" ]
        [ div [ class "flex -mb-px" ]
            [ viewTab "Subscription Plan" (model.activeTab == PlanTab) (ChangeTab PlanTab)
            , viewTab "Payment Methods" (model.activeTab == PaymentTab) (ChangeTab PaymentTab)
            , viewTab "Billing History" (model.activeTab == BillingTab) (ChangeTab BillingTab)
            ]
        ]


viewTab : String -> Bool -> Msg -> Html Msg
viewTab label isActive msg =
    button
        [ class
            ("px-4 py-2 font-medium text-sm "
                ++ (if isActive then
                        "border-b-2 border-[#03045E] text-[#03045E]"

                    else
                        "text-gray-500 hover:text-gray-700 hover:border-gray-300"
                   )
            )
        , onClick msg
        ]
        [ text label ]


viewTabContent : Model -> Html Msg
viewTabContent model =
    case model.activeTab of
        PlanTab ->
            viewSubscriptionPlan model

        PaymentTab ->
            viewPaymentMethods model

        BillingTab ->
            viewBillingHistory model


viewLoading : Html Msg
viewLoading =
    div [ class "flex justify-center items-center h-64" ]
        [ div [ class "animate-spin rounded-full h-8 w-8 border-4 border-[#03045E] border-t-transparent" ] [] ]


viewSubscriptionPlan : Model -> Html Msg
viewSubscriptionPlan model =
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ case model.subscriptionData of
            Just subscription ->
                div [ class "space-y-6" ]
                    [ div [ class "flex justify-between items-center" ]
                        [ div []
                            [ h2 [ class "text-lg font-medium text-gray-900" ]
                                [ text "Current Plan" ]
                            , div [ class "mt-1 text-sm text-gray-500" ]
                                [ text "Contact-based subscription" ]
                            ]
                        , div [ class "px-3 py-1 bg-blue-50 text-blue-700 rounded-full text-sm font-medium" ]
                            [ text subscription.status ]
                        ]
                    , div [ class "border-t border-gray-200 pt-4" ]
                        [ div [ class "flex items-baseline" ]
                            [ span [ class "text-3xl font-bold text-gray-900" ]
                                [ text ("Tier " ++ String.fromInt subscription.tier) ]
                            , span [ class "ml-3 text-gray-500" ]
                                [ text (String.fromInt subscription.contactLimit ++ " contacts") ]
                            ]
                        , div [ class "mt-1 text-sm text-gray-500" ]
                            [ text ("Current usage: " ++ String.fromInt model.contactCount ++ " contacts") ]
                        , div [ class "mt-1 text-sm text-gray-500" ]
                            [ text ("Next billing date: " ++ subscription.currentPeriodEnd) ]
                        ]
                    , div [ class "border-t border-gray-200 pt-4" ]
                        [ h3 [ class "text-md font-medium text-gray-900 mb-2" ]
                            [ text "Features" ]
                        , ul [ class "space-y-2" ]
                            (List.map
                                (\feature ->
                                    li [ class "flex items-center text-gray-600" ]
                                        [ div [ class "mr-2 text-green-500" ]
                                            [ viewCheckIcon ]
                                        , text feature
                                        ]
                                )
                                subscription.features
                            )
                        ]
                    , div [ class "border-t border-gray-200 pt-4" ]
                        [ h3 [ class "text-md font-medium text-gray-900 mb-3" ]
                            [ text "Auto-Upgrade Settings" ]
                        , div [ class "flex items-center space-x-4" ]
                            [ div [ class "text-sm text-gray-700" ]
                                [ text "Automatically upgrade when contacts exceed limit up to: " ]
                            , select
                                [ class "form-select rounded-md border-gray-300 text-sm"
                                , onInput (\value -> SetAutoUpgradeLimit (Maybe.withDefault 0 (String.toInt value)))
                                , value (String.fromInt model.autoUpgradeLimit)
                                ]
                                [ option [ value "0" ] [ text "Disabled (require manual approval)" ]
                                , option [ value "1000" ] [ text "1,000 contacts" ]
                                , option [ value "1500" ] [ text "1,500 contacts" ]
                                , option [ value "2000" ] [ text "2,000 contacts" ]
                                , option [ value "2500" ] [ text "2,500 contacts" ]
                                , option [ value "5000" ] [ text "5,000 contacts" ]
                                ]
                            ]
                        ]
                    , div [ class "border-t border-gray-200 pt-4" ]
                        [ h3 [ class "text-md font-medium text-gray-900 mb-3" ]
                            [ text "Upgrade Your Plan" ]
                        , div [ class "grid grid-cols-3 gap-4" ]
                            (List.map
                                (\tier ->
                                    viewTierCard
                                        tier
                                        (tier * 500)
                                        (if tier == 1 then
                                            60

                                         else
                                            60 + ((tier - 1) * 40)
                                        )
                                        subscription.tier
                                )
                                [ 1, 2, 3, 4, 5, 10 ]
                            )
                        ]
                    ]

            Nothing ->
                div [ class "space-y-6" ]
                    [ div [ class "text-center text-gray-500 py-8" ]
                        [ text "No subscription active. Subscribe to start using the service." ]
                    , div [ class "grid grid-cols-3 gap-4" ]
                        (List.map
                            (\tier ->
                                viewTierCard
                                    tier
                                    (tier * 500)
                                    (if tier == 1 then
                                        60

                                     else
                                        60 + ((tier - 1) * 40)
                                    )
                                    0
                            )
                            [ 1, 2, 3, 4, 5, 10 ]
                        )
                    ]
        ]


viewTierCard : Int -> Int -> Int -> Int -> Html Msg
viewTierCard tier contactLimit price currentTier =
    let
        isCurrentTier =
            tier == currentTier
    in
    div
        [ class
            ("border rounded-lg p-4 "
                ++ (if isCurrentTier then
                        "border-[#03045E] bg-blue-50"

                    else
                        "border-gray-200"
                   )
            )
        ]
        [ div [ class "flex justify-between items-center mb-2" ]
            [ h4 [ class "font-medium text-gray-900" ]
                [ text ("Tier " ++ String.fromInt tier) ]
            , if isCurrentTier then
                span [ class "px-2 py-1 bg-[#03045E] text-white text-xs rounded-full" ]
                    [ text "Current" ]

              else
                text ""
            ]
        , div [ class "flex items-baseline mb-2" ]
            [ span [ class "text-xl font-bold text-gray-900" ]
                [ text ("$" ++ String.fromInt price) ]
            , span [ class "ml-1 text-gray-500 text-sm" ]
                [ text "/month" ]
            ]
        , div [ class "text-sm text-gray-600 mb-4" ]
            [ text (String.fromInt contactLimit ++ " contacts") ]
        , if isCurrentTier then
            button
                [ class "w-full px-3 py-2 text-sm font-medium text-gray-500 bg-gray-100 rounded-md cursor-not-allowed"
                , disabled True
                ]
                [ text "Current Plan" ]

          else if currentTier == 0 then
            button
                [ class "w-full px-3 py-2 text-sm font-medium text-white bg-[#03045E] rounded-md hover:bg-opacity-90"
                , onClick (CreateCheckoutSession tier)
                ]
                [ text "Subscribe" ]

          else if tier > currentTier then
            button
                [ class "w-full px-3 py-2 text-sm font-medium text-white bg-[#03045E] rounded-md hover:bg-opacity-90"
                , onClick (OpenUpgradeModal tier)
                ]
                [ text "Upgrade" ]

          else
            button
                [ class "w-full px-3 py-2 text-sm font-medium text-gray-500 bg-gray-100 rounded-md cursor-not-allowed"
                , disabled True
                ]
                [ text "Lower Tier" ]
        ]


viewUpgradeModal : Model -> Html Msg
viewUpgradeModal model =
    let
        currentTier =
            case model.subscriptionData of
                Just sub ->
                    sub.tier

                Nothing ->
                    0

        currentLimit =
            case model.subscriptionData of
                Just sub ->
                    sub.contactLimit

                Nothing ->
                    0

        newLimit =
            model.selectedTier * 500

        price =
            if model.selectedTier == 1 then
                60

            else
                60 + ((model.selectedTier - 1) * 40)

        currentPrice =
            if currentTier == 1 then
                60

            else
                60 + ((currentTier - 1) * 40)

        priceDifference =
            price - currentPrice
    in
    div [ class "fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50" ]
        [ div [ class "bg-white rounded-lg max-w-lg w-full mx-4" ]
            [ div [ class "p-6" ]
                [ h3 [ class "text-lg font-medium text-gray-900 mb-4" ]
                    [ text "Upgrade Subscription" ]
                , p [ class "text-gray-600 mb-4" ]
                    [ text ("You are upgrading from Tier " ++ String.fromInt currentTier ++ " (" ++ String.fromInt currentLimit ++ " contacts) to Tier " ++ String.fromInt model.selectedTier ++ " (" ++ String.fromInt newLimit ++ " contacts).") ]
                , p [ class "text-gray-600 mb-4" ]
                    [ text ("Your monthly price will increase by $" ++ String.fromInt priceDifference ++ ", from $" ++ String.fromInt currentPrice ++ " to $" ++ String.fromInt price ++ ".") ]
                , p [ class "text-gray-600 mb-6" ]
                    [ text "This change will take effect immediately, and you will be charged a prorated amount for the remainder of your billing cycle." ]
                , div [ class "flex justify-end space-x-4" ]
                    [ button
                        [ class "px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200"
                        , onClick CloseUpgradeModal
                        ]
                        [ text "Cancel" ]
                    , button
                        [ class "px-4 py-2 text-sm font-medium text-white bg-[#03045E] rounded-md hover:bg-opacity-90"
                        , onClick (UpgradeTier model.selectedTier)
                        ]
                        [ text "Confirm Upgrade" ]
                    ]
                ]
            ]
        ]


viewPaymentMethods : Model -> Html Msg
viewPaymentMethods model =
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ div [ class "flex justify-between items-center mb-4" ]
            [ h2 [ class "text-lg font-medium text-gray-900" ]
                [ text "Payment Methods" ]
            , button
                [ class "px-4 py-2 text-sm font-medium text-white bg-[#03045E] rounded-md hover:bg-opacity-90"
                , onClick AddPaymentMethod
                ]
                [ text "Add Payment Method" ]
            ]
        , if List.isEmpty model.paymentMethods then
            div [ class "text-center text-gray-500 py-8" ]
                [ text "No payment methods added yet" ]

          else
            div [ class "space-y-4" ]
                (List.map viewPaymentMethod model.paymentMethods)
        ]


viewPaymentMethod : PaymentMethod -> Html Msg
viewPaymentMethod method =
    div [ class "border rounded-lg p-4 flex justify-between items-center" ]
        [ div [ class "flex items-center" ]
            [ div [ class "flex-shrink-0 w-10 h-6 bg-gray-100 rounded flex items-center justify-center mr-3" ]
                [ text (String.left 1 method.brand) ]
            , div []
                [ div [ class "text-gray-900" ]
                    [ text (method.brand ++ " •••• " ++ method.last4) ]
                , div [ class "text-sm text-gray-500" ]
                    [ text ("Expires " ++ String.fromInt method.expiryMonth ++ "/" ++ String.fromInt method.expiryYear) ]
                ]
            ]
        , div [ class "flex items-center space-x-2" ]
            [ if method.isDefault then
                span [ class "px-2 py-1 bg-green-100 text-green-800 text-xs rounded-full" ]
                    [ text "Default" ]

              else
                button
                    [ class "text-sm text-blue-600 hover:text-blue-800"
                    , onClick (SetDefaultPaymentMethod method.id)
                    ]
                    [ text "Set Default" ]
            , button
                [ class "text-sm text-red-600 hover:text-red-800"
                , onClick (RemovePaymentMethod method.id)
                ]
                [ text "Remove" ]
            ]
        ]


viewBillingHistory : Model -> Html Msg
viewBillingHistory model =
    div [ class "bg-white shadow rounded-lg p-6" ]
        [ h2 [ class "text-lg font-medium text-gray-900 mb-4" ]
            [ text "Billing History" ]
        , if List.isEmpty model.billingHistory then
            div [ class "text-center text-gray-500 py-8" ]
                [ text "No billing history available" ]

          else
            div [ class "overflow-x-auto" ]
                [ table [ class "min-w-full divide-y divide-gray-200" ]
                    [ thead [ class "bg-gray-50" ]
                        [ tr []
                            [ th [ class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ]
                                [ text "Date" ]
                            , th [ class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ]
                                [ text "Description" ]
                            , th [ class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ]
                                [ text "Amount" ]
                            , th [ class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ]
                                [ text "Status" ]
                            , th [ class "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" ]
                                [ text "Actions" ]
                            ]
                        ]
                    , tbody [ class "bg-white divide-y divide-gray-200" ]
                        (List.map viewBillingRecord model.billingHistory)
                    ]
                ]
        ]


viewBillingRecord : BillingRecord -> Html Msg
viewBillingRecord record =
    tr []
        [ td [ class "px-6 py-4 whitespace-nowrap text-sm text-gray-500" ]
            [ text record.date ]
        , td [ class "px-6 py-4 whitespace-nowrap text-sm text-gray-900" ]
            [ text record.description ]
        , td [ class "px-6 py-4 whitespace-nowrap text-sm text-gray-500" ]
            [ text ("$" ++ String.fromFloat record.amount) ]
        , td [ class "px-6 py-4 whitespace-nowrap" ]
            [ span
                [ class
                    ("px-2 py-1 text-xs rounded-full "
                        ++ (case record.status of
                                "Paid" ->
                                    "bg-green-100 text-green-800"

                                "Failed" ->
                                    "bg-red-100 text-red-800"

                                "Pending" ->
                                    "bg-yellow-100 text-yellow-800"

                                _ ->
                                    "bg-gray-100 text-gray-800"
                           )
                    )
                ]
                [ text record.status ]
            ]
        , td [ class "px-6 py-4 whitespace-nowrap text-sm text-gray-500" ]
            [ case record.invoiceUrl of
                Just url ->
                    button
                        [ class "text-blue-600 hover:text-blue-800"
                        , onClick (DownloadInvoice url)
                        ]
                        [ text "Download" ]

                Nothing ->
                    text "—"
            ]
        ]



-- Helper Functions and Icons


viewCheckIcon : Html msg
viewCheckIcon =
    svg
        [ Svg.Attributes.class "h-5 w-5"
        , viewBox "0 0 20 20"
        , fill "currentColor"
        ]
        [ path
            [ fillRule "evenodd"
            , clipRule "evenodd"
            , d "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
            ]
            []
        ]


viewSmallCheckIcon : Html msg
viewSmallCheckIcon =
    svg
        [ Svg.Attributes.class "h-4 w-4"
        , viewBox "0 0 20 20"
        , fill "currentColor"
        ]
        [ path
            [ fillRule "evenodd"
            , clipRule "evenodd"
            , d "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
            ]
            []
        ]



-- HTTP


fetchSubscriptionData : Cmd Msg
fetchSubscriptionData =
    Http.get
        { url = "/api/subscription/status"
        , expect = Http.expectJson GotSubscriptionData subscriptionDataDecoder
        }


subscriptionDataDecoder : Decoder SubscriptionDataResponse
subscriptionDataDecoder =
    Decode.succeed SubscriptionDataResponse
        |> Pipeline.required "subscription" (Decode.nullable subscriptionDecoder)
        |> Pipeline.required "contactCount" Decode.int
        |> Pipeline.required "autoUpgradeLimit" Decode.int


subscriptionDecoder : Decoder SubscriptionData
subscriptionDecoder =
    Decode.succeed SubscriptionData
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "status" Decode.string
        |> Pipeline.required "tier" Decode.int
        |> Pipeline.required "contactLimit" Decode.int
        |> Pipeline.required "currentPeriodEnd" Decode.string
        |> Pipeline.required "cancelAtPeriodEnd" Decode.bool
        |> Pipeline.hardcoded [ "Contact-based pricing", "Email scheduling", "Analytics dashboard" ]


fetchPaymentMethods : Cmd Msg
fetchPaymentMethods =
    Http.get
        { url = "/api/payment-methods"
        , expect = Http.expectJson GotPaymentMethods (Decode.list paymentMethodDecoder)
        }


paymentMethodDecoder : Decoder PaymentMethod
paymentMethodDecoder =
    Decode.succeed PaymentMethod
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "brand" Decode.string
        |> Pipeline.required "last4" Decode.string
        |> Pipeline.required "expiryMonth" Decode.int
        |> Pipeline.required "expiryYear" Decode.int
        |> Pipeline.required "isDefault" Decode.bool


fetchBillingHistory : Cmd Msg
fetchBillingHistory =
    Http.get
        { url = "/api/billing-history"
        , expect = Http.expectJson GotBillingHistory (Decode.list billingRecordDecoder)
        }


billingRecordDecoder : Decoder BillingRecord
billingRecordDecoder =
    Decode.succeed BillingRecord
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "date" Decode.string
        |> Pipeline.required "amount" Decode.float
        |> Pipeline.required "status" Decode.string
        |> Pipeline.required "description" Decode.string
        |> Pipeline.optional "invoiceUrl" (Decode.nullable Decode.string) Nothing


upgradeTier : Int -> Cmd Msg
upgradeTier tier =
    Http.post
        { url = "/api/subscription/upgrade"
        , body = Http.jsonBody (Encode.object [ ( "newTier", Encode.int tier ) ])
        , expect = Http.expectJson UpgradeTierResult upgradeResponseDecoder
        }


upgradeResponseDecoder : Decoder UpgradeResponse
upgradeResponseDecoder =
    Decode.succeed UpgradeResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.optional "previousTier" (Decode.nullable Decode.int) Nothing
        |> Pipeline.optional "newTier" (Decode.nullable Decode.int) Nothing
        |> Pipeline.optional "contactLimit" (Decode.nullable Decode.int) Nothing
        |> Pipeline.optional "message" (Decode.nullable Decode.string) Nothing


updateAutoUpgradeLimit : Int -> Cmd Msg
updateAutoUpgradeLimit limit =
    Http.post
        { url = "/api/subscription/auto-upgrade"
        , body = Http.jsonBody (Encode.object [ ( "autoUpgradeLimit", Encode.int limit ) ])
        , expect = Http.expectJson AutoUpgradeLimitUpdated autoUpgradeLimitDecoder
        }


autoUpgradeLimitDecoder : Decoder AutoUpgradeResponse
autoUpgradeLimitDecoder =
    Decode.succeed AutoUpgradeResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "autoUpgradeLimit" Decode.int


createCheckoutSession : Int -> Cmd Msg
createCheckoutSession tier =
    Http.post
        { url = "/api/subscription/checkout"
        , body = Http.jsonBody (Encode.object [ ( "contactTier", Encode.int tier ) ])
        , expect = Http.expectJson GotCheckoutSession checkoutResponseDecoder
        }


checkoutResponseDecoder : Decoder CheckoutResponse
checkoutResponseDecoder =
    Decode.succeed CheckoutResponse
        |> Pipeline.required "clientSecret" Decode.string
        |> Pipeline.required "subscriptionId" Decode.string


removePaymentMethod : String -> Cmd Msg
removePaymentMethod id =
    Http.post
        { url = "/api/payment-methods/remove"
        , body = Http.jsonBody (Encode.object [ ( "id", Encode.string id ) ])
        , expect = Http.expectJson PaymentMethodUpdated (Decode.list paymentMethodDecoder)
        }


setDefaultPaymentMethod : String -> Cmd Msg
setDefaultPaymentMethod id =
    Http.post
        { url = "/api/payment-methods/set-default"
        , body = Http.jsonBody (Encode.object [ ( "id", Encode.string id ) ])
        , expect = Http.expectJson PaymentMethodUpdated (Decode.list paymentMethodDecoder)
        }



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/TempLanding.elm
================
module TempLanding exposing (Model, Msg(..), init, subscriptions, update, view)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick)


type alias Model =
    {}


type Msg
    = NavigateTo String


init : () -> ( Model, Cmd Msg )
init _ =
    ( {}, Cmd.none )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NavigateTo _ ->
            ( model, Cmd.none )


view : Model -> Browser.Document Msg
view model =
    { title = "Welcome"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex flex-col justify-center" ]
            [ div [ class "text-center space-y-8" ]
                [ h1 [ class "text-4xl font-bold text-gray-900" ]
                    [ text "Welcome! You're logged in!" ]
                , div [ class "flex justify-center space-x-4" ]
                    [ button
                        [ class "inline-flex items-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                        , onClick (NavigateTo "/dashboard")
                        ]
                        [ text "Go to Dashboard" ]
                    , button
                        [ class "inline-flex items-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                        , onClick (NavigateTo "/settings")
                        ]
                        [ text "Go to Settings" ]
                    ]
                ]
            ]
        ]
    }


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/src/typescript.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#007ACC" d="M0 128v128h256V0H0z"></path><path fill="#FFF" d="m56.612 128.85l-.081 10.483h33.32v94.68h23.568v-94.68h33.321v-10.28c0-5.69-.122-10.444-.284-10.566c-.122-.162-20.4-.244-44.983-.203l-44.74.122l-.121 10.443Zm149.955-10.742c6.501 1.625 11.459 4.51 16.01 9.224c2.357 2.52 5.851 7.111 6.136 8.208c.08.325-11.053 7.802-17.798 11.988c-.244.162-1.22-.894-2.317-2.52c-3.291-4.795-6.745-6.867-12.028-7.233c-7.76-.528-12.759 3.535-12.718 10.321c0 1.992.284 3.17 1.097 4.795c1.707 3.536 4.876 5.649 14.832 9.956c18.326 7.883 26.168 13.084 31.045 20.48c5.445 8.249 6.664 21.415 2.966 31.208c-4.063 10.646-14.14 17.879-28.323 20.276c-4.388.772-14.79.65-19.504-.203c-10.28-1.828-20.033-6.908-26.047-13.572c-2.357-2.6-6.949-9.387-6.664-9.874c.122-.163 1.178-.813 2.356-1.504c1.138-.65 5.446-3.129 9.509-5.485l7.355-4.267l1.544 2.276c2.154 3.29 6.867 7.801 9.712 9.305c8.167 4.307 19.383 3.698 24.909-1.26c2.357-2.153 3.332-4.388 3.332-7.68c0-2.966-.366-4.266-1.91-6.501c-1.99-2.845-6.054-5.242-17.595-10.24c-13.206-5.69-18.895-9.224-24.096-14.832c-3.007-3.25-5.852-8.452-7.03-12.8c-.975-3.617-1.22-12.678-.447-16.335c2.723-12.76 12.353-21.659 26.25-24.3c4.51-.853 14.994-.528 19.424.569Z"></path></svg>

================
File: frontend/src/vite-env.d.ts
================
/// <reference types="vite/client" />

declare module "*.elm" {
  export const Elm: any;
}

================
File: frontend/src/Waitlist.elm
================
module Waitlist exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Html exposing (Html, a, button, div, form, h1, img, input, label, p, span, text)
import Html.Attributes exposing (class, disabled, for, href, id, min, placeholder, type_, value)
import Html.Events exposing (onInput, onSubmit)
import Http
import Json.Encode


type alias Model =
    { name : String
    , email : String
    , phone : String
    , displayPhone : String
    , numAgents : String
    , bookSize : String
    , formState : FormState
    , errorMessage : Maybe String
    }


type FormState
    = Editing
    | Submitting
    | Success
    | Error


type Msg
    = UpdateName String
    | UpdateEmail String
    | UpdatePhone String
    | UpdateNumAgents String
    | UpdateBookSize String
    | SubmitForm
    | GotSubmitResponse (Result Http.Error ())


init : ( Model, Cmd Msg )
init =
    ( { name = ""
      , email = ""
      , phone = ""
      , displayPhone = ""
      , numAgents = ""
      , bookSize = ""
      , formState = Editing
      , errorMessage = Nothing
      }
    , Cmd.none
    )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateName value ->
            ( { model | name = value }, Cmd.none )

        UpdateEmail value ->
            ( { model | email = value }, Cmd.none )

        UpdatePhone value ->
            let
                digitsOnly =
                    String.filter Char.isDigit value
                        |> String.left 10
            in
            ( { model
                | phone = digitsOnly
                , displayPhone = formatPhoneNumber digitsOnly
              }
            , Cmd.none
            )

        UpdateNumAgents value ->
            if String.all Char.isDigit value || value == "" then
                ( { model | numAgents = value }, Cmd.none )

            else
                ( model, Cmd.none )

        UpdateBookSize value ->
            if String.all Char.isDigit value || value == "" then
                ( { model | bookSize = value }, Cmd.none )

            else
                ( model, Cmd.none )

        SubmitForm ->
            if isValidForm model then
                ( { model | formState = Submitting }
                , submitForm model
                )

            else
                ( { model | errorMessage = Just "Please fill out all fields correctly." }
                , Cmd.none
                )

        GotSubmitResponse result ->
            case result of
                Ok _ ->
                    ( { model | formState = Success }
                    , Cmd.none
                    )

                Err _ ->
                    ( { model
                        | formState = Error
                        , errorMessage = Just "Something went wrong. Please try again."
                      }
                    , Cmd.none
                    )


isValidForm : Model -> Bool
isValidForm model =
    not (String.isEmpty model.name)
        && isValidEmail model.email
        && not (String.isEmpty model.phone)
        && isValidPositiveInt model.numAgents
        && isValidPositiveInt model.bookSize


isValidEmail : String -> Bool
isValidEmail email =
    let
        trimmedEmail =
            String.trim email
    in
    not (String.isEmpty trimmedEmail)
        && String.contains "@" trimmedEmail
        && String.contains "." trimmedEmail
        && not (String.startsWith "@" trimmedEmail)
        && not (String.endsWith "@" trimmedEmail)
        && not (String.endsWith "." trimmedEmail)
        && (String.indexes "@" trimmedEmail |> List.length)
        == 1
        && String.length (String.dropLeft (String.length (String.left (String.indexes "." trimmedEmail |> List.head |> Maybe.withDefault 0) trimmedEmail)) trimmedEmail)
        > 1


isValidPositiveInt : String -> Bool
isValidPositiveInt str =
    case String.toInt str of
        Just n ->
            n > 0

        Nothing ->
            False


submitForm : Model -> Cmd Msg
submitForm model =
    Http.post
        { url = "/api/waitlist"
        , body =
            Http.jsonBody
                (encodeFormData model)
        , expect = Http.expectWhatever GotSubmitResponse
        }


encodeFormData : Model -> Json.Encode.Value
encodeFormData model =
    Json.Encode.object
        [ ( "name", Json.Encode.string model.name )
        , ( "email", Json.Encode.string model.email )
        , ( "phone", Json.Encode.string model.phone )
        , ( "numAgents", Json.Encode.string model.numAgents )
        , ( "bookSize", Json.Encode.string model.bookSize )
        ]


view : Model -> Browser.Document Msg
view model =
    { title = "Join the Waitlist - Medicare Max"
    , body =
        [ div [ class "min-h-screen bg-white py-16 px-4 sm:px-6 lg:px-8" ]
            [ div [ class "max-w-md mx-auto" ]
                [ div [ class "text-center mb-8" ]
                    [ a [ href "/", class "block" ]
                        [ img
                            [ Html.Attributes.src "/images/medicare-max-logo.png"
                            , Html.Attributes.alt "Medicare Max Logo"
                            , class "mx-auto mb-6 h-12"
                            ]
                            []
                        ]
                    , h1 [ class "text-3xl font-bold text-gray-900" ]
                        [ text "Join the Waitlist" ]
                    , p [ class "mt-2 text-sm text-gray-600" ]
                        [ text "Be the first to know when we launch." ]
                    ]
                , case model.formState of
                    Success ->
                        div [ class "bg-green-50 p-4 rounded-md" ]
                            [ p [ class "text-green-800 text-center" ]
                                [ text "Thanks for joining! We'll be in touch soon." ]
                            ]

                    _ ->
                        formView model
                ]
            ]
        ]
    }


formView : Model -> Html Msg
formView model =
    form [ onSubmit SubmitForm, class "space-y-8" ]
        [ div [ class "space-y-2" ]
            [ label [ for "name", class "block text-sm font-medium text-gray-700" ]
                [ text "Name" ]
            , div [ class "mt-1" ]
                [ input
                    [ type_ "text"
                    , id "name"
                    , value model.name
                    , onInput UpdateName
                    , class "shadow-sm focus:ring-[#03045E] focus:border-[#03045E] block w-full sm:text-sm border-gray-300 rounded-md px-3.5 py-2.5"
                    , placeholder "John Smith"
                    ]
                    []
                ]
            ]
        , div [ class "space-y-2" ]
            [ label [ for "email", class "block text-sm font-medium text-gray-700" ]
                [ text "Email" ]
            , div [ class "mt-1" ]
                [ input
                    [ type_ "email"
                    , id "email"
                    , value model.email
                    , onInput UpdateEmail
                    , class "shadow-sm focus:ring-[#03045E] focus:border-[#03045E] block w-full sm:text-sm border-gray-300 rounded-md px-3.5 py-2.5"
                    , placeholder "you@example.com"
                    ]
                    []
                ]
            ]
        , div [ class "space-y-2" ]
            [ label [ for "phone", class "block text-sm font-medium text-gray-700" ]
                [ text "Phone Number" ]
            , div [ class "mt-1" ]
                [ input
                    [ type_ "tel"
                    , id "phone"
                    , value model.displayPhone
                    , onInput UpdatePhone
                    , class "shadow-sm focus:ring-[#03045E] focus:border-[#03045E] block w-full sm:text-sm border-gray-300 rounded-md px-3.5 py-2.5"
                    , placeholder "(555) 555-5555"
                    ]
                    []
                ]
            ]
        , div [ class "space-y-2" ]
            [ label [ for "numAgents", class "block text-sm font-medium text-gray-700" ]
                [ text "Number of Agents" ]
            , div [ class "mt-1" ]
                [ input
                    [ type_ "number"
                    , id "numAgents"
                    , value model.numAgents
                    , onInput UpdateNumAgents
                    , class "shadow-sm focus:ring-[#03045E] focus:border-[#03045E] block w-full sm:text-sm border-gray-300 rounded-md px-3.5 py-2.5"
                    , Html.Attributes.min "1"
                    , placeholder "1"
                    ]
                    []
                ]
            ]
        , div [ class "space-y-2" ]
            [ label [ for "bookSize", class "block text-sm font-medium text-gray-700" ]
                [ text "Current Book Size" ]
            , div [ class "mt-1" ]
                [ input
                    [ type_ "number"
                    , id "bookSize"
                    , value model.bookSize
                    , onInput UpdateBookSize
                    , class "shadow-sm focus:ring-[#03045E] focus:border-[#03045E] block w-full sm:text-sm border-gray-300 rounded-md px-3.5 py-2.5"
                    , Html.Attributes.min "1"
                    , placeholder "100"
                    ]
                    []
                ]
            ]
        , if model.errorMessage /= Nothing then
            div [ class "text-red-600 text-sm" ]
                [ text (Maybe.withDefault "" model.errorMessage) ]

          else
            text ""
        , div []
            [ button
                [ type_ "submit"
                , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-[#03045E] hover:bg-[#1a1f5f] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#03045E]"
                , disabled (model.formState == Submitting)
                ]
                [ text
                    (if model.formState == Submitting then
                        "Submitting..."

                     else
                        "Join Waitlist"
                    )
                ]
            ]
        ]


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none


formatPhoneNumber : String -> String
formatPhoneNumber phone =
    let
        digits =
            String.filter Char.isDigit phone
                |> String.left 10

        len =
            String.length digits
    in
    if len == 0 then
        ""

    else if len <= 3 then
        "(" ++ digits

    else if len <= 6 then
        "(" ++ String.left 3 digits ++ ") " ++ String.dropLeft 3 digits

    else
        "(" ++ String.left 3 digits ++ ") " ++ String.slice 3 6 digits ++ "-" ++ String.dropLeft 6 digits

================
File: frontend/src/Walkthrough.elm
================
module Walkthrough exposing (Model, Msg(..), init, subscriptions, update, view)

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Http
import Json.Decode as Decode
import Svg
import Svg.Attributes


-- MODEL


type alias Model =
    { isOpen : Bool
    , isCompleting : Bool
    , error : Maybe String
    }


init : Bool -> ( Model, Cmd Msg )
init isOpen =
    ( { isOpen = isOpen
      , isCompleting = False
      , error = Nothing
      }
    , Cmd.none
    )



-- UPDATE


type Msg
    = CloseModalClicked
    | MarkWalkthroughCompleted
    | CompleteWalkthroughResponse (Result Http.Error ())
    | WalkthroughCompletedAndMarked
    | NoOp


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        CloseModalClicked ->
            ( { model | isOpen = False }, Cmd.none )

        MarkWalkthroughCompleted ->
            ( { model | isCompleting = True, error = Nothing }
            , markWalkthroughCompleted
            )

        CompleteWalkthroughResponse (Ok _) ->
            ( { model | isCompleting = False, isOpen = False }
            , Cmd.none
            )

        CompleteWalkthroughResponse (Err _) ->
            ( { model | isCompleting = False, error = Just "Failed to save walkthrough completion. Please try again." }
            , Cmd.none
            )

        WalkthroughCompletedAndMarked ->
            -- This message is handled by parent components
            ( model, Cmd.none )

        NoOp ->
            ( model, Cmd.none )


markWalkthroughCompleted : Cmd Msg
markWalkthroughCompleted =
    Http.post
        { url = "/api/profile/complete-walkthrough"
        , body = Http.emptyBody
        , expect = Http.expectWhatever CompleteWalkthroughResponse
        }



-- VIEW


view : Model -> Html Msg
view model =
    if model.isOpen then
        div []
            [ -- Modal backdrop
              div
                [ class "fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity z-40"
                , onClick CloseModalClicked
                ]
                []

            -- Modal content
            , div [ class "fixed inset-0 z-50 overflow-y-auto" ]
                [ div [ class "flex min-h-full items-end justify-center p-4 text-center sm:items-center sm:p-0" ]
                    [ div
                        [ class "relative transform overflow-hidden rounded-lg bg-white text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-4xl"
                        , Html.Events.stopPropagationOn "click" (Decode.succeed ( NoOp, True ))
                        ]
                        [ -- Modal header
                          div [ class "px-6 py-4 border-b border-gray-200 bg-[#03045E] text-white" ]
                            [ div [ class "flex items-center justify-between" ]
                                [ h2 [ class "text-2xl font-semibold" ]
                                    [ text "Welcome to Medicare Max" ]
                                , button
                                    [ type_ "button"
                                    , class "text-white hover:text-gray-200"
                                    , onClick CloseModalClicked
                                    ]
                                    [ Svg.svg
                                        [ Svg.Attributes.class "h-6 w-6"
                                        , Svg.Attributes.fill "none"
                                        , Svg.Attributes.viewBox "0 0 24 24"
                                        , Svg.Attributes.stroke "currentColor"
                                        ]
                                        [ Svg.path
                                            [ Svg.Attributes.strokeLinecap "round"
                                            , Svg.Attributes.strokeLinejoin "round"
                                            , Svg.Attributes.strokeWidth "2"
                                            , Svg.Attributes.d "M6 18L18 6M6 6l12 12"
                                            ]
                                            []
                                        ]
                                    ]
                                ]
                            ]

                        -- Modal body
                        , div [ class "p-6 max-h-[calc(100vh-200px)] overflow-y-auto" ]
                            [ -- Error message
                              case model.error of
                                Just errorMsg ->
                                    div [ class "mb-4 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded" ]
                                        [ text errorMsg ]

                                Nothing ->
                                    text ""

                            -- Content
                            , div [ class "mb-8 text-center" ]
                                [ h3 [ class "text-xl font-medium text-gray-800 mb-2" ]
                                    [ text "Get Started with Our Platform" ]
                                , p [ class "text-gray-600 max-w-2xl mx-auto" ]
                                    [ text "Watch this video walkthrough to learn how to use Medicare Max and make the most of its features." ]
                                ]

                            -- Video placeholder
                            , div [ class "mx-auto max-w-3xl bg-gray-100 rounded-lg p-6 aspect-video flex items-center justify-center mb-8" ]
                                [ div [ class "text-center" ]
                                    [ div [ class "text-6xl text-gray-400 mb-4" ]
                                        [ text "▶️" ]
                                    , p [ class "text-gray-500 font-medium" ]
                                        [ text "Video Walkthrough Coming Soon" ]
                                    , p [ class "text-gray-400 text-sm mt-2" ]
                                        [ text "This video will demonstrate how to use the Medicare Max platform" ]
                                    ]
                                ]

                            -- Quick Start Guide
                            , div [ class "max-w-3xl mx-auto" ]
                                [ h4 [ class "text-lg font-medium text-gray-800 mb-4" ]
                                    [ text "Quick Start Guide" ]
                                , div [ class "bg-blue-50 rounded-lg p-5 border border-blue-100" ]
                                    [ ul [ class "space-y-4" ]
                                        [ li [ class "flex" ]
                                            [ div [ class "shrink-0 flex items-center justify-center w-8 h-8 bg-blue-600 text-white rounded-full mr-3" ]
                                                [ text "1" ]
                                            , div []
                                                [ h5 [ class "font-medium text-blue-800" ]
                                                    [ text "Set Up Your Profile" ]
                                                , p [ class "text-blue-700 mt-1 text-sm" ]
                                                    [ text "Complete your profile information to personalize your experience." ]
                                                ]
                                            ]
                                        , li [ class "flex" ]
                                            [ div [ class "shrink-0 flex items-center justify-center w-8 h-8 bg-blue-600 text-white rounded-full mr-3" ]
                                                [ text "2" ]
                                            , div []
                                                [ h5 [ class "font-medium text-blue-800" ]
                                                    [ text "Add Clients" ]
                                                , p [ class "text-blue-700 mt-1 text-sm" ]
                                                    [ text "Start adding your clients to manage their information and policies." ]
                                                ]
                                            ]
                                        , li [ class "flex" ]
                                            [ div [ class "shrink-0 flex items-center justify-center w-8 h-8 bg-blue-600 text-white rounded-full mr-3" ]
                                                [ text "3" ]
                                            , div []
                                                [ h5 [ class "font-medium text-blue-800" ]
                                                    [ text "Generate Quotes" ]
                                                , p [ class "text-blue-700 mt-1 text-sm" ]
                                                    [ text "Use our quoting tools to find the best options for your clients." ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]

                        -- Modal footer
                        , div [ class "bg-gray-50 px-6 py-4 sm:flex sm:flex-row-reverse" ]
                            [ button
                                [ type_ "button"
                                , class "w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                                , onClick MarkWalkthroughCompleted
                                , disabled model.isCompleting
                                ]
                                [ text
                                    (if model.isCompleting then
                                        "Saving..."

                                     else
                                        "Got it, Don't Show Again"
                                    )
                                ]
                            , button
                                [ type_ "button"
                                , class "mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:w-auto sm:text-sm"
                                , onClick CloseModalClicked
                                ]
                                [ text "Close" ]
                            ]
                        ]
                    ]
                ]
            ]

    else
        text ""





-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none

================
File: frontend/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: frontend/elm-test.html
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Elm Test</title>
</head>
<body>
  <div id="app"></div>

  <script src="/dist/main.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      try {
        console.log('Trying to initialize Elm directly');
        
        setTimeout(function() {
          if (typeof Elm !== 'undefined' && Elm.Main) {
            console.log('Elm.Main available:', !!Elm.Main);
            console.log('Elm.Main.init available:', !!(Elm.Main && typeof Elm.Main.init === 'function'));
            
            // Create flags properly
            var flags = { initialSession: null };
            console.log('Flags:', flags);
            
            // Initialize Elm
            var app = Elm.Main.init({
              node: document.getElementById('app'),
              flags: flags
            });
            
            console.log('Elm initialization successful!');
          } else {
            console.error('Elm object is not available on the window');
          }
        }, 1000);
      } catch (e) {
        console.error('Direct Elm initialization error:', e);
      }
    });
  </script>
</body>
</html>

================
File: frontend/elm.json
================
{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "BrianHicks/elm-csv": "4.0.1",
            "NoRedInk/elm-json-decode-pipeline": "1.0.1",
            "elm/browser": "1.0.2",
            "elm/bytes": "1.0.8",
            "elm/core": "1.0.5",
            "elm/file": "1.0.5",
            "elm/html": "1.0.0",
            "elm/http": "2.0.0",
            "elm/json": "1.1.3",
            "elm/parser": "1.1.0",
            "elm/random": "1.0.0",
            "elm/regex": "1.0.0",
            "elm/svg": "1.0.1",
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm-community/list-extra": "8.7.0",
            "justinmimbs/date": "4.1.0",
            "justinmimbs/time-extra": "1.2.0",
            "terezka/elm-charts": "4.0.0",
            "tripokey/elm-fuzzy": "5.2.1"
        },
        "indirect": {
            "K-Adam/elm-dom": "1.0.0",
            "danhandrea/elm-time-extra": "1.1.0",
            "elm/virtual-dom": "1.0.3",
            "myrho/elm-round": "1.0.5",
            "ryan-haskell/date-format": "1.0.0",
            "terezka/intervals": "2.0.2"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}

================
File: frontend/index.html
================
<!doctype html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<link rel="icon" type="image/png" href="/images/max.png" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Medicare Max</title>
	<!-- Add meta tags for description, keywords, and author -->
	<meta name="description"
		content="Medicare Max: Your trusted platform for Medicare Supplement plan selection, eligibility checks, and personalized quotes.">
	<meta name="keywords" content="Medicare, software, technology, health insurance, Medicare plans, eligibility, quotes, senior healthcare, meditcech, insuretech">
	<meta name="author" content="Medicare Max Team">
	<script async defer src="https://tools.luckyorange.com/core/lo.js?site-id=ebb797c5"></script>
	<!-- Fathom - beautiful, simple website analytics -->
	<script src="https://cdn.usefathom.com/script.js" data-spa="auto" data-site="DCTYIHCU" defer></script> 
	<!-- / Fathom -->
</head>

<body>
	<div id="app"></div>
	<script type="module" src="/src/main.ts"></script>
</body>

</html>

================
File: frontend/package.json
================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "bunx --bun vite",
    "build": "tsc && bunx --bun vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "typescript": "~5.6.2",
    "vite": "^6.0.5",
    "vite-plugin-elm": "^3.0.1"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.0.3",
    "chartist": "^1.3.1",
    "stripe": "^18.0.0",
    "tailwindcss": "^4.0.3",
    "tailwindcss-animate": "^1.0.7"
  }
}

================
File: frontend/tailwind.config.js.copy
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx,elm}",
  ],
  theme: {
    extend: {
      colors: {
        'cyber': {
          'primary': '#00fff5',    // Bright cyan
          'secondary': '#ff00ff',  // Magenta
          'accent': '#f700ff',     // Hot pink
          'dark': '#0d1117',       // Deep space black
          'light': '#1c1c1c',      // Lighter black
          'error': '#ff0044',      // Neon red
          'success': '#00ff9f',    // Neon green
          'text': '#ffffff',       // White text
          'muted': '#8b8b8b',      // Muted text
        },
        'gradient': {
          'start': '#00fff5',
          'end': '#ff00ff',
        }
      },
      boxShadow: {
        'cyber': '0 0 10px rgba(0, 255, 245, 0.3)',
        'cyber-hover': '0 0 20px rgba(0, 255, 245, 0.5)',
        'cyber-error': '0 0 10px rgba(255, 0, 68, 0.3)',
      },
      animation: {
        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
      }
    },
  },
  plugins: [],
}

================
File: frontend/temp_bracket.txt
================
}

================
File: frontend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: frontend/vite.config.ts
================
import { defineConfig } from 'vite'
import elmPlugin from 'vite-plugin-elm'
import { resolve } from 'path'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [
    elmPlugin({
      // Set a custom temp directory inside your project
      cwd: resolve(__dirname, 'elm-temp')
    }),
    tailwindcss(),
  ],
  resolve: {
    extensions: ['.ts', '.js', '.elm']
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
        secure: false,
        configure: (proxy, _options) => {
          proxy.on('error', (err) => {
            console.log('proxy error', err);
          });
          proxy.on('proxyReq', (proxyReq) => {
            console.log('Sending Request:', proxyReq.method, proxyReq.path);
          });
          proxy.on('proxyRes', (proxyRes) => {
            console.log('Received Response:', proxyRes.statusCode);
          });
        }
      }
    },
    allowedHosts: ['localhost', '127.0.0.1', 'medicaremax.ngrok.dev']
  },
  build: {
    outDir: '../dist',
    emptyOutDir: true,
    assetsDir: 'assets',
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html')
      }
    }
  }
})

================
File: migrations/0005_add_org_slug.sql
================
-- Add slug column to organizations table
ALTER TABLE organizations ADD COLUMN slug TEXT DEFAULT NULL;

-- Update existing organizations with a default slug based on name
UPDATE organizations 
SET slug = LOWER(REPLACE(name, ' ', '-'));

-- Make slug NOT NULL after populating data
ALTER TABLE organizations 
ALTER COLUMN slug SET NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS idx_organizations_slug 
ON organizations(slug);

================
File: migrations/0005_fresh_start.sql
================
-- Drop all existing tables
DROP TABLE IF EXISTS sessions;
DROP TABLE IF EXISTS magic_links;
DROP TABLE IF EXISTS contacts;
DROP TABLE IF EXISTS agents;
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS subscription_tiers;
DROP TABLE IF EXISTS organizations;

-- Create fresh tables
CREATE TABLE organizations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    slug TEXT NOT NULL,
    subscription_tier TEXT NOT NULL DEFAULT 'basic',
    agent_limit INTEGER NOT NULL DEFAULT 5,
    contact_limit INTEGER NOT NULL DEFAULT 100,
    stripe_customer_id TEXT,
    stripe_subscription_id TEXT,
    settings JSON,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(slug)
);

CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    organization_id INTEGER NOT NULL,
    role TEXT CHECK(role IN ('admin', 'agent')) NOT NULL,
    is_active BOOLEAN DEFAULT true,
    last_login DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (organization_id) REFERENCES organizations(id)
);

CREATE TABLE magic_links (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    token TEXT UNIQUE NOT NULL,
    email TEXT NOT NULL,
    organization_id INTEGER NOT NULL,
    expires_at DATETIME NOT NULL,
    used_at DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (organization_id) REFERENCES organizations(id)
);

CREATE TABLE agents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    organization_id INTEGER NOT NULL,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL,
    phone TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (organization_id) REFERENCES organizations(id),
    UNIQUE(email, organization_id)
);

CREATE TABLE contacts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    organization_id INTEGER NOT NULL,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL,
    current_carrier TEXT,
    plan_type TEXT,
    effective_date DATE,
    birth_date DATE,
    tobacco_user BOOLEAN DEFAULT FALSE,
    gender TEXT,
    state TEXT,
    zip_code TEXT,
    agent_id INTEGER,
    last_emailed DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (agent_id) REFERENCES agents(id),
    FOREIGN KEY (organization_id) REFERENCES organizations(id)
);

CREATE TABLE subscription_tiers (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    agent_limit INTEGER NOT NULL,
    contact_limit INTEGER NOT NULL,
    price_monthly INTEGER NOT NULL,
    price_yearly INTEGER NOT NULL,
    features JSON NOT NULL
);

CREATE TABLE sessions (
    id TEXT PRIMARY KEY,
    user_id INTEGER NOT NULL,
    expires_at DATETIME NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Insert default subscription tiers
INSERT INTO subscription_tiers (id, name, agent_limit, contact_limit, price_monthly, price_yearly, features)
VALUES 
    ('basic', 'Basic', 5, 100, 2900, 29000, '{"emailAutomation": false, "customBranding": false}'),
    ('pro', 'Professional', 20, 1000, 7900, 79000, '{"emailAutomation": true, "customBranding": false}'),
    ('enterprise', 'Enterprise', 100, 10000, 19900, 199000, '{"emailAutomation": true, "customBranding": true}');

-- Create demo organization
INSERT INTO organizations (name, slug, subscription_tier)
VALUES ('Demo Organization', 'demo-org', 'basic');

================
File: migrations/0006_add_agent_settings.sql
================
CREATE TABLE agent_settings (
    id SERIAL PRIMARY KEY,
    agent_id INTEGER NOT NULL REFERENCES users(id),
    state_licenses TEXT[], -- Array of state codes
    carrier_contracts TEXT[], -- Array of carrier ids
    state_carrier_settings JSONB, -- Stores state->carrier->settings mapping
    email_send_birthday BOOLEAN DEFAULT false,
    email_send_policy_anniversary BOOLEAN DEFAULT false,
    email_send_aep BOOLEAN DEFAULT false,
    smart_send_enabled BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(agent_id)
);

-- Trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_agent_settings_updated_at
    BEFORE UPDATE ON agent_settings
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

================
File: migrations/0006_add_demo_user.sql
================
-- Add user entry for the demo agent
INSERT INTO users (email, organization_id, role)
SELECT 
    'reub.brooks@gmail.com',
    o.id,
    'agent'
FROM organizations o 
WHERE o.slug = 'demo-org';

================
File: migrations/0007_organization_and_agent_settings.sql
================
-- Rename existing settings column to org_settings
ALTER TABLE organizations 
RENAME COLUMN settings TO org_settings;

-- Create agent_settings table
CREATE TABLE agent_settings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    agent_id INTEGER NOT NULL REFERENCES users(id),
    inherit_org_settings BOOLEAN DEFAULT 1,
    settings TEXT NOT NULL DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(agent_id)
);

-- Trigger to update updated_at
CREATE TRIGGER update_agent_settings_timestamp
AFTER UPDATE ON agent_settings
BEGIN
    UPDATE agent_settings SET updated_at = CURRENT_TIMESTAMP
    WHERE id = NEW.id;
END;

================
File: migrations/0007_verify_user.sql
================
-- Verify user exists with correct data
SELECT u.*, o.slug 
FROM users u
JOIN organizations o ON u.organization_id = o.id
WHERE LOWER(u.email) = LOWER('reub.brooks@gmail.com')
AND o.slug = 'demo-org';

================
File: migrations/0008_recommended_state_carrier_settings.sql
================
CREATE TABLE guaranteed_issue_recommendations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    state TEXT NOT NULL COLLATE NOCASE,
    carrier TEXT NOT NULL COLLATE NOCASE,
    created_at TEXT DEFAULT (datetime('now')),
    updated_at TEXT DEFAULT (datetime('now')),
    UNIQUE(state, carrier)
);

CREATE TRIGGER update_gi_recommendations_timestamp 
AFTER UPDATE ON guaranteed_issue_recommendations
BEGIN
    UPDATE guaranteed_issue_recommendations 
    SET updated_at = datetime('now')
    WHERE id = NEW.id;
END;

================
File: migrations/0009_carriers_table.sql
================
CREATE TABLE carriers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE COLLATE NOCASE,
    created_at TEXT DEFAULT (datetime('now')),
    updated_at TEXT DEFAULT (datetime('now'))
);

-- Initial carrier data
INSERT INTO carriers (name) VALUES 
    ('Aetna'),
    ('Humana'),
    ('UnitedHealthcare'),
    ('Cigna'),
    ('Aflac'),
    ('Allstate'),
    ('Mutual of Omaha'),
    ('Ace Chubb');

CREATE TRIGGER update_carriers_timestamp 
AFTER UPDATE ON carriers
BEGIN
    UPDATE carriers 
    SET updated_at = datetime('now')
    WHERE id = NEW.id;
END;

================
File: migrations/0009_organization_turso_databases.sql
================
-- Add Turso database info to organizations table
ALTER TABLE organizations ADD COLUMN turso_db_url TEXT;
ALTER TABLE organizations ADD COLUMN turso_auth_token TEXT;

-- Remove contacts table since it will move to org-specific Turso DBs
DROP TABLE IF EXISTS contacts;

================
File: migrations/0010_add_user_names.sql
================
ALTER TABLE users ADD COLUMN first_name TEXT NOT NULL DEFAULT '';
ALTER TABLE users ADD COLUMN last_name TEXT NOT NULL DEFAULT '';

================
File: migrations/0011_remove_verification_tokens.sql
================
DROP TABLE IF EXISTS verification_tokens; 
DROP TABLE IF EXISTS magic_links;

================
File: migrations/0012_default_user_active.sql
================
-- Set default value for is_active to 1 in users table
ALTER TABLE users ADD COLUMN temp_is_active INTEGER NOT NULL DEFAULT 1;
UPDATE users SET temp_is_active = is_active;
ALTER TABLE users DROP COLUMN is_active;
ALTER TABLE users RENAME COLUMN temp_is_active TO is_active;

-- Update existing users to be active
UPDATE users SET is_active = 1 WHERE email = 'reuben.brooks@medicaremax.ai';

================
File: migrations/0013_add_org_updated_at.sql
================
-- Add updated_at column to organizations table
ALTER TABLE organizations ADD COLUMN updated_at TEXT;

-- Set existing rows to have current timestamp
UPDATE organizations 
SET updated_at = DATETIME('now')
WHERE updated_at IS NULL;

================
File: migrations/0014_add_phone_to_users.sql
================
-- First, let's check if phone column exists
SELECT sql FROM sqlite_master WHERE type='table' AND name='users';

-- Drop users_new if it exists from a failed migration
DROP TABLE IF EXISTS users_new;

-- Update existing users to have a default phone value
UPDATE users 
SET phone = ''
WHERE phone IS NULL;

-- Enable foreign key support
PRAGMA foreign_keys=OFF;

-- Create new table with NOT NULL constraint on phone
CREATE TABLE users_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    organization_id INTEGER NOT NULL,
    role TEXT CHECK(role IN ('admin', 'agent')) NOT NULL,
    last_login DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    first_name TEXT NOT NULL DEFAULT '',
    last_name TEXT NOT NULL DEFAULT '',
    is_active INTEGER NOT NULL DEFAULT 1,
    phone TEXT NOT NULL DEFAULT '',
    FOREIGN KEY (organization_id) REFERENCES organizations(id)
);

-- Copy the data
INSERT INTO users_new 
SELECT id, email, organization_id, role, last_login, created_at, 
       first_name, last_name, is_active, phone
FROM users;

-- Drop the old table
DROP TABLE users;

-- Rename the new table
ALTER TABLE users_new RENAME TO users;

-- Re-enable foreign key support
PRAGMA foreign_keys=ON;

================
File: migrations/0015_update_user_roles.sql
================
-- First, let's check if the table exists
SELECT sql FROM sqlite_master WHERE type='table' AND name='users';

-- Drop users_new if it exists from a failed migration
DROP TABLE IF EXISTS users_new;

-- Enable foreign key support
PRAGMA foreign_keys=OFF;

-- Create new table with updated role constraint
CREATE TABLE users_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    organization_id INTEGER NOT NULL,
    role TEXT CHECK(role IN ('admin', 'agent', 'admin_agent')) NOT NULL,
    last_login DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    first_name TEXT NOT NULL DEFAULT '',
    last_name TEXT NOT NULL DEFAULT '',
    is_active INTEGER NOT NULL DEFAULT 1,
    phone TEXT NOT NULL DEFAULT '',
    FOREIGN KEY (organization_id) REFERENCES organizations(id)
);

-- Copy the data
INSERT INTO users_new 
SELECT id, email, organization_id, role, last_login, created_at, 
       first_name, last_name, is_active, phone
FROM users;

-- Drop the old table
DROP TABLE users;

-- Rename the new table
ALTER TABLE users_new RENAME TO users;

-- Re-enable foreign key support
PRAGMA foreign_keys=ON;

================
File: migrations/0016_fix_schema.sql
================
-- Drop unused tables
DROP TABLE IF EXISTS agents;
DROP TABLE IF EXISTS migrations;
DROP TABLE IF EXISTS verification_tokens;

-- Drop any existing triggers
DROP TRIGGER IF EXISTS update_contacts_timestamp;

-- Drop and recreate contacts table
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL,
    current_carrier TEXT,
    plan_type TEXT,
    effective_date DATE,
    birth_date DATE,
    tobacco_user BOOLEAN DEFAULT FALSE,
    gender TEXT,
    state TEXT,
    zip_code TEXT,
    agent_id INTEGER,
    last_emailed DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (agent_id) REFERENCES users(id)
);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email);
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);

================
File: migrations/0017_update_user_roles.sql
================
-- First, let's check if the table exists
SELECT sql FROM sqlite_master WHERE type='table' AND name='users';

-- Drop users_new if it exists from a failed migration
DROP TABLE IF EXISTS users_new;

-- Enable foreign key support
PRAGMA foreign_keys=OFF;

-- Create new table with updated role constraint
CREATE TABLE users_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    organization_id INTEGER NOT NULL,
    role TEXT CHECK(role IN ('admin', 'agent', 'admin_agent')) NOT NULL,
    last_login DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    first_name TEXT NOT NULL DEFAULT '',
    last_name TEXT NOT NULL DEFAULT '',
    is_active INTEGER NOT NULL DEFAULT 1,
    phone TEXT NOT NULL DEFAULT '',
    FOREIGN KEY (organization_id) REFERENCES organizations(id)
);

-- Copy the data
INSERT INTO users_new 
SELECT id, email, organization_id, role, last_login, created_at, 
       first_name, last_name, is_active, phone
FROM users;

-- Drop the old table
DROP TABLE users;

-- Rename the new table
ALTER TABLE users_new RENAME TO users;

-- Re-enable foreign key support
PRAGMA foreign_keys=ON;

================
File: migrations/0018_brand_settings.sql
================
CREATE TABLE brand_settings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    organization_id INTEGER NOT NULL,
    brand_name TEXT NOT NULL DEFAULT '',
    primary_color TEXT NOT NULL DEFAULT '#6B46C1',
    secondary_color TEXT NOT NULL DEFAULT '#9F7AEA',
    logo_data TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (organization_id) REFERENCES organizations(id),
    UNIQUE(organization_id)
);

CREATE TRIGGER update_brand_settings_timestamp 
AFTER UPDATE ON brand_settings
BEGIN
    UPDATE brand_settings 
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = NEW.id;
END;

================
File: migrations/0019_add_user_role_booleans.sql
================
-- First, let's check if the table exists
SELECT sql FROM sqlite_master WHERE type='table' AND name='users';

-- Drop users_new if it exists from a failed migration
DROP TABLE IF EXISTS users_new;

-- Enable foreign key support
PRAGMA foreign_keys=OFF;

-- Create new table with is_admin and is_agent columns
CREATE TABLE users_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    organization_id INTEGER NOT NULL,
    is_admin BOOLEAN NOT NULL DEFAULT 0,
    is_agent BOOLEAN NOT NULL DEFAULT 0,
    last_login DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    first_name TEXT NOT NULL DEFAULT '',
    last_name TEXT NOT NULL DEFAULT '',
    is_active INTEGER NOT NULL DEFAULT 1,
    phone TEXT NOT NULL DEFAULT '',
    FOREIGN KEY (organization_id) REFERENCES organizations(id)
);

-- Copy the data with role conversion
INSERT INTO users_new 
SELECT 
    id, 
    email, 
    organization_id,
    CASE 
        WHEN role = 'admin' THEN 1
        WHEN role = 'admin_agent' THEN 1
        ELSE 0
    END as is_admin,
    CASE 
        WHEN role = 'agent' THEN 1
        WHEN role = 'admin_agent' THEN 1
        ELSE 0
    END as is_agent,
    last_login,
    created_at,
    first_name,
    last_name,
    is_active,
    phone
FROM users;

-- Drop the old table
DROP TABLE users;

-- Rename the new table
ALTER TABLE users_new RENAME TO users;

-- Create indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_org_id ON users(organization_id);

-- Re-enable foreign key support
PRAGMA foreign_keys=ON;

================
File: migrations/002_add_email_and_agents.sql
================
-- Create agents table
CREATE TABLE IF NOT EXISTS agents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    phone TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Create trigger for agents updated_at
CREATE TRIGGER IF NOT EXISTS update_agents_timestamp 
AFTER UPDATE ON agents
BEGIN
    UPDATE agents SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
END;

-- Create temporary table with new schema
CREATE TABLE contacts_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL,
    current_carrier TEXT NOT NULL,
    plan_type TEXT NOT NULL,
    effective_date DATE NOT NULL,
    birth_date DATE NOT NULL,
    tobacco_user BOOLEAN NOT NULL DEFAULT FALSE,
    gender TEXT CHECK(gender IN ('M', 'F')) NOT NULL,
    state TEXT NOT NULL,
    zip_code TEXT NOT NULL,
    agent_id INTEGER,
    last_emailed_date DATE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (agent_id) REFERENCES agents(id)
);

-- Copy existing data with generated email addresses
INSERT INTO contacts_new (
    id, first_name, last_name, email, current_carrier,
    plan_type, effective_date, birth_date, tobacco_user,
    gender, state, zip_code, last_emailed_date, created_at,
    updated_at
)
SELECT 
    id, first_name, last_name,
    lower(first_name || '.' || last_name || '@example.com') as email,
    current_carrier, plan_type, effective_date, birth_date,
    tobacco_user, gender, state, zip_code, last_emailed_date,
    created_at, updated_at
FROM contacts;

-- Drop old table and rename new one
DROP TABLE contacts;
ALTER TABLE contacts_new RENAME TO contacts;

-- Recreate the updated_at trigger for contacts
CREATE TRIGGER IF NOT EXISTS update_contacts_timestamp 
AFTER UPDATE ON contacts
BEGIN
    UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
END;

-- Create indexes
CREATE INDEX idx_contacts_email ON contacts(email);
CREATE INDEX idx_contacts_agent_id ON contacts(agent_id);
CREATE INDEX idx_agents_email ON agents(email);

================
File: migrations/0020_fix_user_roles.sql
================
-- Update any existing users that might have incorrect is_admin/is_agent values
UPDATE users
SET is_admin = 1, is_agent = 1
WHERE is_admin = 0 AND is_agent = 0;

-- Make sure admin_agent users have both flags set
UPDATE users
SET is_admin = 1, is_agent = 1
WHERE is_admin = 1 OR is_agent = 1;

-- Set admin-only users
UPDATE users
SET is_admin = 1, is_agent = 0
WHERE email LIKE '%@medicaremax.ai';

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_is_admin ON users(is_admin);
CREATE INDEX IF NOT EXISTS idx_users_is_agent ON users(is_agent);

================
File: migrations/0021_add_carrier_aliases.sql
================
-- Add aliases column to carriers table
ALTER TABLE carriers ADD COLUMN aliases JSON DEFAULT '[]';

-- Update existing carriers with known aliases
UPDATE carriers 
SET aliases = '["UHC", "UnitedHealthcare", "AARP"]'
WHERE name = 'United Healthcare';

UPDATE carriers 
SET aliases = '["MOO"]'
WHERE name = 'Mutual of Omaha';

UPDATE carriers 
SET aliases = '["Ace", "Chubb"]'
WHERE name = 'Ace Chubb';

================
File: migrations/0022_add_subscription_status.sql
================
-- Add subscription status fields to organizations table
ALTER TABLE organizations ADD COLUMN subscription_status TEXT NOT NULL DEFAULT 'active';
ALTER TABLE organizations ADD COLUMN billing_cycle_end DATETIME;
ALTER TABLE organizations ADD COLUMN trial_end_date DATETIME;
ALTER TABLE organizations ADD COLUMN payment_failure_count INTEGER NOT NULL DEFAULT 0;
ALTER TABLE organizations ADD COLUMN last_payment_date DATETIME;
ALTER TABLE organizations ADD COLUMN extra_agents INTEGER NOT NULL DEFAULT 0;
ALTER TABLE organizations ADD COLUMN extra_contacts INTEGER NOT NULL DEFAULT 0;

-- Create a view for organization status
CREATE VIEW IF NOT EXISTS organization_status AS
SELECT 
    o.id,
    o.slug,
    o.name,
    o.subscription_tier,
    o.subscription_status,
    o.agent_limit,
    o.contact_limit,
    o.extra_agents,
    o.extra_contacts,
    o.billing_cycle_end,
    o.payment_failure_count,
    (SELECT COUNT(*) FROM agents WHERE organization_id = o.id) as current_agent_count,
    (SELECT COUNT(*) FROM contacts WHERE organization_id = o.id) as current_contact_count,
    CASE 
        WHEN o.subscription_status != 'active' THEN 'inactive'
        WHEN (SELECT COUNT(*) FROM agents WHERE organization_id = o.id) > (o.agent_limit + o.extra_agents) THEN 'agent_limit_exceeded'
        WHEN (SELECT COUNT(*) FROM contacts WHERE organization_id = o.id) > (o.contact_limit + o.extra_contacts) THEN 'contact_limit_exceeded'
        ELSE 'good_standing'
    END as account_status
FROM organizations o;

================
File: migrations/0025_add_default_agent.sql
================
-- Add default_agent_id to organizations table
ALTER TABLE organizations ADD COLUMN default_agent_id INTEGER REFERENCES users(id);

-- Add index for faster lookups
CREATE INDEX IF NOT EXISTS idx_organizations_default_agent ON organizations(default_agent_id);

================
File: migrations/0026_add_booking_link_to_users.sql
================
-- Add booking_link column to users table
ALTER TABLE users ADD COLUMN booking_link TEXT DEFAULT '';

================
File: migrations/0027_add_signature_to_users.sql
================
-- Add signature column to users table
ALTER TABLE users ADD COLUMN signature TEXT DEFAULT '';

================
File: migrations/20240227_add_aep_request_columns.sql
================
-- Add AEP request columns to contacts table
ALTER TABLE contacts ADD COLUMN aep_request BOOLEAN DEFAULT FALSE;
ALTER TABLE contacts ADD COLUMN aep_request_date DATETIME;

================
File: migrations/20240325_fix_contacts_status.sql
================
-- Temporarily disable foreign key constraints
PRAGMA foreign_keys = OFF;

-- Drop any leftover tables/views from previous failed migrations
DROP TABLE IF EXISTS contacts_new;
DROP VIEW IF EXISTS v_contact_stats;

-- Create contacts table if it doesn't exist
CREATE TABLE IF NOT EXISTS contacts (
  id INTEGER PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT NOT NULL,
  current_carrier TEXT,
  plan_type TEXT,
  effective_date TEXT NOT NULL,
  birth_date TEXT NOT NULL,
  tobacco_user BOOLEAN NOT NULL,
  gender TEXT NOT NULL,
  state TEXT NOT NULL,
  zip_code TEXT NOT NULL,
  agent_id INTEGER,
  last_emailed TEXT,
  phone_number TEXT NOT NULL DEFAULT '',
  status TEXT NOT NULL DEFAULT '',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  aep_request BOOLEAN DEFAULT FALSE,
  aep_request_date DATETIME
);

-- Create new contacts table with proper constraints
CREATE TABLE contacts_new (
  id INTEGER PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT NOT NULL,
  current_carrier TEXT,
  plan_type TEXT,
  effective_date TEXT NOT NULL,
  birth_date TEXT NOT NULL,
  tobacco_user BOOLEAN NOT NULL,
  gender TEXT NOT NULL,
  state TEXT NOT NULL,
  zip_code TEXT NOT NULL,
  agent_id INTEGER,
  last_emailed TEXT,
  phone_number TEXT NOT NULL DEFAULT '',
  status TEXT NOT NULL DEFAULT '',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  aep_request BOOLEAN DEFAULT FALSE,
  aep_request_date DATETIME
);

-- Copy data from old table to new table, handling missing columns
INSERT INTO contacts_new (
  id,
  first_name,
  last_name,
  email,
  current_carrier,
  plan_type,
  effective_date,
  birth_date,
  tobacco_user,
  gender,
  state,
  zip_code,
  agent_id,
  last_emailed,
  phone_number,
  status,
  created_at,
  aep_request,
  aep_request_date
)
SELECT 
  id,
  first_name,
  last_name,
  email,
  current_carrier,
  plan_type,
  effective_date,
  birth_date,
  tobacco_user,
  gender,
  state,
  zip_code,
  agent_id,
  NULL as last_emailed,
  '' as phone_number,
  '' as status,
  CURRENT_TIMESTAMP as created_at,
  FALSE as aep_request,
  NULL as aep_request_date
FROM contacts;

-- Drop old contacts table and rename new one
DROP TABLE contacts;
ALTER TABLE contacts_new RENAME TO contacts;

-- Create indices for better performance
CREATE INDEX IF NOT EXISTS idx_contacts_agent_id ON contacts(agent_id);
CREATE INDEX IF NOT EXISTS idx_contacts_status ON contacts(status);
CREATE INDEX IF NOT EXISTS idx_contacts_aep_request ON contacts(aep_request);

-- Recreate the view
CREATE VIEW v_contact_stats AS
WITH contact_metrics AS (
    SELECT 
        agent_id,
        current_carrier,
        state,
        COUNT(*) as total_contacts,
        SUM(CASE WHEN last_emailed IS NOT NULL THEN 1 ELSE 0 END) as contacted_count,
        SUM(CASE WHEN tobacco_user = 1 THEN 1 ELSE 0 END) as tobacco_users,
        SUM(CASE WHEN plan_type IS NOT NULL THEN 1 ELSE 0 END) as with_plan_type
    FROM contacts
    GROUP BY agent_id, current_carrier, state
)
SELECT 
    cm.*,
    (SELECT COUNT(DISTINCT current_carrier) FROM contacts WHERE agent_id = cm.agent_id) as unique_carriers,
    (SELECT COUNT(DISTINCT state) FROM contacts WHERE agent_id = cm.agent_id) as unique_states
FROM contact_metrics cm;

-- Re-enable foreign key constraints
PRAGMA foreign_keys = ON;

================
File: migrations/20250329_fix_email_unique_constraint.sql
================
-- Migration to fix email unique constraint for proper ON CONFLICT handling
-- Date: 2025-03-29

-- Turn off foreign key enforcement temporarily for migration
PRAGMA foreign_keys = OFF;

-- Diagnostic step: Get table information to debug schema issues
PRAGMA table_info(contacts);
SELECT name, sql FROM sqlite_master WHERE type='table' AND name='contacts';
SELECT name, sql FROM sqlite_master WHERE type='table' AND name='contacts_backup';
SELECT name, sql FROM sqlite_master WHERE type='table' AND name='eligibility_answers';

-- Check if updated_at column exists in contacts
SELECT COUNT(*) as has_updated_at_column FROM pragma_table_info('contacts') WHERE name = 'updated_at';

-- Step 1: Check if contacts table exists
SELECT name FROM sqlite_master WHERE type='table' AND name='contacts';

-- Save view definitions that depend on contacts table
-- Get the SQL for the v_contact_stats view if it exists
SELECT sql FROM sqlite_master WHERE type='view' AND name='v_contact_stats';

-- Drop any views that depend on the contacts table
DROP VIEW IF EXISTS v_contact_stats;

-- Drop dependent tables temporarily (we'll recreate them later)
-- Store their schema first
SELECT sql FROM sqlite_master WHERE type='table' AND name='eligibility_answers';
CREATE TABLE IF NOT EXISTS schema_backup (
  table_name TEXT PRIMARY KEY,
  table_sql TEXT,
  data_backup_table TEXT
);

-- Store schema info for dependent tables
INSERT OR REPLACE INTO schema_backup (table_name, table_sql)
SELECT 'eligibility_answers', sql FROM sqlite_master 
WHERE type='table' AND name='eligibility_answers';

-- Create backup for eligibility_answers if it exists
CREATE TABLE IF NOT EXISTS eligibility_answers_backup AS 
SELECT * FROM eligibility_answers
WHERE EXISTS (SELECT 1 FROM sqlite_master WHERE type='table' AND name='eligibility_answers');

-- Update schema_backup to record the data backup
UPDATE schema_backup SET data_backup_table = 'eligibility_answers_backup'
WHERE table_name = 'eligibility_answers';

-- Now drop the dependent table to avoid foreign key issues
DROP TABLE IF EXISTS eligibility_answers;

-- Check if updated_at column exists in contacts
SELECT COUNT(*) as has_updated_at_column FROM pragma_table_info('contacts') WHERE name = 'updated_at';

-- Add updated_at column to contacts if it doesn't exist
-- Since SQLite doesn't have IF NOT EXISTS for ADD COLUMN in older versions, we need a workaround
-- We'll use a transaction and a separate table to store the results

-- First approach: Try-catch with transaction
BEGIN TRANSACTION;
  -- This will succeed if the column doesn't exist and fail if it does
  SELECT CASE 
    WHEN NOT EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'updated_at')
    THEN 'Adding updated_at column'
    ELSE 'Column already exists'
  END as status;
  
  -- Only try to add the column if it doesn't exist
  SELECT CASE 
    WHEN NOT EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'updated_at')
    THEN (
      -- This is a dummy statement to make the syntax valid - the actual ALTER TABLE is below
      SELECT 'Will add column'
    ) 
    ELSE (
      -- This is a dummy statement to make the syntax valid
      SELECT 'Will skip adding column'
    )
  END as action;
COMMIT;

-- Now we can safely execute the ALTER TABLE outside the transaction
-- It will error if the column already exists, but we'll catch that in the script
BEGIN;
  SELECT 'Attempting to add updated_at column if needed' as operation;
  SELECT CASE 
    WHEN NOT EXISTS(SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'updated_at')
    THEN 'true'
    ELSE 'false'
  END as should_add_column;
COMMIT;

-- Step 2: If contacts table doesn't exist, create it from scratch
CREATE TABLE IF NOT EXISTS contacts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT NOT NULL UNIQUE,
  current_carrier TEXT NOT NULL,
  plan_type TEXT NOT NULL,
  effective_date TEXT NOT NULL,
  birth_date TEXT NOT NULL,
  tobacco_user INTEGER NOT NULL,
  gender TEXT NOT NULL,
  state TEXT NOT NULL,
  zip_code TEXT NOT NULL,
  agent_id INTEGER,
  last_emailed DATETIME,
  phone_number TEXT NOT NULL DEFAULT '',
  status TEXT NOT NULL DEFAULT '',
  aep_request INTEGER DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Check if we need to restore from backup
SELECT name FROM sqlite_master WHERE type='table' AND name='contacts_backup';

-- Dynamically construct column list for backup restore based on what exists
-- This will be more flexible when dealing with different schema versions
CREATE TEMP TABLE IF NOT EXISTS contact_columns AS
SELECT name FROM pragma_table_info('contacts');

-- If original migration was interrupted and we have a backup, restore it with flexible column handling
INSERT OR IGNORE INTO contacts (
  id, first_name, last_name, email, current_carrier, plan_type, 
  effective_date, birth_date, tobacco_user, gender, state, zip_code, 
  agent_id, last_emailed, phone_number, 
  -- Only include these if they exist in both tables
  CASE WHEN EXISTS (SELECT 1 FROM pragma_table_info('contacts_backup') WHERE name = 'status') THEN 'status' ELSE NULL END,
  CASE WHEN EXISTS (SELECT 1 FROM pragma_table_info('contacts_backup') WHERE name = 'aep_request') THEN 'aep_request' ELSE NULL END,
  created_at, updated_at
)
SELECT 
  id, first_name, last_name, email, current_carrier, plan_type, 
  effective_date, birth_date, tobacco_user, gender, state, zip_code, 
  agent_id, last_emailed, phone_number, 
  -- Only include these if they exist, otherwise use defaults
  CASE WHEN EXISTS (SELECT 1 FROM pragma_table_info('contacts_backup') WHERE name = 'status') 
       THEN status ELSE '' END,
  CASE WHEN EXISTS (SELECT 1 FROM pragma_table_info('contacts_backup') WHERE name = 'aep_request') 
       THEN aep_request ELSE 0 END,
  created_at, 
  CASE WHEN EXISTS (SELECT 1 FROM pragma_table_info('contacts_backup') WHERE name = 'updated_at') 
       THEN updated_at ELSE created_at END
FROM contacts_backup 
WHERE EXISTS (SELECT 1 FROM sqlite_master WHERE type='table' AND name='contacts_backup')
AND NOT EXISTS (SELECT 1 FROM contacts LIMIT 1);

-- After this point, we'll proceed with the main migration steps if contacts exists
-- First check if we have contacts with data
SELECT COUNT(*) as contacts_count FROM contacts;

-- Create a flexible backup taking into account column differences
CREATE TABLE IF NOT EXISTS contacts_backup AS 
SELECT 
  id, first_name, last_name, email, current_carrier, plan_type, 
  effective_date, birth_date, tobacco_user, gender, state, zip_code, 
  agent_id, last_emailed, phone_number,
  CASE WHEN EXISTS (SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'status') 
       THEN status ELSE '' END as status,
  CASE WHEN EXISTS (SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'aep_request') 
       THEN aep_request ELSE 0 END as aep_request,
  created_at,
  CASE WHEN EXISTS (SELECT 1 FROM pragma_table_info('contacts') WHERE name = 'updated_at') 
       THEN updated_at ELSE created_at END as updated_at
FROM contacts 
WHERE EXISTS (SELECT 1 FROM contacts LIMIT 1)
AND NOT EXISTS (SELECT 1 FROM sqlite_master WHERE type='table' AND name='contacts_backup');

-- Create a temporary table with deduplicated contacts
-- We'll keep the most recently updated record for each email
CREATE TABLE contacts_temp AS
SELECT 
  id, first_name, last_name, email, current_carrier, plan_type, 
  effective_date, birth_date, tobacco_user, gender, state, zip_code, 
  agent_id, last_emailed, phone_number, status, aep_request,
  created_at, updated_at
FROM (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY LOWER(TRIM(email)) ORDER BY 
    CASE 
      -- Handle missing updated_at column by using created_at as fallback
      WHEN updated_at IS NULL THEN created_at 
      ELSE updated_at 
    END DESC,
    id DESC
  ) as rn
  FROM contacts
) WHERE rn = 1;

-- Drop existing indexes on contacts
DROP INDEX IF EXISTS idx_contacts_email;
DROP INDEX IF EXISTS idx_contacts_email_unique;
DROP INDEX IF EXISTS idx_contacts_agent_id;
DROP INDEX IF EXISTS idx_contacts_status;
DROP INDEX IF EXISTS idx_contacts_aep_request;
DROP TRIGGER IF EXISTS update_contacts_timestamp;

-- Drop the original contacts table
DROP TABLE IF EXISTS contacts;

-- Rename the temporary table to contacts
ALTER TABLE contacts_temp RENAME TO contacts;

-- Add the PRIMARY KEY constraint back (using proper methods, not the reserved name)
-- Don't try to create sqlite_autoindex_contacts_1 directly, as it's a reserved name
-- Instead, declare the id column as PRIMARY KEY directly when possible
-- If your SQLite version doesn't support ALTER TABLE ADD PRIMARY KEY, use this to properly 
-- set id as primary key in an existing table:
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_id_pk ON contacts(id);

-- Create the proper unique constraint on the email column
-- This will ensure ON CONFLICT(email) works correctly
-- SQLite doesn't support ALTER TABLE ADD CONSTRAINT, so we use a unique index instead
CREATE UNIQUE INDEX contact_email_unique ON contacts(email);

-- Add our lowercased trimmed index for case-insensitive comparison
-- This is for searching and preventing duplicates when inserting
CREATE UNIQUE INDEX idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

-- Recreate other indexes from the original table
CREATE INDEX idx_contacts_email ON contacts(email);
CREATE INDEX idx_contacts_agent_id ON contacts(agent_id);
CREATE INDEX idx_contacts_status ON contacts(status);
CREATE INDEX idx_contacts_aep_request ON contacts(aep_request);

-- Ensure the updated_at column exists
SELECT COUNT(*) as has_updated_at_column FROM pragma_table_info('contacts') WHERE name = 'updated_at';

-- Recreate the update timestamp trigger
CREATE TRIGGER update_contacts_timestamp 
AFTER UPDATE ON contacts 
BEGIN 
  UPDATE contacts SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id; 
END;

-- Create the contact_events table if it doesn't exist
CREATE TABLE IF NOT EXISTS contact_events (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  contact_id INTEGER,
  lead_id INTEGER,
  event_type TEXT NOT NULL,
  metadata TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  -- Removing foreign keys initially, will add them after all tables exist
);

-- Create indexes for contact_events
CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id);
CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id);
CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type);

-- Create the leads table if it doesn't exist
CREATE TABLE IF NOT EXISTS leads (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(email)
);

-- Create index for leads
CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email);

-- Recreate eligibility_answers from backup if available
CREATE TABLE IF NOT EXISTS eligibility_answers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  contact_id INTEGER NOT NULL,
  quote_id TEXT NOT NULL,
  answers TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  -- Removing foreign keys initially, will add them after all tables exist
);

-- Create index for eligibility_answers
CREATE INDEX IF NOT EXISTS idx_eligibility_answers_contact_id ON eligibility_answers(contact_id);

-- Now add foreign key constraints using ALTER TABLE if supported, or recreate the tables if needed
-- SQLite doesn't support adding constraints with ALTER TABLE, but we can enable them functionally
-- by creating appropriate indexes and enforcing at the application level

-- Recreate constraints by adding appropriate DELETE triggers as a workaround for ON DELETE CASCADE
-- When a contact is deleted, delete related records
CREATE TRIGGER IF NOT EXISTS trg_contacts_delete
AFTER DELETE ON contacts
BEGIN
  DELETE FROM eligibility_answers WHERE contact_id = OLD.id;
  DELETE FROM contact_events WHERE contact_id = OLD.id;
END;

-- When a lead is deleted, delete or null related records
CREATE TRIGGER IF NOT EXISTS trg_leads_delete
AFTER DELETE ON leads
BEGIN
  DELETE FROM contact_events WHERE lead_id = OLD.id;
END;

-- Restore data for eligibility_answers if we have a backup
INSERT OR IGNORE INTO eligibility_answers
SELECT * FROM eligibility_answers_backup
WHERE EXISTS (SELECT 1 FROM sqlite_master WHERE type='table' AND name='eligibility_answers_backup');

-- Drop backup tables when done
DROP TABLE IF EXISTS eligibility_answers_backup;
DROP TABLE IF EXISTS schema_backup;
DROP TABLE IF EXISTS contact_columns;

-- Recreate the v_contact_stats view
CREATE VIEW IF NOT EXISTS v_contact_stats AS
SELECT 
  COUNT(*) as total_contacts,
  SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_contacts,
  SUM(CASE WHEN created_at > date('now', '-30 days') THEN 1 ELSE 0 END) as new_contacts_30d
FROM contacts;

-- Show the results
SELECT 
  COUNT(*) as total_contacts_after,
  (SELECT COUNT(*) FROM contacts_backup WHERE EXISTS (SELECT 1 FROM sqlite_master WHERE type='table' AND name='contacts_backup')) as backup_count,
  COUNT(*) - COUNT(DISTINCT LOWER(TRIM(email))) as duplicate_emails_after
FROM contacts;

-- Final check: Verify we can do an ON CONFLICT query
INSERT OR IGNORE INTO contacts (
  first_name, last_name, email, current_carrier, plan_type, 
  effective_date, birth_date, tobacco_user, gender, state, zip_code, phone_number
) 
VALUES ('Test', 'User', 'test@example.com', 'Test', 'Test', 
  '2025-01-01', '1970-01-01', 0, 'M', 'TX', '12345', '123-456-7890')
ON CONFLICT(email) DO NOTHING;

-- Turn foreign keys back on
PRAGMA foreign_keys = ON;

================
File: migrations/20250407_add_usage_based_subscription_fields.sql
================
-- Migration: Add usage-based subscription tracking fields to organizations table
-- Date: 2025-04-07

-- Add fields for usage-based subscription tracking
ALTER TABLE organizations ADD COLUMN stripe_usage_item_id TEXT;
ALTER TABLE organizations ADD COLUMN current_contact_count INTEGER DEFAULT 0;
ALTER TABLE organizations ADD COLUMN last_usage_report_time DATETIME;
ALTER TABLE organizations ADD COLUMN usage_meter_id TEXT;
ALTER TABLE organizations ADD COLUMN auto_upgrade_limit INTEGER DEFAULT 0;

-- Add an index for more efficient subscription lookups
CREATE INDEX IF NOT EXISTS idx_organizations_subscription ON organizations (stripe_subscription_id);

================
File: migrations/add_agent_settings_to_user.sql
================
ALTER TABLE users ADD COLUMN use_org_sender_details BOOLEAN DEFAULT 1;

================
File: migrations/add_email_unique_index.sql
================
-- Begin transaction for atomic operations
BEGIN TRANSACTION;

-- Identify and remove duplicate emails (keeping only the row with highest ID)
DELETE FROM contacts 
WHERE id NOT IN (
    SELECT MAX(id) 
    FROM contacts 
    GROUP BY LOWER(TRIM(email))
);

-- Add missing unique index for case-insensitive email uniqueness
CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_email_unique ON contacts(LOWER(TRIM(email)));

-- Commit the transaction
COMMIT;

-- Verify the index was created
PRAGMA index_list(contacts);

================
File: migrations/add_turso_connection_optimization.sql
================
-- Turso/SQLite optimization settings
-- These settings will help improve performance and reduce 429 errors

-- Set synchronous mode to NORMAL for better performance with Turso
PRAGMA synchronous = NORMAL;

-- Set journal mode to WAL for better concurrent operations
PRAGMA journal_mode = WAL;

-- Set temp store to MEMORY to reduce disk I/O
PRAGMA temp_store = MEMORY;

-- Set cache size to 10000 pages (about 40MB)
PRAGMA cache_size = 10000;

-- Set mmap size to 30MB for better read performance 
PRAGMA mmap_size = 30000000;

-- Optimize all indexes
PRAGMA optimize;

================
File: migrations/contact_001.sql
================
-- Add new columns with defaults
ALTER TABLE contacts ADD COLUMN phone_number TEXT NOT NULL DEFAULT '';
ALTER TABLE contacts ADD COLUMN status TEXT NOT NULL DEFAULT '';

================
File: migrations/contact_002.sql
================
-- Add contact_events table for generic event logging
CREATE TABLE IF NOT EXISTS contact_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER NOT NULL,
    event_type TEXT NOT NULL,
    metadata TEXT, -- JSON field for additional event-specific data
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (contact_id) REFERENCES contacts(id)
);

CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id);
CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type);


DROP TABLE IF EXISTS contact_requests;

================
File: migrations/contact_003.sql
================
-- Create eligibility_answers table to track responses
CREATE TABLE IF NOT EXISTS eligibility_answers (
    id INTEGER PRIMARY KEY,
    contact_id INTEGER NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    answers TEXT NOT NULL, -- Format: {"1": true, "2": false, "3": true}
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Create index for faster lookups by contact
CREATE INDEX IF NOT EXISTS eligibility_answers_contact_id_idx ON eligibility_answers(contact_id);

================
File: migrations/contact_004.sql
================
-- Create leads table to track potential contacts
CREATE TABLE IF NOT EXISTS leads (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'new',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    converted_contact_id INTEGER,
    FOREIGN KEY (converted_contact_id) REFERENCES contacts(id)
);

-- Add indexes for leads table
CREATE INDEX IF NOT EXISTS idx_leads_email ON leads(email);
CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status);

-- Drop and recreate contact_events table to support both contacts and leads
DROP TABLE IF EXISTS contact_events;

CREATE TABLE contact_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER,
    lead_id INTEGER,
    event_type TEXT NOT NULL,
    metadata TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (contact_id) REFERENCES contacts(id),
    FOREIGN KEY (lead_id) REFERENCES leads(id),
    CHECK ((contact_id IS NOT NULL AND lead_id IS NULL) OR (contact_id IS NULL AND lead_id IS NOT NULL))
);

-- Add indexes for contact_events table
CREATE INDEX IF NOT EXISTS idx_contact_events_contact_id ON contact_events(contact_id);
CREATE INDEX IF NOT EXISTS idx_contact_events_lead_id ON contact_events(lead_id);
CREATE INDEX IF NOT EXISTS idx_contact_events_type ON contact_events(event_type);

-- Create eligibility_answers table if it doesn't exist
CREATE TABLE IF NOT EXISTS eligibility_answers (
    id INTEGER PRIMARY KEY,
    contact_id INTEGER NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    quote_id TEXT,
    answers TEXT NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Create index for faster lookups by contact if it doesn't exist
CREATE INDEX IF NOT EXISTS eligibility_answers_contact_id_idx ON eligibility_answers(contact_id);

-- Create a new temporary table without the quote_id column
CREATE TABLE IF NOT EXISTS eligibility_answers_new (
    id INTEGER PRIMARY KEY,
    contact_id INTEGER NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    answers TEXT NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Copy data from the old table to the new one, excluding quote_id
INSERT INTO eligibility_answers_new (id, contact_id, answers, created_at)
SELECT id, contact_id, answers, created_at 
FROM eligibility_answers;

-- Drop the old table
DROP TABLE eligibility_answers;

-- Rename the new table to the original name
ALTER TABLE eligibility_answers_new RENAME TO eligibility_answers;

-- Add the quote_id column as nullable
ALTER TABLE eligibility_answers ADD COLUMN quote_id TEXT;

-- Recreate the index
CREATE INDEX IF NOT EXISTS eligibility_answers_contact_id_idx ON eligibility_answers(contact_id);

================
File: migrations/contact_005.sql
================
PRAGMA foreign_keys=off;
BEGIN TRANSACTION;
CREATE TABLE contacts_new (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT NOT NULL,
  current_carrier TEXT,
  plan_type TEXT,
  effective_date TEXT NOT NULL,
  birth_date TEXT NOT NULL,
  tobacco_user BOOLEAN NOT NULL,
  gender TEXT NOT NULL,
  state TEXT NOT NULL,
  zip_code TEXT NOT NULL,
  agent_id INTEGER,
  last_emailed TEXT,
  phone_number TEXT NOT NULL DEFAULT '',
  status TEXT NOT NULL DEFAULT '',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP
);
INSERT INTO contacts_new SELECT * FROM contacts;
DROP TABLE contacts;
ALTER TABLE contacts_new RENAME TO contacts;
COMMIT;
PRAGMA foreign_keys=on;

================
File: migrations/show_org.sql
================
SELECT * FROM organizations WHERE id = 11;

================
File: migrations/verify_schema.sql
================
-- Run these queries to verify the schema
SELECT sql FROM sqlite_master WHERE type='table' AND name='organizations';
SELECT sql FROM sqlite_master WHERE type='table' AND name='users';
SELECT sql FROM sqlite_master WHERE type='table' AND name='verification_tokens';

================
File: scripts/apply_contact_schema_fix.sh
================
#!/bin/bash
# Script to apply both migrations to handle all organization database states

echo "Starting contact schema migration fix..."

# First run migration for databases WITH contacts table
echo "Step 1: Applying migration for databases WITH an existing contacts table..."
./scripts/apply_migration_to_orgs.sh backend/migrations/20250425_fix_schema_with_contacts.sql

# Then run migration for databases WITHOUT contacts table
echo "Step 2: Applying migration for databases WITHOUT an existing contacts table..."
./scripts/apply_migration_to_orgs.sh backend/migrations/20250425_create_schema_no_contacts.sql

echo "Contact schema migration completed!"
echo "Some errors are expected and can be ignored if they relate to missing tables."

================
File: scripts/apply_migration_to_orgs.sh
================
#!/bin/bash

# Check if SQL file is provided
if [ $# -eq 0 ]; then
    echo "Error: No SQL file provided"
    echo "Usage: $0 <path_to_sql_file>"
    exit 1
fi

SQL_FILE=$1

# Check if the SQL file exists
if [ ! -f "$SQL_FILE" ]; then
    echo "Error: SQL file '$SQL_FILE' not found"
    exit 1
fi

echo "Applying migration from $SQL_FILE to org databases from maxretain..."

# Get organization databases from main-max / maxretain group
ORG_DBS=$(turso db shell main-max-sandbox "SELECT turso_db_url FROM organizations WHERE turso_db_url IS NOT NULL;" | grep -v "TURSO DB URL" | while read url; do
    # Strip protocol if present (https:// or libsql://)
    clean_url=$(echo "$url" | sed -E 's#^(https://|libsql://)##')
    
    # Extract the first part before the first period and remove -pyrex41 suffix
    db_name=$(echo "$clean_url" | cut -d. -f1 | sed 's/-pyrex41$//')
    
    echo "$db_name"
done)

# Check if any org databases were found
if [ -z "$ORG_DBS" ]; then
    echo "No org databases found"
    exit 0
fi

# Apply the migration to each org database
for DB in $ORG_DBS; do
    echo "Applying migration to $DB"
    turso db shell "$DB" < "$SQL_FILE"
    
    # Check the exit status
    if [ $? -eq 0 ]; then
        echo "✅ Successfully applied migration to $DB"
    else
        echo "❌ Failed to apply migration to $DB"
    fi
done

echo "Migration process completed!"

================
File: scripts/check_user_fks.sh
================
#!/bin/bash

DB="main-max"

# Get all table names except sqlite_sequence (internal)
tables=$(turso db shell $DB "SELECT name FROM sqlite_master WHERE type='table' AND name != 'sqlite_sequence';" | tail -n +2)

echo "Checking for foreign keys referencing 'users' in all tables..."

for table in $tables; do
    # Get foreign keys for this table
    fk_info=$(turso db shell $DB "PRAGMA foreign_key_list('$table');" | grep users)
    if [ ! -z "$fk_info" ]; then
        echo "Table '$table' has foreign key(s) referencing 'users':"
        turso db shell $DB "PRAGMA foreign_key_list('$table');" | grep users
        echo "----------------------------------------"
    fi
done

echo "Done."

================
File: scripts/migrate-to-sqlite.ts
================
import { Database } from '../backend/src/database'
import { config } from '../backend/src/config'
import { logger } from '../backend/src/logger'
import path from 'path'
import fs from 'fs/promises'
import { Database as BunDatabase } from 'bun:sqlite'

// Set required environment variables for local SQLite
process.env.USE_LOCAL_SQLITE = 'true'
process.env.LOCAL_DB_PATH = process.env.LOCAL_DB_PATH || 'data/organizations'

// Define table dependencies
const TABLE_ORDER = [
  'leads',
  'contacts',
  'eligibility_answers',
  'contact_events',
  'contact_requests'
]

async function migrateToSqlite() {
  try {
    // Ensure local DB directory exists
    const dbDir = path.join(process.cwd(), 'data/organizations')
    await fs.mkdir(dbDir, { recursive: true })
    
    // Get main database connection with Turso (force Turso for source)
    const mainDb = new Database(config.TURSO_DATABASE_URL, config.TURSO_AUTH_TOKEN)
    
    // Get all organizations
    const orgs = await mainDb.fetchAll('SELECT id, turso_db_url, turso_auth_token FROM organizations')
    logger.info(`Found ${orgs.length} organizations to migrate`)
    
    for (const org of orgs) {
      try {
        if (!org.turso_db_url || !org.turso_auth_token) {
          logger.warn(`Skipping organization ${org.id} - missing database credentials`)
          continue
        }

        const { dbName } = Database.normalizeDbUrl(org.turso_db_url)
        if (!dbName) {
          logger.warn(`Skipping organization ${org.id} - invalid database URL format`)
          continue
        }

        const localDbPath = path.join(dbDir, `${dbName}.sqlite`)
        
        // Check if database already exists
        const dbExists = await fs.access(localDbPath).then(() => true).catch(() => false)
        if (dbExists) {
          logger.info(`Database already exists for org ${org.id}, removing it first`)
          await fs.unlink(localDbPath)
        }
        
        logger.info(`Migrating organization ${org.id} to ${localDbPath}`)
        
        // Get Turso database connection (force Turso for source)
        const tursoDb = new Database(org.turso_db_url, org.turso_auth_token)
        
        // Get schema and data
        const tables = await tursoDb.fetchAll(`
          SELECT name, sql 
          FROM sqlite_master 
          WHERE type='table' AND name NOT LIKE 'sqlite_%'
        `)
        
        if (!tables || tables.length === 0) {
          logger.warn(`No tables found for organization ${org.id}`)
          continue
        }

        logger.info(`Found ${tables.length} tables to migrate`)

        // Create local database file
        const localDb = new BunDatabase(localDbPath)
        
        // Enable foreign keys
        localDb.exec('PRAGMA foreign_keys = ON;')
        
        // First create all tables
        for (const table of tables) {
          if (!table.name || !table.sql) {
            logger.warn(`Skipping invalid table definition for org ${org.id}`)
            continue
          }

          logger.info(`Creating table: ${table.name}`)
          try {
            localDb.exec(table.sql)
          } catch (error) {
            logger.error(`Error creating table ${table.name}: ${error}`)
            throw error
          }
        }

        // Create indexes
        const indexes = await tursoDb.fetchAll(`
          SELECT sql 
          FROM sqlite_master 
          WHERE type='index' AND sql IS NOT NULL
        `)
        
        for (const index of indexes) {
          try {
            localDb.exec(index.sql)
          } catch (error) {
            logger.warn(`Error creating index: ${error}`)
            // Continue even if index creation fails
          }
        }

        // Then copy data for all tables in dependency order
        const tableMap = new Map(tables.map(t => [t.name, t]))
        for (const tableName of TABLE_ORDER) {
          const table = tableMap.get(tableName)
          if (!table) continue // Skip if table doesn't exist in this org's schema

          // Copy data
          const data = await tursoDb.fetchAll(`SELECT * FROM ${tableName}`)
          if (data.length > 0) {
            logger.info(`Copying ${data.length} rows for table ${tableName}`)
            
            const columns = Object.keys(data[0])
            const placeholders = columns.map(() => '?').join(',')
            const sql = `INSERT INTO ${tableName} (${columns.join(',')}) VALUES (${placeholders})`
            
            // Use transaction for better performance
            localDb.exec('BEGIN TRANSACTION')
            
            try {
              const stmt = localDb.prepare(sql)
              for (const row of data) {
                stmt.run(...Object.values(row))
              }
              localDb.exec('COMMIT')
            } catch (error) {
              localDb.exec('ROLLBACK')
              logger.error(`Error inserting data for table ${tableName} in org ${org.id}: ${error}`)
              throw error
            }
          }
        }
        
        // Close the local database
        localDb.close()
        
        logger.info(`Successfully migrated organization ${org.id}`)
      } catch (error) {
        logger.error(`Error migrating organization ${org.id}: ${error}`)
        // Continue with next organization instead of failing completely
        continue
      }
    }
    
    logger.info('Migration complete')
  } catch (error) {
    logger.error(`Migration failed: ${error}`)
    process.exit(1)
  }
}

migrateToSqlite()

================
File: scripts/setup_db.py
================
import os
from pathlib import Path
from dotenv import load_dotenv
from db.database import db

# Get the project root directory
BASE_DIR = Path(__file__).resolve().parent.parent

# Load environment variables from .env file in project root
load_dotenv(BASE_DIR / '.env')

def run_migrations():
    print(f"Using database URL: {os.getenv('TURSO_DATABASE_URL')}")  # Debug print
    
    # Read and execute migration files
    migrations_dir = BASE_DIR / "migrations"
    for migration_file in sorted(migrations_dir.glob("*.sql")):
        print(f"Running migration: {migration_file.name}")
        with open(migration_file) as f:
            migration_sql = f.read()
            db.execute(migration_sql)

if __name__ == "__main__":
    run_migrations()

================
File: static/css/main.css
================
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');

body {
  font-family: 'Space Grotesk', system-ui, sans-serif;
}

/* Table styles */
.table-header {
  padding: 0.75rem 1rem;
  text-align: left;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: uppercase;
  color: #6b7280;
}

.table-cell {
  padding: 0.75rem 1rem;
  font-size: 0.875rem;
  color: #111827;
}

/* Icon button styles */
.action-icon-btn {
  color: #9ca3af;
  transition: color 0.2s;
}

.action-icon-btn:hover {
  color: #8b5cf6;
}

================
File: .cursorrules
================
Do not restart frontend or backend servers using agent -- process typically already running with file watchers so no need to restart.

================
File: .gitignore
================
# Environment variables
backend/.env
# But allow frontend/.env to be committed

dist/
frontend/node_modules/
backend/node_modules/
frontend/elm-stuff/

# Ignore root zipData.json but not the one in backend/data
/zipData.json
**/.claude/settings.local.json

================
File: .python-version
================
3.13

================
File: .replit
================
modules = ["nodejs-20", "web", "bun-1.2"]
run = "bun run start"

[nix]
channel = "stable-24_05"

[deployment]
run = ["sh", "-c", "bun run start"]
deploymentTarget = "cloudrun"

[[ports]]
localPort = 8000
externalPort = 80

================
File: add_protected_route.txt
================
I'll create a file with instructions for adding a protected route:

```text:add_protected_route_directions.txt
How to Add a Protected Route
===========================

Follow these steps to add a new protected route to the application:

1. Create New Page Module
------------------------
Create a new file in frontend/src/ (e.g., NewPage.elm):

```elm
module NewPage exposing (Model, Msg, init, subscriptions, update, view)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)

type alias Model =
    {}

type Msg
    = NoOp

init : () -> ( Model, Cmd Msg )
init _ =
    ( {}, Cmd.none )

update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

view : Model -> Browser.Document Msg
view model =
    { title = "New Page"
    , body =
        [ div [ class "min-h-screen bg-gray-50" ]
            [ div [ class "max-w-7xl mx-auto py-6 sm:px-6 lg:px-8" ]
                [ h1 [ class "text-2xl font-semibold text-gray-900" ]
                    [ text "New Page" ]
                ]
            ]
        ]
    }

subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none
```

2. Update Main.elm
-----------------

a. Add import:
```elm
import NewPage
```

b. Add to Page type:
```elm
type Page
    = ...
    | NewPagePage NewPage.Model
```

c. Add to Msg type:
```elm
type Msg
    = ...
    | NewPageMsg NewPage.Msg
```

d. Add to ProtectedRoute type:
```elm
type ProtectedRoute
    = ...
    | NewPageRoute
```

e. Add route to parser:
```elm
routeParser : Parser (Route -> a) a
routeParser =
    oneOf
        [ ...
        , map (Protected NewPageRoute) (s "new-page")
        ]
```

f. Add to showProtectedRoute:
```elm
showProtectedRoute : ProtectedRoute -> Model -> ( Model, Cmd Msg )
showProtectedRoute route model =
    case route of
        ...
        NewPageRoute ->
            let
                ( pageModel, pageCmd ) =
                    NewPage.init ()
            in
            ( { model | page = NewPagePage pageModel }
            , Cmd.map NewPageMsg pageCmd
            )
```

g. Add to update:
```elm
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        ...
        NewPageMsg subMsg ->
            case model.page of
                NewPagePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            NewPage.update subMsg pageModel
                    in
                    ( { model | page = NewPagePage newPageModel }
                    , Cmd.map NewPageMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )
```

h. Add to view:
```elm
view : Model -> Document Msg
view model =
    case model.page of
        ...
        NewPagePage pageModel ->
            { title = "New Page"
            , body = List.map (Html.map NewPageMsg) (NewPage.view pageModel).body
            }
```

i. Add to subscriptions:
```elm
subscriptions : Model -> Sub Msg
subscriptions model =
    case model.page of
        ...
        NewPagePage pageModel ->
            Sub.map NewPageMsg (NewPage.subscriptions pageModel)
```

3. Testing
----------
1. Try accessing /new-page without being logged in
   - Should redirect to login page
2. Log in and try accessing /new-page
   - Should show the new protected page
3. Log out and try accessing /new-page again
   - Should redirect to login page

The route is protected because:
- It's defined as a ProtectedRoute type
- Protected routes require session verification
- Users without a valid session are redirected to login
- After successful login, users can access the protected page

Note: Remember to compile and test thoroughly after adding new routes.
```

================
File: bun.lock
================
{
  "lockfileVersion": 1,
  "workspaces": {
    "": {
      "name": "dashboard-monorepo",
      "dependencies": {
        "tailwindcss-animate": "^1.0.7",
      },
      "devDependencies": {
        "concurrently": "^8.2.2",
        "typescript": "^5.7.3",
        "vite-plugin-elm": "^3.0.1",
      },
    },
  },
  "packages": {
    "@babel/runtime": ["@babel/runtime@7.26.9", "", { "dependencies": { "regenerator-runtime": "^0.14.0" } }, "sha512-aA63XwOkcl4xxQa3HjPMqOP6LiK0ZDv3mUPYEFXkpHbaFjtGggE1A61FjFzJnB+p7/oy2gA8E+rcBNl/zC1tMg=="],

    "@esbuild/aix-ppc64": ["@esbuild/aix-ppc64@0.25.0", "", { "os": "aix", "cpu": "ppc64" }, "sha512-O7vun9Sf8DFjH2UtqK8Ku3LkquL9SZL8OLY1T5NZkA34+wG3OQF7cl4Ql8vdNzM6fzBbYfLaiRLIOZ+2FOCgBQ=="],

    "@esbuild/android-arm": ["@esbuild/android-arm@0.25.0", "", { "os": "android", "cpu": "arm" }, "sha512-PTyWCYYiU0+1eJKmw21lWtC+d08JDZPQ5g+kFyxP0V+es6VPPSUhM6zk8iImp2jbV6GwjX4pap0JFbUQN65X1g=="],

    "@esbuild/android-arm64": ["@esbuild/android-arm64@0.25.0", "", { "os": "android", "cpu": "arm64" }, "sha512-grvv8WncGjDSyUBjN9yHXNt+cq0snxXbDxy5pJtzMKGmmpPxeAmAhWxXI+01lU5rwZomDgD3kJwulEnhTRUd6g=="],

    "@esbuild/android-x64": ["@esbuild/android-x64@0.25.0", "", { "os": "android", "cpu": "x64" }, "sha512-m/ix7SfKG5buCnxasr52+LI78SQ+wgdENi9CqyCXwjVR2X4Jkz+BpC3le3AoBPYTC9NHklwngVXvbJ9/Akhrfg=="],

    "@esbuild/darwin-arm64": ["@esbuild/darwin-arm64@0.25.0", "", { "os": "darwin", "cpu": "arm64" }, "sha512-mVwdUb5SRkPayVadIOI78K7aAnPamoeFR2bT5nszFUZ9P8UpK4ratOdYbZZXYSqPKMHfS1wdHCJk1P1EZpRdvw=="],

    "@esbuild/darwin-x64": ["@esbuild/darwin-x64@0.25.0", "", { "os": "darwin", "cpu": "x64" }, "sha512-DgDaYsPWFTS4S3nWpFcMn/33ZZwAAeAFKNHNa1QN0rI4pUjgqf0f7ONmXf6d22tqTY+H9FNdgeaAa+YIFUn2Rg=="],

    "@esbuild/freebsd-arm64": ["@esbuild/freebsd-arm64@0.25.0", "", { "os": "freebsd", "cpu": "arm64" }, "sha512-VN4ocxy6dxefN1MepBx/iD1dH5K8qNtNe227I0mnTRjry8tj5MRk4zprLEdG8WPyAPb93/e4pSgi1SoHdgOa4w=="],

    "@esbuild/freebsd-x64": ["@esbuild/freebsd-x64@0.25.0", "", { "os": "freebsd", "cpu": "x64" }, "sha512-mrSgt7lCh07FY+hDD1TxiTyIHyttn6vnjesnPoVDNmDfOmggTLXRv8Id5fNZey1gl/V2dyVK1VXXqVsQIiAk+A=="],

    "@esbuild/linux-arm": ["@esbuild/linux-arm@0.25.0", "", { "os": "linux", "cpu": "arm" }, "sha512-vkB3IYj2IDo3g9xX7HqhPYxVkNQe8qTK55fraQyTzTX/fxaDtXiEnavv9geOsonh2Fd2RMB+i5cbhu2zMNWJwg=="],

    "@esbuild/linux-arm64": ["@esbuild/linux-arm64@0.25.0", "", { "os": "linux", "cpu": "arm64" }, "sha512-9QAQjTWNDM/Vk2bgBl17yWuZxZNQIF0OUUuPZRKoDtqF2k4EtYbpyiG5/Dk7nqeK6kIJWPYldkOcBqjXjrUlmg=="],

    "@esbuild/linux-ia32": ["@esbuild/linux-ia32@0.25.0", "", { "os": "linux", "cpu": "ia32" }, "sha512-43ET5bHbphBegyeqLb7I1eYn2P/JYGNmzzdidq/w0T8E2SsYL1U6un2NFROFRg1JZLTzdCoRomg8Rvf9M6W6Gg=="],

    "@esbuild/linux-loong64": ["@esbuild/linux-loong64@0.25.0", "", { "os": "linux", "cpu": "none" }, "sha512-fC95c/xyNFueMhClxJmeRIj2yrSMdDfmqJnyOY4ZqsALkDrrKJfIg5NTMSzVBr5YW1jf+l7/cndBfP3MSDpoHw=="],

    "@esbuild/linux-mips64el": ["@esbuild/linux-mips64el@0.25.0", "", { "os": "linux", "cpu": "none" }, "sha512-nkAMFju7KDW73T1DdH7glcyIptm95a7Le8irTQNO/qtkoyypZAnjchQgooFUDQhNAy4iu08N79W4T4pMBwhPwQ=="],

    "@esbuild/linux-ppc64": ["@esbuild/linux-ppc64@0.25.0", "", { "os": "linux", "cpu": "ppc64" }, "sha512-NhyOejdhRGS8Iwv+KKR2zTq2PpysF9XqY+Zk77vQHqNbo/PwZCzB5/h7VGuREZm1fixhs4Q/qWRSi5zmAiO4Fw=="],

    "@esbuild/linux-riscv64": ["@esbuild/linux-riscv64@0.25.0", "", { "os": "linux", "cpu": "none" }, "sha512-5S/rbP5OY+GHLC5qXp1y/Mx//e92L1YDqkiBbO9TQOvuFXM+iDqUNG5XopAnXoRH3FjIUDkeGcY1cgNvnXp/kA=="],

    "@esbuild/linux-s390x": ["@esbuild/linux-s390x@0.25.0", "", { "os": "linux", "cpu": "s390x" }, "sha512-XM2BFsEBz0Fw37V0zU4CXfcfuACMrppsMFKdYY2WuTS3yi8O1nFOhil/xhKTmE1nPmVyvQJjJivgDT+xh8pXJA=="],

    "@esbuild/linux-x64": ["@esbuild/linux-x64@0.25.0", "", { "os": "linux", "cpu": "x64" }, "sha512-9yl91rHw/cpwMCNytUDxwj2XjFpxML0y9HAOH9pNVQDpQrBxHy01Dx+vaMu0N1CKa/RzBD2hB4u//nfc+Sd3Cw=="],

    "@esbuild/netbsd-arm64": ["@esbuild/netbsd-arm64@0.25.0", "", { "os": "none", "cpu": "arm64" }, "sha512-RuG4PSMPFfrkH6UwCAqBzauBWTygTvb1nxWasEJooGSJ/NwRw7b2HOwyRTQIU97Hq37l3npXoZGYMy3b3xYvPw=="],

    "@esbuild/netbsd-x64": ["@esbuild/netbsd-x64@0.25.0", "", { "os": "none", "cpu": "x64" }, "sha512-jl+qisSB5jk01N5f7sPCsBENCOlPiS/xptD5yxOx2oqQfyourJwIKLRA2yqWdifj3owQZCL2sn6o08dBzZGQzA=="],

    "@esbuild/openbsd-arm64": ["@esbuild/openbsd-arm64@0.25.0", "", { "os": "openbsd", "cpu": "arm64" }, "sha512-21sUNbq2r84YE+SJDfaQRvdgznTD8Xc0oc3p3iW/a1EVWeNj/SdUCbm5U0itZPQYRuRTW20fPMWMpcrciH2EJw=="],

    "@esbuild/openbsd-x64": ["@esbuild/openbsd-x64@0.25.0", "", { "os": "openbsd", "cpu": "x64" }, "sha512-2gwwriSMPcCFRlPlKx3zLQhfN/2WjJ2NSlg5TKLQOJdV0mSxIcYNTMhk3H3ulL/cak+Xj0lY1Ym9ysDV1igceg=="],

    "@esbuild/sunos-x64": ["@esbuild/sunos-x64@0.25.0", "", { "os": "sunos", "cpu": "x64" }, "sha512-bxI7ThgLzPrPz484/S9jLlvUAHYMzy6I0XiU1ZMeAEOBcS0VePBFxh1JjTQt3Xiat5b6Oh4x7UC7IwKQKIJRIg=="],

    "@esbuild/win32-arm64": ["@esbuild/win32-arm64@0.25.0", "", { "os": "win32", "cpu": "arm64" }, "sha512-ZUAc2YK6JW89xTbXvftxdnYy3m4iHIkDtK3CLce8wg8M2L+YZhIvO1DKpxrd0Yr59AeNNkTiic9YLf6FTtXWMw=="],

    "@esbuild/win32-ia32": ["@esbuild/win32-ia32@0.25.0", "", { "os": "win32", "cpu": "ia32" }, "sha512-eSNxISBu8XweVEWG31/JzjkIGbGIJN/TrRoiSVZwZ6pkC6VX4Im/WV2cz559/TXLcYbcrDN8JtKgd9DJVIo8GA=="],

    "@esbuild/win32-x64": ["@esbuild/win32-x64@0.25.0", "", { "os": "win32", "cpu": "x64" }, "sha512-ZENoHJBxA20C2zFzh6AI4fT6RraMzjYw4xKWemRTRmRVtN9c5DcH9r/f2ihEkMjOW5eGgrwCslG/+Y/3bL+DHQ=="],

    "@rollup/rollup-android-arm-eabi": ["@rollup/rollup-android-arm-eabi@4.34.8", "", { "os": "android", "cpu": "arm" }, "sha512-q217OSE8DTp8AFHuNHXo0Y86e1wtlfVrXiAlwkIvGRQv9zbc6mE3sjIVfwI8sYUyNxwOg0j/Vm1RKM04JcWLJw=="],

    "@rollup/rollup-android-arm64": ["@rollup/rollup-android-arm64@4.34.8", "", { "os": "android", "cpu": "arm64" }, "sha512-Gigjz7mNWaOL9wCggvoK3jEIUUbGul656opstjaUSGC3eT0BM7PofdAJaBfPFWWkXNVAXbaQtC99OCg4sJv70Q=="],

    "@rollup/rollup-darwin-arm64": ["@rollup/rollup-darwin-arm64@4.34.8", "", { "os": "darwin", "cpu": "arm64" }, "sha512-02rVdZ5tgdUNRxIUrFdcMBZQoaPMrxtwSb+/hOfBdqkatYHR3lZ2A2EGyHq2sGOd0Owk80oV3snlDASC24He3Q=="],

    "@rollup/rollup-darwin-x64": ["@rollup/rollup-darwin-x64@4.34.8", "", { "os": "darwin", "cpu": "x64" }, "sha512-qIP/elwR/tq/dYRx3lgwK31jkZvMiD6qUtOycLhTzCvrjbZ3LjQnEM9rNhSGpbLXVJYQ3rq39A6Re0h9tU2ynw=="],

    "@rollup/rollup-freebsd-arm64": ["@rollup/rollup-freebsd-arm64@4.34.8", "", { "os": "freebsd", "cpu": "arm64" }, "sha512-IQNVXL9iY6NniYbTaOKdrlVP3XIqazBgJOVkddzJlqnCpRi/yAeSOa8PLcECFSQochzqApIOE1GHNu3pCz+BDA=="],

    "@rollup/rollup-freebsd-x64": ["@rollup/rollup-freebsd-x64@4.34.8", "", { "os": "freebsd", "cpu": "x64" }, "sha512-TYXcHghgnCqYFiE3FT5QwXtOZqDj5GmaFNTNt3jNC+vh22dc/ukG2cG+pi75QO4kACohZzidsq7yKTKwq/Jq7Q=="],

    "@rollup/rollup-linux-arm-gnueabihf": ["@rollup/rollup-linux-arm-gnueabihf@4.34.8", "", { "os": "linux", "cpu": "arm" }, "sha512-A4iphFGNkWRd+5m3VIGuqHnG3MVnqKe7Al57u9mwgbyZ2/xF9Jio72MaY7xxh+Y87VAHmGQr73qoKL9HPbXj1g=="],

    "@rollup/rollup-linux-arm-musleabihf": ["@rollup/rollup-linux-arm-musleabihf@4.34.8", "", { "os": "linux", "cpu": "arm" }, "sha512-S0lqKLfTm5u+QTxlFiAnb2J/2dgQqRy/XvziPtDd1rKZFXHTyYLoVL58M/XFwDI01AQCDIevGLbQrMAtdyanpA=="],

    "@rollup/rollup-linux-arm64-gnu": ["@rollup/rollup-linux-arm64-gnu@4.34.8", "", { "os": "linux", "cpu": "arm64" }, "sha512-jpz9YOuPiSkL4G4pqKrus0pn9aYwpImGkosRKwNi+sJSkz+WU3anZe6hi73StLOQdfXYXC7hUfsQlTnjMd3s1A=="],

    "@rollup/rollup-linux-arm64-musl": ["@rollup/rollup-linux-arm64-musl@4.34.8", "", { "os": "linux", "cpu": "arm64" }, "sha512-KdSfaROOUJXgTVxJNAZ3KwkRc5nggDk+06P6lgi1HLv1hskgvxHUKZ4xtwHkVYJ1Rep4GNo+uEfycCRRxht7+Q=="],

    "@rollup/rollup-linux-loongarch64-gnu": ["@rollup/rollup-linux-loongarch64-gnu@4.34.8", "", { "os": "linux", "cpu": "none" }, "sha512-NyF4gcxwkMFRjgXBM6g2lkT58OWztZvw5KkV2K0qqSnUEqCVcqdh2jN4gQrTn/YUpAcNKyFHfoOZEer9nwo6uQ=="],

    "@rollup/rollup-linux-powerpc64le-gnu": ["@rollup/rollup-linux-powerpc64le-gnu@4.34.8", "", { "os": "linux", "cpu": "ppc64" }, "sha512-LMJc999GkhGvktHU85zNTDImZVUCJ1z/MbAJTnviiWmmjyckP5aQsHtcujMjpNdMZPT2rQEDBlJfubhs3jsMfw=="],

    "@rollup/rollup-linux-riscv64-gnu": ["@rollup/rollup-linux-riscv64-gnu@4.34.8", "", { "os": "linux", "cpu": "none" }, "sha512-xAQCAHPj8nJq1PI3z8CIZzXuXCstquz7cIOL73HHdXiRcKk8Ywwqtx2wrIy23EcTn4aZ2fLJNBB8d0tQENPCmw=="],

    "@rollup/rollup-linux-s390x-gnu": ["@rollup/rollup-linux-s390x-gnu@4.34.8", "", { "os": "linux", "cpu": "s390x" }, "sha512-DdePVk1NDEuc3fOe3dPPTb+rjMtuFw89gw6gVWxQFAuEqqSdDKnrwzZHrUYdac7A7dXl9Q2Vflxpme15gUWQFA=="],

    "@rollup/rollup-linux-x64-gnu": ["@rollup/rollup-linux-x64-gnu@4.34.8", "", { "os": "linux", "cpu": "x64" }, "sha512-8y7ED8gjxITUltTUEJLQdgpbPh1sUQ0kMTmufRF/Ns5tI9TNMNlhWtmPKKHCU0SilX+3MJkZ0zERYYGIVBYHIA=="],

    "@rollup/rollup-linux-x64-musl": ["@rollup/rollup-linux-x64-musl@4.34.8", "", { "os": "linux", "cpu": "x64" }, "sha512-SCXcP0ZpGFIe7Ge+McxY5zKxiEI5ra+GT3QRxL0pMMtxPfpyLAKleZODi1zdRHkz5/BhueUrYtYVgubqe9JBNQ=="],

    "@rollup/rollup-win32-arm64-msvc": ["@rollup/rollup-win32-arm64-msvc@4.34.8", "", { "os": "win32", "cpu": "arm64" }, "sha512-YHYsgzZgFJzTRbth4h7Or0m5O74Yda+hLin0irAIobkLQFRQd1qWmnoVfwmKm9TXIZVAD0nZ+GEb2ICicLyCnQ=="],

    "@rollup/rollup-win32-ia32-msvc": ["@rollup/rollup-win32-ia32-msvc@4.34.8", "", { "os": "win32", "cpu": "ia32" }, "sha512-r3NRQrXkHr4uWy5TOjTpTYojR9XmF0j/RYgKCef+Ag46FWUTltm5ziticv8LdNsDMehjJ543x/+TJAek/xBA2w=="],

    "@rollup/rollup-win32-x64-msvc": ["@rollup/rollup-win32-x64-msvc@4.34.8", "", { "os": "win32", "cpu": "x64" }, "sha512-U0FaE5O1BCpZSeE6gBl3c5ObhePQSfk9vDRToMmTkbhCOgW4jqvtS5LGyQ76L1fH8sM0keRp4uDTsbjiUyjk0g=="],

    "@types/estree": ["@types/estree@1.0.6", "", {}, "sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw=="],

    "acorn": ["acorn@8.14.0", "", { "bin": { "acorn": "bin/acorn" } }, "sha512-cl669nCJTZBsL97OF4kUQm5g5hC2uihk0NxY3WENAC0TYdILVkAyHymAntgxGkl7K+t0cXIrH5siy5S4XkFycA=="],

    "acorn-walk": ["acorn-walk@8.3.4", "", { "dependencies": { "acorn": "^8.11.0" } }, "sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g=="],

    "ansi-regex": ["ansi-regex@5.0.1", "", {}, "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ=="],

    "ansi-styles": ["ansi-styles@4.3.0", "", { "dependencies": { "color-convert": "^2.0.1" } }, "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg=="],

    "balanced-match": ["balanced-match@1.0.2", "", {}, "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw=="],

    "brace-expansion": ["brace-expansion@1.1.11", "", { "dependencies": { "balanced-match": "^1.0.0", "concat-map": "0.0.1" } }, "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA=="],

    "chalk": ["chalk@4.1.2", "", { "dependencies": { "ansi-styles": "^4.1.0", "supports-color": "^7.1.0" } }, "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA=="],

    "cliui": ["cliui@8.0.1", "", { "dependencies": { "string-width": "^4.2.0", "strip-ansi": "^6.0.1", "wrap-ansi": "^7.0.0" } }, "sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ=="],

    "color-convert": ["color-convert@2.0.1", "", { "dependencies": { "color-name": "~1.1.4" } }, "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ=="],

    "color-name": ["color-name@1.1.4", "", {}, "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA=="],

    "concat-map": ["concat-map@0.0.1", "", {}, "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg=="],

    "concurrently": ["concurrently@8.2.2", "", { "dependencies": { "chalk": "^4.1.2", "date-fns": "^2.30.0", "lodash": "^4.17.21", "rxjs": "^7.8.1", "shell-quote": "^1.8.1", "spawn-command": "0.0.2", "supports-color": "^8.1.1", "tree-kill": "^1.2.2", "yargs": "^17.7.2" }, "bin": { "conc": "dist/bin/concurrently.js", "concurrently": "dist/bin/concurrently.js" } }, "sha512-1dP4gpXFhei8IOtlXRE/T/4H88ElHgTiUzh71YUmtjTEHMSRS2Z/fgOxHSxxusGHogsRfxNq1vyAwxSC+EVyDg=="],

    "cross-spawn": ["cross-spawn@6.0.5", "", { "dependencies": { "nice-try": "^1.0.4", "path-key": "^2.0.1", "semver": "^5.5.0", "shebang-command": "^1.2.0", "which": "^1.2.9" } }, "sha512-eTVLrBSt7fjbDygz805pMnstIs2VTBNkRm0qxZd+M7A5XDdxVRWO5MxGBXZhjY4cqLYLdtrGqRf8mBPmzwSpWQ=="],

    "date-fns": ["date-fns@2.30.0", "", { "dependencies": { "@babel/runtime": "^7.21.0" } }, "sha512-fnULvOpxnC5/Vg3NCiWelDsLiUc9bRwAPs/+LfTLNvetFCtCTN+yQz15C/fs4AwX1R9K5GLtLfn8QW+dWisaAw=="],

    "elm-esm": ["elm-esm@1.1.4", "", { "dependencies": { "which": "^2.0.2" }, "bin": { "elm-esm": "src/run.js" } }, "sha512-dGWDtgsdDrhn3GFl/uT6Yt5DIBgnvOmakLNl6brkoYqb7i8mQ/beHoR+emx3ux4M4sq3GpRfRvzMoiRHVcaWKw=="],

    "emoji-regex": ["emoji-regex@8.0.0", "", {}, "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A=="],

    "esbuild": ["esbuild@0.25.0", "", { "optionalDependencies": { "@esbuild/aix-ppc64": "0.25.0", "@esbuild/android-arm": "0.25.0", "@esbuild/android-arm64": "0.25.0", "@esbuild/android-x64": "0.25.0", "@esbuild/darwin-arm64": "0.25.0", "@esbuild/darwin-x64": "0.25.0", "@esbuild/freebsd-arm64": "0.25.0", "@esbuild/freebsd-x64": "0.25.0", "@esbuild/linux-arm": "0.25.0", "@esbuild/linux-arm64": "0.25.0", "@esbuild/linux-ia32": "0.25.0", "@esbuild/linux-loong64": "0.25.0", "@esbuild/linux-mips64el": "0.25.0", "@esbuild/linux-ppc64": "0.25.0", "@esbuild/linux-riscv64": "0.25.0", "@esbuild/linux-s390x": "0.25.0", "@esbuild/linux-x64": "0.25.0", "@esbuild/netbsd-arm64": "0.25.0", "@esbuild/netbsd-x64": "0.25.0", "@esbuild/openbsd-arm64": "0.25.0", "@esbuild/openbsd-x64": "0.25.0", "@esbuild/sunos-x64": "0.25.0", "@esbuild/win32-arm64": "0.25.0", "@esbuild/win32-ia32": "0.25.0", "@esbuild/win32-x64": "0.25.0" }, "bin": { "esbuild": "bin/esbuild" } }, "sha512-BXq5mqc8ltbaN34cDqWuYKyNhX8D/Z0J1xdtdQ8UcIIIyJyz+ZMKUt58tF3SrZ85jcfN/PZYhjR5uDQAYNVbuw=="],

    "escalade": ["escalade@3.2.0", "", {}, "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA=="],

    "find-elm-dependencies": ["find-elm-dependencies@2.0.4", "", { "dependencies": { "firstline": "^1.2.0", "lodash": "^4.17.19" }, "bin": { "find-elm-dependencies": "bin/cli.js" } }, "sha512-x/4w4fVmlD2X4PD9oQ+yh9EyaQef6OtEULdMGBTuWx0Nkppvo2Z/bAiQioW2n+GdRYKypME2b9OmYTw5tw5qDg=="],

    "find-up": ["find-up@7.0.0", "", { "dependencies": { "locate-path": "^7.2.0", "path-exists": "^5.0.0", "unicorn-magic": "^0.1.0" } }, "sha512-YyZM99iHrqLKjmt4LJDj58KI+fYyufRLBSYcqycxf//KpBk9FoewoGX0450m9nB44qrZnovzC2oeP5hUibxc/g=="],

    "firstline": ["firstline@1.3.1", "", {}, "sha512-ycwgqtoxujz1dm0kjkBFOPQMESxB9uKc/PlD951dQDIG+tBXRpYZC2UmJb0gDxopQ1ZX6oyRQN3goRczYu7Deg=="],

    "fs.realpath": ["fs.realpath@1.0.0", "", {}, "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw=="],

    "fsevents": ["fsevents@2.3.3", "", { "os": "darwin" }, "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw=="],

    "get-caller-file": ["get-caller-file@2.0.5", "", {}, "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg=="],

    "glob": ["glob@7.2.3", "", { "dependencies": { "fs.realpath": "^1.0.0", "inflight": "^1.0.4", "inherits": "2", "minimatch": "^3.1.1", "once": "^1.3.0", "path-is-absolute": "^1.0.0" } }, "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q=="],

    "has-flag": ["has-flag@4.0.0", "", {}, "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ=="],

    "inflight": ["inflight@1.0.6", "", { "dependencies": { "once": "^1.3.0", "wrappy": "1" } }, "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA=="],

    "inherits": ["inherits@2.0.4", "", {}, "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="],

    "is-fullwidth-code-point": ["is-fullwidth-code-point@3.0.0", "", {}, "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg=="],

    "isexe": ["isexe@2.0.0", "", {}, "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw=="],

    "locate-path": ["locate-path@7.2.0", "", { "dependencies": { "p-locate": "^6.0.0" } }, "sha512-gvVijfZvn7R+2qyPX8mAuKcFGDf6Nc61GdvGafQsHL0sBIxfKzA+usWn4GFC/bk+QdwPUD4kWFJLhElipq+0VA=="],

    "lodash": ["lodash@4.17.21", "", {}, "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="],

    "minimatch": ["minimatch@3.1.2", "", { "dependencies": { "brace-expansion": "^1.1.7" } }, "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw=="],

    "minimist": ["minimist@1.2.8", "", {}, "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA=="],

    "mkdirp": ["mkdirp@0.5.6", "", { "dependencies": { "minimist": "^1.2.6" }, "bin": { "mkdirp": "bin/cmd.js" } }, "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw=="],

    "nanoid": ["nanoid@3.3.8", "", { "bin": { "nanoid": "bin/nanoid.cjs" } }, "sha512-WNLf5Sd8oZxOm+TzppcYk8gVOgP+l58xNy58D0nbUnOxOWRWvlcCV4kUF7ltmI6PsrLl/BgKEyS4mqsGChFN0w=="],

    "nice-try": ["nice-try@1.0.5", "", {}, "sha512-1nh45deeb5olNY7eX82BkPO7SSxR5SSYJiPTrTdFUVYwAl8CKMA5N9PjTYkHiRjisVcxcQ1HXdLhx2qxxJzLNQ=="],

    "node-elm-compiler": ["node-elm-compiler@5.0.6", "", { "dependencies": { "cross-spawn": "6.0.5", "find-elm-dependencies": "^2.0.4", "lodash": "^4.17.19", "temp": "^0.9.0" } }, "sha512-DWTRQR8b54rvschcZRREdsz7K84lnS8A6YJu8du3QLQ8f204SJbyTaA6NzYYbfUG97OTRKRv/0KZl82cTfpLhA=="],

    "once": ["once@1.4.0", "", { "dependencies": { "wrappy": "1" } }, "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w=="],

    "p-limit": ["p-limit@4.0.0", "", { "dependencies": { "yocto-queue": "^1.0.0" } }, "sha512-5b0R4txpzjPWVw/cXXUResoD4hb6U/x9BH08L7nw+GN1sezDzPdxeRvpc9c433fZhBan/wusjbCsqwqm4EIBIQ=="],

    "p-locate": ["p-locate@6.0.0", "", { "dependencies": { "p-limit": "^4.0.0" } }, "sha512-wPrq66Llhl7/4AGC6I+cqxT07LhXvWL08LNXz1fENOw0Ap4sRZZ/gZpTTJ5jpurzzzfS2W/Ge9BY3LgLjCShcw=="],

    "path-exists": ["path-exists@5.0.0", "", {}, "sha512-RjhtfwJOxzcFmNOi6ltcbcu4Iu+FL3zEj83dk4kAS+fVpTxXLO1b38RvJgT/0QwvV/L3aY9TAnyv0EOqW4GoMQ=="],

    "path-is-absolute": ["path-is-absolute@1.0.1", "", {}, "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg=="],

    "path-key": ["path-key@2.0.1", "", {}, "sha512-fEHGKCSmUSDPv4uoj8AlD+joPlq3peND+HRYyxFz4KPw4z926S/b8rIuFs2FYJg3BwsxJf6A9/3eIdLaYC+9Dw=="],

    "picocolors": ["picocolors@1.1.1", "", {}, "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA=="],

    "postcss": ["postcss@8.5.3", "", { "dependencies": { "nanoid": "^3.3.8", "picocolors": "^1.1.1", "source-map-js": "^1.2.1" } }, "sha512-dle9A3yYxlBSrt8Fu+IpjGT8SY8hN0mlaA6GY8t0P5PjIOZemULz/E2Bnm/2dcUOena75OTNkHI76uZBNUUq3A=="],

    "regenerator-runtime": ["regenerator-runtime@0.14.1", "", {}, "sha512-dYnhHh0nJoMfnkZs6GmmhFknAGRrLznOu5nc9ML+EJxGvrx6H7teuevqVqCuPcPK//3eDrrjQhehXVx9cnkGdw=="],

    "require-directory": ["require-directory@2.1.1", "", {}, "sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q=="],

    "rimraf": ["rimraf@2.6.3", "", { "dependencies": { "glob": "^7.1.3" }, "bin": { "rimraf": "./bin.js" } }, "sha512-mwqeW5XsA2qAejG46gYdENaxXjx9onRNCfn7L0duuP4hCuTIi/QO7PDK07KJfp1d+izWPrzEJDcSqBa0OZQriA=="],

    "rollup": ["rollup@4.34.8", "", { "dependencies": { "@types/estree": "1.0.6" }, "optionalDependencies": { "@rollup/rollup-android-arm-eabi": "4.34.8", "@rollup/rollup-android-arm64": "4.34.8", "@rollup/rollup-darwin-arm64": "4.34.8", "@rollup/rollup-darwin-x64": "4.34.8", "@rollup/rollup-freebsd-arm64": "4.34.8", "@rollup/rollup-freebsd-x64": "4.34.8", "@rollup/rollup-linux-arm-gnueabihf": "4.34.8", "@rollup/rollup-linux-arm-musleabihf": "4.34.8", "@rollup/rollup-linux-arm64-gnu": "4.34.8", "@rollup/rollup-linux-arm64-musl": "4.34.8", "@rollup/rollup-linux-loongarch64-gnu": "4.34.8", "@rollup/rollup-linux-powerpc64le-gnu": "4.34.8", "@rollup/rollup-linux-riscv64-gnu": "4.34.8", "@rollup/rollup-linux-s390x-gnu": "4.34.8", "@rollup/rollup-linux-x64-gnu": "4.34.8", "@rollup/rollup-linux-x64-musl": "4.34.8", "@rollup/rollup-win32-arm64-msvc": "4.34.8", "@rollup/rollup-win32-ia32-msvc": "4.34.8", "@rollup/rollup-win32-x64-msvc": "4.34.8", "fsevents": "~2.3.2" }, "bin": { "rollup": "dist/bin/rollup" } }, "sha512-489gTVMzAYdiZHFVA/ig/iYFllCcWFHMvUHI1rpFmkoUtRlQxqh6/yiNqnYibjMZ2b/+FUQwldG+aLsEt6bglQ=="],

    "rxjs": ["rxjs@7.8.2", "", { "dependencies": { "tslib": "^2.1.0" } }, "sha512-dhKf903U/PQZY6boNNtAGdWbG85WAbjT/1xYoZIC7FAY0yWapOBQVsVrDl58W86//e1VpMNBtRV4MaXfdMySFA=="],

    "semver": ["semver@5.7.2", "", { "bin": { "semver": "bin/semver" } }, "sha512-cBznnQ9KjJqU67B52RMC65CMarK2600WFnbkcaiwWq3xy/5haFJlshgnpjovMVJ+Hff49d8GEn0b87C5pDQ10g=="],

    "shebang-command": ["shebang-command@1.2.0", "", { "dependencies": { "shebang-regex": "^1.0.0" } }, "sha512-EV3L1+UQWGor21OmnvojK36mhg+TyIKDh3iFBKBohr5xeXIhNBcx8oWdgkTEEQ+BEFFYdLRuqMfd5L84N1V5Vg=="],

    "shebang-regex": ["shebang-regex@1.0.0", "", {}, "sha512-wpoSFAxys6b2a2wHZ1XpDSgD7N9iVjg29Ph9uV/uaP9Ex/KXlkTZTeddxDPSYQpgvzKLGJke2UU0AzoGCjNIvQ=="],

    "shell-quote": ["shell-quote@1.8.2", "", {}, "sha512-AzqKpGKjrj7EM6rKVQEPpB288oCfnrEIuyoT9cyF4nmGa7V8Zk6f7RRqYisX8X9m+Q7bd632aZW4ky7EhbQztA=="],

    "source-map-js": ["source-map-js@1.2.1", "", {}, "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA=="],

    "spawn-command": ["spawn-command@0.0.2", "", {}, "sha512-zC8zGoGkmc8J9ndvml8Xksr1Amk9qBujgbF0JAIWO7kXr43w0h/0GJNM/Vustixu+YE8N/MTrQ7N31FvHUACxQ=="],

    "string-width": ["string-width@4.2.3", "", { "dependencies": { "emoji-regex": "^8.0.0", "is-fullwidth-code-point": "^3.0.0", "strip-ansi": "^6.0.1" } }, "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g=="],

    "strip-ansi": ["strip-ansi@6.0.1", "", { "dependencies": { "ansi-regex": "^5.0.1" } }, "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A=="],

    "supports-color": ["supports-color@8.1.1", "", { "dependencies": { "has-flag": "^4.0.0" } }, "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q=="],

    "tailwindcss": ["tailwindcss@4.0.9", "", {}, "sha512-12laZu+fv1ONDRoNR9ipTOpUD7RN9essRVkX36sjxuRUInpN7hIiHN4lBd/SIFjbISvnXzp8h/hXzmU8SQQYhw=="],

    "tailwindcss-animate": ["tailwindcss-animate@1.0.7", "", { "peerDependencies": { "tailwindcss": ">=3.0.0 || insiders" } }, "sha512-bl6mpH3T7I3UFxuvDEXLxy/VuFxBk5bbzplh7tXI68mwMokNYd1t9qPBHlnyTwfa4JGC4zP516I1hYYtQ/vspA=="],

    "temp": ["temp@0.9.4", "", { "dependencies": { "mkdirp": "^0.5.1", "rimraf": "~2.6.2" } }, "sha512-yYrrsWnrXMcdsnu/7YMYAofM1ktpL5By7vZhf15CrXijWWrEYZks5AXBudalfSWJLlnen/QUJUB5aoB0kqZUGA=="],

    "tree-kill": ["tree-kill@1.2.2", "", { "bin": { "tree-kill": "cli.js" } }, "sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A=="],

    "tslib": ["tslib@2.8.1", "", {}, "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w=="],

    "typescript": ["typescript@5.7.3", "", { "bin": { "tsc": "bin/tsc", "tsserver": "bin/tsserver" } }, "sha512-84MVSjMEHP+FQRPy3pX9sTVV/INIex71s9TL2Gm5FG/WG1SqXeKyZ0k7/blY/4FdOzI12CBy1vGc4og/eus0fw=="],

    "unicorn-magic": ["unicorn-magic@0.1.0", "", {}, "sha512-lRfVq8fE8gz6QMBuDM6a+LO3IAzTi05H6gCVaUpir2E1Rwpo4ZUog45KpNXKC/Mn3Yb9UDuHumeFTo9iV/D9FQ=="],

    "vite": ["vite@6.2.0", "", { "dependencies": { "esbuild": "^0.25.0", "postcss": "^8.5.3", "rollup": "^4.30.1" }, "optionalDependencies": { "fsevents": "~2.3.3" }, "peerDependencies": { "@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0", "jiti": ">=1.21.0", "less": "*", "lightningcss": "^1.21.0", "sass": "*", "sass-embedded": "*", "stylus": "*", "sugarss": "*", "terser": "^5.16.0", "tsx": "^4.8.1", "yaml": "^2.4.2" }, "optionalPeers": ["@types/node", "jiti", "less", "lightningcss", "sass", "sass-embedded", "stylus", "sugarss", "terser", "tsx", "yaml"], "bin": { "vite": "bin/vite.js" } }, "sha512-7dPxoo+WsT/64rDcwoOjk76XHj+TqNTIvHKcuMQ1k4/SeHDaQt5GFAeLYzrimZrMpn/O6DtdI03WUjdxuPM0oQ=="],

    "vite-plugin-elm": ["vite-plugin-elm@3.0.1", "", { "dependencies": { "acorn": "^8.0.0", "acorn-walk": "^8.0.0", "elm-esm": "1.1.4", "find-up": "^7.0.0", "node-elm-compiler": "5.0.6" }, "peerDependencies": { "vite": ">= 5.0.0" } }, "sha512-xdIJ4SCrSfdcjsyvFOicn3xFq3wNXobX+OOnU4z24/7n/XGMJO3k70gUrH30tusdApOPQpIPM50wynoG3F35HQ=="],

    "which": ["which@2.0.2", "", { "dependencies": { "isexe": "^2.0.0" }, "bin": { "node-which": "./bin/node-which" } }, "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA=="],

    "wrap-ansi": ["wrap-ansi@7.0.0", "", { "dependencies": { "ansi-styles": "^4.0.0", "string-width": "^4.1.0", "strip-ansi": "^6.0.0" } }, "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q=="],

    "wrappy": ["wrappy@1.0.2", "", {}, "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ=="],

    "y18n": ["y18n@5.0.8", "", {}, "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA=="],

    "yargs": ["yargs@17.7.2", "", { "dependencies": { "cliui": "^8.0.1", "escalade": "^3.1.1", "get-caller-file": "^2.0.5", "require-directory": "^2.1.1", "string-width": "^4.2.3", "y18n": "^5.0.5", "yargs-parser": "^21.1.1" } }, "sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w=="],

    "yargs-parser": ["yargs-parser@21.1.1", "", {}, "sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw=="],

    "yocto-queue": ["yocto-queue@1.1.1", "", {}, "sha512-b4JR1PFR10y1mKjhHY9LaGo6tmrgjit7hxVIeAmyMw3jegXR4dhYqLaQF5zMXZxY7tLpMyJeLjr1C4rLmkVe8g=="],

    "chalk/supports-color": ["supports-color@7.2.0", "", { "dependencies": { "has-flag": "^4.0.0" } }, "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw=="],

    "cross-spawn/which": ["which@1.3.1", "", { "dependencies": { "isexe": "^2.0.0" }, "bin": { "which": "./bin/which" } }, "sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ=="],
  }
}

================
File: CLAUDE.md
================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# Medicare Portal Development Guidelines

## Build Commands
- Backend: `cd backend && bun run dev` - starts backend server with file watching
- Frontend: `cd frontend && bunx --bun vite` - starts frontend dev server
- Build frontend: `cd frontend && tsc && bunx --bun vite build`
- Add agent: `cd backend && bun run add-agent`
- Manage recommendations: `cd backend && bun run manage-recommendations`
- Manage Turso databases: `cd backend && bun run manage-turso`
- Test bulk import: `cd backend && bun run test-import`
- Generate test data: `cd backend && bun run generate-data`
- Fix contacts: `cd backend && bun run fix-contacts`
- Start production server: `cd backend && bun run start`

## Architecture

### Backend
- Runtime: Bun with Elysia.js framework
- Database: Turso/LibSQL (SQLite in the cloud)
- Database structure:
  - Main central database for users, organizations, and auth
  - Per-organization databases for contacts and related data
- Authentication: Cookie-based sessions (middleware/auth.ts)
- Key services:
  - auth.ts: User authentication and sessions
  - email.ts: Email sending via SendGrid
  - stripe.ts: Payment processing
  - turso.ts: Database management
  - contactTracking.ts: Contact activity tracking

### Frontend
- Framework: Elm for the main application logic
- Build: Vite with TypeScript for configuration
- Styling: TailwindCSS
- JavaScript interop: Through Elm ports (Ports.elm)
- Key modules:
  - Main.elm: Main application entry point
  - Components/: Reusable UI components
  - Utils/: Utilities and helper functions

### Database Schema
- Organizations have users (agents/admins)
- Each organization has its own database for contacts
- Contacts can be imported via CSV
- Tracking for contact interactions and email activity

## Code Style
- TypeScript: Use strict mode, prefer explicit types
- Frontend: Elm for main app logic, TypeScript for interop
- Imports: Group by external/internal, alphabetize
- Naming: camelCase for variables/functions, PascalCase for types/components
- Error handling: Use explicit error types from errors.ts
- File organization: Feature-based folders in src/

## Key Project Features
- Medicare plan comparison and quoting
- Contact management system
- Agent management and licensing
- Email automation and scheduling
- Payment processing with Stripe
- Bulk contact import

## Important Rules
- Do not restart frontend or backend servers - file watchers are active
- Always use transactions for multi-step database operations
- For database operations on organization databases, use Database.getOrgDb or Database.getOrInitOrgDb
- Check for proper authentication in API routes
- Handle errors consistently with the errorHandler middleware

================
File: cookies.txt
================
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

================
File: diff.txt
================
diff --git a/diff.txt b/diff.txt
index 0cd9664..e69de29 100644
--- a/diff.txt
+++ b/diff.txt
@@ -1,1094 +0,0 @@
-diff --git a/backend/src/index.ts b/backend/src/index.ts
-index ee4499e..2836434 100644
---- a/backend/src/index.ts
-+++ b/backend/src/index.ts
-@@ -23,6 +23,7 @@ import { EmailService } from './services/email'
- import * as cron from 'node-cron'
- import { eligibilityRoutes } from './routes/eligibility'
- import { generateQuoteId } from './utils/quoteId'
-+import { createSelfServiceRoutes } from './routes/self-service'
- 
- // At the top of the file, add interface for ZIP data
- interface ZipInfo {
-@@ -1170,6 +1171,8 @@ const startServer = async () => {
-       .use(createOnboardingRoutes())
-       // Add eligibility routes
-       .use(eligibilityRoutes)
-+      // Add self-service routes
-+      .use(createSelfServiceRoutes())
-       // In production, serve the frontend static files
-       .use(process.env.NODE_ENV === 'production' 
-         ? async (app) => {
-diff --git a/backend/src/services/email.ts b/backend/src/services/email.ts
-index 1815c8d..3e73e82 100644
---- a/backend/src/services/email.ts
-+++ b/backend/src/services/email.ts
-@@ -1,5 +1,6 @@
- import sgMail from '@sendgrid/mail';
- import { logger } from '../logger';
-+import crypto from 'crypto';
- 
- 
- interface MagicLinkEmailParams {
-@@ -146,4 +147,69 @@ export async function sendMagicLink({ email, magicLink, name }: {
-     logger.error(`Failed to send magic link email: ${error}`);
-     throw error;
-   }
-+}
-+
-+// Generate a hash for onboarding link validation
-+function generateHash(orgId: string, email: string): string {
-+  const SECRET = process.env.HASH_SECRET || 'default-hash-secret'; // Ensure this is set in your environment
-+  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
-+}
-+
-+/**
-+ * Sends an onboarding link that includes organizationId, and optionally email and hash
-+ * @param orgId Organization ID to include in the link
-+ * @param email Optional email to include in the link and use as recipient
-+ */
-+export async function sendOnboardingLink(orgId: string, email?: string) {
-+  try {
-+    // Base onboarding URL with orgId
-+    const baseUrl = process.env.FRONTEND_URL || 'https://medicaremax.ai';
-+    let onboardingUrl = `${baseUrl}/onboard?orgId=${orgId}`;
-+    
-+    // If email is provided, add email and hash to the URL
-+    if (email) {
-+      const hash = generateHash(orgId, email);
-+      onboardingUrl += `&email=${encodeURIComponent(email)}&hash=${hash}`;
-+    }
-+    
-+    // Create email message
-+    const msg = {
-+      to: email || process.env.FALLBACK_EMAIL || 'information@medicaremax.ai', // Fallback if no email provided
-+      from: process.env.SENDGRID_FROM_EMAIL || 'information@medicaremax.ai',
-+      subject: 'Join MedicareMax',
-+      text: `Click this link to create or update your profile: ${onboardingUrl}`,
-+      html: `
-+        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
-+          <h2 style="color: #333;">Welcome to MedicareMax</h2>
-+          <p>Click the button below to create or update your profile:</p>
-+          <div style="margin: 30px 0;">
-+            <a href="${onboardingUrl}" 
-+               style="background-color: #4F46E5; color: white; padding: 12px 24px; 
-+                      text-decoration: none; border-radius: 4px; display: inline-block;">
-+              Get Started
-+            </a>
-+          </div>
-+          <p style="color: #666; font-size: 14px;">
-+            If the button doesn't work, copy and paste this link into your browser:
-+            <br>
-+            <a href="${onboardingUrl}" style="color: #4F46E5;">${onboardingUrl}</a>
-+          </p>
-+          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
-+            <p style="color: #888; font-size: 14px;">
-+              If you have any questions, please don't hesitate to contact us.
-+              <br>
-+              The MedicareMax Team
-+            </p>
-+          </div>
-+        </div>
-+      `
-+    };
-+
-+    await sgMail.send(msg);
-+    logger.info(`Onboarding link email sent successfully${email ? ` to ${email}` : ''}`);
-+    return { success: true };
-+  } catch (error) {
-+    logger.error(`Error sending onboarding link email: ${error}`);
-+    throw new Error('Failed to send onboarding link email');
-+  }
- } 
-\ No newline at end of file
-module SelfServiceOnboarding exposing (..)
-
-import Browser
-import Browser.Navigation as Nav
-import Html exposing (..)
-import Html.Attributes exposing (..)
-import Html.Events exposing (..)
-import Http
-import Json.Decode as Decode exposing (Decoder)
-import Json.Encode as Encode
-import Url exposing (Url)
-import Url.Parser exposing (..)
-import Url.Parser.Query as Query
-
-
-
--- MODEL
-
-
-type alias Model =
-    { orgId : Maybe String
-    , email : String
-    , firstName : String
-    , lastName : String
-    , optInQuarterlyUpdates : Bool
-    , emailReadOnly : Bool
-    , isSubmitting : Bool
-    , error : Maybe String
-    , success : Bool
-    , key : Nav.Key
-    }
-
-
-
--- INIT
-
-
-type alias UrlParams =
-    { orgId : Maybe String
-    , email : Maybe String
-    , hash : Maybe String
-    }
-
-
-parseUrlParams : Url -> UrlParams
-parseUrlParams url =
-    let
-        parser =
-            Query.map3 UrlParams
-                (Query.string "orgId")
-                (Query.string "email")
-                (Query.string "hash")
-    in
-    Url.Parser.parse (Url.Parser.query parser) url |> Maybe.withDefault { orgId = Nothing, email = Nothing, hash = Nothing }
-
-
-init : Nav.Key -> Url -> ( Model, Cmd Msg )
-init key url =
-    let
-        params =
-            parseUrlParams url
-
-        orgId =
-            params.orgId
-
-        email =
-            params.email
-
-        hash =
-            params.hash
-
-        initCmd =
-            case orgId of
-                Just oid ->
-                    let
-                        queryParams =
-                            List.filterMap identity
-                                [ Just ( "orgId", oid )
-                                , Maybe.map (\e -> ( "email", e )) email
-                                , Maybe.map (\h -> ( "hash", h )) hash
-                                ]
-                                |> List.map (\( k, v ) -> k ++ "=" ++ Url.percentEncode v)
-                                |> String.join "&"
-                    in
-                    Http.get
-                        { url = "/api/self-service/init?" ++ queryParams
-                        , expect = Http.expectJson GotInitResponse initResponseDecoder
-                        }
-
-                Nothing ->
-                    Cmd.none
-    in
-    ( { orgId = orgId
-      , email = ""
-      , firstName = ""
-      , lastName = ""
-      , optInQuarterlyUpdates = False
-      , emailReadOnly = False
-      , isSubmitting = False
-      , error = Nothing
-      , success = False
-      , key = key
-      }
-    , initCmd
-    )
-
-
-
--- UPDATE
-
-
-type Msg
-    = GotInitResponse (Result Http.Error InitResponse)
-    | UpdateEmail String
-    | UpdateFirstName String
-    | UpdateLastName String
-    | ToggleOptIn Bool
-    | SubmitForm
-    | GotSignupResponse (Result Http.Error ())
-
-
-type alias InitResponse =
-    { contact : Maybe Contact
-    , email : Maybe String
-    , emailReadOnly : Bool
-    }
-
-
-type alias Contact =
-    { email : String
-    , firstName : String
-    , lastName : String
-    , optInQuarterlyUpdates : Bool
-    }
-
-
-update : Msg -> Model -> ( Model, Cmd Msg )
-update msg model =
-    case msg of
-        GotInitResponse result ->
-            case result of
-                Ok response ->
-                    let
-                        email =
-                            response.email |> Maybe.withDefault ""
-
-                        contact =
-                            response.contact
-
-                        firstName =
-                            contact |> Maybe.map .firstName |> Maybe.withDefault ""
-
-                        lastName =
-                            contact |> Maybe.map .lastName |> Maybe.withDefault ""
-
-                        optIn =
-                            contact |> Maybe.map .optInQuarterlyUpdates |> Maybe.withDefault False
-                    in
-                    ( { model
-                        | email = email
-                        , firstName = firstName
-                        , lastName = lastName
-                        , optInQuarterlyUpdates = optIn
-                        , emailReadOnly = response.emailReadOnly
-                        , error = Nothing
-                      }
-                    , Cmd.none
-                    )
-
-                Err _ ->
-                    ( { model | error = Just "Failed to load existing contact details. Please try again." }
-                    , Cmd.none
-                    )
-
-        UpdateEmail newEmail ->
-            ( { model
-                | email =
-                    if model.emailReadOnly then
-                        model.email
-
-                    else
-                        newEmail
-              }
-            , Cmd.none
-            )
-
-        UpdateFirstName newFirstName ->
-            ( { model | firstName = newFirstName }, Cmd.none )
-
-        UpdateLastName newLastName ->
-            ( { model | lastName = newLastName }, Cmd.none )
-
-        ToggleOptIn newValue ->
-            ( { model | optInQuarterlyUpdates = newValue }, Cmd.none )
-
-        SubmitForm ->
-            if isFormValid model then
-                ( { model | isSubmitting = True, error = Nothing }
-                , submitForm model
-                )
-
-            else
-                ( { model | error = Just "Please fill out all required fields" }
-                , Cmd.none
-                )
-
-        GotSignupResponse result ->
-            case result of
-                Ok _ ->
-                    ( { model | isSubmitting = False, success = True, error = Nothing }
-                    , Cmd.none
-                    )
-
-                Err _ ->
-                    ( { model | isSubmitting = False, error = Just "Signup failed. Please try again." }
-                    , Cmd.none
-                    )
-
-
-isFormValid : Model -> Bool
-isFormValid model =
-    not (String.isEmpty model.email)
-        && not (String.isEmpty model.firstName)
-        && not (String.isEmpty model.lastName)
-
-
-
--- FORM SUBMISSION
-
-
-submitForm : Model -> Cmd Msg
-submitForm model =
-    Http.post
-        { url = "/api/self-service/signup"
-        , body = Http.jsonBody (encodeForm model)
-        , expect = Http.expectWhatever GotSignupResponse
-        }
-
-
-encodeForm : Model -> Encode.Value
-encodeForm model =
-    Encode.object
-        [ ( "orgId", Encode.string (Maybe.withDefault "" model.orgId) )
-        , ( "email", Encode.string model.email )
-        , ( "firstName", Encode.string model.firstName )
-        , ( "lastName", Encode.string model.lastName )
-        , ( "optInQuarterlyUpdates", Encode.bool model.optInQuarterlyUpdates )
-        ]
-
-
-
--- DECODERS
-
-
-initResponseDecoder : Decoder InitResponse
-initResponseDecoder =
-    Decode.map3 InitResponse
-        (Decode.maybe (Decode.field "contact" contactDecoder))
-        (Decode.maybe (Decode.field "email" Decode.string))
-        (Decode.field "emailReadOnly" Decode.bool)
-
-
-contactDecoder : Decoder Contact
-contactDecoder =
-    Decode.map4 Contact
-        (Decode.field "email" Decode.string)
-        (Decode.field "firstName" Decode.string)
-        (Decode.field "lastName" Decode.string)
-        (Decode.field "optInQuarterlyUpdates" Decode.bool)
-
-
-
--- VIEW
-
-
-view : Model -> Browser.Document Msg
-view model =
-    { title = "Self-Service Onboarding"
-    , body =
-        [ div [ class "container mx-auto px-4 py-8" ]
-            [ h1 [ class "text-2xl font-bold mb-6" ] [ text "Complete Your Profile" ]
-            , viewForm model
-            ]
-        ]
-    }
-
-
-viewForm : Model -> Html Msg
-viewForm model =
-    div [ class "max-w-md mx-auto bg-white rounded-lg shadow-md p-6" ]
-        [ if model.success then
-            div [ class "p-4 mb-4 bg-green-100 border border-green-400 text-green-700 rounded" ]
-                [ text "Profile updated successfully!" ]
-
-          else
-            div []
-                [ inputField "Email" model.email UpdateEmail model.emailReadOnly
-                , inputField "First Name" model.firstName UpdateFirstName False
-                , inputField "Last Name" model.lastName UpdateLastName False
-                , checkboxField "Receive quarterly Medicare updates" model.optInQuarterlyUpdates ToggleOptIn
-                , viewError model.error
-                , button
-                    [ type_ "button"
-                    , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
-                    , onClick SubmitForm
-                    , disabled (model.isSubmitting || not (isFormValid model))
-                    ]
-                    [ text
-                        (if model.isSubmitting then
-                            "Submitting..."
-
-                         else
-                            "Submit"
-                        )
-                    ]
-                ]
-        ]
-
-
-inputField : String -> String -> (String -> Msg) -> Bool -> Html Msg
-inputField labelText value toMsg isDisabled =
-    div [ class "mb-4" ]
-        [ label [ class "block text-sm font-medium text-gray-700 mb-1" ] [ text labelText ]
-        , input
-            [ type_ "text"
-            , class "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
-            , Html.Attributes.value value
-            , onInput toMsg
-            , disabled isDisabled
-            ]
-            []
-        ]
-
-
-checkboxField : String -> Bool -> (Bool -> Msg) -> Html Msg
-checkboxField labelText isChecked toMsg =
-    div [ class "mb-6" ]
-        [ label [ class "flex items-center" ]
-            [ input
-                [ type_ "checkbox"
-                , class "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
-                , checked isChecked
-                , onCheck toMsg
-                ]
-                []
-            , span [ class "ml-2 text-sm text-gray-600" ] [ text labelText ]
-            ]
-        ]
-
-
-viewError : Maybe String -> Html msg
-viewError maybeError =
-    case maybeError of
-        Just error ->
-            div [ class "mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded" ]
-                [ text error ]
-
-        Nothing ->
-            text ""
-
-
-viewSuccess : Bool -> Html msg
-viewSuccess success =
-    if success then
-        div [ class "mb-4 p-3 bg-green-100 border border-green-400 text-green-700 rounded" ]
-            [ text "Profile updated successfully!" ]
-
-    else
-        text ""
-
-
-
--- HELPERS
-
-
-errorToString : Http.Error -> String
-errorToString error =
-    case error of
-        Http.BadUrl url ->
-            "Bad URL: " ++ url
-
-        Http.Timeout ->
-            "Request timed out"
-
-        Http.NetworkError ->
-            "Network error"
-
-        Http.BadStatus status ->
-            "Bad status: " ++ String.fromInt status
-
-        Http.BadBody message ->
-            "Bad body: " ++ message
-
-
-
--- MAIN
-
-
-main : Program () Model Msg
-main =
-    Browser.application
-        { init = \flags url key -> init key url
-        , view = view
-        , update = update
-        , subscriptions = \_ -> Sub.none
-        , onUrlChange = \_ -> GotInitResponse (Err (Http.BadUrl "URL changed"))
-        , onUrlRequest = \_ -> GotInitResponse (Err (Http.BadUrl "URL requested"))
-        }
-import { Elysia, t } from 'elysia';
-import { Database } from '../database';
-import { logger } from '../logger';
-import crypto from 'crypto';
-
-// Import generateHash function - reimplementing it since it's not exported from email.ts
-function generateHash(orgId: string, email: string): string {
-  const SECRET = process.env.HASH_SECRET || 'default-hash-secret';
-  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
-}
-
-export function createSelfServiceRoutes() {
-  return new Elysia()
-    .get('/api/self-service/init', async ({ query, set }) => {
-      // Extract query parameters
-      const { orgId, email, hash } = query as { 
-        orgId?: string; 
-        email?: string; 
-        hash?: string;
-      };
-
-      // Validate required parameters
-      if (!orgId) {
-        set.status = 400;
-        return { error: 'orgId is required' };
-      }
-
-      // Validate hash if email is provided
-      if (email && hash) {
-        const expectedHash = generateHash(orgId, email);
-        if (hash !== expectedHash) {
-          logger.warn(`Invalid hash for email ${email} and orgId ${orgId}`);
-          set.status = 403;
-          return { error: 'Invalid email or hash' };
-        }
-      }
-
-      try {
-        // Get organization database
-        const orgDb = await Database.getOrgDb(orgId);
-        
-        // If email is provided, check for existing contact
-        if (email) {
-          const client = orgDb.getClient();
-          const result = await client.execute({
-            sql: `SELECT 
-                  email, 
-                  first_name AS firstName, 
-                  last_name AS lastName, 
-                  opt_in_quarterly_updates AS optInQuarterlyUpdates 
-                FROM contacts 
-                WHERE email = ?`,
-            args: [email]
-          });
-
-          // If contact exists, return contact details
-          if (result.rows.length > 0) {
-            const contact = result.rows[0];
-            logger.info(`Contact found for email ${email} in organization ${orgId}`);
-            return { 
-              contact, 
-              email, 
-              emailReadOnly: true 
-            };
-          }
-
-          // If no contact exists but email is provided
-          logger.info(`No contact found for email ${email} in organization ${orgId}`);
-          return { 
-            email, 
-            emailReadOnly: true 
-          };
-        }
-
-        // If no email is provided
-        return { emailReadOnly: false };
-
-      } catch (error) {
-        logger.error(`Error in self-service init endpoint: ${error}`);
-        set.status = 500;
-        return { error: 'Internal server error' };
-      }
-    });
-} 
-
-+++ New file: frontend/src/SelfServiceOnboarding.elm
-
-module SelfServiceOnboarding exposing (..)
-
-import Browser
-import Browser.Navigation as Nav
-import Html exposing (..)
-import Html.Attributes exposing (..)
-import Html.Events exposing (..)
-import Http
-import Json.Decode as Decode exposing (Decoder)
-import Json.Encode as Encode
-import Url exposing (Url)
-import Url.Parser exposing (..)
-import Url.Parser.Query as Query
-
-
-
--- MODEL
-
-
-type alias Model =
-    { orgId : Maybe String
-    , email : String
-    , firstName : String
-    , lastName : String
-    , optInQuarterlyUpdates : Bool
-    , emailReadOnly : Bool
-    , isSubmitting : Bool
-    , error : Maybe String
-    , success : Bool
-    , key : Nav.Key
-    }
-
-
-
--- INIT
-
-
-type alias UrlParams =
-    { orgId : Maybe String
-    , email : Maybe String
-    , hash : Maybe String
-    }
-
-
-parseUrlParams : Url -> UrlParams
-parseUrlParams url =
-    let
-        parser =
-            Query.map3 UrlParams
-                (Query.string "orgId")
-                (Query.string "email")
-                (Query.string "hash")
-    in
-    Url.Parser.parse (Url.Parser.query parser) url |> Maybe.withDefault { orgId = Nothing, email = Nothing, hash = Nothing }
-
-
-init : Nav.Key -> Url -> ( Model, Cmd Msg )
-init key url =
-    let
-        params =
-            parseUrlParams url
-
-        orgId =
-            params.orgId
-
-        email =
-            params.email
-
-        hash =
-            params.hash
-
-        initCmd =
-            case orgId of
-                Just oid ->
-                    let
-                        queryParams =
-                            List.filterMap identity
-                                [ Just ( "orgId", oid )
-                                , Maybe.map (\e -> ( "email", e )) email
-                                , Maybe.map (\h -> ( "hash", h )) hash
-                                ]
-                                |> List.map (\( k, v ) -> k ++ "=" ++ Url.percentEncode v)
-                                |> String.join "&"
-                    in
-                    Http.get
-                        { url = "/api/self-service/init?" ++ queryParams
-                        , expect = Http.expectJson GotInitResponse initResponseDecoder
-                        }
-
-                Nothing ->
-                    Cmd.none
-    in
-    ( { orgId = orgId
-      , email = ""
-      , firstName = ""
-      , lastName = ""
-      , optInQuarterlyUpdates = False
-      , emailReadOnly = False
-      , isSubmitting = False
-      , error = Nothing
-      , success = False
-      , key = key
-      }
-    , initCmd
-    )
-
-
-
--- UPDATE
-
-
-type Msg
-    = GotInitResponse (Result Http.Error InitResponse)
-    | UpdateEmail String
-    | UpdateFirstName String
-    | UpdateLastName String
-    | ToggleOptIn Bool
-    | SubmitForm
-    | GotSignupResponse (Result Http.Error ())
-
-
-type alias InitResponse =
-    { contact : Maybe Contact
-    , email : Maybe String
-    , emailReadOnly : Bool
-    }
-
-
-type alias Contact =
-    { email : String
-    , firstName : String
-    , lastName : String
-    , optInQuarterlyUpdates : Bool
-    }
-
-
-update : Msg -> Model -> ( Model, Cmd Msg )
-update msg model =
-    case msg of
-        GotInitResponse result ->
-            case result of
-                Ok response ->
-                    let
-                        email =
-                            response.email |> Maybe.withDefault ""
-
-                        contact =
-                            response.contact
-
-                        firstName =
-                            contact |> Maybe.map .firstName |> Maybe.withDefault ""
-
-                        lastName =
-                            contact |> Maybe.map .lastName |> Maybe.withDefault ""
-
-                        optIn =
-                            contact |> Maybe.map .optInQuarterlyUpdates |> Maybe.withDefault False
-                    in
-                    ( { model
-                        | email = email
-                        , firstName = firstName
-                        , lastName = lastName
-                        , optInQuarterlyUpdates = optIn
-                        , emailReadOnly = response.emailReadOnly
-                        , error = Nothing
-                      }
-                    , Cmd.none
-                    )
-
-                Err _ ->
-                    ( { model | error = Just "Failed to load existing contact details. Please try again." }
-                    , Cmd.none
-                    )
-
-        UpdateEmail newEmail ->
-            ( { model
-                | email =
-                    if model.emailReadOnly then
-                        model.email
-
-                    else
-                        newEmail
-              }
-            , Cmd.none
-            )
-
-        UpdateFirstName newFirstName ->
-            ( { model | firstName = newFirstName }, Cmd.none )
-
-        UpdateLastName newLastName ->
-            ( { model | lastName = newLastName }, Cmd.none )
-
-        ToggleOptIn newValue ->
-            ( { model | optInQuarterlyUpdates = newValue }, Cmd.none )
-
-        SubmitForm ->
-            if isFormValid model then
-                ( { model | isSubmitting = True, error = Nothing }
-                , submitForm model
-                )
-
-            else
-                ( { model | error = Just "Please fill out all required fields" }
-                , Cmd.none
-                )
-
-        GotSignupResponse result ->
-            case result of
-                Ok _ ->
-                    ( { model | isSubmitting = False, success = True, error = Nothing }
-                    , Cmd.none
-                    )
-
-                Err _ ->
-                    ( { model | isSubmitting = False, error = Just "Signup failed. Please try again." }
-                    , Cmd.none
-                    )
-
-
-isFormValid : Model -> Bool
-isFormValid model =
-    not (String.isEmpty model.email)
-        && not (String.isEmpty model.firstName)
-        && not (String.isEmpty model.lastName)
-
-
-
--- FORM SUBMISSION
-
-
-submitForm : Model -> Cmd Msg
-submitForm model =
-    Http.post
-        { url = "/api/self-service/signup"
-        , body = Http.jsonBody (encodeForm model)
-        , expect = Http.expectWhatever GotSignupResponse
-        }
-
-
-encodeForm : Model -> Encode.Value
-encodeForm model =
-    Encode.object
-        [ ( "orgId", Encode.string (Maybe.withDefault "" model.orgId) )
-        , ( "email", Encode.string model.email )
-        , ( "firstName", Encode.string model.firstName )
-        , ( "lastName", Encode.string model.lastName )
-        , ( "optInQuarterlyUpdates", Encode.bool model.optInQuarterlyUpdates )
-        ]
-
-
-
--- DECODERS
-
-
-initResponseDecoder : Decoder InitResponse
-initResponseDecoder =
-    Decode.map3 InitResponse
-        (Decode.maybe (Decode.field "contact" contactDecoder))
-        (Decode.maybe (Decode.field "email" Decode.string))
-        (Decode.field "emailReadOnly" Decode.bool)
-
-
-contactDecoder : Decoder Contact
-contactDecoder =
-    Decode.map4 Contact
-        (Decode.field "email" Decode.string)
-        (Decode.field "firstName" Decode.string)
-        (Decode.field "lastName" Decode.string)
-        (Decode.field "optInQuarterlyUpdates" Decode.bool)
-
-
-
--- VIEW
-
-
-view : Model -> Browser.Document Msg
-view model =
-    { title = "Self-Service Onboarding"
-    , body =
-        [ div [ class "container mx-auto px-4 py-8" ]
-            [ h1 [ class "text-2xl font-bold mb-6" ] [ text "Complete Your Profile" ]
-            , viewForm model
-            ]
-        ]
-    }
-
-
-viewForm : Model -> Html Msg
-viewForm model =
-    div [ class "max-w-md mx-auto bg-white rounded-lg shadow-md p-6" ]
-        [ if model.success then
-            div [ class "p-4 mb-4 bg-green-100 border border-green-400 text-green-700 rounded" ]
-                [ text "Profile updated successfully!" ]
-
-          else
-            div []
-                [ inputField "Email" model.email UpdateEmail model.emailReadOnly
-                , inputField "First Name" model.firstName UpdateFirstName False
-                , inputField "Last Name" model.lastName UpdateLastName False
-                , checkboxField "Receive quarterly Medicare updates" model.optInQuarterlyUpdates ToggleOptIn
-                , viewError model.error
-                , button
-                    [ type_ "button"
-                    , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
-                    , onClick SubmitForm
-                    , disabled (model.isSubmitting || not (isFormValid model))
-                    ]
-                    [ text
-                        (if model.isSubmitting then
-                            "Submitting..."
-
-                         else
-                            "Submit"
-                        )
-                    ]
-                ]
-        ]
-
-
-inputField : String -> String -> (String -> Msg) -> Bool -> Html Msg
-inputField labelText value toMsg isDisabled =
-    div [ class "mb-4" ]
-        [ label [ class "block text-sm font-medium text-gray-700 mb-1" ] [ text labelText ]
-        , input
-            [ type_ "text"
-            , class "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
-            , Html.Attributes.value value
-            , onInput toMsg
-            , disabled isDisabled
-            ]
-            []
-        ]
-
-
-checkboxField : String -> Bool -> (Bool -> Msg) -> Html Msg
-checkboxField labelText isChecked toMsg =
-    div [ class "mb-6" ]
-        [ label [ class "flex items-center" ]
-            [ input
-                [ type_ "checkbox"
-                , class "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
-                , checked isChecked
-                , onCheck toMsg
-                ]
-                []
-            , span [ class "ml-2 text-sm text-gray-600" ] [ text labelText ]
-            ]
-        ]
-
-
-viewError : Maybe String -> Html msg
-viewError maybeError =
-    case maybeError of
-        Just error ->
-            div [ class "mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded" ]
-                [ text error ]
-
-        Nothing ->
-            text ""
-
-
-viewSuccess : Bool -> Html msg
-viewSuccess success =
-    if success then
-        div [ class "mb-4 p-3 bg-green-100 border border-green-400 text-green-700 rounded" ]
-            [ text "Profile updated successfully!" ]
-
-    else
-        text ""
-
-
-
--- HELPERS
-
-
-errorToString : Http.Error -> String
-errorToString error =
-    case error of
-        Http.BadUrl url ->
-            "Bad URL: " ++ url
-
-        Http.Timeout ->
-            "Request timed out"
-
-        Http.NetworkError ->
-            "Network error"
-
-        Http.BadStatus status ->
-            "Bad status: " ++ String.fromInt status
-
-        Http.BadBody message ->
-            "Bad body: " ++ message
-
-
-
--- MAIN
-
-
-main : Program () Model Msg
-main =
-    Browser.application
-        { init = \flags url key -> init key url
-        , view = view
-        , update = update
-        , subscriptions = \_ -> Sub.none
-        , onUrlChange = \_ -> GotInitResponse (Err (Http.BadUrl "URL changed"))
-        , onUrlRequest = \_ -> GotInitResponse (Err (Http.BadUrl "URL requested"))
-        }
-
-
-+++ New file: backend/src/routes/self-service.ts
-
-import { Elysia, t } from 'elysia';
-import { Database } from '../database';
-import { logger } from '../logger';
-import crypto from 'crypto';
-
-// Import generateHash function - reimplementing it since it's not exported from email.ts
-function generateHash(orgId: string, email: string): string {
-  const SECRET = process.env.HASH_SECRET || 'default-hash-secret';
-  return crypto.createHash('sha256').update(`${orgId}${email}${SECRET}`).digest('hex').slice(0, 16);
-}
-
-export function createSelfServiceRoutes() {
-  return new Elysia()
-    .get('/api/self-service/init', async ({ query, set }) => {
-      // Extract query parameters
-      const { orgId, email, hash } = query as { 
-        orgId?: string; 
-        email?: string; 
-        hash?: string;
-      };
-
-      // Validate required parameters
-      if (!orgId) {
-        set.status = 400;
-        return { error: 'orgId is required' };
-      }
-
-      // Validate hash if email is provided
-      if (email && hash) {
-        const expectedHash = generateHash(orgId, email);
-        if (hash !== expectedHash) {
-          logger.warn(`Invalid hash for email ${email} and orgId ${orgId}`);
-          set.status = 403;
-          return { error: 'Invalid email or hash' };
-        }
-      }
-
-      try {
-        // Get organization database
-        const orgDb = await Database.getOrgDb(orgId);
-        
-        // If email is provided, check for existing contact
-        if (email) {
-          const client = orgDb.getClient();
-          const result = await client.execute({
-            sql: `SELECT 
-                  email, 
-                  first_name AS firstName, 
-                  last_name AS lastName, 
-                  opt_in_quarterly_updates AS optInQuarterlyUpdates 
-                FROM contacts 
-                WHERE email = ?`,
-            args: [email]
-          });
-
-          // If contact exists, return contact details
-          if (result.rows.length > 0) {
-            const contact = result.rows[0];
-            logger.info(`Contact found for email ${email} in organization ${orgId}`);
-            return { 
-              contact, 
-              email, 
-              emailReadOnly: true 
-            };
-          }
-
-          // If no contact exists but email is provided
-          logger.info(`No contact found for email ${email} in organization ${orgId}`);
-          return { 
-            email, 
-            emailReadOnly: true 
-          };
-        }
-
-        // If no email is provided
-        return { emailReadOnly: false };
-
-      } catch (error) {
-        logger.error(`Error in self-service init endpoint: ${error}`);
-        set.status = 500;
-        return { error: 'Internal server error' };
-      }
-    });
-} 
\ No newline at end of file
diff --git a/frontend/src/Compare.elm b/frontend/src/Compare.elm
index 6122581..7b72f2a 100644
--- a/frontend/src/Compare.elm
+++ b/frontend/src/Compare.elm
@@ -299,9 +299,8 @@ init key maybeParams =
                     -- No quote ID, check if we have an org ID
                     case extractedOrgId of
                         Just orgId ->
-                            -- We have an org ID but no quote ID - in a real implementation, we might
-                            -- redirect to a self-service page, but for now we'll continue with default data
-                            initialCommands
+                            -- Redirect to the self-service onboarding page for this organization
+                            [ Nav.pushUrl key ("/self-onboarding/" ++ orgId) ]
 
                         Nothing ->
                             -- No org ID either - this is an error case
diff --git a/frontend/src/SelfServiceOnboarding.elm b/frontend/src/SelfServiceOnboarding.elm
index 8886795..5f172db 100644
--- a/frontend/src/SelfServiceOnboarding.elm
+++ b/frontend/src/SelfServiceOnboarding.elm
@@ -2,6 +2,7 @@ module SelfServiceOnboarding exposing (..)
 
 import Browser
 import Browser.Navigation as Nav
+import Date exposing (Date)
 import Dict
 import Html exposing (..)
 import Html.Attributes exposing (..)
@@ -9,7 +10,10 @@ import Html.Events exposing (..)
 import Http
 import Json.Decode as Decode exposing (Decoder)
 import Json.Encode as Encode
+import Task
+import Time
 import Url exposing (Url)
+import Url.Builder as Builder
 import Url.Parser as Parser exposing ((</>), Parser, oneOf, string)
 
 
@@ -23,15 +27,34 @@ type alias Model =
     , email : String
     , firstName : String
     , lastName : String
+    , zipCode : String
+    , dateOfBirth : String
+    , gender : String
+    , tobacco : Bool
+    , phoneNumber : String
+    , currentPremium : String
+    , currentCarrier : String
     , optInQuarterlyUpdates : Bool
     , emailReadOnly : Bool
     , isSubmitting : Bool
     , error : Maybe String
     , success : Bool
     , key : Nav.Key
+    , currentDate : Maybe Date
+    , state : Maybe String
+    , counties : List String
+    , selectedCounty : Maybe String
+    , isLoadingZipData : Bool
+    , zipError : Maybe String
+    , formStep : FormStep
     }
 
 
+type FormStep
+    = BasicInfo
+    | QuoteInfo
+    | ConfirmSubmit
+
 
 -- INIT
 
@@ -73,18 +96,35 @@ init key url =
             , email = ""
             , firstName = ""
             , lastName = ""
+            , zipCode = ""
+            , dateOfBirth = ""
+            , gender = "M"
+            , tobacco = False
+            , phoneNumber = ""
+            , currentPremium = ""
+            , currentCarrier = ""
             , optInQuarterlyUpdates = False
             , emailReadOnly = False
             , isSubmitting = False
             , error = Nothing
             , success = False
             , key = key
+            , currentDate = Nothing
+            , state = Nothing
+            , counties = []
+            , selectedCounty = Nothing
+            , isLoadingZipData = False
+            , zipError = Nothing
+            , formStep = BasicInfo
             }
+
+        commands =
+            [ Task.perform GotCurrentDate Date.today ]
     in
     case route of
         SlugRoute slug ->
             ( { initialModel | orgSlug = Just slug }
-            , fetchOrgDetails slug
+            , Cmd.batch (fetchOrgDetails slug :: commands)
             )
 
         QueryRoute ->
@@ -124,7 +164,7 @@ init key url =
                             Cmd.none
             in
             ( { initialModel | orgId = orgId }
-            , initCmd
+            , Cmd.batch (initCmd :: commands)
             )
 
 
@@ -165,6 +205,14 @@ fetchOrgDetails slug =
         }
 
 
+fetchZipInfo : String -> Cmd Msg
+fetchZipInfo zipCode =
+    Http.get
+        { url = "/api/zipinfo/" ++ zipCode
+        , expect = Http.expectJson GotZipInfo zipInfoDecoder
+        }
+
+
 
 -- UPDATE
 
@@ -175,9 +223,22 @@ type Msg
     | UpdateEmail String
     | UpdateFirstName String
     | UpdateLastName String
+    | UpdateZipCode String
+    | UpdateDateOfBirth String
+    | UpdateGender String
+    | UpdateTobacco String
+    | UpdatePhoneNumber String
+    | UpdateCurrentPremium String
+    | UpdateCurrentCarrier String
+    | UpdateSelectedCounty String
     | ToggleOptIn Bool
     | SubmitForm
+    | GotCurrentDate Date
+    | GotZipInfo (Result Http.Error ZipInfo)
     | GotSignupResponse (Result Http.Error ())
+    | NextStep
+    | PrevStep
+    | GoToQuote
 
 
 type alias InitResponse =
@@ -201,6 +262,30 @@ type alias Contact =
     }
 
 
+type alias ZipInfo =
+    { state : String
+    , counties : List String
+    }
+
+
+zipInfoDecoder : Decoder ZipInfo
+zipInfoDecoder =
+    Decode.field "success" Decode.bool
+        |> Decode.andThen
+            (\success ->
+                if success then
+                    Decode.field "data"
+                        (Decode.map2 ZipInfo
+                            (Decode.field "state" Decode.string)
+                            (Decode.field "counties" (Decode.list Decode.string))
+                        )
+
+                else
+                    Decode.field "error" Decode.string
+                        |> Decode.andThen (\error -> Decode.fail error)
+            )
+
+
 update : Msg -> Model -> ( Model, Cmd Msg )
 update msg model =
     case msg of
@@ -269,9 +354,136 @@ update msg model =
         UpdateLastName newLastName ->
             ( { model | lastName = newLastName }, Cmd.none )
 
+        UpdateZipCode zip ->
+            let
+                filteredZip =
+                    String.filter Char.isDigit zip |> String.left 5
+
+                cmd =
+                    if String.length filteredZip == 5 && filteredZip /= model.zipCode then
+                        fetchZipInfo filteredZip
+
+                    else
+                        Cmd.none
+            in
+            ( { model
+                | zipCode = filteredZip
+                , isLoadingZipData = String.length filteredZip == 5 && filteredZip /= model.zipCode
+                , state =
+                    if String.length filteredZip /= 5 then
+                        Nothing
+
+                    else
+                        model.state
+                , counties =
+                    if String.length filteredZip /= 5 then
+                        []
+
+                    else
+                        model.counties
+                , selectedCounty =
+                    if String.length filteredZip /= 5 then
+                        Nothing
+
+                    else
+                        model.selectedCounty
+                , zipError = Nothing
+              }
+            , cmd
+            )
+
+        GotZipInfo result ->
+            case result of
+                Ok zipInfo ->
+                    let
+                        -- Always select the first county as default
+                        selectedCounty =
+                            List.head zipInfo.counties
+                    in
+                    ( { model
+                        | state = Just zipInfo.state
+                        , counties = zipInfo.counties
+                        , selectedCounty = selectedCounty
+                        , isLoadingZipData = False
+                        , zipError = Nothing
+                      }
+                    , Cmd.none
+                    )
+
+                Err error ->
+                    ( { model
+                        | state = Nothing
+                        , counties = []
+                        , selectedCounty = Nothing
+                        , isLoadingZipData = False
+                        , zipError = Just (httpErrorToString error)
+                      }
+                    , Cmd.none
+                    )
+
+        UpdateSelectedCounty county ->
+            ( { model | selectedCounty = Just county }, Cmd.none )
+
+        UpdateDateOfBirth dob ->
+            ( { model | dateOfBirth = dob }, Cmd.none )
+
+        UpdateGender value ->
+            ( { model | gender = value }, Cmd.none )
+
+        UpdateTobacco value ->
+            ( { model | tobacco = value == "true" }, Cmd.none )
+
+        UpdatePhoneNumber phone ->
+            ( { model | phoneNumber = phone }, Cmd.none )
+
+        UpdateCurrentPremium premium ->
+            ( { model | currentPremium = premium }, Cmd.none )
+
+        UpdateCurrentCarrier carrier ->
+            ( { model | currentCarrier = carrier }, Cmd.none )
+
         ToggleOptIn newValue ->
             ( { model | optInQuarterlyUpdates = newValue }, Cmd.none )
 
+        GotCurrentDate date ->
+            ( { model | currentDate = Just date }, Cmd.none )
+
+        NextStep ->
+            let
+                nextStep =
+                    case model.formStep of
+                        BasicInfo ->
+                            if isBasicInfoValid model then
+                                QuoteInfo
+                            else
+                                BasicInfo
+
+                        QuoteInfo ->
+                            if isQuoteInfoValid model then
+                                ConfirmSubmit
+                            else
+                                QuoteInfo
+
+                        ConfirmSubmit ->
+                            ConfirmSubmit
+            in
+            ( { model | formStep = nextStep, error = Nothing }, Cmd.none )
+
+        PrevStep ->
+            let
+                prevStep =
+                    case model.formStep of
+                        BasicInfo ->
+                            BasicInfo
+
+                        QuoteInfo ->
+                            BasicInfo
+
+                        ConfirmSubmit ->
+                            QuoteInfo
+            in
+            ( { model | formStep = prevStep, error = Nothing }, Cmd.none )
+
         SubmitForm ->
             if isFormValid model then
                 ( { model | isSubmitting = True, error = Nothing }
@@ -295,9 +507,54 @@ update msg model =
                     , Cmd.none
                     )
 
+        GoToQuote ->
+            if isQuoteInfoValid model then
+                let
+                    county =
+                        case model.selectedCounty of
+                            Just c ->
+                                c
+
+                            Nothing ->
+                                List.head model.counties
+                                    |> Maybe.withDefault ""
+
+                    state =
+                        model.state
+                            |> Maybe.withDefault ""
+
+                    orgId =
+                        model.orgId |> Maybe.withDefault ""
+
+                    compareUrl =
+                        Builder.absolute [ "compare" ]
+                            [ Builder.string "zip" model.zipCode
+                            , Builder.string "state" state
+                            , Builder.string "county" county
+                            , Builder.string "gender" model.gender
+                            , Builder.string "tobacco"
+                                (if model.tobacco then
+                                    "true"
+
+                                 else
+                                    "false"
+                                )
+                            , Builder.string "dateOfBirth" model.dateOfBirth
+                            , Builder.string "planType" "G"
+                            , Builder.string "orgId" orgId
+                            ]
+                in
+                ( model
+                , Nav.pushUrl model.key compareUrl
+                )
+            else
+                ( { model | error = Just "Please fill out all required fields for a quote" }
+                , Cmd.none
+                )
 
-isFormValid : Model -> Bool
-isFormValid model =
+
+isBasicInfoValid : Model -> Bool
+isBasicInfoValid model =
     not (String.isEmpty model.email)
         && not (String.isEmpty model.firstName)
         && not (String.isEmpty model.lastName)
@@ -305,6 +562,38 @@ isFormValid model =
         /= Nothing
 
 
+isQuoteInfoValid : Model -> Bool
+isQuoteInfoValid model =
+    String.length model.zipCode == 5
+        && not (String.isEmpty model.dateOfBirth)
+        && not (String.isEmpty model.gender)
+        && model.state /= Nothing
+
+
+isFormValid : Model -> Bool
+isFormValid model =
+    isBasicInfoValid model && isQuoteInfoValid model
+
+
+httpErrorToString : Http.Error -> String
+httpErrorToString error =
+    case error of
+        Http.BadUrl url ->
+            "Bad URL: " ++ url
+
+        Http.Timeout ->
+            "Request timed out"
+
+        Http.NetworkError ->
+            "Network error"
+
+        Http.BadStatus statusCode ->
+            "Bad status: " ++ String.fromInt statusCode
+
+        Http.BadBody message ->
+            "Data error: " ++ message
+
+
 
 -- FORM SUBMISSION
 
@@ -325,6 +614,15 @@ encodeForm model =
         , ( "email", Encode.string model.email )
         , ( "firstName", Encode.string model.firstName )
         , ( "lastName", Encode.string model.lastName )
+        , ( "zipCode", Encode.string model.zipCode )
+        , ( "dateOfBirth", Encode.string model.dateOfBirth )
+        , ( "gender", Encode.string model.gender )
+        , ( "tobacco", Encode.bool model.tobacco )
+        , ( "phoneNumber", Encode.string model.phoneNumber )
+        , ( "currentPremium", Encode.string model.currentPremium )
+        , ( "currentCarrier", Encode.string model.currentCarrier )
+        , ( "state", Encode.string (Maybe.withDefault "" model.state) )
+        , ( "county", Encode.string (Maybe.withDefault "" model.selectedCounty) )
         , ( "optInQuarterlyUpdates", Encode.bool model.optInQuarterlyUpdates )
         ]
 
@@ -377,56 +675,289 @@ viewForm : Model -> Html Msg
 viewForm model =
     div [ class "max-w-md mx-auto bg-white rounded-lg shadow-md p-6" ]
         [ if model.success then
-            div [ class "p-4 mb-4 bg-green-100 border border-green-400 text-green-700 rounded" ]
-                [ text "Profile updated successfully!" ]
+            div []
+                [ div [ class "p-4 mb-4 bg-green-100 border border-green-400 text-green-700 rounded" ]
+                    [ text "Profile updated successfully!" ]
+                , button
+                    [ type_ "button"
+                    , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 mt-4"
+                    , onClick GoToQuote
+                    ]
+                    [ text "Get Your Quote" ]
+                ]
 
           else if model.orgId == Nothing && model.error == Nothing then
             div [ class "p-4 mb-4 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded" ]
                 [ text "Loading organization details..." ]
 
           else
+            viewFormStep model
+        ]
+
+
+viewFormStep : Model -> Html Msg
+viewFormStep model =
+    case model.formStep of
+        BasicInfo ->
             div []
-                [ inputField "Email" model.email UpdateEmail model.emailReadOnly
-                , inputField "First Name" model.firstName UpdateFirstName False
-                , inputField "Last Name" model.lastName UpdateLastName False
-                , checkboxField "Receive quarterly Medicare updates" model.optInQuarterlyUpdates ToggleOptIn
+                [ viewBasicInfoForm model
                 , viewError model.error
                 , button
                     [ type_ "button"
                     , class "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
-                    , onClick SubmitForm
-                    , disabled (model.isSubmitting || not (isFormValid model))
+                    , onClick NextStep
+                    , disabled (not (isBasicInfoValid model))
                     ]
-                    [ text
-                        (if model.isSubmitting then
-                            "Submitting..."
+                    [ text "Next" ]
+                ]
 
-                         else
-                            "Submit"
-                        )
+        QuoteInfo ->
+            div []
+                [ viewQuoteInfoForm model
+                , viewError model.error
+                , div [ class "flex justify-between mt-4" ]
+                    [ button
+                        [ type_ "button"
+                        , class "flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
+                        , onClick PrevStep
+                        ]
+                        [ text "Back" ]
+                    , button
+                        [ type_ "button"
+                        , class "flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
+                        , onClick NextStep
+                        , disabled (not (isQuoteInfoValid model))
+                        ]
+                        [ text "Next" ]
+                    ]
+                ]
+
+        ConfirmSubmit ->
+            div []
+                [ viewFormSummary model
+                , viewError model.error
+                , div [ class "flex justify-between mt-4" ]
+                    [ button
+                        [ type_ "button"
+                        , class "flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
+                        , onClick PrevStep
+                        ]
+                        [ text "Back" ]
+                    , button
+                        [ type_ "button"
+                        , class "flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
+                        , onClick SubmitForm
+                        , disabled (model.isSubmitting || not (isFormValid model))
+                        ]
+                        [ text
+                            (if model.isSubmitting then
+                                "Submitting..."
+
+                             else
+                                "Submit"
+                            )
+                        ]
                     ]
                 ]
+
+
+viewBasicInfoForm : Model -> Html Msg
+viewBasicInfoForm model =
+    div []
+        [ inputField "Email" "email" model.email UpdateEmail model.emailReadOnly
+        , inputField "First Name" "text" model.firstName UpdateFirstName False
+        , inputField "Last Name" "text" model.lastName UpdateLastName False
+        , inputField "Phone Number" "tel" model.phoneNumber UpdatePhoneNumber False
+        , checkboxField "Receive quarterly Medicare updates" model.optInQuarterlyUpdates ToggleOptIn
+        ]
+
+
+viewQuoteInfoForm : Model -> Html Msg
+viewQuoteInfoForm model =
+    div []
+        [ zipCodeField model
+        , if List.length model.counties > 1 then
+            viewCountyDropdown model.counties model.selectedCounty
+          else
+            text ""
+        , inputField "Date of Birth" "date" model.dateOfBirth UpdateDateOfBirth False
+        , formRadioGroup "Gender"
+            model.gender
+            UpdateGender
+            [ ( "M", "Male" ), ( "F", "Female" ) ]
+        , formRadioGroup "Tobacco User"
+            (if model.tobacco then
+                "true"
+             else
+                "false"
+            )
+            UpdateTobacco
+            [ ( "true", "Yes" ), ( "false", "No" ) ]
+        , inputField "Current Premium (Optional)" "number" model.currentPremium UpdateCurrentPremium False
+        , inputField "Current Carrier (Optional)" "text" model.currentCarrier UpdateCurrentCarrier False
+        ]
+
+
+viewFormSummary : Model -> Html Msg
+viewFormSummary model =
+    div [ class "border rounded-md p-4 mb-4" ]
+        [ h3 [ class "font-medium text-lg mb-3" ] [ text "Review Your Information" ]
+        , summaryItem "Email" model.email
+        , summaryItem "Name" (model.firstName ++ " " ++ model.lastName)
+        , summaryItem "Phone" model.phoneNumber
+        , summaryItem "Zip Code" model.zipCode
+        , summaryItem "State"
+            (model.state
+                |> Maybe.withDefault "Unknown"
+            )
+        , summaryItem "County"
+            (model.selectedCounty
+                |> Maybe.withDefault "Unknown"
+            )
+        , summaryItem "Date of Birth" model.dateOfBirth
+        , summaryItem "Gender"
+            (if model.gender == "M" then
+                "Male"
+             else
+                "Female"
+            )
+        , summaryItem "Tobacco User"
+            (if model.tobacco then
+                "Yes"
+             else
+                "No"
+            )
+        , if not (String.isEmpty model.currentPremium) then
+            summaryItem "Current Premium" ("$" ++ model.currentPremium)
+          else
+            text ""
+        , if not (String.isEmpty model.currentCarrier) then
+            summaryItem "Current Carrier" model.currentCarrier
+          else
+            text ""
+        , summaryItem "Quarterly Updates"
+            (if model.optInQuarterlyUpdates then
+                "Yes"
+             else
+                "No"
+            )
+        ]
+
+
+summaryItem : String -> String -> Html Msg
+summaryItem label value =
+    div [ class "flex justify-between py-1 border-b last:border-b-0" ]
+        [ span [ class "text-gray-600" ] [ text label ]
+        , span [ class "font-medium" ] [ text value ]
         ]
 
 
-inputField : String -> String -> (String -> Msg) -> Bool -> Html Msg
-inputField labelText value toMsg isDisabled =
+zipCodeField : Model -> Html Msg
+zipCodeField model =
     div [ class "mb-4" ]
-        [ label [ class "block text-sm font-medium text-gray-700 mb-1" ] [ text labelText ]
+        [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
+            [ text "Zip Code" ]
         , input
             [ type_ "text"
             , class "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
-            , Html.Attributes.value value
-            , onInput toMsg
+            , Html.Attributes.value model.zipCode
+            , onInput UpdateZipCode
+            , Html.Attributes.maxlength 5
+            , Html.Attributes.pattern "[0-9]*"
+            , required True
+            ]
+            []
+        , if model.isLoadingZipData then
+            div [ class "text-xs text-blue-600 mt-1" ]
+                [ text "Looking up location..." ]
+          else if model.zipError /= Nothing then
+            div [ class "text-xs text-red-600 mt-1" ]
+                [ text (Maybe.withDefault "Invalid zip code" model.zipError) ]
+          else if model.state /= Nothing then
+            div [ class "text-xs text-green-600 mt-1" ]
+                [ text ("Found: " ++ Maybe.withDefault "" model.state) ]
+          else
+            text ""
+        ]
+
+
+viewCountyDropdown : List String -> Maybe String -> Html Msg
+viewCountyDropdown counties selectedCounty =
+    div [ class "mb-4" ]
+        [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
+            [ text "County" ]
+        , select
+            [ class "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
+            , onInput UpdateSelectedCounty
+            , required True
+            ]
+            (option [ value "", disabled True, selected (selectedCounty == Nothing) ]
+                [ text "Select your county" ]
+                :: List.map
+                    (\county ->
+                        option
+                            [ value county
+                            , selected (selectedCounty == Just county)
+                            ]
+                            [ text county ]
+                    )
+                    counties
+            )
+        ]
+
+
+inputField : String -> String -> String -> (String -> Msg) -> Bool -> Html Msg
+inputField labelText inputType inputValue msg isDisabled =
+    div [ class "mb-4" ]
+        [ label [ class "block text-sm font-medium text-gray-700 mb-1" ] [ text labelText ]
+        , input
+            [ type_ inputType
+            , class "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
+            , Html.Attributes.value inputValue
+            , onInput msg
             , disabled isDisabled
             ]
             []
         ]
 
 
+formRadioGroup : String -> String -> (String -> Msg) -> List ( String, String ) -> Html Msg
+formRadioGroup labelText selectedValue msg options =
+    div [ class "mb-4" ]
+        [ label [ class "block text-sm font-medium text-gray-700 mb-1" ]
+            [ text labelText ]
+        , div [ class "flex gap-4" ]
+            (List.map
+                (\( val, txt ) ->
+                    label
+                        [ class
+                            ("flex items-center justify-center px-4 py-2 rounded-lg border-2 cursor-pointer transition-all flex-1 "
+                                ++ (if selectedValue == val then
+                                        "border-indigo-500 bg-indigo-50 text-indigo-700"
+                                    else
+                                        "border-gray-200 hover:border-indigo-200"
+                                   )
+                            )
+                        ]
+                        [ input
+                            [ type_ "radio"
+                            , value val
+                            , checked (selectedValue == val)
+                            , onInput msg
+                            , class "sr-only"
+                            ]
+                            []
+                        , text txt
+                        ]
+                )
+                options
+            )
+        ]
+
+
 checkboxField : String -> Bool -> (Bool -> Msg) -> Html Msg
 checkboxField labelText isChecked toMsg =
-    div [ class "mb-6" ]
+    div [ class "mb-4" ]
         [ label [ class "flex items-center" ]
             [ input
                 [ type_ "checkbox"
@@ -464,4 +995,4 @@ main =
         , subscriptions = \_ -> Sub.none
         , onUrlChange = \_ -> GotInitResponse (Err (Http.BadUrl "URL changed"))
         , onUrlRequest = \_ -> GotInitResponse (Err (Http.BadUrl "URL requested"))
-        }
+        }
\ No newline at end of file

================
File: example.env
================
# Turso Database
TURSO_DATABASE_URL="libsql://your-database-name.turso.io"  # Get this from: turso db show your-database-name --url
TURSO_AUTH_TOKEN="your-auth-token"  # Get this from: turso db tokens create your-database-name

# Application settings
PUBLIC_URL="http://localhost:5173"
COOKIE_SECRET="your-cookie-secret"
SESSION_DURATION=604800

# SendGrid (for email functionality)
SENDGRID_API_KEY="your-sendgrid-api-key"
SENDGRID_FROM_EMAIL="your-sender@email.com"

# Stripe configuration
STRIPE_SECRET_KEY="sk_test_your_test_key"
STRIPE_PUBLISHABLE_KEY="pk_test_your_test_key"
STRIPE_WEBHOOK_SECRET="whsec_your_webhook_secret"

# Stripe product/price IDs (created in Stripe Dashboard)
STRIPE_PRICE_BASIC="price_basic_id"
STRIPE_PRICE_PRO="price_pro_id"
STRIPE_PRICE_ENTERPRISE="price_enterprise_id"
STRIPE_PRICE_EXTRA_AGENT="price_extra_agent_id"
STRIPE_PRICE_EXTRA_CONTACT="price_extra_contact_id"

================
File: fix_elm.py
================
import re

with open("frontend/src/Onboarding/Onboarding.elm", "r") as f:
    content = f.read()

# Fix the missing closing parenthesis for Task.succeed ()
fixed_content = content.replace("(Task.perform (\\_ -> PlanSelection.LoadPlanFromSession plan) (Task.succeed ())", 
                                "(Task.perform (\\_ -> PlanSelection.LoadPlanFromSession plan) (Task.succeed ()))")
fixed_content = fixed_content.replace("(Task.perform (\\_ -> PlanSelection.LoadPlanFromSession planType) (Task.succeed ())", 
                                     "(Task.perform (\\_ -> PlanSelection.LoadPlanFromSession planType) (Task.succeed ()))")
fixed_content = fixed_content.replace("(Task.perform (\\_ -> UserDetails.loadUserFromSession userData) (Task.succeed ())", 
                                     "(Task.perform (\\_ -> UserDetails.loadUserFromSession userData) (Task.succeed ()))")

with open("frontend/src/Onboarding/Onboarding.elm", "w") as f:
    f.write(fixed_content)

print("File updated successfully")

================
File: hardcode_quote.json
================
[{"naic":"20699","group":-1,"company_name":"Ace Prop & Cas Ins Co","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":13958,"discount_rate":12981,"discount_category":"Roommate"}]},{"naic":"20699","group":-1,"company_name":"Ace Prop & Cas Ins Co","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":10575,"discount_rate":9835,"discount_category":"Roommate"}]},{"naic":"60380","group":-1,"company_name":"AFLAC","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":15756,"discount_rate":14180,"discount_category":"Roommate"}]},{"naic":"60380","group":-1,"company_name":"AFLAC","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":12196,"discount_rate":10976,"discount_category":"Roommate"}]},{"naic":"60984","group":-1,"company_name":"Humana Insurance Company","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":14944,"discount_rate":13152,"discount_category":"Roommate"}]},{"naic":"60984","group":-1,"company_name":"Humana Insurance Company","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":11321,"discount_rate":9962,"discount_category":"Roommate"}]},{"naic":"67369","group":-1,"company_name":"Cigna Hlth & Life Ins Co","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":12394,"discount_rate":11650,"discount_category":"Multi-Insured / Roommate"}]},{"naic":"67369","group":-1,"company_name":"Cigna Hlth & Life Ins Co","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":9011,"discount_rate":8470,"discount_category":"Multi-Insured / Roommate"}]},{"naic":"68500","group":-1,"company_name":"Continental Life Ins Co Brentwood","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":15277,"discount_rate":14208,"discount_category":"Multi-Insured"}]},{"naic":"68500","group":-1,"company_name":"Continental Life Ins Co Brentwood","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":11087,"discount_rate":10311,"discount_category":"Multi-Insured"}]},{"naic":"73288","group":-1,"company_name":"Humana Ins Co","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":26558,"discount_rate":25230,"discount_category":"Multi-Insured"}]},{"naic":"73288","group":-1,"company_name":"Humana Ins Co","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":20720,"discount_rate":19684,"discount_category":"Multi-Insured"}]},{"naic":"79413","group":-1,"company_name":"UnitedHealthcare Ins Co","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":21317,"discount_rate":20251,"discount_category":"Multi-Insured"}]},{"naic":"79413","group":-1,"company_name":"UnitedHealthcare Ins Co","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":19670,"discount_rate":18686,"discount_category":"Multi-Insured"}]},{"naic":"82538","group":-1,"company_name":"Allstate Health Solutions","quotes":[{"age":68,"gender":"F","plan":"G","tobacco":0,"rate":15138,"discount_rate":14079,"discount_category":"Multi-Insured / Roommate"}]},{"naic":"82538","group":-1,"company_name":"Allstate Health Solutions","quotes":[{"age":68,"gender":"F","plan":"N","tobacco":0,"rate":10976,"discount_rate":10208,"discount_category":"Multi-Insured / Roommate"}]}]

================
File: hello.py
================
def main():
    print("Hello from medicare-portal!")


if __name__ == "__main__":
    main()

================
File: Household Discounts Cheatsheet - HHD Simple.csv
================
,ACE/Chubb,,AETNA,,AFLAC,,Allstate,,Anthem,,CIGNA,,Mutual of Omaha,,Humana (MIPPA),,Humana (Achieve),,UHIC,,UHICA,
Alabama,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,10%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Alaska,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,,No Supps,"7%
addional 3%
additional 10%","Live with someone 50+
Multiple-member
Annual pay discount",,No Supps,20%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,,No Discount,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,,No Supps,5%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Arizona,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",5%,Both you and your spouse/partner must have a supplemental plan with Anthem.,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,15%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Arkansas,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
addional 3%","Live with someone 50+
Multiple-member",,No Supps,12%,"You need to live with a spouse or someone who is at least 50 years old.
",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,10%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
California,7%,You need to live with a spouse or someone who is at least 50 years old.,5%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",5%,Both you and your spouse/partner must have a supplemental plan with Anthem.,"6%
additional 5%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,,No Discount,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #. Additional $25 discount for first 12 months for new to Medicare on Plan G.,,No Supps
Colorado,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",10%,Both you and your spouse/partner must have a supplemental plan with Anthem.,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Connecticut,,No Supps,,No Supps,,No Supps,,No Supps,5%,Both you and your spouse/partner must have a supplemental plan with Anthem.,7%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,,No Discount,12%,You need to live with a spouse or someone who is at least 18 years old.,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Delaware,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
District of Columbia,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,,No discount,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,5%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,,No Discount,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,,No Supps,,No Supps,,No Supps
Florida,3%,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,,No discount,3%,Both you and your spouse/partner must have a supplemental plan with AFLAC.,3%,Live with someone 50+,,No Supps,3%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,,No Discount,,No Discount,3%,Both you and your spouse/partner must have a supplemental plan with Humana.,3%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Georgia,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",10%,You need to live with a spouse or someone who is at least 60 years old.,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,10%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Hawaii,,No Supps,,No Supps,,No Supps,,No Supps,,No Supps,,No Discount,,No Discount,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,,No Supps,,No Supps,,No Supps
Idaho,,No discount,,No discount,,No discount,,No discount,,No Supps,,No Discount,,No Discount,,*Value Plan - No Discount,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Illinois,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,10%,Live with someone 50+,,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,15%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Indiana,7%,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"10%
additional 5%
additional 10%","Live with someone 50+
Activity tracker discount (registered wearable device)
Annual pay discount",10%,Both you and your spouse/partner must have a supplemental plan with Anthem.,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,,No Discount,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,15%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Iowa,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Kansas,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,15%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Kentucky,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 18+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",10%,Both you and your spouse/partner must have a supplemental plan with Anthem.,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,12%,Both you and your spouse/partner must have a supplemental plan with Humana.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Louisiana,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,10%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Maine,7%,You need to live with a spouse or someone who is at least 50 years old.,,No Supps,,No Supps,,No Supps,5%,Both you and your spouse/partner must have a supplemental plan with Anthem.,7%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,7%,Both you and your spouse/partner must have a supplemental plan with Mutual of Omaha.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Maryland,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,,No Supps,10%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Massachusetts,,No Supps,,No Supps,,No Supps,,No Supps,,No Supps,,No Supps,,No Discount,12%,You need to live with a spouse or someone who is at least 18 years old.,,No Supps,5%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Michigan,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Minnesota,,No discount,,No discount,,No Supps,"5%
additional 10%","Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,,No Discount,,No Discount,,No Supps,,No Supps,5%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Mississippi,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,15%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Missouri,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",10%,Both you and your spouse/partner must have a supplemental plan with Anthem.,10%,"You need to live with someone who is at least 50 years old.
",12%,You need to live with a spouse or domestic partner.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Montana,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 18 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with someone who is at least 18 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Nebraska,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,5%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Nevada,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
addional 3%","Live with someone 50+
Multiple-member",5%,Both you and your spouse/partner must have a supplemental plan with Anthem.,"6%
additional 5%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
New Hampshire,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,,No Supps,,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,,No Supps,,No Supps
New Jersey,7%,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,7%,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,7%,Live with someone 50+,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,7%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,Both you and your spouse/partner must have a supplemental plan with Humana.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
New Mexico,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,,No Supps,,No Supps,,No Supps
New York,,No Supps,,No Supps,,No Supps,,No Supps,,Not accepting new Supps,,No Supps,,No Discount,,No Discount,,No Supps,,No Discount,,No Supps
North Carolina,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,15%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
North Dakota,,No Supps,,No discount,10%,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 4%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",10%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,,No Supps,,No Supps
Ohio,7%,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,10%,Live with someone 50+,5%,Both you and your spouse/partner must have a supplemental plan with Anthem.,7%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,12%,"You need to live with your spouse, partner, or a roomate for the last 12 months.",5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,Both you and your spouse/partner must have a supplemental plan with Humana.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,12%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Oklahoma,7%%,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,Both you and your spouse/partner/family member must have a supplemental plan with AFLAC.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,20%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,7%,"You need to live with your spouse, partner, or a roomate for the last 12 months.",12%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,10%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,20%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Oregon,,No Supps,5%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,7%,Live with someone 50+,,No Supps,11%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,,No Supps,12%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Pennsylvania,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,7%,Live with someone 50+,,No Supps,"6%
additional 14%","You need to live with a spouse or partner.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or domestic partner.,12%,"You need to live with spouse, civil or domestic partner.",12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,15%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Rhode Island,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,,No Supps,,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,,No Discount,,No Supps,,No Supps,,No Supps
South Carolina,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,15%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
South Dakota,7%,You need to live with a spouse or someone who is at least 50 years old.,,No discount,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,5%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Tennessee,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,15%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Texas,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",5%,Both you and your spouse/partner must have a supplemental plan with Anthem.,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with someone who is at least 18 years old.,12%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,20%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.
Utah,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Vermont,,No Supps,,No discount,,No discount,,No Supps,,No Supps,,No Discount,,No Discount,,No Discount,,No Supps,,No Supps,,No Supps
Virginia,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,Both you and your spouse/partner must have a supplemental plan with AFLAC.,"7%
addional 3%","Live with someone 50+
Multiple-member",5%,Both you and your spouse/partner must have a supplemental plan with Anthem.,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,12%,You need to live with a spouse or someone who is at least 18 years old.,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Washington,7%,Both you and your spouse/partner must have a supplemental plan with Ace/Chubb.,,No Supps,,No Supps,,No Supps,,No Supps,5%,Both you and your spouse/partner must have a supplemental plan with CIGNA.,7%,Both you and your spouse/partner must have a supplemental plan with Mutual of Omaha.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,,No Supps,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
West Virginia,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Wisconsin,7%,You need to live with a spouse or someone who is at least 50 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",10%,Both you and your spouse/partner must have a supplemental plan with Anthem.,"6%
additional 14%","You need to live with someone who is at least 18 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,7%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps
Wyoming,7%,You need to live with a spouse or someone who is at least 50 years old.,5%,Both you and your spouse/partner must have a supplemental plan with AETNA.,10%,You need to live with a spouse or someone who is at least 50 years old.,"7%
additional 3%
additional 5%
additional 10%","Live with someone 50+
Multiple-member
Activity tracker discount (registered wearable device)
Annual pay discount",,No Supps,"6%
additional 14%","You need to live with a spouse or someone who is at least 50 years old.
Both you and your spouse/partner must have a supplemental plan with CIGNA.",12%,You need to live with a spouse or someone who is at least 60 years old.,5%,Both you and your spouse/partner must have a supplemental plan with Humana.,12%,You need to live with a spouse or someone who is at least 18 years old.,5%,Both you and your spouse/partner must have a supplemental plan with AARP / UHC and use the same AARP Membership #.,,No Supps

================
File: msg.md
================
<think>Let me analyze the code to identify all the endpoints involved in the onboarding process and summarize what information is sent to each.

Based on the provided code, I can see the following endpoints used in the onboarding flow:

1. `/api/onboarding/initialize`
2. `/api/onboarding/resume-onboarding`
3. `/api/onboarding/{orgSlug}/user`
4. `/api/onboarding/{orgSlug}/company`
5. `/api/onboarding/{orgSlug}/licensing`
6. `/api/onboarding/{orgSlug}/team-members`
7. `/api/onboarding/{orgSlug}/complete`
8. `/api/organizations/complete-onboarding` (this appears to be possibly a different endpoint for the same purpose as the one above)
9. `/api/organizations/check-email/{email}` (for checking email availability)
10. `/api/me` (for fetching user details)
11. `/api/organizations/signup` (appears to be used for user details in the old workflow)

Let me go through each one to summarize the request methods, data sent, and purpose.</think># Onboarding Endpoints Summary

Based on the code you've shared, here's a detailed summary of all the endpoints involved in the progressive onboarding process:

## 1. Initialize Onboarding
- **Endpoint**: `/api/onboarding/initialize` (POST)
- **Purpose**: Start a new onboarding process
- **Data Sent**:
  ```json
  {
    "planType": "string", // basic, pro, or enterprise
    "email": "string"
  }
  ```
- **Response**:
  ```json
  {
    "organizationId": number,
    "slug": "string",
    "sessionToken": "string",
    "onboardingStep": number
  }
  ```

## 2. Resume Onboarding
- **Endpoint**: `/api/onboarding/resume-onboarding` (POST)
- **Purpose**: Resume an in-progress onboarding
- **Data Sent**:
  ```json
  {
    "email": "string"
  }
  ```
- **Response**: Same as initialize endpoint

## 3. Update User Details
- **Endpoint**: `/api/onboarding/{orgSlug}/user` (PUT)
- **Headers**: `Authorization: Bearer {sessionToken}`
- **Purpose**: Save user's personal information
- **Data Sent**:
  ```json
  {
    "firstName": "string",
    "lastName": "string",
    "email": "string",
    "phone": "string"
  }
  ```
- **Response**:
  ```json
  {
    "onboardingStep": number
  }
  ```

## 4. Update Company Details
- **Endpoint**: `/api/onboarding/{orgSlug}/company` (PUT)
- **Headers**: `Authorization: Bearer {sessionToken}`
- **Purpose**: Save company information
- **Data Sent**:
  ```json
  {
    "agencyName": "string",
    "website": "string",
    "phone": "string",
    "primaryColor": "string",
    "secondaryColor": "string",
    "logo": "string" // optional, can be null
  }
  ```
- **Response**:
  ```json
  {
    "onboardingStep": number
  }
  ```

## 5. Update Licensing Details
- **Endpoint**: `/api/onboarding/{orgSlug}/licensing` (PUT)
- **Headers**: `Authorization: Bearer {sessionToken}`
- **Purpose**: Save licensing and carrier information
- **Data Sent**:
  ```json
  {
    "stateLicenses": ["string"],
    "carrierContracts": ["string"],
    "useSmartSendForGI": boolean
  }
  ```
- **Response**:
  ```json
  {
    "onboardingStep": number,
    "nextStep": number,
    "isBasicPlan": boolean
  }
  ```

## 6. Add Team Members
- **Endpoint**: `/api/onboarding/{orgSlug}/team-members` (PUT)
- **Headers**: `Authorization: Bearer {sessionToken}`
- **Purpose**: Add team members/agents to the organization
- **Data Sent**:
  ```json
  {
    "agents": [
      {
        "firstName": "string",
        "lastName": "string",
        "email": "string",
        "phone": "string",
        "isAdmin": boolean,
        "isAgent": boolean
      }
    ]
  }
  ```
- **Response**:
  ```json
  {
    "onboardingStep": number
  }
  ```

## 7. Complete Subscription
- **Endpoint**: `/api/onboarding/{orgSlug}/complete` (POST)
- **Headers**: `Authorization: Bearer {sessionToken}`
- **Purpose**: Complete the onboarding process and set up subscription
- **Data Sent**:
  ```json
  {
    "planType": "string",
    "extraAgents": number,
    "extraContacts": number
  }
  ```
- **Response**:
  ```json
  {
    "clientSecret": "string",
    "publishableKey": "string"
  }
  ```

## 8. Complete Onboarding (Alternative Endpoint)
- **Endpoint**: `/api/organizations/complete-onboarding` (POST)
- **Purpose**: Submit all onboarding data at once (seems to be a legacy endpoint)
- **Data Sent**: A complex object containing all the onboarding data:
  ```json
  {
    "plan": {
      "type": "string",
      "extraAgents": number,
      "extraContacts": number,
      "price": number,
      "billingCycle": "string"
    },
    "user": {
      "firstName": "string",
      "lastName": "string",
      "email": "string",
      "phone": "string"
    },
    "company": {
      "agencyName": "string",
      "website": "string",
      "phone": "string",
      "primaryColor": "string",
      "secondaryColor": "string",
      "logo": "string" // or null
    },
    "licensing": {
      "stateLicenses": ["string"],
      "carrierContracts": ["string"],
      "stateCarrierSettings": [
        {
          "state": "string",
          "carrier": "string",
          "active": boolean,
          "targetGI": boolean
        }
      ]
    },
    "agents": [...] // list of agent objects
  }
  ```

## 9. Check Email Availability
- **Endpoint**: `/api/organizations/check-email/{email}` (GET)
- **Purpose**: Check if an email is available for registration
- **Response**:
  ```json
  {
    "available": boolean,
    "message": "string"
  }
  ```

The main flow follows a step-by-step progression where each endpoint corresponds to a step in the onboarding process. The progressive approach allows users to save their progress and continue later, with state tracked both on the backend and in the browser's local storage.

Let me know if you need more specific details about any particular endpoint or aspect of the implementation!

================
File: output.txt
================
⣾  Connecting to database
ID     NAME         SLUG         SUBSCRIPTION TIER     AGENT LIMIT     CONTACT LIMIT     STRIPE CUSTOMER ID     STRIPE SUBSCRIPTION ID     ORG SETTINGS     CREATED AT              TURSO DB URL                                      TURSO AUTH TOKEN                                                                                                                                                                                                                                                            
11     Test Org     test-org     basic                 5               100               NULL                   NULL                       NULL             2025-02-10 15:49:15     https://org-11-pyrex41.aws-us-east-1.turso.io     eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE3MzkyMDI1NTcsImlkIjoiNDA2ZjI5NTAtODAzOS00MDgyLWExZTMtOTY4ZTQxMjJjYzkxIiwicmlkIjoiNWUzYTVmMmItMjMwMS00MDk3LThkNmMtODZhY2VhOTAzMjE3In0.wSAMaTtXPtf7S3eanCMgbu4dxqzgAxkoZGNfWdiJPRoPAdGDExWNKWdXt-tqhR4ExJj7cTVCWfY0_LfdjLPrDg

================
File: package.json
================
{
  "name": "dashboard-monorepo",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "NODE_ENV=development concurrently 'bun run dev:frontend' 'bun run dev:backend'",
    "dev:frontend": "cd frontend && bun run dev",
    "dev:backend": "cd backend && bun run dev",
    "build": "cd frontend && bun run build",
    "start": "cd backend && NODE_ENV=production bun run src/index.ts"
  },
  "devDependencies": {
    "concurrently": "^8.2.2",
    "typescript": "^5.7.3",
    "vite-plugin-elm": "^3.0.1"
  },
  "dependencies": {
    "tailwindcss-animate": "^1.0.7"
  }
}

================
File: port-example.js
================
// Example JavaScript port implementation for Onboarding plan type
// This would typically be added to your JavaScript initialization file
// where you set up Elm ports

// Initialize the Elm app and connect ports
const app = Elm.Main.init({
  node: document.getElementById('elm-app'),
  flags: {
    // Any flags your app needs
  }
});

// Handle retrieving plan type from localStorage or API
app.ports.retrievePlanType.subscribe(function(orgSlug) {
  // In a real app, this would check localStorage or make an API call
  const planType = localStorage.getItem('plan_type_' + orgSlug) || 'basic';
  
  console.log('Retrieved plan type:', planType, 'for org:', orgSlug);
  
  // Send the plan type back to Elm
  app.ports.planTypeReceived.send(planType);
});

// Handle saving and retrieving user details
app.ports.storeUserDetails.subscribe(function(userData) {
  console.log('Storing user details for:', userData.organizationId);
  localStorage.setItem('user_details_' + userData.organizationId, JSON.stringify(userData));
});

app.ports.retrieveUserDetails.subscribe(function(organizationId) {
  console.log('Retrieving user details for:', organizationId);
  const userDetailsStr = localStorage.getItem('user_details_' + organizationId);
  const userData = userDetailsStr ? JSON.parse(userDetailsStr) : null;
  
  // Send back only the user data fields needed by the UserDetails module
  if (userData) {
    app.ports.userDetailsReceived.send({
      firstName: userData.firstName,
      lastName: userData.lastName,
      email: userData.email,
      phone: userData.phone
    });
  } else {
    app.ports.userDetailsReceived.send(null);
  }
});

// Storage port for when a plan is selected
// You would need to add this port to your Elm app
app.ports.storePlanType.subscribe(function(data) {
  console.log('Storing plan type:', data.planType, 'for org:', data.orgSlug);
  localStorage.setItem('plan_type_' + data.orgSlug, data.planType);
});

// Other port handlers for existing functionality
app.ports.storeOnboardingState.subscribe(function(state) {
  console.log('Storing onboarding state:', state);
  localStorage.setItem('onboarding_state', JSON.stringify(state));
});

app.ports.retrieveOnboardingState.subscribe(function() {
  const stateStr = localStorage.getItem('onboarding_state');
  const state = stateStr ? JSON.parse(stateStr) : null;
  console.log('Retrieved onboarding state:', state);
  app.ports.onboardingStateReceived.send(state);
});

================
File: replit.nix
================
{pkgs}: {
  deps = [
    pkgs.elmPackages.elm
    pkgs.tree
    pkgs.sqlite
  ];
}

================
File: sensitive-paths.txt
================
monitor/node_modules/bun-types/docs/guides/ecosystem/discordjs.md

================
File: svgo-config.js
================
module.exports = {
  plugins: [
    'removeDimensions',
    'removeViewBox',
    'cleanupIDs',
    'removeRasterImages',
    'removeUselessDefs',
    'removeNonInheritableGroupAttrs',
    'removeUselessStrokeAndFill',
    'convertStyleToAttrs',
    'removeDuplicateElements',
    {
      name: 'removeAttrs',
      params: {
        attrs: ['class', 'data-name', 'fill-rule', 'clip-rule']
      }
    },
    {
      name: 'convertColors',
      params: {
        currentColor: false,
        names2hex: true,
        rgb2hex: true,
        shorthex: true
      }
    },
    {
      name: 'convertPathData',
      params: {
        noSpaceAfterFlags: false
      }
    },
    {
      name: 'cleanupNumericValues',
      params: {
        floatPrecision: 2,
        leadingZero: true,
        defaultPx: true,
        convertToPx: true
      }
    }
  ]
}

================
File: svgo.config.yml
================
plugins:
  - removeDimensions
  - removeViewBox
  - cleanupIDs
  - removeRasterImages
  - removeUselessDefs
  - removeNonInheritableGroupAttrs
  - removeUselessStrokeAndFill
  - convertStyleToAttrs
  - removeDuplicateElements
  - removeAttrs:
      attrs:
        - class
        - data-name
        - fill-rule
        - clip-rule
  - convertColors:
      currentColor: false
      names2hex: true
      rgb2hex: true
      shorthex: true
  - convertPathData:
      noSpaceAfterFlags: false
  - cleanupNumericValues:
      floatPrecision: 2
      leadingZero: true
      defaultPx: true
      convertToPx: true

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: ["./src/**/*.{html,js,elm}", "*.{js,ts,jsx,tsx,mdx}"],
  theme: {
    extend: {
      fontFamily: {
        sans: [
          '-apple-system',
          'BlinkMacSystemFont',
          'Roboto',
          '"Segoe UI"',
          '"Helvetica Neue"',
          'Arial',
          '"Noto Sans"',
          'sans-serif',
          '"Apple Color Emoji"',
          '"Segoe UI Emoji"',
          '"Segoe UI Symbol"',
          '"Noto Color Emoji"',
        ],
        heading: ['Inter', 'system-ui', 'sans-serif'],
      },
      colors: {
        brand: {
          DEFAULT: '#03045e',
          light: '#f9fafb',
        },
        gray: {
          50: '#f9fafb',
          100: '#eaecf0',
          300: '#d0d5dd',
          400: '#98a2b3',
          500: '#667085',
          600: '#475467',
          700: '#344054',
          900: '#101828',
        },
        // Keep existing shadcn/ui colors
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        // Medicare-specific colors
        medicare: {
          success: "#047857",
          "success-light": "#eafcf1",
          danger: "#ef4444",
          "danger-light": "#fecaca",
        },
        // New theme colors for questions
        theme: {
          blue: {
            DEFAULT: "#0075F2",
            light: "rgba(0, 117, 242, 0.1)",
            medium: "rgba(0, 117, 242, 0.2)",
          },
          purple: {
            DEFAULT: "#7F56D9",
            light: "rgba(127, 86, 217, 0.1)",
            medium: "rgba(127, 86, 217, 0.2)",
          },
          amber: {
            DEFAULT: "#F59E0B",
            light: "rgb(254, 243, 199)",
            medium: "rgb(253, 230, 138)",
          },
          brand: {
            DEFAULT: "#03045E",
            light: "#ADE8F4",
            medium: "rgba(173, 232, 244, 0.5)",
          }
        }
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      boxShadow: {
        'card': '0px 4px 6px -2px rgba(0, 0, 0, 0.05), 0px 10px 15px -3px rgba(0, 0, 0, 0.1)',
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}

================
File: test_billing_endpoints.sh
================
#!/bin/bash

# Usage: ./test_billing_endpoints.sh <session_cookie>
SESSION_COOKIE="${1:-5e296135324bad158796b97d1cec9bece2b7f3dae33314570969b459081d37fc}"
BASE_URL="http://localhost:5173"

echo "=== /api/billing/plan ==="
curl -s --cookie "session=$SESSION_COOKIE" "$BASE_URL/api/billing/plan" | jq
echo

echo "=== /api/billing/payment-method ==="
curl -s --cookie "session=$SESSION_COOKIE" "$BASE_URL/api/billing/payment-method" | jq
echo

echo "=== /api/billing/invoices ==="
curl -s --cookie "session=$SESSION_COOKIE" "$BASE_URL/api/billing/invoices" | jq
echo

================
File: todo.txt
================
Below is the synthesized and optimized prompt document for the AI agent tasked with implementing UI/UX improvements to the MedicareMax front-end application. This version combines the best elements from both provided prompt documents, ensuring clarity, actionable steps, and a focus on user experience. It incorporates detailed code snippets where helpful, resolves ambiguities, and prioritizes tasks effectively.
Optimized Prompt Document for AI Agent: MedicareMax UI/UX Improvements
Objective
Implement a series of UI/UX improvements, bug fixes, and feature enhancements to the MedicareMax front-end application. The focus is on enhancing user onboarding, navigation, visual consistency, contact management, profile/settings functionality, and admin features, while ensuring seamless integration with the back-end where applicable.
Context
Codebase: The front-end is built with Elm, styled using Tailwind CSS, and uses Vite for the build process. Key files include Signup.elm, Dashboard.elm, Contacts.elm, Profile.elm, and Settings.elm.
Visual Context: Screenshots are provided to reflect the current UI state (e.g., dashboard graph, organization settings).
Back-End Access: The AI can introspect and modify the back-end API (proxied at http://localhost:8000) as needed.
Application Purpose: A CRM/management tool for Medicare insurance agents.
General Guidelines
User Experience: Prioritize intuitive navigation, clear feedback, and a visually appealing interface.
Consistency: Use existing Tailwind classes (e.g., bg-[#03045E], text-white, rounded-md) and ensure UI elements align across the application.
Error Handling: For back-end interactions, implement proper error handling and user feedback (e.g., success/error messages).
Code Quality: Write clean, maintainable code following existing conventions in the codebase.
Testing: Validate changes in the browser, ensuring responsiveness and correct functionality across screen sizes.
Tasks (Prioritized)
1. Post-Payment Onboarding & Navigation (High Priority)
Task 1.1: Dashboard Redirect and Tutorial Modal
Trigger: After successful payment submission (detect via front-end or back-end signal, e.g., /api/payments response).
Actions:
Redirect to /dashboard.
Display a dismissible modal with a video walkthrough (setup tutorial). Assume a placeholder video URL if not provided (e.g., https://www.youtube.com/embed/VIDEO_ID).
Implementation:
Update payment submission logic (likely in Signup.elm or Onboarding/Steps/Payment.elm):
elm
case msg of
    PaymentSubmitted (Ok _) ->
        ( { model | isSubmitting = False }, Nav.pushUrl model.key "/dashboard" )
In Dashboard.elm, add modal logic:
elm
type alias Model =
    { ... , showTutorialModal : Bool }

init : (...) -> ( Model, Cmd Msg )
init flags =
    ( { ... , showTutorialModal = flags.isPostPayment |> Maybe.withDefault False }, Cmd.none )

view : Model -> Html Msg
view model =
    div []
        [ if model.showTutorialModal then viewTutorialModal else text ""
        , ... ]

viewTutorialModal : Html Msg
viewTutorialModal =
    div [ class "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center" ]
        [ div [ class "bg-white p-6 rounded-lg shadow-lg max-w-2xl w-full" ]
            [ iframe [ src "https://www.youtube.com/embed/VIDEO_ID", class "w-full h-96", attribute "allowfullscreen" "" ] []
            , button [ class "mt-4 px-4 py-2 bg-blue-600 text-white rounded-md", onClick CloseModal ] [ text "Close" ]
            ]
        ]
Handle CloseModal to set showTutorialModal to False.
Back-End: If payment success includes a flag (e.g., isPostPayment), use it to trigger the modal.
Task 1.2: "Watch Setup Tutorial" Link
Location: User profile dropdown menu.
Action: Open the same video modal as in Task 1.1.
Implementation:
In Profile.elm, update the menu:
elm
viewNavigation : Model -> Html Msg
viewNavigation model =
    nav []
        [ viewNavLink "Watch Setup Tutorial" "#" OpenTutorialModal
        , viewNavLink "Profile" "/profile" NoOp
        , viewNavLink "Organization Settings" "/settings" NoOp ]
Handle OpenTutorialModal to set showTutorialModal to True.
Task 1.3: Prevent Back Button Navigation to Payment
Goal: Prevent navigation back to payment or plan selection screens post-payment.
Implementation:
Use history.replaceState() in main.ts or equivalent:
javascript
window.addEventListener('popstate', () => {
    if (location.pathname.match(/dashboard|contacts|settings/)) {
        history.replaceState({}, document.title, '/dashboard');
    }
});
Alternatively, add a server-side check to redirect paid users from payment pages.
Testing: Confirm back button redirects to /dashboard after payment.
2. Dashboard Visual Updates (High Priority)
Task 2.1: Update Graph Colors
Colors:
Quotes Sent: #DCE2E5
Quotes Viewed: #53389E
Follow-Up Requests: #03045E
Implementation:
In Dashboard.elm, update the graph:
elm
viewGraph : Model -> Html Msg
viewGraph model =
    svg [ viewBox "0 0 300 200" ]
        [ rect [ x "10", y "150", width "80", height "50", fill "#DCE2E5" ] [] -- Quotes Sent
        , rect [ x "100", y "120", width "80", height "80", fill "#53389E" ] [] -- Quotes Viewed
        , rect [ x "190", y "100", width "80", height "100", fill "#03045E" ] [] -- Follow-Up Requests
        ]
Task 2.2: Update Analytics Number Color
Color: #03045E
Implementation:
In Dashboard.elm:
elm
viewAnalytics : Model -> Html Msg
viewAnalytics model =
    div [ class "text-[#03045E] text-2xl font-bold" ]
        [ text (String.fromInt model.quotesSent) ]
3. Navigation and Layout (Medium Priority)
Task 3.1: Main Navigation Hover Color
Color: #DCE2E5
Implementation:
In Settings.elm or shared navigation component:
elm
viewNavLink : String -> String -> Msg -> Html Msg
viewNavLink label path msg =
    a [ href path, class "text-gray-700 hover:bg-[#DCE2E5] px-3 py-2 rounded-md" ]
        [ text label ]
Task 3.2: Expand Contacts Table Width
Goal: Align with "Add Contact" button and top analytics.
Implementation:
In Contacts.elm:
elm
viewContacts : Model -> Html Msg
viewContacts model =
    table [ class "w-full max-w-7xl" ]
        [ ... ]
Task 3.3: Update "Settings" Label and Reorder Menu
Label: Change "Settings" to "Organization Settings".
Order: Move "Profile" above "Organization Settings".
Implementation:
In Profile.elm:
elm
viewNavigation model =
    nav []
        [ viewNavLink "Watch Setup Tutorial" "#" OpenTutorialModal
        , viewNavLink "Profile" "/profile" NoOp
        , viewNavLink "Organization Settings" "/settings" NoOp ]
4. Contact Management (Medium Priority)
Task 4.1: Adding Contacts Modal - Hover Color
Color: #03045E
Implementation:
In Contacts.elm:
elm
viewAddContactModal : Model -> Html Msg
viewAddContactModal model =
    div [ class "space-y-4" ]
        [ div [ class "hover:bg-[#03045E] hover:text-white p-2 rounded-md", onClick SelectOption ] [ text "Option" ] ]
Task 4.2: Reduce Spacing in Adding Contacts Modal
Goal: Lessen vertical space between "Add Contacts" and subtext.
Implementation:
In Contacts.elm:
elm
viewAddContactModal : Model -> Html Msg
viewAddContactModal model =
    div [ class "space-y-2" ]
        [ h2 [ class "text-lg font-medium" ] [ text "Add Contacts" ]
        , p [ class "text-gray-600" ] [ text "Select how you want to add your new contacts." ]
        ]
Task 4.3: Make Single Contact Modal Scrollable
Issue: Form overflows on smaller screens without scrolling.
Implementation:
In Contacts.elm:
elm
viewSingleContactModal : Model -> Html Msg
viewSingleContactModal model =
    div [ class "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center" ]
        [ div [ class "bg-white p-6 rounded-lg shadow-lg max-w-lg w-full overflow-y-auto max-h-[80vh]" ]
            [ Html.form []
                [ input [ class "w-full mb-4", placeholder "First Name" ] []
                , input [ class "w-full mb-4", placeholder "Last Name" ] []
                , ... ]
            ]
        ]
5. Profile and Organization Settings (Medium Priority)
Task 5.1: Add Dropdowns for Carriers and Plan Types
Location: Add/edit contact modals.
Implementation:
In Contacts.elm:
elm
viewSingleContactModal model =
    div []
        [ select [ class "w-full mb-4", onInput UpdateCarrier ]
            (option [] [ text "-- Select Carrier --" ] :: List.map (\c -> option [ value c ] [ text c ]) model.allCarriers)
        , select [ class "w-full mb-4", onInput UpdatePlanType ]
            [ option [] [ text "-- Select Plan Type --" ]
            , option [ value "Basic" ] [ text "Basic" ]
            , option [ value "Professional" ] [ text "Professional" ]
            ]
        ]
Data Source: Check if allCarriers should be static or fetched from /api/carriers.
Task 5.2: Update Organization Settings Headline Color
Color: #03045E
Implementation:
In Settings.elm:
elm
h1 [ class "text-2xl font-semibold text-[#03045E]" ] [ text "Organization Settings" ]
Task 5.3: Design Review for State, Carrier, GI Selections
Prompt: "Analyze the current design for State, Carrier, and Guaranteed Issue (GI) selections on the Organization Settings page. Consider multi-select dropdowns, searchable dropdowns, or tag-based selection. Provide specific recommendations for improvement."
Task 5.4: Fix "Clear All" for State & Carrier Settings
Issue: Only clears "GA".
Implementation:
In Settings.elm:
elm
update msg model =
    case msg of
        ToggleAllStates False ->
            updateSettings model (\s -> { s | stateLicenses = [] })
        ToggleAllCarriers False ->
            updateSettings model (\s -> { s | carrierContracts = [] })
Task 5.5: Assess Save Button Necessity
Prompt: "Check if Organization Settings auto-saves. If not, add a 'Save' button with API calls (e.g., /api/settings/update). If auto-saving, add feedback (e.g., 'Saving...' indicator)."
Task 5.6: Remove "Next: Go to Dashboard" Button
Implementation:
In Settings.elm, remove from viewBottomBar.
Task 5.7: Add Calendar URL to Profile Page
Implementation:
In Profile.elm:
elm
viewProfileForm : Model -> Html Msg
viewProfileForm model =
    div []
        [ input [ class "w-full px-3.5 py-2.5", placeholder "Calendar URL", onInput UpdateCalendarUrl ] [] ]
Persist via /api/users/update.
6. Admin Features (Low Priority)
Task 6.1: Subscription & Payment Options Page
Access: Admin-only.
Content: View/change subscription plans, update payment methods, view billing history.
Implementation:
Create Subscription.elm with API calls (e.g., /api/subscriptions).
Link from Profile.elm:
elm
if model.user.isAdmin then viewNavLink "Subscription & Payments" "/subscription" NoOp else text ""
Task 6.2: Simplify Admin Role Terminology
Goal: Use "Admin" and "Agent" only.
Implementation:
Update UI in Onboarding/Steps/AddAgents.elm.
Check back-end for "Admin Agent" usage; hide or remove if possible.
Task 6.3: Standardize Profile Page Input Sizes
Implementation:
In Profile.elm, ensure inputs use px-3.5 py-2.5.
Task 6.4: Check Multiple Agent Addition
Prompt: "Verify if multiple agent addition is supported. If not, enforce single-agent addition. If supported, ensure it works correctly."
Deliverables
Updated Elm files.
New Subscription.elm (if applicable).
Summary of changes, including back-end modifications.
Next Steps
Implement tasks in priority order, testing each change.
Provide a final report for review.
This synthesized prompt document offers a comprehensive, prioritized roadmap for the AI agent, blending detailed instructions and flexibility for back-end coordination. It ensures a consistent, user-friendly MedicareMax application.

================
File: w2.csv
================
First Name,Last Name,Email,Current Carrier,Plan Type,Effective Date,Birth Date,Tobacco User,Gender,ZIP Code,Phone Number
Margaret,Wilson,margaret.wilson@email.com,Humana,G,2023-05-15,1953-08-12,No,F,33405,(555) 222-3333
Steven,Johnson,steve.johnson@email.com,UHC,N,2023-06-01,1950-04-22,No,M,75002,(555) 333-4444
Nancy,Thompson,nancy.t@email.com,Aetna,G,2023-05-10,1955-02-18,No,F,66210,(555) 444-5555
George,Roberts,george.roberts@email.com,Cigna,N,2023-06-15,1952-11-05,No,M,90015,(555) 555-6666
Laura,Jackson,laura.jackson@email.com,Anthem,G,2023-05-01,1954-07-30,No,F,10002,(555) 666-7777

================
File: ws.csv
================
First Name,Last Name,Email,Current Carrier,Plan Type,Effective Date,Birth Date,Tobacco User,Gender,ZIP Code,Phone Number
John,Smith,john.smith@email.com,Humana,G,2023-01-01,1955-03-15,No,M,33401,(555) 123-4567
Mary,Johnson,mary.j@email.com,UHC,N,2023-02-01,1948-07-22,No,F,75001,(555) 234-5678
Robert,Williams,rob.w@email.com,Aetna,G,2023-03-01,1952-11-30,Yes,M,85001,(555) 345-6789
Patricia,Brown,pat.brown@email.com,Cigna,N,2023-01-01,1950-04-18,No,F,90001,(555) 456-7890
James,Davis,james.demail.com,Anthem,G,2023-02-01,1953-09-05,No,M,10001,(555) 567-8901
Linda,Miller,linda.m@email.com,Humana,N,2023-03-01,1951-06-12,No,F,60601,(555) 678-9012
Michael,Wilson,mike.w@email.com,United Healthcare,G,2023-01-01,1954-08-25,Yes,M,30301,(555) 789-0123
Barbara,Moore,barb.moore@email.com,Aetna,N,2023-02-01,1949-12-03,No,F,27601,(55) 890-1234
William,Taylor,will.t@email.com,Cigna,G,2023-03-01,1956-02-28,No,M,43201,555-901-2345
Elizabeth,Anderson,liz.a@email.com,Anthem,N,2023-01-01,1947-10-14,No,F,48201,5550123456
Carl,Weathers,cweathers@email.com,UnitegHealthcare,G,2023-01-01,1955-03-15,No,M,33401,(555) 123-4567
Melinda,Craft,mcraft@email.com,UHC,N,2023-02-01,1948-07-22,No,F,75001,(555) 234-5678
Sarah,California,sarah.ca@example.com,Humana,G,2023-01-01,1953-03-10,No,F,90210,(555) 111-2222
David,Idaho,david.id@example.com,UHC,N,2023-01-01,1954-03-15,No,M,83702,(555) 222-3333
Jennifer,Illinois,jennifer.il@example.com,Aetna,G,2023-02-01,1955-03-20,No,F,60601,(555) 333-4444
Thomas,Kentucky,thomas.ky@example.com,Cigna,N,2023-02-01,1956-03-25,No,M,40202,(555) 444-5555
Jessica,Louisiana,jessica.la@example.com,Anthem,G,2023-03-01,1957-03-05,No,F,70112,(555) 555-6666
Richard,Maryland,richard.md@example.com,Humana,N,2023-03-01,1958-03-12,No,M,21201,(555) 666-7777
Susan,Nevada,susan.nv@example.com,UHC,G,2023-01-01,1959-03-18,No,F,89101,(555) 777-8888
Joseph,Oklahoma,joseph.ok@example.com,Aetna,N,2023-01-01,1960-03-22,No,M,73102,(555) 888-9999
Karen,Oregon,karen.or@example.com,Cigna,G,2023-02-01,1961-03-28,No,F,97201,(555) 999-0000
Michael,Missouri,michael.mo@example.com,UHC,G,2023-03-01,1962-07-10,No,M,63101,(555) 111-3333
Emily,Connecticut,emily.ct@example.com,Aetna,N,2023-01-01,1963-03-05,No,F,06101,(555) 222-4444
Daniel,Massachusetts,daniel.ma@example.com,Cigna,G,2023-02-01,1964-03-12,No,M,02108,(555) 333-5555
Olivia,NewYork,olivia.ny@example.com,Anthem,N,2023-02-01,1965-03-18,No,F,10001,(555) 444-6666
Christopher,Washington,chris.wa@example.com,Humana,G,2023-03-01,1966-03-25,No,M,98101,(555) 555-7777



================================================================
End of Codebase
================================================================

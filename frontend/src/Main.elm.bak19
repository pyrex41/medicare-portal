module Main exposing (main)

import AddAgent
import Browser exposing (Document)
import Browser.Events
import Browser.Navigation as Nav
import ChangePlan
import ChoosePlan
import Compare exposing (CompareParams)
import Components.AccountStatusBanner as AccountStatusBanner
import Contact
import Contacts
import Dashboard
import Eligibility
import Home
import Html exposing (Html, a, button, div, h1, img, nav, p, text)
import Html.Attributes exposing (alt, class, href, src)
import Html.Events exposing (onClick, stopPropagationOn)
import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline as Pipeline
import Json.Encode as E
import Login
import Logout
import Onboarding.Onboarding as Onboarding
import Process
import Profile
import Quote
import Schedule
import SelfServiceOnboarding
import Settings
import Signup
import Svg exposing (path, svg)
import Svg.Attributes exposing (d, fill, viewBox)
import Task
import TempLanding
import Url exposing (Url)
import Url.Parser as Parser exposing ((</>), (<?>), Parser, map, oneOf, s, string, top)
import Url.Parser.Query as Query
import Walkthrough



-- ONBOARDING STEP TYPES


type OnboardingStep
    = PlanStep
    | PersonalStep
    | CompanyStep
    | LicensingStep
    | AgentsStep
    | PaymentStep
    | EnterpriseStep



-- PORTS
-- Send a message to JavaScript to clear the session cookie


type alias VerificationResponse =
    { success : Bool
    , redirectUrl : String
    , session : String
    , email : String
    , orgSlug : String
    }


type alias SessionResponse =
    { valid : Bool
    , session : String
    , email : String
    , organizationSlug : String
    , firstName : String
    , lastName : String
    , id : String
    }


verificationDecoder : Decoder VerificationResponse
verificationDecoder =
    Decode.map5 VerificationResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "redirectUrl" Decode.string)
        (Decode.field "session" Decode.string)
        (Decode.field "email" Decode.string)
        (Decode.field "orgSlug" Decode.string)


sessionDecoder : Decoder SessionResponse
sessionDecoder =
    Decode.map7 SessionResponse
        (Decode.field "valid" Decode.bool)
        (Decode.field "session" Decode.string)
        (Decode.field "email" Decode.string)
        (Decode.field "organizationSlug" Decode.string)
        (Decode.oneOf
            [ Decode.field "firstName" Decode.string
            , Decode.field "first_name" Decode.string
            ]
        )
        (Decode.oneOf
            [ Decode.field "lastName" Decode.string
            , Decode.field "last_name" Decode.string
            ]
        )
        (Decode.field "id" (Decode.map String.fromInt Decode.int))


type Role
    = AdminOnly
    | AdminAgent
    | AgentOnly


type alias User =
    { id : String
    , email : String
    , isAdmin : Bool
    , isAgent : Bool
    , organizationSlug : String
    , organizationId : String
    , firstName : String
    , lastName : String
    , subscriptionTier : String
    , accountStatus : Maybe AccountStatusBanner.AccountStatusDetails
    }



-- Account status types


type alias AccountStatus =
    String


type alias AccountStatusDetails =
    { status : AccountStatus
    , message : String
    , organizationId : Int
    , organizationName : String
    , organizationSlug : String
    , subscriptionTier : String
    , subscriptionStatus : String
    , agentLimit : Int
    , contactLimit : Int
    , currentAgentCount : Int
    , currentContactCount : Int
    , billingCycleEnd : Maybe String
    , paymentFailureCount : Int
    }


type alias Model =
    { key : Nav.Key
    , url : Url
    , page : Page
    , session : SessionState
    , currentUser : Maybe User
    , isSetup : Bool
    , intendedDestination : Maybe String
    , showDropdown : Bool
    , showStatusBanner : Bool
    }


type SessionState
    = Unknown -- Initial state
    | Verified String -- Has valid session
    | NoSession -- Definitely no valid session


type Page
    = NotFoundPage
    | LoginPage Login.Model
    | ContactsPage Contacts.Model
    | TempLandingPage TempLanding.Model
    | SettingsPage Settings.Model
    | Signup Signup.Model
    | ChoosePlanPage ChoosePlan.Model
    | ChangePlanPage ChangePlan.Model
    | AddAgentsPage AddAgent.Model
    | ProfilePage Profile.Model
    | LoadingPage
    | HomePage Home.Model
    | ContactPage Contact.Model
    | ComparePage Compare.Model
    | QuotePage Quote.Model
    | EligibilityPage Eligibility.Model
    | SchedulePage Schedule.Model
    | DashboardPage Dashboard.Model
    | LogoutPage Logout.Model
    | OnboardingPage Onboarding.Model
    | WalkthroughPage Walkthrough.Model
    | SelfOnboardingPage SelfServiceOnboarding.Model


type Msg
    = LinkClicked Browser.UrlRequest
    | InternalLinkClicked String
    | UrlChanged Url
    | LoginMsg Login.Msg
    | ContactsMsg Contacts.Msg
    | TempLandingMsg TempLanding.Msg
    | SettingsMsg Settings.Msg
    | SignupMsg Signup.Msg
    | ChoosePlanMsg ChoosePlan.Msg
    | ChangePlanMsg ChangePlan.Msg
    | AddAgentsMsg AddAgent.Msg
    | GotVerification (Result Http.Error VerificationResponse)
    | GotSession (Result Http.Error SessionResponse)
    | ProfileMsg Profile.Msg
    | HomeMsg Home.Msg
    | ContactMsg Contact.Msg
    | CompareMsg Compare.Msg
    | QuoteMsg Quote.Msg
    | EligibilityMsg Eligibility.Msg
    | ScheduleMsg Schedule.Msg
    | DashboardMsg Dashboard.Msg
    | NoOp
    | GotCurrentUser (Result Http.Error CurrentUserResponse)
    | OrgFinalized (Result Http.Error ())
    | LogoutMsg Logout.Msg
    | OnboardingMsg Onboarding.Msg
    | ToggleDropdown
    | CloseDropdown
    | InitiateLogout
    | GotAccountStatus (Result Http.Error AccountStatusResponse)
    | CloseStatusBanner
    | WalkthroughMsg Walkthrough.Msg
    | ShowDropdown
    | HideDropdown
    | ToggleStatusBanner
    | PerformRedirect String
    | DirectPageUpdate
    | SelfOnboardingMsg SelfServiceOnboarding.Msg


type alias Flags =
    { initialSession : Maybe String }


type alias CompareFlags =
    { state : String
    , zip : String
    , county : String
    , gender : String
    , tobacco : Bool
    , age : Int
    , planType : String
    , currentCarrier : Maybe String
    , dateOfBirth : String
    , quoteId : Maybe String
    }


main : Program Flags Model Msg
main =
    Browser.application
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        , onUrlChange = UrlChanged
        , onUrlRequest = LinkClicked
        }


type alias AccountStatusResponse =
    { success : Bool
    , status : AccountStatusDetails
    }


accountStatusDecoder : Decoder AccountStatusDetails
accountStatusDecoder =
    Decode.succeed AccountStatusDetails
        |> Pipeline.required "status" Decode.string
        |> Pipeline.required "message" Decode.string
        |> Pipeline.required "organizationId" Decode.int
        |> Pipeline.required "organizationName" Decode.string
        |> Pipeline.required "organizationSlug" Decode.string
        |> Pipeline.required "subscriptionTier" Decode.string
        |> Pipeline.required "subscriptionStatus" Decode.string
        |> Pipeline.required "agentLimit" Decode.int
        |> Pipeline.required "contactLimit" Decode.int
        |> Pipeline.required "currentAgentCount" Decode.int
        |> Pipeline.required "currentContactCount" Decode.int
        |> Pipeline.optional "billingCycleEnd" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "paymentFailureCount" Decode.int


accountStatusResponseDecoder : Decoder AccountStatusResponse
accountStatusResponseDecoder =
    Decode.succeed AccountStatusResponse
        |> Pipeline.required "success" Decode.bool
        |> Pipeline.required "status" accountStatusDecoder


init : Flags -> Url.Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url key =
    let
        initialSession =
            case flags.initialSession of
                Just session ->
                    Verified session

                Nothing ->
                    Unknown

        -- Parse the initial route to determine if we're on a public page
        initialRoute =
            Parser.parse routeParser url

        -- Determine if this is a public route that can be rendered immediately
        isPublicRoute =
            case initialRoute of
                Just (PublicRoute _) ->
                    True

                _ ->
                    False

        -- Set initial page appropriately
        initialPage =
            if isPublicRoute then
                -- For public routes, we'll immediately handle this in updatePageForcePublic below
                LoadingPage

            else
                -- For protected routes, we need to wait for session verification
                LoadingPage

        model =
            { key = key
            , url = url
            , page = initialPage
            , session = initialSession
            , currentUser = Nothing
            , isSetup = False
            , intendedDestination = Nothing
            , showDropdown = False
            , showStatusBanner = True
            }

        checkSession =
            Http.get
                { url = "/api/auth/session"
                , expect = Http.expectJson GotSession sessionDecoder
                }

        -- Use a very short timer for the initial direct page update for public routes
        directPageUpdate =
            Task.perform (\_ -> DirectPageUpdate) (Process.sleep 50)

        -- Check session and also immediately try to render public routes
        cmds =
            case initialSession of
                Verified _ ->
                    -- If we have a session, also fetch the current user immediately
                    Cmd.batch [ checkSession, fetchCurrentUser, directPageUpdate ]

                _ ->
                    Cmd.batch [ checkSession, directPageUpdate ]
    in
    -- For public routes, immediately try to render without waiting for session
    if isPublicRoute then
        -- Try to render public route immediately
        updatePageForcePublic url ( model, cmds )

    else
        -- For protected routes, wait for session verification
        ( model, cmds )


type alias CompareParams =
    { state : String
    , zip : String
    , county : String
    , gender : String
    , tobacco : Bool
    , age : Int
    , planType : String
    , currentCarrier : Maybe String
    , dateOfBirth : String
    , quoteId : Maybe String
    , trackingId : Maybe String
    , orgId : Maybe String -- Add this field
    }


type alias CompareParamsPartial1 =
    { state : String
    , zip : String
    , county : String
    , gender : String
    }


type alias CompareParamsPartial2 =
    { tobacco : Bool
    , age : Int
    , planType : String
    , currentCarrier : Maybe String
    }


type Route
    = PublicRoute PublicPage
    | ProtectedRoute ProtectedPage
    | AdminRoute AdminPage
    | SetupRoute SetupPage
    | NotFound


type VerifyParams
    = VerifyParams String String


type PublicPage
    = HomeRoute
    | LoginRoute
    | SignupRoute
    | OnboardingRoute OnboardingStep
    | VerifyRoute VerifyParams
    | CompareRoute CompareParams
    | QuoteRoute { quoteId : Maybe String, trackingId : Maybe String, planType : Maybe String, orgId : Maybe String }
    | EligibilityRoute ( Maybe String, Maybe String, Maybe String ) -- Change from String to Maybe String
    | ScheduleRoute ( Maybe String, Maybe String, Maybe String )
    | SelfOnboardingRoute String


type ProtectedPage
    = ContactsRoute
    | ProfileRoute
    | TempLandingRoute
    | ContactRoute String
    | DashboardRoute
    | ChangePlanRoute
    | WalkthroughRoute


type AdminPage
    = SettingsRoute
    | AgentsRoute


type SetupPage
    = ChoosePlanRoute (Maybe SetupProgress)
    | SetupSettingsRoute (Maybe SetupProgress)
    | AddAgentsRoute (Maybe SetupProgress)


type alias SetupProgress =
    { plan : Maybe String
    , orgSettings : Bool
    }


type RouteAccess
    = Public -- No auth needed (login, home)
    | Protected -- Requires valid session
    | Setup -- Special setup flow routes


setupProgressDecoder : Query.Parser (Maybe SetupProgress)
setupProgressDecoder =
    Query.map2
        (\plan org ->
            case ( plan, org ) of
                ( Just p, Just o ) ->
                    Just
                        { plan = Just p
                        , orgSettings = o == "complete"
                        }

                _ ->
                    Nothing
        )
        (Query.string "plan")
        (Query.string "org")


compareParamsParser : Query.Parser CompareParams
compareParamsParser =
    let
        part1 =
            Query.map4 CompareParamsPartial1
                (Query.string "state" |> Query.map (Maybe.withDefault "TX"))
                (Query.string "zip" |> Query.map (Maybe.withDefault "75201"))
                (Query.string "county" |> Query.map (Maybe.withDefault "Dallas"))
                (Query.string "gender" |> Query.map (Maybe.withDefault "Male"))

        part2 =
            Query.map4 CompareParamsPartial2
                (Query.string "tobacco" |> Query.map (Maybe.map (\t -> t == "yes") >> Maybe.withDefault False))
                (Query.string "age" |> Query.map (Maybe.andThen String.toInt >> Maybe.withDefault 65))
                (Query.string "planType" |> Query.map (Maybe.withDefault "G"))
                (Query.string "currentCarrier")

        combineParams p1 p2 dateOfBirth quoteId trackingId orgId =
            { state = p1.state
            , zip = p1.zip
            , county = p1.county
            , gender = p1.gender
            , tobacco = p2.tobacco
            , age = p2.age
            , planType = p2.planType
            , currentCarrier = p2.currentCarrier
            , dateOfBirth = dateOfBirth
            , quoteId = quoteId
            , trackingId = trackingId
            , orgId = orgId
            }
    in
    Query.map6 combineParams
        part1
        part2
        (Query.string "dateOfBirth" |> Query.map (Maybe.withDefault ""))
        (Query.string "id")
        -- quoteId is the most important parameter now
        (Query.string "tid")
        (Query.string "orgId")



-- Parse the orgId


routeParser : Parser (Route -> a) a
routeParser =
    oneOf
        [ map (PublicRoute HomeRoute) top
        , map (PublicRoute LoginRoute) (s "login")
        , map (PublicRoute SignupRoute) (s "signup")
        , map (PublicRoute (OnboardingRoute PlanStep)) (s "onboarding" </> s "plan")
        , map (PublicRoute (OnboardingRoute PersonalStep)) (s "onboarding" </> s "personal")
        , map (PublicRoute (OnboardingRoute CompanyStep)) (s "onboarding" </> s "company")
        , map (PublicRoute (OnboardingRoute LicensingStep)) (s "onboarding" </> s "licensing")
        , map (PublicRoute (OnboardingRoute AgentsStep)) (s "onboarding" </> s "agents")
        , map (PublicRoute (OnboardingRoute PaymentStep)) (s "onboarding" </> s "payment")
        , map (PublicRoute (OnboardingRoute EnterpriseStep)) (s "onboarding" </> s "enterprise")
        , map (PublicRoute (OnboardingRoute PlanStep)) (s "onboarding") -- Default to plan step
        , map (\params -> PublicRoute (VerifyRoute params))
            (s "auth" </> s "verify" </> string </> string)
        , map (PublicRoute << CompareRoute) (s "compare" <?> compareParamsParser)
        , map (PublicRoute << QuoteRoute)
            (s "quote"
                <?> Query.map4
                        (\id tid planType orgId ->
                            { quoteId = id, trackingId = tid, planType = planType, orgId = orgId }
                        )
                        (Query.string "id")
                        (Query.string "tid")
                        (Query.string "planType")
                        (Query.string "orgId")
            )
        , map (PublicRoute << EligibilityRoute)
            (s "eligibility"
                <?> Query.map3
                        (\id tid orgId ->
                            ( id, tid, orgId )
                        )
                        (Query.string "id")
                        (Query.string "tid")
                        (Query.string "orgId")
            )
        , map (PublicRoute << ScheduleRoute)
            (s "schedule"
                <?> Query.map3 (\id status tid -> ( id, status, tid ))
                        (Query.string "id")
                        (Query.string "status")
                        (Query.string "tid")
            )
        , map (\orgSlug -> PublicRoute (SelfOnboardingRoute orgSlug))
            (s "self-onboarding" </> string)
        , map (ProtectedRoute ChangePlanRoute) (s "change-plan")
        , map (ProtectedRoute ContactsRoute) (s "contacts")
        , map (AdminRoute SettingsRoute) (s "settings")
        , map (ProtectedRoute ProfileRoute) (s "profile")
        , map (ProtectedRoute TempLandingRoute) (s "templanding")
        , map (ProtectedRoute WalkthroughRoute) (s "walkthrough")
        , map (AdminRoute AgentsRoute) (s "add-agents")
        , map (ProtectedRoute DashboardRoute) (s "dashboard")
        , map (\id -> ProtectedRoute (ContactRoute id)) (s "contact" </> string)
        , map (\progress -> SetupRoute (ChoosePlanRoute progress))
            (s "choose-plan" <?> setupProgressDecoder)
        , map (\progress -> SetupRoute (SetupSettingsRoute progress))
            (s "setup" </> s "settings" <?> setupProgressDecoder)
        , map (\progress -> SetupRoute (AddAgentsRoute progress))
            (s "setup" </> s "add-agents" <?> setupProgressDecoder)
        ]


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        DirectPageUpdate ->
            -- Force updatePage even if we're in Unknown session state
            updatePageForcePublic model.url ( model, Cmd.none )

        LinkClicked urlRequest ->
            case urlRequest of
                Browser.Internal url ->
                    ( model
                    , Nav.pushUrl model.key (Url.toString url)
                    )

                Browser.External href ->
                    ( model
                    , Nav.load href
                    )

        InternalLinkClicked frag ->
            ( { model | showDropdown = False }
            , Nav.pushUrl model.key frag
            )

        UrlChanged url ->
            ( { model | url = url }
            , Cmd.none
            )
                |> updatePage url

        LoginMsg subMsg ->
            case model.page of
                LoginPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Login.update subMsg pageModel
                    in
                    ( { model | page = LoginPage newPageModel }
                    , Cmd.map LoginMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ContactsMsg subMsg ->
            case model.page of
                ContactsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Contacts.update subMsg pageModel
                    in
                    ( { model | page = ContactsPage newPageModel }
                    , Cmd.map ContactsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        TempLandingMsg subMsg ->
            case model.page of
                TempLandingPage pageModel ->
                    case subMsg of
                        TempLanding.NavigateTo path ->
                            ( model
                            , Nav.pushUrl model.key path
                            )

                _ ->
                    ( model, Cmd.none )

        SettingsMsg subMsg ->
            case model.page of
                SettingsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Settings.update subMsg pageModel
                    in
                    ( { model | page = SettingsPage newPageModel }
                    , Cmd.map SettingsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        SignupMsg subMsg ->
            case model.page of
                Signup signupModel ->
                    let
                        ( newSignupModel, newCmd ) =
                            Signup.update subMsg signupModel
                    in
                    ( { model | page = Signup newSignupModel }
                    , Cmd.map SignupMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ChoosePlanMsg subMsg ->
            case model.page of
                ChoosePlanPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            ChoosePlan.update subMsg pageModel
                    in
                    ( { model | page = ChoosePlanPage newPageModel }
                    , Cmd.map ChoosePlanMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ChangePlanMsg subMsg ->
            case model.page of
                ChangePlanPage pageModel ->
                    let
                        ( updatedPageModel, updatedCmd ) =
                            ChangePlan.update subMsg pageModel
                    in
                    ( { model | page = ChangePlanPage updatedPageModel }
                    , Cmd.map ChangePlanMsg updatedCmd
                    )

                _ ->
                    ( model, Cmd.none )

        AddAgentsMsg subMsg ->
            case model.page of
                AddAgentsPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            AddAgent.update subMsg pageModel
                    in
                    ( { model | page = AddAgentsPage newPageModel }
                    , Cmd.map AddAgentsMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        GotVerification result ->
            case result of
                Ok response ->
                    if response.success then
                        let
                            ( choosePlanModel, choosePlanCmd ) =
                                ChoosePlan.init response.orgSlug response.session model.key False

                            -- Only set isSetup to True if we're being redirected to a setup route
                            isInSetup =
                                String.startsWith "/choose-plan" response.redirectUrl
                                    || String.startsWith "/setup" response.redirectUrl

                            newModel =
                                { model
                                    | session = Verified response.session
                                    , currentUser =
                                        Just
                                            { id = ""
                                            , email = response.email
                                            , isAdmin = False
                                            , isAgent = False
                                            , organizationSlug = response.orgSlug
                                            , organizationId = response.orgSlug
                                            , firstName = ""
                                            , lastName = ""
                                            , subscriptionTier = ""
                                            , accountStatus = Nothing
                                            }
                                    , isSetup = isInSetup
                                    , page = LoadingPage -- Force to loading page to prevent UI flicker during redirection
                                }
                        in
                        ( newModel
                        , Cmd.batch
                            [ -- Instead of direct navigation, use a message to redirect
                              case model.intendedDestination of
                                Just destination ->
                                    Task.perform PerformRedirect (Task.succeed destination)

                                Nothing ->
                                    Task.perform PerformRedirect (Task.succeed response.redirectUrl)
                            , fetchCurrentUser
                            ]
                        )

                    else
                        ( model, Nav.pushUrl model.key "/login" )

                Err error ->
                    ( model, Nav.pushUrl model.key "/login" )

        PerformRedirect url ->
            -- Navigate to the specified URL
            ( model, Nav.pushUrl model.key url )

        GotSession result ->
            case result of
                Ok response ->
                    if response.valid then
                        let
                            user =
                                { id = response.id
                                , email = response.email
                                , isAdmin = False -- We'll get this from /api/me endpoint
                                , isAgent = False -- We'll get this from /api/me endpoint
                                , organizationSlug = response.organizationSlug
                                , organizationId = response.organizationSlug -- Use the org slug as org ID for now
                                , firstName = response.firstName
                                , lastName = response.lastName
                                , subscriptionTier = ""
                                , accountStatus = Nothing
                                }

                            -- Only set isSetup to True if we're in the middle of setup
                            isInSetup =
                                case Parser.parse routeParser model.url of
                                    Just (SetupRoute _) ->
                                        True

                                    _ ->
                                        False

                            newModel =
                                { model
                                    | session = Verified response.session
                                    , currentUser = Just user
                                    , isSetup = isInSetup
                                }
                        in
                        Cmd.batch [ fetchCurrentUser, updatePage model.url ( newModel, Cmd.none ) |> Tuple.second ]
                            |> (\cmd -> ( newModel, cmd ))

                    else
                        let
                            newModel =
                                { model | session = NoSession }
                        in
                        -- For invalid session, update page which will handle redirects
                        updatePage model.url ( newModel, Cmd.none )

                Err error ->
                    let
                        newModel =
                            { model | session = NoSession }
                    in
                    -- For session error, update page which will handle redirects
                    updatePage model.url ( newModel, Cmd.none )

        ProfileMsg subMsg ->
            case model.page of
                ProfilePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Profile.update subMsg pageModel
                    in
                    ( { model | page = ProfilePage newPageModel }
                    , case subMsg of
                        Profile.NavigateTo path ->
                            Nav.pushUrl model.key path

                        _ ->
                            Cmd.map ProfileMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        HomeMsg subMsg ->
            case model.page of
                HomePage pageModel ->
                    let
                        ( newPageModel, homeCmd ) =
                            Home.update subMsg pageModel
                    in
                    ( { model | page = HomePage newPageModel }
                    , Cmd.map HomeMsg homeCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ContactMsg subMsg ->
            case model.page of
                ContactPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Contact.update subMsg pageModel
                    in
                    ( { model | page = ContactPage newPageModel }
                    , Cmd.map ContactMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        CompareMsg subMsg ->
            case model.page of
                ComparePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Compare.update subMsg pageModel
                    in
                    ( { model | page = ComparePage newPageModel }
                    , Cmd.map CompareMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        QuoteMsg subMsg ->
            case model.page of
                QuotePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Quote.update subMsg pageModel
                    in
                    ( { model | page = QuotePage newPageModel }
                    , Cmd.map QuoteMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        EligibilityMsg subMsg ->
            case model.page of
                EligibilityPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Eligibility.update subMsg pageModel
                    in
                    ( { model | page = EligibilityPage newPageModel }
                    , Cmd.map EligibilityMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ScheduleMsg subMsg ->
            case model.page of
                SchedulePage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Schedule.update subMsg pageModel
                    in
                    ( { model | page = SchedulePage newPageModel }
                    , Cmd.map ScheduleMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        DashboardMsg subMsg ->
            case model.page of
                DashboardPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Dashboard.update subMsg pageModel
                    in
                    ( { model | page = DashboardPage newPageModel }
                    , Cmd.map DashboardMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        GotCurrentUser result ->
            case result of
                Ok response ->
                    case response.user of
                        Just user ->
                            let
                                currentUser =
                                    Just
                                        { id = user.id
                                        , email = user.email
                                        , isAdmin = user.isAdmin
                                        , isAgent = user.isAgent
                                        , organizationSlug = user.organizationSlug
                                        , organizationId = user.organizationId
                                        , firstName = user.firstName
                                        , lastName = user.lastName
                                        , subscriptionTier = user.subscriptionTier
                                        , accountStatus = Nothing -- Will fetch this separately
                                        }

                                newModel =
                                    { model | currentUser = currentUser }

                                -- Fetch account status after user is loaded
                                cmd =
                                    fetchAccountStatus user.organizationSlug
                            in
                            -- Check if we were already on the right page with the right data
                            -- Only update the page if something meaningful has changed
                            case model.currentUser of
                                Just existingUser ->
                                    if existingUser.id == user.id && existingUser.organizationSlug == user.organizationSlug then
                                        -- We already have the same user, just update the model without triggering updatePage
                                        ( newModel, cmd )

                                    else
                                        -- User has changed, update the page
                                        updatePage model.url ( newModel, cmd )

                                Nothing ->
                                    -- We didn't have a user before, update the page
                                    updatePage model.url ( newModel, cmd )

                        Nothing ->
                            -- No user data, but we should still update the page to avoid being stuck
                            updatePage model.url ( model, Cmd.none )

                Err error ->
                    -- Error retrieving user data, but we should still update the page to avoid being stuck
                    updatePage model.url ( model, Cmd.none )

        GotAccountStatus result ->
            case result of
                Ok response ->
                    if response.success then
                        -- Update user with account status
                        let
                            updatedUser =
                                model.currentUser
                                    |> Maybe.map
                                        (\user ->
                                            { user | accountStatus = Just response.status }
                                        )

                            updatedModel =
                                { model | currentUser = updatedUser }
                        in
                        -- Now that we have all data (session, user, account status), update the page
                        updatePage model.url ( updatedModel, Cmd.none )

                    else
                        ( model, Cmd.none )

                Err _ ->
                    -- Even if there's an error getting account status, we should still update the page
                    -- rather than staying on the loading screen
                    updatePage model.url ( model, Cmd.none )

        CloseStatusBanner ->
            ( { model | showStatusBanner = False }
            , Cmd.none
            )

        OrgFinalized result ->
            case result of
                Ok _ ->
                    ( model, Cmd.none )

                -- Navigation already happened
                Err _ ->
                    ( { model | page = LoadingPage }
                    , Nav.pushUrl model.key "/settings"
                      -- Redirect to settings on error
                    )

        LogoutMsg subMsg ->
            case model.page of
                LogoutPage logoutModel ->
                    let
                        ( newLogoutModel, logoutCmd ) =
                            Logout.update subMsg logoutModel
                    in
                    ( { model | page = LogoutPage newLogoutModel }
                    , Cmd.map LogoutMsg logoutCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ToggleDropdown ->
            ( { model | showDropdown = not model.showDropdown }
            , Cmd.none
            )

        CloseDropdown ->
            ( { model | showDropdown = False }
            , Cmd.none
            )

        InitiateLogout ->
            ( { model
                | session = NoSession
                , currentUser = Nothing
                , showDropdown = False
              }
            , Cmd.batch
                [ Nav.pushUrl model.key "/"
                , Http.post
                    { url = "/api/auth/logout"
                    , body = Http.emptyBody
                    , expect = Http.expectWhatever (\_ -> NoOp)
                    }
                ]
            )

        NoOp ->
            ( model, Cmd.none )

        OnboardingMsg subMsg ->
            case model.page of
                OnboardingPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Onboarding.update subMsg pageModel
                    in
                    ( { model | page = OnboardingPage newPageModel }
                    , Cmd.map OnboardingMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        WalkthroughMsg subMsg ->
            case model.page of
                WalkthroughPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            Walkthrough.update subMsg pageModel
                    in
                    ( { model | page = WalkthroughPage newPageModel }
                    , Cmd.map WalkthroughMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        SelfOnboardingMsg subMsg ->
            case model.page of
                SelfOnboardingPage pageModel ->
                    let
                        ( newPageModel, newCmd ) =
                            SelfServiceOnboarding.update subMsg pageModel
                    in
                    ( { model | page = SelfOnboardingPage newPageModel }
                    , Cmd.map SelfOnboardingMsg newCmd
                    )

                _ ->
                    ( model, Cmd.none )

        ShowDropdown ->
            ( { model | showDropdown = True }, Cmd.none )

        HideDropdown ->
            ( { model | showDropdown = False }, Cmd.none )

        ToggleStatusBanner ->
            ( { model | showStatusBanner = not model.showStatusBanner }, Cmd.none )


view : Model -> Browser.Document Msg
view model =
    let
        viewPage =
            case model.page of
                NotFoundPage ->
                    viewNotFound

                LoginPage loginModel ->
                    let
                        loginView =
                            Login.view loginModel
                    in
                    { title = loginView.title
                    , body = List.map (Html.map LoginMsg) loginView.body
                    }

                ContactsPage contactsModel ->
                    { title = "Contacts"
                    , body = [ viewWithNav model (Html.map ContactsMsg (Contacts.view contactsModel)) ]
                    }

                TempLandingPage landingModel ->
                    let
                        landingView =
                            TempLanding.view landingModel
                    in
                    { title = landingView.title
                    , body = [ viewWithNav model (Html.map TempLandingMsg (div [] landingView.body)) ]
                    }

                SettingsPage settingsModel ->
                    let
                        settingsView =
                            Settings.view settingsModel
                    in
                    { title = settingsView.title
                    , body = [ viewWithNav model (Html.map SettingsMsg (div [] settingsView.body)) ]
                    }

                Signup signupModel ->
                    let
                        signupView =
                            Signup.view signupModel
                    in
                    { title = signupView.title
                    , body = [ viewWithNav model (Html.map SignupMsg (div [] signupView.body)) ]
                    }

                ChoosePlanPage choosePlanModel ->
                    let
                        choosePlanView =
                            ChoosePlan.view choosePlanModel
                    in
                    { title = choosePlanView.title
                    , body = [ viewWithNav model (Html.map ChoosePlanMsg (div [] choosePlanView.body)) ]
                    }

                ChangePlanPage changePlanModel ->
                    let
                        changePlanView =
                            ChangePlan.view changePlanModel
                    in
                    { title = changePlanView.title
                    , body = [ viewWithNav model (Html.map ChangePlanMsg (div [] changePlanView.body)) ]
                    }

                AddAgentsPage addAgentModel ->
                    let
                        addAgentView =
                            AddAgent.view addAgentModel
                    in
                    { title = addAgentView.title
                    , body =
                        if addAgentModel.isSetup then
                            -- In setup flow, don't show the header
                            [ Html.map AddAgentsMsg (div [] addAgentView.body) ]

                        else
                            -- Not in setup flow, show the header
                            [ viewWithNav model (Html.map AddAgentsMsg (div [] addAgentView.body)) ]
                    }

                ProfilePage profileModel ->
                    let
                        profileView =
                            Profile.view profileModel
                    in
                    { title = profileView.title
                    , body = [ viewWithNav model (Html.map ProfileMsg (div [] profileView.body)) ]
                    }

                LoadingPage ->
                    { title = "Loading..."
                    , body = [ viewLoading ]
                    }

                HomePage homeModel ->
                    let
                        homeView =
                            Home.view homeModel
                    in
                    { title = homeView.title
                    , body = List.map (Html.map HomeMsg) homeView.body
                    }

                ContactPage contactModel ->
                    let
                        contactView =
                            Contact.view contactModel
                    in
                    { title = contactView.title
                    , body = [ viewWithNav model (Html.map ContactMsg (div [] contactView.body)) ]
                    }

                ComparePage compareModel ->
                    let
                        compareView =
                            Compare.view compareModel
                    in
                    { title = compareView.title
                    , body = [ viewWithNav model (Html.map CompareMsg (div [] compareView.body)) ]
                    }

                QuotePage quoteModel ->
                    let
                        quoteView =
                            Quote.view quoteModel
                    in
                    { title = quoteView.title
                    , body = [ viewWithNav model (Html.map QuoteMsg (div [] quoteView.body)) ]
                    }

                EligibilityPage eligibilityModel ->
                    let
                        eligibilityView =
                            Eligibility.view eligibilityModel
                    in
                    { title = eligibilityView.title
                    , body = [ viewWithNav model (Html.map EligibilityMsg (div [] eligibilityView.body)) ]
                    }

                SchedulePage scheduleModel ->
                    let
                        scheduleView =
                            Schedule.view scheduleModel
                    in
                    { title = scheduleView.title
                    , body = [ viewWithNav model (Html.map ScheduleMsg (div [] scheduleView.body)) ]
                    }

                DashboardPage dashboardModel ->
                    let
                        dashboardView =
                            Dashboard.view dashboardModel
                    in
                    { title = dashboardView.title
                    , body = [ viewWithNav model (Html.map DashboardMsg (div [] dashboardView.body)) ]
                    }

                LogoutPage logoutModel ->
                    let
                        logoutView =
                            Logout.view logoutModel
                    in
                    { title = logoutView.title
                    , body = List.map (Html.map LogoutMsg) logoutView.body
                    }

                OnboardingPage pageModel ->
                    let
                        onboardingView =
                            Onboarding.view pageModel
                    in
                    { title = onboardingView.title
                    , body = [ Html.map OnboardingMsg (div [] onboardingView.body) ]
                    }

                WalkthroughPage pageModel ->
                    let
                        walkthroughView =
                            Walkthrough.view pageModel
                    in
                    { title = walkthroughView.title
                    , body = [ viewWithNav model (Html.map WalkthroughMsg (div [] walkthroughView.body)) ]
                    }

                SelfOnboardingPage pageModel ->
                    let
                        selfOnboardingView =
                            SelfServiceOnboarding.view pageModel
                    in
                    { title = selfOnboardingView.title
                    , body = List.map (Html.map SelfOnboardingMsg) selfOnboardingView.body
                    }
    in
    viewPage


viewWithNav : Model -> Html Msg -> Html Msg
viewWithNav model content =
    div []
        [ if model.isSetup then
            -- Don't show header during setup flow
            content

          else
            -- Show header for regular pages
            div []
                [ viewNavHeader model
                , content
                ]
        ]


viewNavHeader : Model -> Html Msg
viewNavHeader model =
    let
        -- Check if current page is one of the quote flow pages that should have simplified header
        isQuoteFlowPage =
            case model.page of
                QuotePage _ ->
                    True

                ComparePage _ ->
                    True

                EligibilityPage _ ->
                    True

                SchedulePage _ ->
                    True

                _ ->
                    False
    in
    if isQuoteFlowPage then
        -- Simplified header with just the logo for quote flow pages
        nav [ class "bg-white border-b border-gray-200" ]
            [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
                [ div [ class "flex justify-center h-14 sm:h-16" ]
                    [ div [ class "shrink-0 flex items-center" ]
                        [ a
                            [ href "#"
                            , onClick (InternalLinkClicked "/")
                            , class "cursor-pointer"
                            ]
                            [ img
                                [ src "/images/medicare-max-logo.png"
                                , class "h-6 sm:h-6 w-auto"
                                , alt "Medicare Max logo"
                                ]
                                []
                            ]
                        ]
                    ]
                ]
            ]

    else
        -- Full header with navigation for other pages
        nav [ class "bg-white border-b border-gray-200" ]
            [ div [ class "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" ]
                [ div [ class "flex justify-between h-16" ]
                    [ div [ class "flex items-center" ]
                        [ div [ class "shrink-0 flex items-center" ]
                            [ a
                                [ href "#"
                                , onClick (InternalLinkClicked "/")
                                , class "cursor-pointer"
                                ]
                                [ img
                                    [ src "/images/medicare-max-logo.png"
                                    , class "h-6 sm:h-6 w-auto mr-2 sm:mr-8"
                                    , alt "Medicare Max logo"
                                    ]
                                    []
                                ]
                            ]
                        , div [ class "hidden sm:flex items-center space-x-4" ]
                            [ button
                                [ class "px-3 py-1.5 text-gray-700 text-sm font-medium hover:bg-[#DCE2E5] rounded-md transition-colors duration-200"
                                , onClick (InternalLinkClicked "/dashboard")
                                ]
                                [ text "Dashboard" ]
                            , button
                                [ class "px-3 py-1.5 text-gray-700 text-sm font-medium hover:bg-[#DCE2E5] rounded-md transition-colors duration-200"
                                , onClick (InternalLinkClicked "/contacts")
                                ]
                                [ text "Contacts" ]
                            ]
                        ]
                    , div [ class "flex items-center" ]
                        [ div [ class "relative" ]
                            [ button
                                [ class "flex items-center space-x-1 sm:space-x-2 px-2 sm:px-3 py-1.5 text-gray-700 text-xs sm:text-sm font-medium hover:bg-[#DCE2E5] rounded-md transition-colors duration-200"
                                , onClick ToggleDropdown
                                , stopPropagationOn "mousedown" (Decode.succeed ( NoOp, True ))
                                ]
                                [ case model.currentUser of
                                    Just user ->
                                        text (user.firstName ++ " " ++ user.lastName)

                                    Nothing ->
                                        text "Menu"
                                , div [ class "w-4 h-4 flex-shrink-0" ]
                                    [ svg
                                        [ Svg.Attributes.viewBox "0 0 20 20"
                                        , Svg.Attributes.fill "currentColor"
                                        ]
                                        [ path
                                            [ Svg.Attributes.d "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" ]
                                            []
                                        ]
                                    ]
                                ]
                            , if model.showDropdown then
                                div
                                    [ class "absolute right-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 z-50"
                                    , stopPropagationOn "mousedown" (Decode.succeed ( NoOp, True ))
                                    ]
                                    [ -- Always show on mobile
                                      div [ class "block sm:hidden" ]
                                        [ button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/dashboard")
                                            ]
                                            [ text "Dashboard" ]
                                        , button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/contacts")
                                            ]
                                            [ text "Contacts" ]
                                        ]
                                    , if isAdmin model.currentUser then
                                        button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/profile")
                                            ]
                                            [ text "Profile" ]

                                      else
                                        text ""
                                    , if isAdmin model.currentUser then
                                        button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/settings")
                                            ]
                                            [ text "Organization Settings" ]

                                      else
                                        text ""
                                    , if isAdmin model.currentUser then
                                        button
                                            [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                            , onClick (InternalLinkClicked "/add-agents")
                                            ]
                                            [ text "Agents" ]

                                      else
                                        text ""
                                    , button
                                        [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                        , onClick (InternalLinkClicked "/change-plan")
                                        ]
                                        [ text "Change Plan" ]
                                    , button
                                        [ class "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-[#DCE2E5]"
                                        , onClick InitiateLogout
                                        ]
                                        [ text "Log out" ]
                                    ]

                              else
                                text ""
                            ]
                        ]
                    ]
                ]
            ]


isAdminOrAdminAgent : Maybe User -> Bool
isAdminOrAdminAgent maybeUser =
    case maybeUser of
        Just user ->
            user.isAdmin && user.isAgent

        Nothing ->
            False


isAdmin : Maybe User -> Bool
isAdmin maybeUser =
    case maybeUser of
        Just user ->
            user.isAdmin

        Nothing ->
            False


viewNotFound : Browser.Document msg
viewNotFound =
    { title = "404 - Page Not Found"
    , body =
        [ div [ class "min-h-screen bg-gray-50 flex flex-col items-center justify-center" ]
            [ h1 [ class "text-4xl font-bold text-gray-900 mb-4" ]
                [ text "404 - Page Not Found" ]
            , p [ class "text-gray-600" ]
                [ text "The page you're looking for doesn't exist." ]
            ]
        ]
    }


viewLoading : Html msg
viewLoading =
    div [ class "min-h-screen bg-gray-50 flex items-center justify-center" ]
        [ div [ class "animate-spin rounded-full h-8 w-8 border-2 border-purple-500 border-t-transparent" ] []
        ]


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        dropdownSub =
            if model.showDropdown then
                Browser.Events.onMouseDown (Decode.succeed CloseDropdown)

            else
                Sub.none

        pageSubs =
            case model.page of
                LoadingPage ->
                    Sub.none

                LoginPage pageModel ->
                    Sub.map LoginMsg (Login.subscriptions pageModel)

                ContactsPage pageModel ->
                    Sub.map ContactsMsg (Contacts.subscriptions pageModel)

                TempLandingPage pageModel ->
                    Sub.map TempLandingMsg (TempLanding.subscriptions pageModel)

                SettingsPage pageModel ->
                    Sub.map SettingsMsg (Settings.subscriptions pageModel)

                Signup signupModel ->
                    Sub.map SignupMsg (Signup.subscriptions signupModel)

                ChoosePlanPage pageModel ->
                    Sub.map ChoosePlanMsg (ChoosePlan.subscriptions pageModel)

                ChangePlanPage pageModel ->
                    Sub.map ChangePlanMsg (ChangePlan.subscriptions pageModel)

                AddAgentsPage pageModel ->
                    Sub.map AddAgentsMsg (AddAgent.subscriptions pageModel)

                ProfilePage pageModel ->
                    Sub.map ProfileMsg (Profile.subscriptions pageModel)

                HomePage pageModel ->
                    Sub.map HomeMsg (Home.subscriptions pageModel)

                ContactPage pageModel ->
                    Sub.map ContactMsg (Contact.subscriptions pageModel)

                ComparePage pageModel ->
                    Sub.map CompareMsg (Compare.subscriptions pageModel)

                QuotePage pageModel ->
                    Sub.map QuoteMsg (Quote.subscriptions pageModel)

                EligibilityPage pageModel ->
                    Sub.map EligibilityMsg (Eligibility.subscriptions pageModel)

                SchedulePage pageModel ->
                    Sub.map ScheduleMsg (Schedule.subscriptions pageModel)

                DashboardPage pageModel ->
                    Sub.map DashboardMsg (Dashboard.subscriptions pageModel)

                NotFoundPage ->
                    Sub.none

                LogoutPage pageModel ->
                    Sub.map LogoutMsg (Logout.subscriptions pageModel)

                OnboardingPage pageModel ->
                    Sub.map OnboardingMsg (Onboarding.subscriptions pageModel)

                WalkthroughPage pageModel ->
                    Sub.map WalkthroughMsg (Walkthrough.subscriptions pageModel)

                SelfOnboardingPage _ ->
                    Sub.none
    in
    Sub.batch [ dropdownSub, pageSubs ]


routeAccessType : Route -> RouteAccess
routeAccessType route =
    case route of
        PublicRoute _ ->
            Public

        ProtectedRoute _ ->
            Protected

        AdminRoute _ ->
            Protected

        -- Still Protected, but we'll check admin status separately
        SetupRoute _ ->
            Setup

        NotFound ->
            Public


userDecoder : Decoder User
userDecoder =
    Decode.succeed User
        |> Pipeline.required "id" (Decode.map String.fromInt Decode.int)
        |> Pipeline.required "email" Decode.string
        |> Pipeline.required "is_admin"
            (Decode.oneOf
                [ Decode.bool
                , Decode.int |> Decode.map (\n -> n == 1)
                ]
            )
        |> Pipeline.required "is_agent"
            (Decode.oneOf
                [ Decode.bool
                , Decode.int |> Decode.map (\n -> n == 1)
                ]
            )
        |> Pipeline.required "organization_slug" Decode.string
        |> Pipeline.required "organization_id" (Decode.map String.fromInt Decode.int)
        |> Pipeline.required "firstName" Decode.string
        |> Pipeline.required "lastName" Decode.string
        |> Pipeline.required "subscription_tier" Decode.string
        |> Pipeline.optional "accountStatus" (Decode.nullable accountStatusDecoder) Nothing


type SetupStep
    = NotStarted
    | PlanSelection
    | OrganizationSetup
    | AgentSetup
    | Complete


getSetupStep : Model -> SetupStep
getSetupStep model =
    case model.currentUser of
        Nothing ->
            NotStarted

        Just user ->
            if not model.isSetup then
                PlanSelection

            else if not (hasOrganizationSettings user) then
                OrganizationSetup

            else if not (hasAgents user) then
                AgentSetup

            else
                Complete


hasOrganizationSettings : User -> Bool
hasOrganizationSettings user =
    -- Check if both organization and brand settings are configured
    case user.organizationSlug of
        "" ->
            False

        _ ->
            -- For now return True since we've merged brand settings into org settings
            -- TODO: Add actual check for required settings once API is updated
            True


hasAgents : User -> Bool
hasAgents user =
    -- TODO: Add actual check for agents
    True


redirectToSetupStep : Model -> ( Model, Cmd Msg )
redirectToSetupStep model =
    case getSetupStep model of
        NotStarted ->
            ( model, Nav.pushUrl model.key "/login" )

        PlanSelection ->
            ( model, Nav.pushUrl model.key "/choose-plan" )

        OrganizationSetup ->
            case model.currentUser of
                Just user ->
                    ( model
                    , Nav.pushUrl model.key
                        ("/setup/settings?plan=" ++ user.organizationSlug)
                    )

                Nothing ->
                    ( model, Nav.pushUrl model.key "/setup/settings" )

        AgentSetup ->
            case model.currentUser of
                Just user ->
                    ( model
                    , Nav.pushUrl model.key
                        ("/setup/add-agents?plan=" ++ user.organizationSlug ++ "&org=complete")
                    )

                Nothing ->
                    ( model, Nav.pushUrl model.key "/setup/add-agents" )

        Complete ->
            ( model, Nav.pushUrl model.key "/contacts" )


shouldRedirectAdminRoute : Route -> Model -> Maybe String
shouldRedirectAdminRoute route model =
    case route of
        AdminRoute _ ->
            case model.currentUser of
                Just user ->
                    if user.isAdmin then
                        Nothing
                        -- Admin user, no redirect needed

                    else
                        Just "/contacts"

                -- Non-admin user, redirect to contacts
                Nothing ->
                    Just "/login"

        -- Not logged in, redirect to login
        _ ->
            Nothing


shouldRedirectToLogin : Route -> Model -> Bool
shouldRedirectToLogin route model =
    let
        result =
            case route of
                PublicRoute _ ->
                    False

                NotFound ->
                    False

                AdminRoute _ ->
                    case model.session of
                        Verified _ ->
                            False

                        _ ->
                            True

                _ ->
                    case model.session of
                        Verified _ ->
                            False

                        _ ->
                            True
    in
    -- Add a debug log for the redirect check
    result


shouldRedirectToSetup : Route -> Model -> Bool
shouldRedirectToSetup route model =
    -- Only check setup state if we're in setup mode
    if model.isSetup then
        case route of
            SetupRoute _ ->
                -- Already in a setup route, no redirect needed
                False

            PublicRoute _ ->
                -- Public routes are always accessible
                False

            NotFound ->
                -- Not found routes don't redirect
                False

            AdminRoute _ ->
                -- Admin routes redirect if setup is not complete
                getSetupStep model /= Complete

            ProtectedRoute _ ->
                -- Protected routes redirect if setup is not complete
                getSetupStep model /= Complete

    else
        False


updatePage : Url -> ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
updatePage url ( model, cmd ) =
    case model.session of
        Unknown ->
            -- When session state is Unknown, still allow public routes to render
            case Parser.parse routeParser url of
                Just route ->
                    case routeAccessType route of
                        Public ->
                            -- For public routes, redirect to the force update function
                            updatePageForcePublic url ( model, cmd )

                        _ ->
                            -- For non-public routes, keep showing loading while we wait
                            ( { model | page = LoadingPage }
                            , cmd
                            )

                Nothing ->
                    ( { model | page = NotFoundPage }
                    , cmd
                    )

        -- Rest of the function remains the same for Verified and NoSession states
        _ ->
            case Parser.parse routeParser url of
                Just route ->
                    let
                        -- Update isSetup based on the route
                        modelWithUpdatedSetup =
                            updateIsSetup model route

                        adminRedirect =
                            shouldRedirectAdminRoute route modelWithUpdatedSetup

                        -- Determine if we should make authenticated requests based on session state
                        -- Only fetch user data if we have a verified session AND don't already have user info
                        authCmd =
                            case ( model.session, model.currentUser ) of
                                ( Verified _, Nothing ) ->
                                    -- Only fetch user data if we have a verified session but no user data
                                    fetchCurrentUser

                                _ ->
                                    -- Don't make authenticated requests if no session or already have user data
                                    Cmd.none
                    in
                    case adminRedirect of
                        Just redirectUrl ->
                            ( modelWithUpdatedSetup, Nav.pushUrl modelWithUpdatedSetup.key redirectUrl )

                        Nothing ->
                            let
                                needsLogin =
                                    shouldRedirectToLogin route modelWithUpdatedSetup

                                needsSetup =
                                    shouldRedirectToSetup route modelWithUpdatedSetup
                            in
                            if needsLogin then
                                ( { modelWithUpdatedSetup
                                    | intendedDestination = Just (Url.toString url)
                                    , page = LoginPage (Login.init modelWithUpdatedSetup.key False url |> Tuple.first)
                                  }
                                , if String.contains "/login" (Url.toString url) then
                                    -- Already on login page, don't redirect
                                    Cmd.none

                                  else
                                    Nav.pushUrl modelWithUpdatedSetup.key "/login"
                                )

                            else if needsSetup then
                                -- Check if we're already on a setup route to prevent redirect loops
                                case route of
                                    SetupRoute _ ->
                                        -- Already on a setup route, just update the page
                                        ( modelWithUpdatedSetup, authCmd )

                                    _ ->
                                        redirectToSetupStep modelWithUpdatedSetup

                            else
                                -- Continue with the original logic for handling different routes
                                -- Rest of the function remains the same
                                case route of
                                    PublicRoute HomeRoute ->
                                        -- Home page handles its own session checking
                                        let
                                            ( homeModel, homeCmd ) =
                                                Home.init modelWithUpdatedSetup.key
                                        in
                                        ( { modelWithUpdatedSetup | page = HomePage homeModel }
                                        , Cmd.map HomeMsg homeCmd
                                        )

                                    PublicRoute LoginRoute ->
                                        let
                                            ( loginModel, loginCmd ) =
                                                Login.init modelWithUpdatedSetup.key False url
                                        in
                                        ( { modelWithUpdatedSetup | page = LoginPage loginModel }
                                        , Cmd.map LoginMsg loginCmd
                                        )

                                    PublicRoute SignupRoute ->
                                        -- Initialize signup page without making authenticated API calls
                                        let
                                            ( signupModel, signupCmd ) =
                                                Signup.init modelWithUpdatedSetup.key
                                        in
                                        ( { modelWithUpdatedSetup | page = Signup signupModel }
                                        , Cmd.map SignupMsg signupCmd
                                        )

                                    PublicRoute (OnboardingRoute step) ->
                                        -- Check if we already have an onboarding page
                                        case model.page of
                                            OnboardingPage existingModel ->
                                                -- We already have an onboarding model, update the step and reset initialization flags
                                                let
                                                    newStep =
                                                        onboardingStepToStep step

                                                    updatedModel =
                                                        { existingModel
                                                            | step = newStep

                                                            -- Reset initialization flags based on the new step
                                                            , userDetailsInitialized =
                                                                if newStep == Onboarding.UserDetailsStep then
                                                                    False

                                                                else
                                                                    existingModel.userDetailsInitialized
                                                            , companyDetailsInitialized =
                                                                if newStep == Onboarding.CompanyDetailsStep then
                                                                    False

                                                                else
                                                                    existingModel.companyDetailsInitialized
                                                            , licensingSettingsInitialized =
                                                                if newStep == Onboarding.LicensingSettingsStep then
                                                                    False

                                                                else
                                                                    existingModel.licensingSettingsInitialized
                                                            , addAgentsInitialized =
                                                                if newStep == Onboarding.AddAgentsStep then
                                                                    False

                                                                else
                                                                    existingModel.addAgentsInitialized
                                                            , paymentInitialized =
                                                                if newStep == Onboarding.PaymentStep then
                                                                    False

                                                                else
                                                                    existingModel.paymentInitialized
                                                            , enterpriseFormInitialized =
                                                                if newStep == Onboarding.EnterpriseFormStep then
                                                                    False

                                                                else
                                                                    existingModel.enterpriseFormInitialized
                                                        }
                                                in
                                                ( { model | page = OnboardingPage updatedModel }
                                                , Cmd.map OnboardingMsg (Task.perform (\_ -> Onboarding.InitializeCurrentStep) (Task.succeed ()))
                                                )

                                            _ ->
                                                -- Initialize onboarding without authenticated calls for new users
                                                let
                                                    ( onboardingModel, onboardingCmd ) =
                                                        Onboarding.init
                                                            model.key
                                                            (model.currentUser
                                                                |> Maybe.map .organizationSlug
                                                                |> Maybe.withDefault ""
                                                            )
                                                            (extractSession model.session)
                                                            (onboardingStepToStep step)
                                                in
                                                ( { model | page = OnboardingPage onboardingModel }
                                                , Cmd.map OnboardingMsg onboardingCmd
                                                )

                                    PublicRoute (VerifyRoute params) ->
                                        -- For verification, we need to make an API call
                                        let
                                            verifyUrl =
                                                case params of
                                                    VerifyParams orgSlug token ->
                                                        "/api/auth/verify/" ++ orgSlug ++ "/" ++ token

                                                        verifyCmd =
                                                            Http.get
                                                                { url = verifyUrl
                                                    , expect = Http.expectJson GotVerification verificationDecoder
                                                    }
                                        in
                                        ( model, verifyCmd )

                                    PublicRoute (CompareRoute params) ->
                                        case params.quoteId of
                                            Just quoteId ->
                                                -- We have a quote ID, which is what we prefer
                                                let
                                                    ( compareModel, compareCmd ) =
                                                        Compare.init model.key (Just params)
                                                in
                                                ( { model | page = ComparePage compareModel }
                                                , Cmd.map CompareMsg compareCmd
                                                )

                                            Nothing ->
                                                -- No quote ID, check if we have a valid orgId
                                                if isValidOrgId params.orgId then
                                                    -- We have a valid orgId but no quoteId, so use the params
                                                    let
                                                        ( compareModel, compareCmd ) =
                                                            Compare.init model.key (Just params)
                                                    in
                                                    ( { model | page = ComparePage compareModel }
                                                    , Cmd.map CompareMsg compareCmd
                                                    )

                                                else
                                                    -- No valid orgId either, redirect to 404
                                                    ( { model | page = NotFoundPage }
                                                    , Nav.pushUrl model.key "/404"
                                                    )

                                    PublicRoute (QuoteRoute params) ->
                                        -- First check if there's a valid quoteId
                                        if isValidQuoteId params.quoteId then
                                            let
                                                initialValues =
                                                    { zipCode = Nothing
                                                    , dateOfBirth = Nothing
                                                    , tobacco = Nothing
                                                    , gender = Nothing
                                                    , quoteId = params.quoteId
                                                    , planType = params.planType
                                                    , orgId = params.orgId -- Pass orgId even if it's Nothing
                                                    }

                                                ( quoteModel, quoteCmd ) =
                                                    Quote.init model.key initialValues
                                            in
                                            ( { model | page = QuotePage quoteModel }
                                            , Cmd.map QuoteMsg quoteCmd
                                            )
                                            -- If there's no valid quoteId, show error

                                        else
                                            -- Redirect to an error page or show an error
                                            ( { model | page = NotFoundPage }
                                            , Nav.pushUrl model.key "/error?message=Missing%20or%20invalid%20quote%20ID"
                                            )

                                    PublicRoute (EligibilityRoute params) ->
                                        let
                                            ( quoteId, _, orgIdStr ) =
                                                params
                                        in
                                        if isValidOrgId orgIdStr then
                                            let
                                                ( eligibilityModel, eligibilityCmd ) =
                                                    Eligibility.init model.key { quoteId = quoteId, orgId = orgIdStr }
                                            in
                                            ( { model | page = EligibilityPage eligibilityModel }
                                            , Cmd.map EligibilityMsg eligibilityCmd
                                            )

                                        else
                                            -- Redirect to an error page or show an error
                                            ( { model | page = NotFoundPage }
                                            , Nav.pushUrl model.key "/error?message=Missing%20or%20invalid%20organization%20ID"
                                            )

                                    PublicRoute (ScheduleRoute params) ->
                                        let
                                            ( scheduleModel, scheduleCmd ) =
                                                Schedule.init model.key
                                                    ((\( id, _, _ ) -> id) params)
                                                    ((\( _, status, _ ) -> status) params)
                                        in
                                        ( { model | page = SchedulePage scheduleModel }
                                        , Cmd.map ScheduleMsg scheduleCmd
                                        )

                                    ProtectedRoute ContactsRoute ->
                                        let
                                            -- Convert Main.elm User to Contacts.elm User format
                                            contactsUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = String.toInt user.id |> Maybe.withDefault 0
                                                            , email = user.email
                                                            , firstName = user.firstName
                                                            , lastName = user.lastName
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , organizationId = String.toInt user.organizationId |> Maybe.withDefault 0
                                                            , isActive = True -- Assume active
                                                            , phone = "" -- Default empty
                                                            , carriers = [] -- Default empty
                                                            , stateLicenses = [] -- Default empty
                                                            }
                                                        )

                                            ( contactsModel, contactsCmd ) =
                                                Contacts.init modelWithUpdatedSetup.key contactsUser
                                        in
                                        ( { modelWithUpdatedSetup | page = ContactsPage contactsModel }
                                        , Cmd.batch
                                            [ Cmd.map ContactsMsg contactsCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute ProfileRoute ->
                                        let
                                            ( profileModel, profileCmd ) =
                                                Profile.init ()
                                        in
                                        ( { modelWithUpdatedSetup | page = ProfilePage profileModel }
                                        , Cmd.batch
                                            [ Cmd.map ProfileMsg profileCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute TempLandingRoute ->
                                        let
                                            ( tempLandingModel, tempLandingCmd ) =
                                                TempLanding.init ()
                                        in
                                        ( { modelWithUpdatedSetup | page = TempLandingPage tempLandingModel }
                                        , Cmd.batch
                                            [ Cmd.map TempLandingMsg tempLandingCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute (ContactRoute id) ->
                                        let
                                            ( contactModel, contactCmd ) =
                                                Contact.init modelWithUpdatedSetup.key id
                                        in
                                        ( { modelWithUpdatedSetup | page = ContactPage contactModel }
                                        , Cmd.batch
                                            [ Cmd.map ContactMsg contactCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute ChangePlanRoute ->
                                        let
                                            ( changePlanModel, changePlanCmd ) =
                                                ChangePlan.init
                                                    { key = modelWithUpdatedSetup.key
                                                    , session = extractSession modelWithUpdatedSetup.session
                                                    , orgSlug = modelWithUpdatedSetup.currentUser |> Maybe.map .organizationSlug |> Maybe.withDefault ""
                                                    }
                                        in
                                        ( { modelWithUpdatedSetup | page = ChangePlanPage changePlanModel }
                                        , Cmd.batch
                                            [ Cmd.map ChangePlanMsg changePlanCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute DashboardRoute ->
                                        let
                                            dashboardFlags =
                                                { isPostPayment =
                                                    case
                                                        Parser.parse
                                                            (Parser.s "dashboard" <?> Query.string "payment_success")
                                                            url
                                                    of
                                                        Just (Just "true") ->
                                                            Just True

                                                        _ ->
                                                            Nothing
                                                }

                                            ( dashboardModel, dashboardCmd ) =
                                                Dashboard.init dashboardFlags
                                        in
                                        ( { modelWithUpdatedSetup | page = DashboardPage dashboardModel }
                                        , Cmd.batch
                                            [ Cmd.map DashboardMsg dashboardCmd
                                            , authCmd
                                            ]
                                        )

                                    ProtectedRoute WalkthroughRoute ->
                                        let
                                            currentUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = user.id
                                                            , name = user.firstName ++ " " ++ user.lastName
                                                            , email = user.email
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            }
                                                        )

                                            ( walkthroughModel, walkthroughCmd ) =
                                                Walkthrough.init modelWithUpdatedSetup.key currentUser
                                        in
                                        ( { modelWithUpdatedSetup | page = WalkthroughPage walkthroughModel }
                                        , Cmd.batch
                                            [ Cmd.map WalkthroughMsg walkthroughCmd
                                            , authCmd
                                            ]
                                        )

                                    AdminRoute SettingsRoute ->
                                        let
                                            -- Convert Main.elm User to Settings.elm CurrentUser format
                                            settingsUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = user.id
                                                            , email = user.email
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , organizationSlug = user.organizationSlug
                                                            , organizationId = user.organizationId
                                                            }
                                                        )

                                            ( settingsModel, settingsCmd ) =
                                                Settings.init
                                                    { isSetup = False
                                                    , key = modelWithUpdatedSetup.key
                                                    , currentUser = settingsUser
                                                    , planType =
                                                        modelWithUpdatedSetup.currentUser
                                                            |> Maybe.map .subscriptionTier
                                                            |> Maybe.withDefault ""
                                                    }
                                        in
                                        ( { modelWithUpdatedSetup | page = SettingsPage settingsModel }
                                        , Cmd.batch
                                            [ Cmd.map SettingsMsg settingsCmd
                                            , authCmd
                                            ]
                                        )

                                    AdminRoute AgentsRoute ->
                                        let
                                            -- Convert Main.elm User to AddAgent.elm CurrentUser format
                                            addAgentUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = user.id
                                                            , email = user.email
                                                            , firstName = user.firstName
                                                            , lastName = user.lastName
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , phone = ""
                                                            }
                                                        )

                                            ( addAgentModel, addAgentCmd ) =
                                                AddAgent.init
                                                    False
                                                    modelWithUpdatedSetup.key
                                                    addAgentUser
                                                    (modelWithUpdatedSetup.currentUser
                                                        |> Maybe.map .subscriptionTier
                                                        |> Maybe.withDefault ""
                                                    )
                                        in
                                        ( { modelWithUpdatedSetup | page = AddAgentsPage addAgentModel }
                                        , Cmd.batch
                                            [ Cmd.map AddAgentsMsg addAgentCmd
                                            , authCmd
                                            ]
                                        )

                                    SetupRoute (ChoosePlanRoute progress) ->
                                        let
                                            orgSlug =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map .organizationSlug
                                                    |> Maybe.withDefault ""

                                            session =
                                                extractSession modelWithUpdatedSetup.session

                                            ( choosePlanModel, choosePlanCmd ) =
                                                ChoosePlan.init orgSlug session modelWithUpdatedSetup.key True
                                        in
                                        ( { modelWithUpdatedSetup | page = ChoosePlanPage choosePlanModel }
                                        , Cmd.batch
                                            [ Cmd.map ChoosePlanMsg choosePlanCmd
                                            , authCmd
                                            ]
                                        )

                                    SetupRoute (SetupSettingsRoute progress) ->
                                        let
                                            -- Get plan type from progress if available, otherwise use subscription tier
                                            planType =
                                                progress
                                                    |> Maybe.andThen .plan
                                                    |> Maybe.withDefault
                                                        (modelWithUpdatedSetup.currentUser
                                                            |> Maybe.map .subscriptionTier
                                                            |> Maybe.withDefault ""
                                                        )

                                            -- Convert Main.elm User to Settings.elm CurrentUser format
                                            settingsUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = user.id
                                                            , email = user.email
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , organizationSlug = user.organizationSlug
                                                            , organizationId = user.organizationId
                                                            }
                                                        )

                                            ( settingsModel, settingsCmd ) =
                                                Settings.init
                                                    { isSetup = True
                                                    , key = modelWithUpdatedSetup.key
                                                    , currentUser = settingsUser
                                                    , planType = planType
                                                    }
                                        in
                                        ( { modelWithUpdatedSetup | page = SettingsPage settingsModel }
                                        , Cmd.batch
                                            [ Cmd.map SettingsMsg settingsCmd
                                            , authCmd
                                            ]
                                        )

                                    SetupRoute (AddAgentsRoute progress) ->
                                        let
                                            -- Get plan type from progress if available, otherwise use subscription tier
                                            planType =
                                                progress
                                                    |> Maybe.andThen .plan
                                                    |> Maybe.withDefault
                                                        (modelWithUpdatedSetup.currentUser
                                                            |> Maybe.map .subscriptionTier
                                                            |> Maybe.withDefault ""
                                                        )

                                            -- Convert Main.elm User to AddAgent.elm CurrentUser format
                                            addAgentUser =
                                                modelWithUpdatedSetup.currentUser
                                                    |> Maybe.map
                                                        (\user ->
                                                            { id = user.id
                                                            , email = user.email
                                                            , firstName = user.firstName
                                                            , lastName = user.lastName
                                                            , isAdmin = user.isAdmin
                                                            , isAgent = user.isAgent
                                                            , phone = ""
                                                            }
                                                        )

                                            ( addAgentModel, addAgentCmd ) =
                                                AddAgent.init True modelWithUpdatedSetup.key addAgentUser planType
                                        in
                                        ( { modelWithUpdatedSetup | page = AddAgentsPage addAgentModel }
                                        , Cmd.batch
                                            [ Cmd.map AddAgentsMsg addAgentCmd
                                            , authCmd
                                            ]
                                        )

                                    NotFound ->
                                        ( modelWithUpdatedSetup, Cmd.none )

                                    PublicRoute (SelfOnboardingRoute orgSlug) ->
                                        let
                                            ( selfOnboardingModel, selfOnboardingCmd ) =
                                                SelfServiceOnboarding.init model.key url
                                        in
                                        ( { model | page = SelfOnboardingPage selfOnboardingModel }
                                        , Cmd.map SelfOnboardingMsg selfOnboardingCmd
                                        )

                Nothing ->
                    ( { model | page = NotFoundPage }
                    , cmd
                    )


type alias CurrentUserResponse =
    { success : Bool
    , user : Maybe User
    }


fetchCurrentUser : Cmd Msg
fetchCurrentUser =
    Http.get
        { url = "/api/me"
        , expect = Http.expectJson GotCurrentUser currentUserResponseDecoder
        }


fetchAccountStatus : String -> Cmd Msg
fetchAccountStatus orgSlug =
    Http.get
        { url = "/api/organizations/" ++ orgSlug ++ "/account-status"
        , expect = Http.expectJson GotAccountStatus accountStatusResponseDecoder
        }


currentUserResponseDecoder : Decoder CurrentUserResponse
currentUserResponseDecoder =
    Decode.map2 CurrentUserResponse
        (Decode.field "success" Decode.bool)
        (Decode.field "user"
            (Decode.nullable
                (Decode.value
                    |> Decode.andThen
                        (\_ ->
                            userDecoder
                        )
                )
            )
        )



-- Wrap the user in Just since our type expects Maybe User


isBasicPlan : Model -> Bool
isBasicPlan model =
    case model.currentUser of
        Just user ->
            user.organizationSlug == "basic"

        Nothing ->
            True


finalizeOrganization : String -> Cmd Msg
finalizeOrganization orgId =
    Http.post
        { url = "/api/organizations/" ++ orgId ++ "/finalize"
        , body = Http.emptyBody
        , expect = Http.expectWhatever OrgFinalized
        }



-- Helper function to extract session string from SessionState


extractSession : SessionState -> String
extractSession sessionState =
    case sessionState of
        Verified session ->
            session

        _ ->
            ""



-- Helper function to map Document msg to Document Msg


mapDocument : (msg -> Msg) -> Browser.Document msg -> Browser.Document Msg
mapDocument toMsg document =
    { title = document.title
    , body = List.map (Html.map toMsg) document.body
    }



-- Update the isSetup flag based on the current URL and route


updateIsSetup : Model -> Route -> Model
updateIsSetup model route =
    let
        -- Determine if we're in setup mode based on the route
        newIsSetup =
            case route of
                SetupRoute _ ->
                    True

                _ ->
                    -- For non-setup routes, only keep isSetup = True if we're in the middle
                    -- of setup flow (haven't completed it yet)
                    model.isSetup && (getSetupStep model /= Complete)
    in
    { model | isSetup = newIsSetup }



-- Convert Main.OnboardingStep to Onboarding.Step


onboardingStepToStep : OnboardingStep -> Onboarding.Step
onboardingStepToStep step =
    case step of
        PlanStep ->
            Onboarding.PlanSelectionStep

        PersonalStep ->
            Onboarding.UserDetailsStep

        CompanyStep ->
            Onboarding.CompanyDetailsStep

        LicensingStep ->
            Onboarding.LicensingSettingsStep

        AgentsStep ->
            Onboarding.AddAgentsStep

        PaymentStep ->
            Onboarding.PaymentStep

        EnterpriseStep ->
            Onboarding.EnterpriseFormStep



-- Add a new function to force update public routes


updatePageForcePublic : Url -> ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
updatePageForcePublic url ( model, cmd ) =
    case Parser.parse routeParser url of
        Just route ->
            case routeAccessType route of
                Public ->
                    -- For public routes, directly initialize the appropriate page
                    -- without waiting for session checks
                    case route of
                        PublicRoute HomeRoute ->
                            let
                                ( homeModel, homeCmd ) =
                                    Home.init model.key
                            in
                            ( { model | page = HomePage homeModel }
                            , Cmd.map HomeMsg homeCmd
                            )

                        PublicRoute LoginRoute ->
                            let
                                ( loginModel, loginCmd ) =
                                    Login.init model.key False url
                            in
                            ( { model | page = LoginPage loginModel }
                            , Cmd.map LoginMsg loginCmd
                            )

                        PublicRoute SignupRoute ->
                            let
                                ( signupModel, signupCmd ) =
                                    Signup.init model.key
                            in
                            ( { model | page = Signup signupModel }
                            , Cmd.map SignupMsg signupCmd
                            )

                        PublicRoute (OnboardingRoute step) ->
                            -- Check if we already have an onboarding page
                            case model.page of
                                OnboardingPage existingModel ->
                                    -- We already have an onboarding model, update the step and reset initialization flags
                                    let
                                        newStep =
                                            onboardingStepToStep step

                                        updatedModel =
                                            { existingModel
                                                | step = newStep

                                                -- Reset initialization flags based on the new step
                                                , userDetailsInitialized =
                                                    if newStep == Onboarding.UserDetailsStep then
                                                        False

                                                    else
                                                        existingModel.userDetailsInitialized
                                                , companyDetailsInitialized =
                                                    if newStep == Onboarding.CompanyDetailsStep then
                                                        False

                                                    else
                                                        existingModel.companyDetailsInitialized
                                                , licensingSettingsInitialized =
                                                    if newStep == Onboarding.LicensingSettingsStep then
                                                        False

                                                    else
                                                        existingModel.licensingSettingsInitialized
                                                , addAgentsInitialized =
                                                    if newStep == Onboarding.AddAgentsStep then
                                                        False

                                                    else
                                                        existingModel.addAgentsInitialized
                                                , paymentInitialized =
                                                    if newStep == Onboarding.PaymentStep then
                                                        False

                                                    else
                                                        existingModel.paymentInitialized
                                                , enterpriseFormInitialized =
                                                    if newStep == Onboarding.EnterpriseFormStep then
                                                        False

                                                    else
                                                        existingModel.enterpriseFormInitialized
                                            }
                                    in
                                    ( { model | page = OnboardingPage updatedModel }
                                    , Cmd.map OnboardingMsg (Task.perform (\_ -> Onboarding.InitializeCurrentStep) (Task.succeed ()))
                                    )

                                _ ->
                                    -- Initialize onboarding without authenticated calls for new users
                                    let
                                        ( onboardingModel, onboardingCmd ) =
                                            Onboarding.init
                                                model.key
                                                (model.currentUser
                                                    |> Maybe.map .organizationSlug
                                                    |> Maybe.withDefault ""
                                                )
                                                (extractSession model.session)
                                                (onboardingStepToStep step)
                                    in
                                    ( { model | page = OnboardingPage onboardingModel }
                                    , Cmd.map OnboardingMsg onboardingCmd
                                    )

                        PublicRoute (CompareRoute params) ->
                            case params.quoteId of
                                Just quoteId ->
                                    -- We have a quote ID, which is what we prefer
                                    let
                                        ( compareModel, compareCmd ) =
                                            Compare.init model.key (Just params)
                                    in
                                    ( { model | page = ComparePage compareModel }
                                    , Cmd.map CompareMsg compareCmd
                                    )

                                Nothing ->
                                    -- No quote ID, check if we have a valid orgId
                                    if isValidOrgId params.orgId then
                                        -- We have a valid orgId but no quoteId, so use the params
                                        let
                                            ( compareModel, compareCmd ) =
                                                Compare.init model.key (Just params)
                                        in
                                        ( { model | page = ComparePage compareModel }
                                        , Cmd.map CompareMsg compareCmd
                                        )

                                    else
                                        -- No valid orgId either, redirect to 404
                                        ( { model | page = NotFoundPage }
                                        , Nav.pushUrl model.key "/404"
                                        )

                        PublicRoute (QuoteRoute params) ->
                            -- First check if there's a valid quoteId
                            if isValidQuoteId params.quoteId then
                                let
                                    initialValues =
                                        { zipCode = Nothing
                                        , dateOfBirth = Nothing
                                        , tobacco = Nothing
                                        , gender = Nothing
                                        , quoteId = params.quoteId
                                        , planType = params.planType
                                        , orgId = params.orgId -- Pass orgId even if it's Nothing
                                        }

                                    ( quoteModel, quoteCmd ) =
                                        Quote.init model.key initialValues
                                in
                                ( { model | page = QuotePage quoteModel }
                                , Cmd.map QuoteMsg quoteCmd
                                )
                                -- If there's no valid quoteId, show error

                            else
                                -- Redirect to an error page or show an error
                                ( { model | page = NotFoundPage }
                                , Nav.pushUrl model.key "/error?message=Missing%20or%20invalid%20quote%20ID"
                                )

                        PublicRoute (EligibilityRoute params) ->
                            let
                                ( quoteId, _, orgIdStr ) =
                                    params
                            in
                            if isValidOrgId orgIdStr then
                                let
                                    ( eligibilityModel, eligibilityCmd ) =
                                        Eligibility.init model.key { quoteId = quoteId, orgId = orgIdStr }
                                in
                                ( { model | page = EligibilityPage eligibilityModel }
                                , Cmd.map EligibilityMsg eligibilityCmd
                                )

                            else
                                -- Redirect to an error page or show an error
                                ( { model | page = NotFoundPage }
                                , Nav.pushUrl model.key "/error?message=Missing%20or%20invalid%20organization%20ID"
                                )

                        PublicRoute (ScheduleRoute params) ->
                            let
                                ( scheduleModel, scheduleCmd ) =
                                    Schedule.init model.key
                                        ((\( id, _, _ ) -> id) params)
                                        ((\( _, status, _ ) -> status) params)
                            in
                            ( { model | page = SchedulePage scheduleModel }
                            , Cmd.map ScheduleMsg scheduleCmd
                            )

                        PublicRoute (SelfOnboardingRoute orgSlug) ->
                            let
                                ( selfOnboardingModel, selfOnboardingCmd ) =
                                    SelfServiceOnboarding.init model.key url
                            in
                            ( { model | page = SelfOnboardingPage selfOnboardingModel }
                            , Cmd.map SelfOnboardingMsg selfOnboardingCmd
                            )

                        PublicRoute (VerifyRoute params) ->
                            -- For verification, we need to make an API call
                            let
                                verifyUrl =
                                    case params of
                                        VerifyParams orgSlug token ->
                                            "/api/auth/verify/" ++ orgSlug ++ "/" ++ token

                                verifyCmd =
                                    Http.get
                                        { url = verifyUrl
                                        , expect = Http.expectJson GotVerification verificationDecoder
                                        }
                            in
                            ( model, verifyCmd )

                        -- For any other routes, use the standard updatePage
                        _ ->
                            updatePage url ( model, cmd )

                _ ->
                    -- For protected routes, use the standard updatePage
                    updatePage url ( model, cmd )

        Nothing ->
            -- For invalid routes, show the not found page
            ( { model | page = NotFoundPage }
            , cmd
            )



-- Add a helper function to check if an organization ID is valid
-- It should return True only if the orgId is not empty, not "default", and is a proper string


isValidOrgId : Maybe String -> Bool
isValidOrgId maybeOrgId =
    case maybeOrgId of
        Just orgId ->
            not (String.isEmpty orgId) && orgId /= "default"

        Nothing ->
            False



-- Add a helper function to check if a quote ID is valid


isValidQuoteId : Maybe String -> Bool
isValidQuoteId maybeQuoteId =
    case maybeQuoteId of
        Just quoteId ->
            not (String.isEmpty quoteId)

        Nothing ->
            False
